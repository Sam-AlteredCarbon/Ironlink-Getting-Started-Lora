
IronLink-Getting-Started-Lora.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .isr_vector   000000c0  08008000  08008000  00008000  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  1 .text         000083d4  080080c0  080080c0  000080c0  2**4
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .rodata       00000600  08010494  08010494  00010494  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  3 .ARM.extab    00000000  08010a94  08010a94  000300c0  2**0
                  CONTENTS
  4 .ARM          00000000  08010a94  08010a94  000300c0  2**0
                  CONTENTS
  5 .preinit_array 00000000  08010a94  08010a94  000300c0  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  6 .init_array   00000004  08010a94  08010a94  00010a94  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  7 .fini_array   00000004  08010a98  08010a98  00010a98  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  8 .data         0000023c  20000400  08010a9c  00020400  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  9 .bss          00002bb0  20000640  08010cd8  00030640  2**3
                  ALLOC
 10 ._user_heap_stack 00000600  200031f0  08010cd8  000331f0  2**0
                  ALLOC
 11 .ARM.attributes 00000028  00000000  00000000  000300c0  2**0
                  CONTENTS, READONLY
 12 .RAMVectorTable 000000c0  20000000  08010cd8  00030000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
 13 .debug_info   00042cd1  00000000  00000000  000300e8  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 14 .debug_abbrev 00008350  00000000  00000000  00072db9  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 15 .debug_loc    0001c2f0  00000000  00000000  0007b109  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 16 .debug_aranges 00001c40  00000000  00000000  00097400  2**3
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 17 .debug_ranges 00002ea8  00000000  00000000  00099040  2**3
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 18 .debug_macro  00019799  00000000  00000000  0009bee8  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 19 .debug_line   0003744c  00000000  00000000  000b5681  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 20 .debug_str    0007de5e  00000000  00000000  000ecacd  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 21 .comment      00000053  00000000  00000000  0016a92b  2**0
                  CONTENTS, READONLY
 22 .debug_frame  00005a44  00000000  00000000  0016a980  2**2
                  CONTENTS, READONLY, DEBUGGING, OCTETS

Disassembly of section .text:

080080c0 <__do_global_dtors_aux>:
 80080c0:	b510      	push	{r4, lr}
 80080c2:	4c06      	ldr	r4, [pc, #24]	; (80080dc <__do_global_dtors_aux+0x1c>)
 80080c4:	7823      	ldrb	r3, [r4, #0]
 80080c6:	2b00      	cmp	r3, #0
 80080c8:	d107      	bne.n	80080da <__do_global_dtors_aux+0x1a>
 80080ca:	4b05      	ldr	r3, [pc, #20]	; (80080e0 <__do_global_dtors_aux+0x20>)
 80080cc:	2b00      	cmp	r3, #0
 80080ce:	d002      	beq.n	80080d6 <__do_global_dtors_aux+0x16>
 80080d0:	4804      	ldr	r0, [pc, #16]	; (80080e4 <__do_global_dtors_aux+0x24>)
 80080d2:	e000      	b.n	80080d6 <__do_global_dtors_aux+0x16>
 80080d4:	bf00      	nop
 80080d6:	2301      	movs	r3, #1
 80080d8:	7023      	strb	r3, [r4, #0]
 80080da:	bd10      	pop	{r4, pc}
 80080dc:	20000640 	.word	0x20000640
 80080e0:	00000000 	.word	0x00000000
 80080e4:	0801047c 	.word	0x0801047c

080080e8 <frame_dummy>:
 80080e8:	4b04      	ldr	r3, [pc, #16]	; (80080fc <frame_dummy+0x14>)
 80080ea:	b510      	push	{r4, lr}
 80080ec:	2b00      	cmp	r3, #0
 80080ee:	d003      	beq.n	80080f8 <frame_dummy+0x10>
 80080f0:	4903      	ldr	r1, [pc, #12]	; (8008100 <frame_dummy+0x18>)
 80080f2:	4804      	ldr	r0, [pc, #16]	; (8008104 <frame_dummy+0x1c>)
 80080f4:	e000      	b.n	80080f8 <frame_dummy+0x10>
 80080f6:	bf00      	nop
 80080f8:	bd10      	pop	{r4, pc}
 80080fa:	46c0      	nop			; (mov r8, r8)
 80080fc:	00000000 	.word	0x00000000
 8008100:	20000644 	.word	0x20000644
 8008104:	0801047c 	.word	0x0801047c

08008108 <strlen>:
 8008108:	2300      	movs	r3, #0
 800810a:	5cc2      	ldrb	r2, [r0, r3]
 800810c:	3301      	adds	r3, #1
 800810e:	2a00      	cmp	r2, #0
 8008110:	d1fb      	bne.n	800810a <strlen+0x2>
 8008112:	1e58      	subs	r0, r3, #1
 8008114:	4770      	bx	lr
	...

08008118 <__gnu_thumb1_case_sqi>:
 8008118:	b402      	push	{r1}
 800811a:	4671      	mov	r1, lr
 800811c:	0849      	lsrs	r1, r1, #1
 800811e:	0049      	lsls	r1, r1, #1
 8008120:	5609      	ldrsb	r1, [r1, r0]
 8008122:	0049      	lsls	r1, r1, #1
 8008124:	448e      	add	lr, r1
 8008126:	bc02      	pop	{r1}
 8008128:	4770      	bx	lr
 800812a:	46c0      	nop			; (mov r8, r8)

0800812c <__gnu_thumb1_case_uqi>:
 800812c:	b402      	push	{r1}
 800812e:	4671      	mov	r1, lr
 8008130:	0849      	lsrs	r1, r1, #1
 8008132:	0049      	lsls	r1, r1, #1
 8008134:	5c09      	ldrb	r1, [r1, r0]
 8008136:	0049      	lsls	r1, r1, #1
 8008138:	448e      	add	lr, r1
 800813a:	bc02      	pop	{r1}
 800813c:	4770      	bx	lr
 800813e:	46c0      	nop			; (mov r8, r8)

08008140 <__gnu_thumb1_case_shi>:
 8008140:	b403      	push	{r0, r1}
 8008142:	4671      	mov	r1, lr
 8008144:	0849      	lsrs	r1, r1, #1
 8008146:	0040      	lsls	r0, r0, #1
 8008148:	0049      	lsls	r1, r1, #1
 800814a:	5e09      	ldrsh	r1, [r1, r0]
 800814c:	0049      	lsls	r1, r1, #1
 800814e:	448e      	add	lr, r1
 8008150:	bc03      	pop	{r0, r1}
 8008152:	4770      	bx	lr

08008154 <__gnu_thumb1_case_uhi>:
 8008154:	b403      	push	{r0, r1}
 8008156:	4671      	mov	r1, lr
 8008158:	0849      	lsrs	r1, r1, #1
 800815a:	0040      	lsls	r0, r0, #1
 800815c:	0049      	lsls	r1, r1, #1
 800815e:	5a09      	ldrh	r1, [r1, r0]
 8008160:	0049      	lsls	r1, r1, #1
 8008162:	448e      	add	lr, r1
 8008164:	bc03      	pop	{r0, r1}
 8008166:	4770      	bx	lr

08008168 <__udivsi3>:
 8008168:	2200      	movs	r2, #0
 800816a:	0843      	lsrs	r3, r0, #1
 800816c:	428b      	cmp	r3, r1
 800816e:	d374      	bcc.n	800825a <__udivsi3+0xf2>
 8008170:	0903      	lsrs	r3, r0, #4
 8008172:	428b      	cmp	r3, r1
 8008174:	d35f      	bcc.n	8008236 <__udivsi3+0xce>
 8008176:	0a03      	lsrs	r3, r0, #8
 8008178:	428b      	cmp	r3, r1
 800817a:	d344      	bcc.n	8008206 <__udivsi3+0x9e>
 800817c:	0b03      	lsrs	r3, r0, #12
 800817e:	428b      	cmp	r3, r1
 8008180:	d328      	bcc.n	80081d4 <__udivsi3+0x6c>
 8008182:	0c03      	lsrs	r3, r0, #16
 8008184:	428b      	cmp	r3, r1
 8008186:	d30d      	bcc.n	80081a4 <__udivsi3+0x3c>
 8008188:	22ff      	movs	r2, #255	; 0xff
 800818a:	0209      	lsls	r1, r1, #8
 800818c:	ba12      	rev	r2, r2
 800818e:	0c03      	lsrs	r3, r0, #16
 8008190:	428b      	cmp	r3, r1
 8008192:	d302      	bcc.n	800819a <__udivsi3+0x32>
 8008194:	1212      	asrs	r2, r2, #8
 8008196:	0209      	lsls	r1, r1, #8
 8008198:	d065      	beq.n	8008266 <__udivsi3+0xfe>
 800819a:	0b03      	lsrs	r3, r0, #12
 800819c:	428b      	cmp	r3, r1
 800819e:	d319      	bcc.n	80081d4 <__udivsi3+0x6c>
 80081a0:	e000      	b.n	80081a4 <__udivsi3+0x3c>
 80081a2:	0a09      	lsrs	r1, r1, #8
 80081a4:	0bc3      	lsrs	r3, r0, #15
 80081a6:	428b      	cmp	r3, r1
 80081a8:	d301      	bcc.n	80081ae <__udivsi3+0x46>
 80081aa:	03cb      	lsls	r3, r1, #15
 80081ac:	1ac0      	subs	r0, r0, r3
 80081ae:	4152      	adcs	r2, r2
 80081b0:	0b83      	lsrs	r3, r0, #14
 80081b2:	428b      	cmp	r3, r1
 80081b4:	d301      	bcc.n	80081ba <__udivsi3+0x52>
 80081b6:	038b      	lsls	r3, r1, #14
 80081b8:	1ac0      	subs	r0, r0, r3
 80081ba:	4152      	adcs	r2, r2
 80081bc:	0b43      	lsrs	r3, r0, #13
 80081be:	428b      	cmp	r3, r1
 80081c0:	d301      	bcc.n	80081c6 <__udivsi3+0x5e>
 80081c2:	034b      	lsls	r3, r1, #13
 80081c4:	1ac0      	subs	r0, r0, r3
 80081c6:	4152      	adcs	r2, r2
 80081c8:	0b03      	lsrs	r3, r0, #12
 80081ca:	428b      	cmp	r3, r1
 80081cc:	d301      	bcc.n	80081d2 <__udivsi3+0x6a>
 80081ce:	030b      	lsls	r3, r1, #12
 80081d0:	1ac0      	subs	r0, r0, r3
 80081d2:	4152      	adcs	r2, r2
 80081d4:	0ac3      	lsrs	r3, r0, #11
 80081d6:	428b      	cmp	r3, r1
 80081d8:	d301      	bcc.n	80081de <__udivsi3+0x76>
 80081da:	02cb      	lsls	r3, r1, #11
 80081dc:	1ac0      	subs	r0, r0, r3
 80081de:	4152      	adcs	r2, r2
 80081e0:	0a83      	lsrs	r3, r0, #10
 80081e2:	428b      	cmp	r3, r1
 80081e4:	d301      	bcc.n	80081ea <__udivsi3+0x82>
 80081e6:	028b      	lsls	r3, r1, #10
 80081e8:	1ac0      	subs	r0, r0, r3
 80081ea:	4152      	adcs	r2, r2
 80081ec:	0a43      	lsrs	r3, r0, #9
 80081ee:	428b      	cmp	r3, r1
 80081f0:	d301      	bcc.n	80081f6 <__udivsi3+0x8e>
 80081f2:	024b      	lsls	r3, r1, #9
 80081f4:	1ac0      	subs	r0, r0, r3
 80081f6:	4152      	adcs	r2, r2
 80081f8:	0a03      	lsrs	r3, r0, #8
 80081fa:	428b      	cmp	r3, r1
 80081fc:	d301      	bcc.n	8008202 <__udivsi3+0x9a>
 80081fe:	020b      	lsls	r3, r1, #8
 8008200:	1ac0      	subs	r0, r0, r3
 8008202:	4152      	adcs	r2, r2
 8008204:	d2cd      	bcs.n	80081a2 <__udivsi3+0x3a>
 8008206:	09c3      	lsrs	r3, r0, #7
 8008208:	428b      	cmp	r3, r1
 800820a:	d301      	bcc.n	8008210 <__udivsi3+0xa8>
 800820c:	01cb      	lsls	r3, r1, #7
 800820e:	1ac0      	subs	r0, r0, r3
 8008210:	4152      	adcs	r2, r2
 8008212:	0983      	lsrs	r3, r0, #6
 8008214:	428b      	cmp	r3, r1
 8008216:	d301      	bcc.n	800821c <__udivsi3+0xb4>
 8008218:	018b      	lsls	r3, r1, #6
 800821a:	1ac0      	subs	r0, r0, r3
 800821c:	4152      	adcs	r2, r2
 800821e:	0943      	lsrs	r3, r0, #5
 8008220:	428b      	cmp	r3, r1
 8008222:	d301      	bcc.n	8008228 <__udivsi3+0xc0>
 8008224:	014b      	lsls	r3, r1, #5
 8008226:	1ac0      	subs	r0, r0, r3
 8008228:	4152      	adcs	r2, r2
 800822a:	0903      	lsrs	r3, r0, #4
 800822c:	428b      	cmp	r3, r1
 800822e:	d301      	bcc.n	8008234 <__udivsi3+0xcc>
 8008230:	010b      	lsls	r3, r1, #4
 8008232:	1ac0      	subs	r0, r0, r3
 8008234:	4152      	adcs	r2, r2
 8008236:	08c3      	lsrs	r3, r0, #3
 8008238:	428b      	cmp	r3, r1
 800823a:	d301      	bcc.n	8008240 <__udivsi3+0xd8>
 800823c:	00cb      	lsls	r3, r1, #3
 800823e:	1ac0      	subs	r0, r0, r3
 8008240:	4152      	adcs	r2, r2
 8008242:	0883      	lsrs	r3, r0, #2
 8008244:	428b      	cmp	r3, r1
 8008246:	d301      	bcc.n	800824c <__udivsi3+0xe4>
 8008248:	008b      	lsls	r3, r1, #2
 800824a:	1ac0      	subs	r0, r0, r3
 800824c:	4152      	adcs	r2, r2
 800824e:	0843      	lsrs	r3, r0, #1
 8008250:	428b      	cmp	r3, r1
 8008252:	d301      	bcc.n	8008258 <__udivsi3+0xf0>
 8008254:	004b      	lsls	r3, r1, #1
 8008256:	1ac0      	subs	r0, r0, r3
 8008258:	4152      	adcs	r2, r2
 800825a:	1a41      	subs	r1, r0, r1
 800825c:	d200      	bcs.n	8008260 <__udivsi3+0xf8>
 800825e:	4601      	mov	r1, r0
 8008260:	4152      	adcs	r2, r2
 8008262:	4610      	mov	r0, r2
 8008264:	4770      	bx	lr
 8008266:	e7ff      	b.n	8008268 <__udivsi3+0x100>
 8008268:	b501      	push	{r0, lr}
 800826a:	2000      	movs	r0, #0
 800826c:	f000 f806 	bl	800827c <__aeabi_idiv0>
 8008270:	bd02      	pop	{r1, pc}
 8008272:	46c0      	nop			; (mov r8, r8)

08008274 <__aeabi_uidivmod>:
 8008274:	2900      	cmp	r1, #0
 8008276:	d0f7      	beq.n	8008268 <__udivsi3+0x100>
 8008278:	e776      	b.n	8008168 <__udivsi3>
 800827a:	4770      	bx	lr

0800827c <__aeabi_idiv0>:
 800827c:	4770      	bx	lr
 800827e:	46c0      	nop			; (mov r8, r8)

08008280 <MX_ADC_Init>:
ADC_HandleTypeDef hadc;
DMA_HandleTypeDef hdma_adc;

/* ADC init function */
void MX_ADC_Init(void)
{
 8008280:	b51f      	push	{r0, r1, r2, r3, r4, lr}

  /* USER CODE BEGIN ADC_Init 0 */

  /* USER CODE END ADC_Init 0 */

  ADC_ChannelConfTypeDef sConfig = {0};
 8008282:	220c      	movs	r2, #12
 8008284:	2100      	movs	r1, #0
 8008286:	a801      	add	r0, sp, #4
 8008288:	f007 fc39 	bl	800fafe <memset>
  hadc.Instance = ADC1;
  hadc.Init.ClockPrescaler = ADC_CLOCK_ASYNC_DIV1;
  hadc.Init.Resolution = ADC_RESOLUTION_12B;
  hadc.Init.DataAlign = ADC_DATAALIGN_RIGHT;
  hadc.Init.ScanConvMode = ADC_SCAN_DIRECTION_FORWARD;
  hadc.Init.EOCSelection = ADC_EOC_SEQ_CONV;
 800828c:	2108      	movs	r1, #8
  hadc.Instance = ADC1;
 800828e:	4c1a      	ldr	r4, [pc, #104]	; (80082f8 <MX_ADC_Init+0x78>)
 8008290:	4b1a      	ldr	r3, [pc, #104]	; (80082fc <MX_ADC_Init+0x7c>)
  hadc.Init.EOCSelection = ADC_EOC_SEQ_CONV;
 8008292:	6161      	str	r1, [r4, #20]
  hadc.Init.LowPowerAutoWait = DISABLE;
 8008294:	2180      	movs	r1, #128	; 0x80
 8008296:	0249      	lsls	r1, r1, #9
  hadc.Instance = ADC1;
 8008298:	6023      	str	r3, [r4, #0]
  hadc.Init.LowPowerAutoWait = DISABLE;
 800829a:	61a1      	str	r1, [r4, #24]
  hadc.Init.ClockPrescaler = ADC_CLOCK_ASYNC_DIV1;
 800829c:	2300      	movs	r3, #0
  hadc.Init.LowPowerAutoPowerOff = DISABLE;
  hadc.Init.ContinuousConvMode = ENABLE;
  hadc.Init.DiscontinuousConvMode = DISABLE;
  hadc.Init.ExternalTrigConv = ADC_SOFTWARE_START;
 800829e:	21c2      	movs	r1, #194	; 0xc2
  hadc.Init.ScanConvMode = ADC_SCAN_DIRECTION_FORWARD;
 80082a0:	2201      	movs	r2, #1
  hadc.Init.ClockPrescaler = ADC_CLOCK_ASYNC_DIV1;
 80082a2:	6063      	str	r3, [r4, #4]
  hadc.Init.Resolution = ADC_RESOLUTION_12B;
 80082a4:	60a3      	str	r3, [r4, #8]
  hadc.Init.DataAlign = ADC_DATAALIGN_RIGHT;
 80082a6:	60e3      	str	r3, [r4, #12]
  hadc.Init.ExternalTrigConv = ADC_SOFTWARE_START;
 80082a8:	31ff      	adds	r1, #255	; 0xff
  hadc.Init.ExternalTrigConvEdge = ADC_EXTERNALTRIGCONVEDGE_NONE;
 80082aa:	6223      	str	r3, [r4, #32]
  hadc.Init.DMAContinuousRequests = ENABLE;
  hadc.Init.Overrun = ADC_OVR_DATA_PRESERVED;
  if (HAL_ADC_Init(&hadc) != HAL_OK)
 80082ac:	0020      	movs	r0, r4
  hadc.Init.DMAContinuousRequests = ENABLE;
 80082ae:	1d63      	adds	r3, r4, #5
  hadc.Init.ScanConvMode = ADC_SCAN_DIRECTION_FORWARD;
 80082b0:	6122      	str	r2, [r4, #16]
  hadc.Init.ExternalTrigConv = ADC_SOFTWARE_START;
 80082b2:	61e1      	str	r1, [r4, #28]
  hadc.Init.DMAContinuousRequests = ENABLE;
 80082b4:	77da      	strb	r2, [r3, #31]
  hadc.Init.Overrun = ADC_OVR_DATA_PRESERVED;
 80082b6:	62a2      	str	r2, [r4, #40]	; 0x28
  if (HAL_ADC_Init(&hadc) != HAL_OK)
 80082b8:	f001 fb84 	bl	80099c4 <HAL_ADC_Init>
 80082bc:	2800      	cmp	r0, #0
 80082be:	d001      	beq.n	80082c4 <MX_ADC_Init+0x44>
  {
    Error_Handler();
 80082c0:	f000 fb34 	bl	800892c <Error_Handler>
  }
  /** Configure for the selected ADC regular channel to be converted.
  */
  sConfig.Channel = ADC_CHANNEL_4;
 80082c4:	2304      	movs	r3, #4
 80082c6:	9301      	str	r3, [sp, #4]
  sConfig.Rank = ADC_RANK_CHANNEL_NUMBER;
 80082c8:	2380      	movs	r3, #128	; 0x80
 80082ca:	015b      	lsls	r3, r3, #5
 80082cc:	9302      	str	r3, [sp, #8]
  sConfig.SamplingTime = ADC_SAMPLETIME_13CYCLES_5;
 80082ce:	2302      	movs	r3, #2
  if (HAL_ADC_ConfigChannel(&hadc, &sConfig) != HAL_OK)
 80082d0:	0020      	movs	r0, r4
 80082d2:	a901      	add	r1, sp, #4
  sConfig.SamplingTime = ADC_SAMPLETIME_13CYCLES_5;
 80082d4:	9303      	str	r3, [sp, #12]
  if (HAL_ADC_ConfigChannel(&hadc, &sConfig) != HAL_OK)
 80082d6:	f001 fd41 	bl	8009d5c <HAL_ADC_ConfigChannel>
 80082da:	2800      	cmp	r0, #0
 80082dc:	d001      	beq.n	80082e2 <MX_ADC_Init+0x62>
  {
    Error_Handler();
 80082de:	f000 fb25 	bl	800892c <Error_Handler>
  }
  /** Configure for the selected ADC regular channel to be converted.
  */
  sConfig.Channel = ADC_CHANNEL_8;
 80082e2:	2308      	movs	r3, #8
  if (HAL_ADC_ConfigChannel(&hadc, &sConfig) != HAL_OK)
 80082e4:	0020      	movs	r0, r4
 80082e6:	a901      	add	r1, sp, #4
  sConfig.Channel = ADC_CHANNEL_8;
 80082e8:	9301      	str	r3, [sp, #4]
  if (HAL_ADC_ConfigChannel(&hadc, &sConfig) != HAL_OK)
 80082ea:	f001 fd37 	bl	8009d5c <HAL_ADC_ConfigChannel>
 80082ee:	2800      	cmp	r0, #0
 80082f0:	d001      	beq.n	80082f6 <MX_ADC_Init+0x76>
  {
    Error_Handler();
 80082f2:	f000 fb1b 	bl	800892c <Error_Handler>
  }
  /* USER CODE BEGIN ADC_Init 2 */

  /* USER CODE END ADC_Init 2 */

}
 80082f6:	bd1f      	pop	{r0, r1, r2, r3, r4, pc}
 80082f8:	20001a64 	.word	0x20001a64
 80082fc:	40012400 	.word	0x40012400

08008300 <HAL_ADC_MspInit>:

void HAL_ADC_MspInit(ADC_HandleTypeDef* adcHandle)
{
 8008300:	b570      	push	{r4, r5, r6, lr}
 8008302:	0006      	movs	r6, r0
 8008304:	b088      	sub	sp, #32

  GPIO_InitTypeDef GPIO_InitStruct = {0};
 8008306:	2214      	movs	r2, #20
 8008308:	2100      	movs	r1, #0
 800830a:	a803      	add	r0, sp, #12
 800830c:	f007 fbf7 	bl	800fafe <memset>
  if(adcHandle->Instance==ADC1)
 8008310:	4b29      	ldr	r3, [pc, #164]	; (80083b8 <HAL_ADC_MspInit+0xb8>)
 8008312:	6832      	ldr	r2, [r6, #0]
 8008314:	429a      	cmp	r2, r3
 8008316:	d14d      	bne.n	80083b4 <HAL_ADC_MspInit+0xb4>
  {
  /* USER CODE BEGIN ADC1_MspInit 0 */

  /* USER CODE END ADC1_MspInit 0 */
    /* ADC1 clock enable */
    __HAL_RCC_ADC1_CLK_ENABLE();
 8008318:	2080      	movs	r0, #128	; 0x80
 800831a:	4b28      	ldr	r3, [pc, #160]	; (80083bc <HAL_ADC_MspInit+0xbc>)
 800831c:	0080      	lsls	r0, r0, #2
 800831e:	6999      	ldr	r1, [r3, #24]
    PA4     ------> ADC_IN4
    PB0     ------> ADC_IN8
    */
    GPIO_InitStruct.Pin = GPIO1_Pin;
    GPIO_InitStruct.Mode = GPIO_MODE_ANALOG;
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 8008320:	2500      	movs	r5, #0
    __HAL_RCC_ADC1_CLK_ENABLE();
 8008322:	4301      	orrs	r1, r0
 8008324:	6199      	str	r1, [r3, #24]
 8008326:	699a      	ldr	r2, [r3, #24]
    GPIO_InitStruct.Mode = GPIO_MODE_ANALOG;
 8008328:	2403      	movs	r4, #3
    __HAL_RCC_ADC1_CLK_ENABLE();
 800832a:	4002      	ands	r2, r0
    __HAL_RCC_GPIOA_CLK_ENABLE();
 800832c:	2080      	movs	r0, #128	; 0x80
    __HAL_RCC_ADC1_CLK_ENABLE();
 800832e:	9200      	str	r2, [sp, #0]
 8008330:	9a00      	ldr	r2, [sp, #0]
    __HAL_RCC_GPIOA_CLK_ENABLE();
 8008332:	6959      	ldr	r1, [r3, #20]
 8008334:	0280      	lsls	r0, r0, #10
 8008336:	4301      	orrs	r1, r0
 8008338:	6159      	str	r1, [r3, #20]
    __HAL_RCC_GPIOB_CLK_ENABLE();
 800833a:	2180      	movs	r1, #128	; 0x80
    __HAL_RCC_GPIOA_CLK_ENABLE();
 800833c:	695a      	ldr	r2, [r3, #20]
    __HAL_RCC_GPIOB_CLK_ENABLE();
 800833e:	02c9      	lsls	r1, r1, #11
    __HAL_RCC_GPIOA_CLK_ENABLE();
 8008340:	4002      	ands	r2, r0
 8008342:	9201      	str	r2, [sp, #4]
 8008344:	9a01      	ldr	r2, [sp, #4]
    __HAL_RCC_GPIOB_CLK_ENABLE();
 8008346:	695a      	ldr	r2, [r3, #20]
    HAL_GPIO_Init(GPIO1_GPIO_Port, &GPIO_InitStruct);
 8008348:	2090      	movs	r0, #144	; 0x90
    __HAL_RCC_GPIOB_CLK_ENABLE();
 800834a:	430a      	orrs	r2, r1
 800834c:	615a      	str	r2, [r3, #20]
 800834e:	695b      	ldr	r3, [r3, #20]
    HAL_GPIO_Init(GPIO1_GPIO_Port, &GPIO_InitStruct);
 8008350:	05c0      	lsls	r0, r0, #23
    __HAL_RCC_GPIOB_CLK_ENABLE();
 8008352:	400b      	ands	r3, r1
 8008354:	9302      	str	r3, [sp, #8]
 8008356:	9b02      	ldr	r3, [sp, #8]
    GPIO_InitStruct.Pin = GPIO1_Pin;
 8008358:	2310      	movs	r3, #16
    HAL_GPIO_Init(GPIO1_GPIO_Port, &GPIO_InitStruct);
 800835a:	a903      	add	r1, sp, #12
    GPIO_InitStruct.Pin = GPIO1_Pin;
 800835c:	9303      	str	r3, [sp, #12]
    GPIO_InitStruct.Mode = GPIO_MODE_ANALOG;
 800835e:	9404      	str	r4, [sp, #16]
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 8008360:	9505      	str	r5, [sp, #20]
    HAL_GPIO_Init(GPIO1_GPIO_Port, &GPIO_InitStruct);
 8008362:	f001 ffbf 	bl	800a2e4 <HAL_GPIO_Init>

    GPIO_InitStruct.Pin = GPIO3_Pin;
 8008366:	2301      	movs	r3, #1
    GPIO_InitStruct.Mode = GPIO_MODE_ANALOG;
    GPIO_InitStruct.Pull = GPIO_NOPULL;
    HAL_GPIO_Init(GPIO3_GPIO_Port, &GPIO_InitStruct);
 8008368:	4815      	ldr	r0, [pc, #84]	; (80083c0 <HAL_ADC_MspInit+0xc0>)
 800836a:	a903      	add	r1, sp, #12
    GPIO_InitStruct.Pin = GPIO3_Pin;
 800836c:	9303      	str	r3, [sp, #12]
    GPIO_InitStruct.Mode = GPIO_MODE_ANALOG;
 800836e:	9404      	str	r4, [sp, #16]
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 8008370:	9505      	str	r5, [sp, #20]
    HAL_GPIO_Init(GPIO3_GPIO_Port, &GPIO_InitStruct);
 8008372:	f001 ffb7 	bl	800a2e4 <HAL_GPIO_Init>

    /* ADC1 DMA Init */
    /* ADC Init */
    hdma_adc.Instance = DMA1_Channel1;
 8008376:	4c13      	ldr	r4, [pc, #76]	; (80083c4 <HAL_ADC_MspInit+0xc4>)
 8008378:	4b13      	ldr	r3, [pc, #76]	; (80083c8 <HAL_ADC_MspInit+0xc8>)
    hdma_adc.Init.MemInc = DMA_MINC_ENABLE;
    hdma_adc.Init.PeriphDataAlignment = DMA_PDATAALIGN_HALFWORD;
    hdma_adc.Init.MemDataAlignment = DMA_MDATAALIGN_HALFWORD;
    hdma_adc.Init.Mode = DMA_NORMAL;
    hdma_adc.Init.Priority = DMA_PRIORITY_LOW;
    if (HAL_DMA_Init(&hdma_adc) != HAL_OK)
 800837a:	0020      	movs	r0, r4
    hdma_adc.Instance = DMA1_Channel1;
 800837c:	6023      	str	r3, [r4, #0]
    hdma_adc.Init.MemInc = DMA_MINC_ENABLE;
 800837e:	2380      	movs	r3, #128	; 0x80
 8008380:	60e3      	str	r3, [r4, #12]
    hdma_adc.Init.PeriphDataAlignment = DMA_PDATAALIGN_HALFWORD;
 8008382:	18db      	adds	r3, r3, r3
 8008384:	6123      	str	r3, [r4, #16]
    hdma_adc.Init.MemDataAlignment = DMA_MDATAALIGN_HALFWORD;
 8008386:	2380      	movs	r3, #128	; 0x80
 8008388:	00db      	lsls	r3, r3, #3
    hdma_adc.Init.Direction = DMA_PERIPH_TO_MEMORY;
 800838a:	6065      	str	r5, [r4, #4]
    hdma_adc.Init.PeriphInc = DMA_PINC_DISABLE;
 800838c:	60a5      	str	r5, [r4, #8]
    hdma_adc.Init.MemDataAlignment = DMA_MDATAALIGN_HALFWORD;
 800838e:	6163      	str	r3, [r4, #20]
    hdma_adc.Init.Mode = DMA_NORMAL;
 8008390:	61a5      	str	r5, [r4, #24]
    hdma_adc.Init.Priority = DMA_PRIORITY_LOW;
 8008392:	61e5      	str	r5, [r4, #28]
    if (HAL_DMA_Init(&hdma_adc) != HAL_OK)
 8008394:	f001 fdd8 	bl	8009f48 <HAL_DMA_Init>
 8008398:	42a8      	cmp	r0, r5
 800839a:	d001      	beq.n	80083a0 <HAL_ADC_MspInit+0xa0>
    {
      Error_Handler();
 800839c:	f000 fac6 	bl	800892c <Error_Handler>
    }

    __HAL_LINKDMA(adcHandle,DMA_Handle,hdma_adc);

    /* ADC1 interrupt Init */
    HAL_NVIC_SetPriority(ADC1_IRQn, 3, 0);
 80083a0:	200c      	movs	r0, #12
 80083a2:	2200      	movs	r2, #0
 80083a4:	2103      	movs	r1, #3
    __HAL_LINKDMA(adcHandle,DMA_Handle,hdma_adc);
 80083a6:	6334      	str	r4, [r6, #48]	; 0x30
 80083a8:	6266      	str	r6, [r4, #36]	; 0x24
    HAL_NVIC_SetPriority(ADC1_IRQn, 3, 0);
 80083aa:	f001 fd85 	bl	8009eb8 <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(ADC1_IRQn);
 80083ae:	200c      	movs	r0, #12
 80083b0:	f001 fdb6 	bl	8009f20 <HAL_NVIC_EnableIRQ>
  /* USER CODE BEGIN ADC1_MspInit 1 */

  /* USER CODE END ADC1_MspInit 1 */
  }
}
 80083b4:	b008      	add	sp, #32
 80083b6:	bd70      	pop	{r4, r5, r6, pc}
 80083b8:	40012400 	.word	0x40012400
 80083bc:	40021000 	.word	0x40021000
 80083c0:	48000400 	.word	0x48000400
 80083c4:	20001a20 	.word	0x20001a20
 80083c8:	40020008 	.word	0x40020008

080083cc <MX_DMA_Init>:

/**
  * Enable DMA controller clock
  */
void MX_DMA_Init(void)
{
 80083cc:	b507      	push	{r0, r1, r2, lr}

  /* DMA controller clock enable */
  __HAL_RCC_DMA1_CLK_ENABLE();
 80083ce:	2001      	movs	r0, #1
 80083d0:	4a08      	ldr	r2, [pc, #32]	; (80083f4 <MX_DMA_Init+0x28>)
 80083d2:	6951      	ldr	r1, [r2, #20]
 80083d4:	4301      	orrs	r1, r0
 80083d6:	6151      	str	r1, [r2, #20]
 80083d8:	6953      	ldr	r3, [r2, #20]

  /* DMA interrupt init */
  /* DMA1_Channel1_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(DMA1_Channel1_IRQn, 3, 0);
 80083da:	2103      	movs	r1, #3
  __HAL_RCC_DMA1_CLK_ENABLE();
 80083dc:	4003      	ands	r3, r0
  HAL_NVIC_SetPriority(DMA1_Channel1_IRQn, 3, 0);
 80083de:	2200      	movs	r2, #0
  __HAL_RCC_DMA1_CLK_ENABLE();
 80083e0:	9301      	str	r3, [sp, #4]
  HAL_NVIC_SetPriority(DMA1_Channel1_IRQn, 3, 0);
 80083e2:	3008      	adds	r0, #8
  __HAL_RCC_DMA1_CLK_ENABLE();
 80083e4:	9b01      	ldr	r3, [sp, #4]
  HAL_NVIC_SetPriority(DMA1_Channel1_IRQn, 3, 0);
 80083e6:	f001 fd67 	bl	8009eb8 <HAL_NVIC_SetPriority>
  HAL_NVIC_EnableIRQ(DMA1_Channel1_IRQn);
 80083ea:	2009      	movs	r0, #9
 80083ec:	f001 fd98 	bl	8009f20 <HAL_NVIC_EnableIRQ>

}
 80083f0:	bd07      	pop	{r0, r1, r2, pc}
 80083f2:	46c0      	nop			; (mov r8, r8)
 80083f4:	40021000 	.word	0x40021000

080083f8 <StartDefaultTask>:
  * @param  argument: Not used
  * @retval None
  */
/* USER CODE END Header_StartDefaultTask */
void StartDefaultTask(void const * argument)
{
 80083f8:	b570      	push	{r4, r5, r6, lr}
  /* init code for USB_DEVICE */

  /* USER CODE BEGIN StartDefaultTask */
	//Initialise Lora modem congfiuration options port and buffer
	il_lora_config lora_config;
	char buffer[50] = {'\0'};
 80083fa:	2600      	movs	r6, #0
{
 80083fc:	b094      	sub	sp, #80	; 0x50
	char buffer[50] = {'\0'};
 80083fe:	222e      	movs	r2, #46	; 0x2e
 8008400:	0031      	movs	r1, r6
 8008402:	a808      	add	r0, sp, #32
 8008404:	9607      	str	r6, [sp, #28]
 8008406:	f007 fb7a 	bl	800fafe <memset>
	uint8_t port = 0x01;
	// Init code for USB_DEVICE
	il_usb_init();
 800840a:	4b31      	ldr	r3, [pc, #196]	; (80084d0 <StartDefaultTask+0xd8>)
 800840c:	681b      	ldr	r3, [r3, #0]
 800840e:	4798      	blx	r3
	//Set the start of line character for the usb
	il_usb_set_sol_char(&usb, '>');
 8008410:	4d30      	ldr	r5, [pc, #192]	; (80084d4 <StartDefaultTask+0xdc>)
 8008412:	213e      	movs	r1, #62	; 0x3e
 8008414:	0028      	movs	r0, r5
 8008416:	f000 ff8b 	bl	8009330 <il_usb_set_sol_char>
	 //Set the start of line character for the usb
	il_usb_set_eol_char(&usb, '\r');
 800841a:	210d      	movs	r1, #13
 800841c:	0028      	movs	r0, r5
 800841e:	f000 ff8a 	bl	8009336 <il_usb_set_eol_char>

	//Send message to make the USB peripheral discoverable by the PC
	il_printf("Enable Transmission\r\n");
 8008422:	482d      	ldr	r0, [pc, #180]	; (80084d8 <StartDefaultTask+0xe0>)
 8008424:	f000 fd54 	bl	8008ed0 <il_printf>
	il_delay(1000);
 8008428:	20fa      	movs	r0, #250	; 0xfa
 800842a:	4c2c      	ldr	r4, [pc, #176]	; (80084dc <StartDefaultTask+0xe4>)
 800842c:	0080      	lsls	r0, r0, #2
 800842e:	6823      	ldr	r3, [r4, #0]
 8008430:	4798      	blx	r3
	il_printf("Begin Transmission\r\n");
 8008432:	482b      	ldr	r0, [pc, #172]	; (80084e0 <StartDefaultTask+0xe8>)
 8008434:	f000 fd4c 	bl	8008ed0 <il_printf>
	il_delay(4000);
 8008438:	20fa      	movs	r0, #250	; 0xfa
 800843a:	6823      	ldr	r3, [r4, #0]
 800843c:	0100      	lsls	r0, r0, #4
 800843e:	4798      	blx	r3


	// Enable the modem
	// Either RN2483 or RN2903 depending on modem model number
	il_lora_enable_modem(RN2483);
 8008440:	0030      	movs	r0, r6
 8008442:	f000 ffc7 	bl	80093d4 <il_lora_enable_modem>

	// Setup Lorawan device and network configuration.
	il_lora_modem_default_config(&lora_config, RN2483);
 8008446:	0031      	movs	r1, r6
 8008448:	4668      	mov	r0, sp
 800844a:	f001 f8eb 	bl	8009624 <il_lora_modem_default_config>

	lora_config.appEui 				= "0000000000000000";					// AppEui can be left as all 0s or you can make customize your own. Must be 16 characters long.
 800844e:	4b25      	ldr	r3, [pc, #148]	; (80084e4 <StartDefaultTask+0xec>)
	lora_config.appKey 				= "00000000000000000000000000000000";   // AppKey is generated on the things network when you create a device. Input the 32 character key here.

	// Initisalise the modem
	il_lora_modem_init(&lora_config);
 8008450:	4668      	mov	r0, sp
	lora_config.appEui 				= "0000000000000000";					// AppEui can be left as all 0s or you can make customize your own. Must be 16 characters long.
 8008452:	9302      	str	r3, [sp, #8]
	lora_config.appKey 				= "00000000000000000000000000000000";   // AppKey is generated on the things network when you create a device. Input the 32 character key here.
 8008454:	4b24      	ldr	r3, [pc, #144]	; (80084e8 <StartDefaultTask+0xf0>)
 8008456:	9303      	str	r3, [sp, #12]
	il_lora_modem_init(&lora_config);
 8008458:	f001 f916 	bl	8009688 <il_lora_modem_init>

	// Check if user is ready to join the network
	il_printf("\r\n Join network (y/n)? \r\n");
 800845c:	4823      	ldr	r0, [pc, #140]	; (80084ec <StartDefaultTask+0xf4>)
 800845e:	f000 fd37 	bl	8008ed0 <il_printf>

	il_usb_read_line(&usb, buffer);
 8008462:	0028      	movs	r0, r5
 8008464:	a907      	add	r1, sp, #28
 8008466:	f000 ff69 	bl	800933c <il_usb_read_line>
	// If yes join the network
	if(strstr((char*)buffer, "y") != NULL)
 800846a:	2179      	movs	r1, #121	; 0x79
 800846c:	a807      	add	r0, sp, #28
 800846e:	f007 fc29 	bl	800fcc4 <strchr>
 8008472:	42b0      	cmp	r0, r6
 8008474:	d002      	beq.n	800847c <StartDefaultTask+0x84>
	{
		il_lora_modem_join_network(&lora_config);
 8008476:	4668      	mov	r0, sp
 8008478:	f001 f9d6 	bl	8009828 <il_lora_modem_join_network>
	}
	// Clear the buffer.
	il_clear_buffer(buffer, 50);
 800847c:	2132      	movs	r1, #50	; 0x32
 800847e:	a807      	add	r0, sp, #28
 8008480:	f000 fd1f 	bl	8008ec2 <il_clear_buffer>

	/* Infinite loop */
	for(;;)
	{
	  // Check if user is ready to send a data packet
	  il_printf("\r\n Send Packet (y/n)? \r\n");
 8008484:	481a      	ldr	r0, [pc, #104]	; (80084f0 <StartDefaultTask+0xf8>)
 8008486:	f000 fd23 	bl	8008ed0 <il_printf>
	  il_usb_read_line(&usb, buffer);
 800848a:	0028      	movs	r0, r5
 800848c:	a907      	add	r1, sp, #28
 800848e:	f000 ff55 	bl	800933c <il_usb_read_line>
	  if(strstr((char*)buffer, "y") != NULL)
 8008492:	2179      	movs	r1, #121	; 0x79
 8008494:	a807      	add	r0, sp, #28
 8008496:	f007 fc15 	bl	800fcc4 <strchr>
 800849a:	2800      	cmp	r0, #0
 800849c:	d00c      	beq.n	80084b8 <StartDefaultTask+0xc0>
	  {
		  il_lora_status status = il_lora_modem_send_packet_u32(0xFF, port, RN_MAC_TX_UNCONFIRMED);
 800849e:	2101      	movs	r1, #1
 80084a0:	20ff      	movs	r0, #255	; 0xff
 80084a2:	4a14      	ldr	r2, [pc, #80]	; (80084f4 <StartDefaultTask+0xfc>)
 80084a4:	f001 fa16 	bl	80098d4 <il_lora_modem_send_packet_u32>

		  if(status == IL_LORA_MAC_TX_OK) {
 80084a8:	280d      	cmp	r0, #13
 80084aa:	d105      	bne.n	80084b8 <StartDefaultTask+0xc0>
			  il_delay(10);
 80084ac:	6823      	ldr	r3, [r4, #0]
 80084ae:	3803      	subs	r0, #3
 80084b0:	4798      	blx	r3
			  il_printf("Transmit Good!\r\n");
 80084b2:	4811      	ldr	r0, [pc, #68]	; (80084f8 <StartDefaultTask+0x100>)
 80084b4:	f000 fd0c 	bl	8008ed0 <il_printf>
		  }
	  }
	  il_clear_buffer(buffer, 50);
 80084b8:	2132      	movs	r1, #50	; 0x32
 80084ba:	a807      	add	r0, sp, #28
 80084bc:	f000 fd01 	bl	8008ec2 <il_clear_buffer>

	  il_printf("Test Working\r\n");
 80084c0:	480e      	ldr	r0, [pc, #56]	; (80084fc <StartDefaultTask+0x104>)
 80084c2:	f000 fd05 	bl	8008ed0 <il_printf>

	  il_delay(90000);
 80084c6:	6823      	ldr	r3, [r4, #0]
 80084c8:	480d      	ldr	r0, [pc, #52]	; (8008500 <StartDefaultTask+0x108>)
 80084ca:	4798      	blx	r3
	  il_printf("\r\n Send Packet (y/n)? \r\n");
 80084cc:	e7da      	b.n	8008484 <StartDefaultTask+0x8c>
 80084ce:	46c0      	nop			; (mov r8, r8)
 80084d0:	20000454 	.word	0x20000454
 80084d4:	2000208c 	.word	0x2000208c
 80084d8:	080104bc 	.word	0x080104bc
 80084dc:	20000400 	.word	0x20000400
 80084e0:	080104d2 	.word	0x080104d2
 80084e4:	080104f7 	.word	0x080104f7
 80084e8:	080104e7 	.word	0x080104e7
 80084ec:	08010508 	.word	0x08010508
 80084f0:	08010522 	.word	0x08010522
 80084f4:	0801053b 	.word	0x0801053b
 80084f8:	08010541 	.word	0x08010541
 80084fc:	08010552 	.word	0x08010552
 8008500:	00015f90 	.word	0x00015f90

08008504 <vApplicationGetIdleTaskMemory>:
  *ppxIdleTaskTCBBuffer = &xIdleTaskTCBBuffer;
 8008504:	4b03      	ldr	r3, [pc, #12]	; (8008514 <vApplicationGetIdleTaskMemory+0x10>)
 8008506:	6003      	str	r3, [r0, #0]
  *ppxIdleTaskStackBuffer = &xIdleStack[0];
 8008508:	4b03      	ldr	r3, [pc, #12]	; (8008518 <vApplicationGetIdleTaskMemory+0x14>)
 800850a:	600b      	str	r3, [r1, #0]
  *pulIdleTaskStackSize = configMINIMAL_STACK_SIZE;
 800850c:	2380      	movs	r3, #128	; 0x80
 800850e:	005b      	lsls	r3, r3, #1
 8008510:	6013      	str	r3, [r2, #0]
}
 8008512:	4770      	bx	lr
 8008514:	20000a5c 	.word	0x20000a5c
 8008518:	2000065c 	.word	0x2000065c

0800851c <MX_FREERTOS_Init>:
void MX_FREERTOS_Init(void) {
 800851c:	b530      	push	{r4, r5, lr}
 800851e:	b089      	sub	sp, #36	; 0x24
  osThreadDef(defaultTask, StartDefaultTask, osPriorityNormal, 0, 512);
 8008520:	a801      	add	r0, sp, #4
 8008522:	0002      	movs	r2, r0
 8008524:	4b06      	ldr	r3, [pc, #24]	; (8008540 <MX_FREERTOS_Init+0x24>)
 8008526:	cb32      	ldmia	r3!, {r1, r4, r5}
 8008528:	c232      	stmia	r2!, {r1, r4, r5}
 800852a:	cb32      	ldmia	r3!, {r1, r4, r5}
 800852c:	c232      	stmia	r2!, {r1, r4, r5}
 800852e:	681b      	ldr	r3, [r3, #0]
  defaultTaskHandle = osThreadCreate(osThread(defaultTask), NULL);
 8008530:	2100      	movs	r1, #0
  osThreadDef(defaultTask, StartDefaultTask, osPriorityNormal, 0, 512);
 8008532:	6013      	str	r3, [r2, #0]
  defaultTaskHandle = osThreadCreate(osThread(defaultTask), NULL);
 8008534:	f006 fb01 	bl	800eb3a <osThreadCreate>
 8008538:	4b02      	ldr	r3, [pc, #8]	; (8008544 <MX_FREERTOS_Init+0x28>)
 800853a:	6018      	str	r0, [r3, #0]
}
 800853c:	b009      	add	sp, #36	; 0x24
 800853e:	bd30      	pop	{r4, r5, pc}
 8008540:	08010494 	.word	0x08010494
 8008544:	20001aa4 	.word	0x20001aa4

08008548 <MX_GPIO_Init>:
        * EXTI
        * Free pins are configured automatically as Analog (this feature is enabled through
        * the Code Generation settings)
*/
void MX_GPIO_Init(void)
{
 8008548:	b5f0      	push	{r4, r5, r6, r7, lr}
 800854a:	b08b      	sub	sp, #44	; 0x2c

  GPIO_InitTypeDef GPIO_InitStruct = {0};
 800854c:	2214      	movs	r2, #20
 800854e:	2100      	movs	r1, #0
 8008550:	a805      	add	r0, sp, #20
 8008552:	f007 fad4 	bl	800fafe <memset>

  /* GPIO Ports Clock Enable */
  __HAL_RCC_GPIOC_CLK_ENABLE();
 8008556:	2080      	movs	r0, #128	; 0x80
 8008558:	4b35      	ldr	r3, [pc, #212]	; (8008630 <MX_GPIO_Init+0xe8>)
 800855a:	0300      	lsls	r0, r0, #12
 800855c:	6959      	ldr	r1, [r3, #20]
  __HAL_RCC_GPIOF_CLK_ENABLE();
  __HAL_RCC_GPIOA_CLK_ENABLE();
  __HAL_RCC_GPIOB_CLK_ENABLE();

  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(GPIOA, GPS_RST_Pin|GPIO2_Pin, GPIO_PIN_RESET);
 800855e:	27a0      	movs	r7, #160	; 0xa0
  __HAL_RCC_GPIOC_CLK_ENABLE();
 8008560:	4301      	orrs	r1, r0
 8008562:	6159      	str	r1, [r3, #20]
 8008564:	695a      	ldr	r2, [r3, #20]
  HAL_GPIO_WritePin(GPIOA, GPS_RST_Pin|GPIO2_Pin, GPIO_PIN_RESET);
 8008566:	2690      	movs	r6, #144	; 0x90
  __HAL_RCC_GPIOC_CLK_ENABLE();
 8008568:	4002      	ands	r2, r0
  __HAL_RCC_GPIOF_CLK_ENABLE();
 800856a:	2080      	movs	r0, #128	; 0x80
  __HAL_RCC_GPIOC_CLK_ENABLE();
 800856c:	9201      	str	r2, [sp, #4]
 800856e:	9a01      	ldr	r2, [sp, #4]
  __HAL_RCC_GPIOF_CLK_ENABLE();
 8008570:	6959      	ldr	r1, [r3, #20]
 8008572:	03c0      	lsls	r0, r0, #15
 8008574:	4301      	orrs	r1, r0
 8008576:	6159      	str	r1, [r3, #20]
 8008578:	695a      	ldr	r2, [r3, #20]

  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(GPIOB, GPIO4_Pin|MODEM_RST_Pin|GPIO7_Pin|GPIO5_Pin, GPIO_PIN_RESET);
 800857a:	4d2e      	ldr	r5, [pc, #184]	; (8008634 <MX_GPIO_Init+0xec>)
  __HAL_RCC_GPIOF_CLK_ENABLE();
 800857c:	4002      	ands	r2, r0
  __HAL_RCC_GPIOA_CLK_ENABLE();
 800857e:	2080      	movs	r0, #128	; 0x80
  __HAL_RCC_GPIOF_CLK_ENABLE();
 8008580:	9202      	str	r2, [sp, #8]
 8008582:	9a02      	ldr	r2, [sp, #8]
  __HAL_RCC_GPIOA_CLK_ENABLE();
 8008584:	6959      	ldr	r1, [r3, #20]
 8008586:	0280      	lsls	r0, r0, #10
 8008588:	4301      	orrs	r1, r0
 800858a:	6159      	str	r1, [r3, #20]
  __HAL_RCC_GPIOB_CLK_ENABLE();
 800858c:	2180      	movs	r1, #128	; 0x80
  __HAL_RCC_GPIOA_CLK_ENABLE();
 800858e:	695a      	ldr	r2, [r3, #20]
  __HAL_RCC_GPIOB_CLK_ENABLE();
 8008590:	02c9      	lsls	r1, r1, #11
  __HAL_RCC_GPIOA_CLK_ENABLE();
 8008592:	4002      	ands	r2, r0
 8008594:	9203      	str	r2, [sp, #12]
 8008596:	9a03      	ldr	r2, [sp, #12]
  __HAL_RCC_GPIOB_CLK_ENABLE();
 8008598:	695a      	ldr	r2, [r3, #20]
  HAL_GPIO_WritePin(GPIOA, GPS_RST_Pin|GPIO2_Pin, GPIO_PIN_RESET);
 800859a:	007f      	lsls	r7, r7, #1
  __HAL_RCC_GPIOB_CLK_ENABLE();
 800859c:	430a      	orrs	r2, r1
 800859e:	615a      	str	r2, [r3, #20]
 80085a0:	695b      	ldr	r3, [r3, #20]
  HAL_GPIO_WritePin(GPIOA, GPS_RST_Pin|GPIO2_Pin, GPIO_PIN_RESET);
 80085a2:	05f6      	lsls	r6, r6, #23
  __HAL_RCC_GPIOB_CLK_ENABLE();
 80085a4:	400b      	ands	r3, r1
  HAL_GPIO_WritePin(GPIOA, GPS_RST_Pin|GPIO2_Pin, GPIO_PIN_RESET);
 80085a6:	0030      	movs	r0, r6
 80085a8:	0039      	movs	r1, r7
  __HAL_RCC_GPIOB_CLK_ENABLE();
 80085aa:	9304      	str	r3, [sp, #16]
  HAL_GPIO_WritePin(GPIOA, GPS_RST_Pin|GPIO2_Pin, GPIO_PIN_RESET);
 80085ac:	2200      	movs	r2, #0
  __HAL_RCC_GPIOB_CLK_ENABLE();
 80085ae:	9b04      	ldr	r3, [sp, #16]
  HAL_GPIO_WritePin(GPIOA, GPS_RST_Pin|GPIO2_Pin, GPIO_PIN_RESET);
 80085b0:	f001 ffc0 	bl	800a534 <HAL_GPIO_WritePin>
  HAL_GPIO_WritePin(GPIOB, GPIO4_Pin|MODEM_RST_Pin|GPIO7_Pin|GPIO5_Pin, GPIO_PIN_RESET);
 80085b4:	2200      	movs	r2, #0
 80085b6:	0028      	movs	r0, r5
 80085b8:	491f      	ldr	r1, [pc, #124]	; (8008638 <MX_GPIO_Init+0xf0>)
 80085ba:	f001 ffbb 	bl	800a534 <HAL_GPIO_WritePin>

  /*Configure GPIO pin : PtPin */
  GPIO_InitStruct.Pin = BATT_STATUS1_Pin;
 80085be:	2380      	movs	r3, #128	; 0x80
  GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
 80085c0:	2400      	movs	r4, #0
  GPIO_InitStruct.Pin = BATT_STATUS1_Pin;
 80085c2:	019b      	lsls	r3, r3, #6
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  HAL_GPIO_Init(BATT_STATUS1_GPIO_Port, &GPIO_InitStruct);
 80085c4:	a905      	add	r1, sp, #20
 80085c6:	481d      	ldr	r0, [pc, #116]	; (800863c <MX_GPIO_Init+0xf4>)
  GPIO_InitStruct.Pin = BATT_STATUS1_Pin;
 80085c8:	9305      	str	r3, [sp, #20]
  GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
 80085ca:	9406      	str	r4, [sp, #24]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 80085cc:	9407      	str	r4, [sp, #28]
  HAL_GPIO_Init(BATT_STATUS1_GPIO_Port, &GPIO_InitStruct);
 80085ce:	f001 fe89 	bl	800a2e4 <HAL_GPIO_Init>

  /*Configure GPIO pins : PAPin PAPin */
  GPIO_InitStruct.Pin = GPS_RST_Pin|GPIO2_Pin;
 80085d2:	9705      	str	r7, [sp, #20]
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
 80085d4:	3f40      	subs	r7, #64	; 0x40
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
  HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 80085d6:	0030      	movs	r0, r6
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
 80085d8:	3fff      	subs	r7, #255	; 0xff
  HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 80085da:	a905      	add	r1, sp, #20
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
 80085dc:	9706      	str	r7, [sp, #24]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 80085de:	9407      	str	r4, [sp, #28]
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 80085e0:	9408      	str	r4, [sp, #32]
  HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 80085e2:	f001 fe7f 	bl	800a2e4 <HAL_GPIO_Init>

  /*Configure GPIO pins : PBPin PBPin */
  GPIO_InitStruct.Pin = BATT_GPOUT_Pin|BATT_STATUS2_Pin;
 80085e6:	2381      	movs	r3, #129	; 0x81
  GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 80085e8:	0028      	movs	r0, r5
  GPIO_InitStruct.Pin = BATT_GPOUT_Pin|BATT_STATUS2_Pin;
 80085ea:	005b      	lsls	r3, r3, #1
  HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 80085ec:	a905      	add	r1, sp, #20
  GPIO_InitStruct.Pin = BATT_GPOUT_Pin|BATT_STATUS2_Pin;
 80085ee:	9305      	str	r3, [sp, #20]
  GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
 80085f0:	9406      	str	r4, [sp, #24]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 80085f2:	9407      	str	r4, [sp, #28]
  HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 80085f4:	f001 fe76 	bl	800a2e4 <HAL_GPIO_Init>

  /*Configure GPIO pins : PBPin PBPin PBPin PBPin */
  GPIO_InitStruct.Pin = GPIO4_Pin|MODEM_RST_Pin|GPIO7_Pin|GPIO5_Pin;
 80085f8:	4b0f      	ldr	r3, [pc, #60]	; (8008638 <MX_GPIO_Init+0xf0>)
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
  HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 80085fa:	0028      	movs	r0, r5
 80085fc:	a905      	add	r1, sp, #20
  GPIO_InitStruct.Pin = GPIO4_Pin|MODEM_RST_Pin|GPIO7_Pin|GPIO5_Pin;
 80085fe:	9305      	str	r3, [sp, #20]
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
 8008600:	9706      	str	r7, [sp, #24]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 8008602:	9407      	str	r4, [sp, #28]
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 8008604:	9408      	str	r4, [sp, #32]
  HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 8008606:	f001 fe6d 	bl	800a2e4 <HAL_GPIO_Init>

  /*Configure GPIO pin : PB5 */
  GPIO_InitStruct.Pin = GPIO_PIN_5;
 800860a:	2320      	movs	r3, #32
 800860c:	9305      	str	r3, [sp, #20]
  GPIO_InitStruct.Mode = GPIO_MODE_IT_RISING;
 800860e:	4b0c      	ldr	r3, [pc, #48]	; (8008640 <MX_GPIO_Init+0xf8>)
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 8008610:	0028      	movs	r0, r5
 8008612:	a905      	add	r1, sp, #20
  GPIO_InitStruct.Mode = GPIO_MODE_IT_RISING;
 8008614:	9306      	str	r3, [sp, #24]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 8008616:	9407      	str	r4, [sp, #28]
  HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 8008618:	f001 fe64 	bl	800a2e4 <HAL_GPIO_Init>

  /* EXTI interrupt init*/
  HAL_NVIC_SetPriority(EXTI4_15_IRQn, 3, 0);
 800861c:	0022      	movs	r2, r4
 800861e:	2103      	movs	r1, #3
 8008620:	2007      	movs	r0, #7
 8008622:	f001 fc49 	bl	8009eb8 <HAL_NVIC_SetPriority>
  HAL_NVIC_EnableIRQ(EXTI4_15_IRQn);
 8008626:	2007      	movs	r0, #7
 8008628:	f001 fc7a 	bl	8009f20 <HAL_NVIC_EnableIRQ>

}
 800862c:	b00b      	add	sp, #44	; 0x2c
 800862e:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8008630:	40021000 	.word	0x40021000
 8008634:	48000400 	.word	0x48000400
 8008638:	0000900c 	.word	0x0000900c
 800863c:	48000800 	.word	0x48000800
 8008640:	10110000 	.word	0x10110000

08008644 <MX_I2C1_Init>:
I2C_HandleTypeDef hi2c1;
I2C_HandleTypeDef hi2c2;

/* I2C1 init function */
void MX_I2C1_Init(void)
{
 8008644:	b510      	push	{r4, lr}
  /* USER CODE END I2C1_Init 0 */

  /* USER CODE BEGIN I2C1_Init 1 */

  /* USER CODE END I2C1_Init 1 */
  hi2c1.Instance = I2C1;
 8008646:	4b13      	ldr	r3, [pc, #76]	; (8008694 <MX_I2C1_Init+0x50>)
 8008648:	4c13      	ldr	r4, [pc, #76]	; (8008698 <MX_I2C1_Init+0x54>)
  hi2c1.Init.Timing = 0x2000090E;
  hi2c1.Init.OwnAddress1 = 0;
  hi2c1.Init.AddressingMode = I2C_ADDRESSINGMODE_7BIT;
 800864a:	2201      	movs	r2, #1
  hi2c1.Instance = I2C1;
 800864c:	6023      	str	r3, [r4, #0]
  hi2c1.Init.Timing = 0x2000090E;
 800864e:	4b13      	ldr	r3, [pc, #76]	; (800869c <MX_I2C1_Init+0x58>)
  hi2c1.Init.DualAddressMode = I2C_DUALADDRESS_DISABLE;
  hi2c1.Init.OwnAddress2 = 0;
  hi2c1.Init.OwnAddress2Masks = I2C_OA2_NOMASK;
  hi2c1.Init.GeneralCallMode = I2C_GENERALCALL_DISABLE;
  hi2c1.Init.NoStretchMode = I2C_NOSTRETCH_DISABLE;
  if (HAL_I2C_Init(&hi2c1) != HAL_OK)
 8008650:	0020      	movs	r0, r4
  hi2c1.Init.Timing = 0x2000090E;
 8008652:	6063      	str	r3, [r4, #4]
  hi2c1.Init.OwnAddress1 = 0;
 8008654:	2300      	movs	r3, #0
  hi2c1.Init.AddressingMode = I2C_ADDRESSINGMODE_7BIT;
 8008656:	60e2      	str	r2, [r4, #12]
  hi2c1.Init.OwnAddress1 = 0;
 8008658:	60a3      	str	r3, [r4, #8]
  hi2c1.Init.DualAddressMode = I2C_DUALADDRESS_DISABLE;
 800865a:	6123      	str	r3, [r4, #16]
  hi2c1.Init.OwnAddress2 = 0;
 800865c:	6163      	str	r3, [r4, #20]
  hi2c1.Init.OwnAddress2Masks = I2C_OA2_NOMASK;
 800865e:	61a3      	str	r3, [r4, #24]
  hi2c1.Init.GeneralCallMode = I2C_GENERALCALL_DISABLE;
 8008660:	61e3      	str	r3, [r4, #28]
  hi2c1.Init.NoStretchMode = I2C_NOSTRETCH_DISABLE;
 8008662:	6223      	str	r3, [r4, #32]
  if (HAL_I2C_Init(&hi2c1) != HAL_OK)
 8008664:	f001 ffc0 	bl	800a5e8 <HAL_I2C_Init>
 8008668:	2800      	cmp	r0, #0
 800866a:	d001      	beq.n	8008670 <MX_I2C1_Init+0x2c>
  {
    Error_Handler();
 800866c:	f000 f95e 	bl	800892c <Error_Handler>
  }
  /** Configure Analogue filter
  */
  if (HAL_I2CEx_ConfigAnalogFilter(&hi2c1, I2C_ANALOGFILTER_ENABLE) != HAL_OK)
 8008670:	2100      	movs	r1, #0
 8008672:	0020      	movs	r0, r4
 8008674:	f002 fb3c 	bl	800acf0 <HAL_I2CEx_ConfigAnalogFilter>
 8008678:	2800      	cmp	r0, #0
 800867a:	d001      	beq.n	8008680 <MX_I2C1_Init+0x3c>
  {
    Error_Handler();
 800867c:	f000 f956 	bl	800892c <Error_Handler>
  }
  /** Configure Digital filter
  */
  if (HAL_I2CEx_ConfigDigitalFilter(&hi2c1, 0) != HAL_OK)
 8008680:	2100      	movs	r1, #0
 8008682:	0020      	movs	r0, r4
 8008684:	f002 fb74 	bl	800ad70 <HAL_I2CEx_ConfigDigitalFilter>
 8008688:	2800      	cmp	r0, #0
 800868a:	d001      	beq.n	8008690 <MX_I2C1_Init+0x4c>
  {
    Error_Handler();
 800868c:	f000 f94e 	bl	800892c <Error_Handler>
  }
  /* USER CODE BEGIN I2C1_Init 2 */

  /* USER CODE END I2C1_Init 2 */

}
 8008690:	bd10      	pop	{r4, pc}
 8008692:	46c0      	nop			; (mov r8, r8)
 8008694:	40005400 	.word	0x40005400
 8008698:	20001aa8 	.word	0x20001aa8
 800869c:	2000090e 	.word	0x2000090e

080086a0 <MX_I2C2_Init>:
/* I2C2 init function */
void MX_I2C2_Init(void)
{
 80086a0:	b510      	push	{r4, lr}
  /* USER CODE END I2C2_Init 0 */

  /* USER CODE BEGIN I2C2_Init 1 */

  /* USER CODE END I2C2_Init 1 */
  hi2c2.Instance = I2C2;
 80086a2:	4b13      	ldr	r3, [pc, #76]	; (80086f0 <MX_I2C2_Init+0x50>)
 80086a4:	4c13      	ldr	r4, [pc, #76]	; (80086f4 <MX_I2C2_Init+0x54>)
  hi2c2.Init.Timing = 0x20303E5D;
  hi2c2.Init.OwnAddress1 = 0;
  hi2c2.Init.AddressingMode = I2C_ADDRESSINGMODE_7BIT;
 80086a6:	2201      	movs	r2, #1
  hi2c2.Instance = I2C2;
 80086a8:	6023      	str	r3, [r4, #0]
  hi2c2.Init.Timing = 0x20303E5D;
 80086aa:	4b13      	ldr	r3, [pc, #76]	; (80086f8 <MX_I2C2_Init+0x58>)
  hi2c2.Init.DualAddressMode = I2C_DUALADDRESS_DISABLE;
  hi2c2.Init.OwnAddress2 = 0;
  hi2c2.Init.OwnAddress2Masks = I2C_OA2_NOMASK;
  hi2c2.Init.GeneralCallMode = I2C_GENERALCALL_DISABLE;
  hi2c2.Init.NoStretchMode = I2C_NOSTRETCH_DISABLE;
  if (HAL_I2C_Init(&hi2c2) != HAL_OK)
 80086ac:	0020      	movs	r0, r4
  hi2c2.Init.Timing = 0x20303E5D;
 80086ae:	6063      	str	r3, [r4, #4]
  hi2c2.Init.OwnAddress1 = 0;
 80086b0:	2300      	movs	r3, #0
  hi2c2.Init.AddressingMode = I2C_ADDRESSINGMODE_7BIT;
 80086b2:	60e2      	str	r2, [r4, #12]
  hi2c2.Init.OwnAddress1 = 0;
 80086b4:	60a3      	str	r3, [r4, #8]
  hi2c2.Init.DualAddressMode = I2C_DUALADDRESS_DISABLE;
 80086b6:	6123      	str	r3, [r4, #16]
  hi2c2.Init.OwnAddress2 = 0;
 80086b8:	6163      	str	r3, [r4, #20]
  hi2c2.Init.OwnAddress2Masks = I2C_OA2_NOMASK;
 80086ba:	61a3      	str	r3, [r4, #24]
  hi2c2.Init.GeneralCallMode = I2C_GENERALCALL_DISABLE;
 80086bc:	61e3      	str	r3, [r4, #28]
  hi2c2.Init.NoStretchMode = I2C_NOSTRETCH_DISABLE;
 80086be:	6223      	str	r3, [r4, #32]
  if (HAL_I2C_Init(&hi2c2) != HAL_OK)
 80086c0:	f001 ff92 	bl	800a5e8 <HAL_I2C_Init>
 80086c4:	2800      	cmp	r0, #0
 80086c6:	d001      	beq.n	80086cc <MX_I2C2_Init+0x2c>
  {
    Error_Handler();
 80086c8:	f000 f930 	bl	800892c <Error_Handler>
  }
  /** Configure Analogue filter
  */
  if (HAL_I2CEx_ConfigAnalogFilter(&hi2c2, I2C_ANALOGFILTER_ENABLE) != HAL_OK)
 80086cc:	2100      	movs	r1, #0
 80086ce:	0020      	movs	r0, r4
 80086d0:	f002 fb0e 	bl	800acf0 <HAL_I2CEx_ConfigAnalogFilter>
 80086d4:	2800      	cmp	r0, #0
 80086d6:	d001      	beq.n	80086dc <MX_I2C2_Init+0x3c>
  {
    Error_Handler();
 80086d8:	f000 f928 	bl	800892c <Error_Handler>
  }
  /** Configure Digital filter
  */
  if (HAL_I2CEx_ConfigDigitalFilter(&hi2c2, 0) != HAL_OK)
 80086dc:	2100      	movs	r1, #0
 80086de:	0020      	movs	r0, r4
 80086e0:	f002 fb46 	bl	800ad70 <HAL_I2CEx_ConfigDigitalFilter>
 80086e4:	2800      	cmp	r0, #0
 80086e6:	d001      	beq.n	80086ec <MX_I2C2_Init+0x4c>
  {
    Error_Handler();
 80086e8:	f000 f920 	bl	800892c <Error_Handler>
  }
  /* USER CODE BEGIN I2C2_Init 2 */

  /* USER CODE END I2C2_Init 2 */

}
 80086ec:	bd10      	pop	{r4, pc}
 80086ee:	46c0      	nop			; (mov r8, r8)
 80086f0:	40005800 	.word	0x40005800
 80086f4:	20001af4 	.word	0x20001af4
 80086f8:	20303e5d 	.word	0x20303e5d

080086fc <HAL_I2C_MspInit>:

void HAL_I2C_MspInit(I2C_HandleTypeDef* i2cHandle)
{
 80086fc:	b530      	push	{r4, r5, lr}
 80086fe:	0004      	movs	r4, r0
 8008700:	b08b      	sub	sp, #44	; 0x2c

  GPIO_InitTypeDef GPIO_InitStruct = {0};
 8008702:	2214      	movs	r2, #20
 8008704:	2100      	movs	r1, #0
 8008706:	a805      	add	r0, sp, #20
 8008708:	f007 f9f9 	bl	800fafe <memset>
  if(i2cHandle->Instance==I2C1)
 800870c:	6823      	ldr	r3, [r4, #0]
 800870e:	4a2d      	ldr	r2, [pc, #180]	; (80087c4 <HAL_I2C_MspInit+0xc8>)
 8008710:	4293      	cmp	r3, r2
 8008712:	d12a      	bne.n	800876a <HAL_I2C_MspInit+0x6e>
  {
  /* USER CODE BEGIN I2C1_MspInit 0 */

  /* USER CODE END I2C1_MspInit 0 */

    __HAL_RCC_GPIOB_CLK_ENABLE();
 8008714:	2180      	movs	r1, #128	; 0x80
 8008716:	4c2c      	ldr	r4, [pc, #176]	; (80087c8 <HAL_I2C_MspInit+0xcc>)
 8008718:	02c9      	lsls	r1, r1, #11
 800871a:	6962      	ldr	r2, [r4, #20]
    PB9     ------> I2C1_SDA
    */
    GPIO_InitStruct.Pin = GPIO_PIN_6|GPIO_PIN_9;
    GPIO_InitStruct.Mode = GPIO_MODE_AF_OD;
    GPIO_InitStruct.Pull = GPIO_PULLUP;
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;
 800871c:	2503      	movs	r5, #3
    __HAL_RCC_GPIOB_CLK_ENABLE();
 800871e:	430a      	orrs	r2, r1
 8008720:	6162      	str	r2, [r4, #20]
 8008722:	6963      	ldr	r3, [r4, #20]
    GPIO_InitStruct.Alternate = GPIO_AF1_I2C1;
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 8008724:	4829      	ldr	r0, [pc, #164]	; (80087cc <HAL_I2C_MspInit+0xd0>)
    __HAL_RCC_GPIOB_CLK_ENABLE();
 8008726:	400b      	ands	r3, r1
 8008728:	9301      	str	r3, [sp, #4]
 800872a:	9b01      	ldr	r3, [sp, #4]
    GPIO_InitStruct.Pin = GPIO_PIN_6|GPIO_PIN_9;
 800872c:	2390      	movs	r3, #144	; 0x90
 800872e:	009b      	lsls	r3, r3, #2
 8008730:	9305      	str	r3, [sp, #20]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_OD;
 8008732:	2312      	movs	r3, #18
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 8008734:	a905      	add	r1, sp, #20
    GPIO_InitStruct.Mode = GPIO_MODE_AF_OD;
 8008736:	9306      	str	r3, [sp, #24]
    GPIO_InitStruct.Pull = GPIO_PULLUP;
 8008738:	3b11      	subs	r3, #17
 800873a:	9307      	str	r3, [sp, #28]
    GPIO_InitStruct.Alternate = GPIO_AF1_I2C1;
 800873c:	9309      	str	r3, [sp, #36]	; 0x24
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;
 800873e:	9508      	str	r5, [sp, #32]
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 8008740:	f001 fdd0 	bl	800a2e4 <HAL_GPIO_Init>

    /* I2C1 clock enable */
    __HAL_RCC_I2C1_CLK_ENABLE();
 8008744:	2180      	movs	r1, #128	; 0x80
 8008746:	69e2      	ldr	r2, [r4, #28]
 8008748:	0389      	lsls	r1, r1, #14
 800874a:	430a      	orrs	r2, r1
 800874c:	61e2      	str	r2, [r4, #28]
 800874e:	69e3      	ldr	r3, [r4, #28]

    /* I2C1 interrupt Init */
    HAL_NVIC_SetPriority(I2C1_IRQn, 3, 0);
 8008750:	2017      	movs	r0, #23
    __HAL_RCC_I2C1_CLK_ENABLE();
 8008752:	400b      	ands	r3, r1
 8008754:	9302      	str	r3, [sp, #8]
    HAL_NVIC_SetPriority(I2C1_IRQn, 3, 0);
 8008756:	2200      	movs	r2, #0
 8008758:	0029      	movs	r1, r5
    __HAL_RCC_I2C1_CLK_ENABLE();
 800875a:	9b02      	ldr	r3, [sp, #8]
    HAL_NVIC_SetPriority(I2C1_IRQn, 3, 0);
 800875c:	f001 fbac 	bl	8009eb8 <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(I2C1_IRQn);
 8008760:	2017      	movs	r0, #23
    /* I2C2 clock enable */
    __HAL_RCC_I2C2_CLK_ENABLE();

    /* I2C2 interrupt Init */
    HAL_NVIC_SetPriority(I2C2_IRQn, 3, 0);
    HAL_NVIC_EnableIRQ(I2C2_IRQn);
 8008762:	f001 fbdd 	bl	8009f20 <HAL_NVIC_EnableIRQ>
  /* USER CODE BEGIN I2C2_MspInit 1 */

  /* USER CODE END I2C2_MspInit 1 */
  }
}
 8008766:	b00b      	add	sp, #44	; 0x2c
 8008768:	bd30      	pop	{r4, r5, pc}
  else if(i2cHandle->Instance==I2C2)
 800876a:	4a19      	ldr	r2, [pc, #100]	; (80087d0 <HAL_I2C_MspInit+0xd4>)
 800876c:	4293      	cmp	r3, r2
 800876e:	d1fa      	bne.n	8008766 <HAL_I2C_MspInit+0x6a>
    __HAL_RCC_GPIOB_CLK_ENABLE();
 8008770:	2180      	movs	r1, #128	; 0x80
 8008772:	4c15      	ldr	r4, [pc, #84]	; (80087c8 <HAL_I2C_MspInit+0xcc>)
 8008774:	02c9      	lsls	r1, r1, #11
 8008776:	6962      	ldr	r2, [r4, #20]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;
 8008778:	2503      	movs	r5, #3
    __HAL_RCC_GPIOB_CLK_ENABLE();
 800877a:	430a      	orrs	r2, r1
 800877c:	6162      	str	r2, [r4, #20]
 800877e:	6963      	ldr	r3, [r4, #20]
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 8008780:	4812      	ldr	r0, [pc, #72]	; (80087cc <HAL_I2C_MspInit+0xd0>)
    __HAL_RCC_GPIOB_CLK_ENABLE();
 8008782:	400b      	ands	r3, r1
 8008784:	9303      	str	r3, [sp, #12]
 8008786:	9b03      	ldr	r3, [sp, #12]
    GPIO_InitStruct.Pin = GPIO_PIN_13|GPIO_PIN_14;
 8008788:	23c0      	movs	r3, #192	; 0xc0
 800878a:	01db      	lsls	r3, r3, #7
 800878c:	9305      	str	r3, [sp, #20]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_OD;
 800878e:	2312      	movs	r3, #18
 8008790:	9306      	str	r3, [sp, #24]
    GPIO_InitStruct.Pull = GPIO_PULLUP;
 8008792:	3b11      	subs	r3, #17
 8008794:	9307      	str	r3, [sp, #28]
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 8008796:	a905      	add	r1, sp, #20
    GPIO_InitStruct.Alternate = GPIO_AF5_I2C2;
 8008798:	3304      	adds	r3, #4
 800879a:	9309      	str	r3, [sp, #36]	; 0x24
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;
 800879c:	9508      	str	r5, [sp, #32]
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 800879e:	f001 fda1 	bl	800a2e4 <HAL_GPIO_Init>
    __HAL_RCC_I2C2_CLK_ENABLE();
 80087a2:	2180      	movs	r1, #128	; 0x80
 80087a4:	69e2      	ldr	r2, [r4, #28]
 80087a6:	03c9      	lsls	r1, r1, #15
 80087a8:	430a      	orrs	r2, r1
 80087aa:	61e2      	str	r2, [r4, #28]
 80087ac:	69e3      	ldr	r3, [r4, #28]
    HAL_NVIC_SetPriority(I2C2_IRQn, 3, 0);
 80087ae:	2018      	movs	r0, #24
    __HAL_RCC_I2C2_CLK_ENABLE();
 80087b0:	400b      	ands	r3, r1
 80087b2:	9304      	str	r3, [sp, #16]
    HAL_NVIC_SetPriority(I2C2_IRQn, 3, 0);
 80087b4:	2200      	movs	r2, #0
 80087b6:	0029      	movs	r1, r5
    __HAL_RCC_I2C2_CLK_ENABLE();
 80087b8:	9b04      	ldr	r3, [sp, #16]
    HAL_NVIC_SetPriority(I2C2_IRQn, 3, 0);
 80087ba:	f001 fb7d 	bl	8009eb8 <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(I2C2_IRQn);
 80087be:	2018      	movs	r0, #24
 80087c0:	e7cf      	b.n	8008762 <HAL_I2C_MspInit+0x66>
 80087c2:	46c0      	nop			; (mov r8, r8)
 80087c4:	40005400 	.word	0x40005400
 80087c8:	40021000 	.word	0x40021000
 80087cc:	48000400 	.word	0x48000400
 80087d0:	40005800 	.word	0x40005800

080087d4 <remap_vector_table>:
#ifdef BOOTLOADER
  void remap_vector_table()
  {

  	uint32_t Index = 0;
  	for(Index = 0; Index < 48; Index++) {
 80087d4:	2300      	movs	r3, #0
  		VectorTable[Index] = *(__IO uint32_t*)((uint32_t)APPLICATION_ADDRESS + (Index << 2));
 80087d6:	4916      	ldr	r1, [pc, #88]	; (8008830 <remap_vector_table+0x5c>)
 80087d8:	4816      	ldr	r0, [pc, #88]	; (8008834 <remap_vector_table+0x60>)
 80087da:	009a      	lsls	r2, r3, #2
 80087dc:	1810      	adds	r0, r2, r0
 80087de:	6800      	ldr	r0, [r0, #0]
  	for(Index = 0; Index < 48; Index++) {
 80087e0:	3301      	adds	r3, #1
  		VectorTable[Index] = *(__IO uint32_t*)((uint32_t)APPLICATION_ADDRESS + (Index << 2));
 80087e2:	5050      	str	r0, [r2, r1]
  	for(Index = 0; Index < 48; Index++) {
 80087e4:	2b30      	cmp	r3, #48	; 0x30
 80087e6:	d1f7      	bne.n	80087d8 <remap_vector_table+0x4>
  	}

  	__HAL_RCC_USB_FORCE_RESET();
 80087e8:	2280      	movs	r2, #128	; 0x80
 80087ea:	4b13      	ldr	r3, [pc, #76]	; (8008838 <remap_vector_table+0x64>)
 80087ec:	0412      	lsls	r2, r2, #16
 80087ee:	6919      	ldr	r1, [r3, #16]
 80087f0:	430a      	orrs	r2, r1
 80087f2:	611a      	str	r2, [r3, #16]
  	__HAL_RCC_GPIOA_FORCE_RESET();
 80087f4:	2280      	movs	r2, #128	; 0x80
 80087f6:	6a99      	ldr	r1, [r3, #40]	; 0x28
 80087f8:	0292      	lsls	r2, r2, #10
 80087fa:	430a      	orrs	r2, r1
 80087fc:	629a      	str	r2, [r3, #40]	; 0x28

  	__HAL_RCC_USB_RELEASE_RESET();
 80087fe:	691a      	ldr	r2, [r3, #16]
 8008800:	490e      	ldr	r1, [pc, #56]	; (800883c <remap_vector_table+0x68>)
 8008802:	400a      	ands	r2, r1
 8008804:	611a      	str	r2, [r3, #16]
  	__HAL_RCC_GPIOA_RELEASE_RESET();
 8008806:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 8008808:	490d      	ldr	r1, [pc, #52]	; (8008840 <remap_vector_table+0x6c>)
 800880a:	400a      	ands	r2, r1
 800880c:	629a      	str	r2, [r3, #40]	; 0x28

  	__HAL_SYSCFG_REMAPMEMORY_SYSTEMFLASH();
 800880e:	2203      	movs	r2, #3
 8008810:	4b0c      	ldr	r3, [pc, #48]	; (8008844 <remap_vector_table+0x70>)
 8008812:	6819      	ldr	r1, [r3, #0]
 8008814:	4391      	bics	r1, r2
 8008816:	6019      	str	r1, [r3, #0]
 8008818:	2101      	movs	r1, #1
 800881a:	6818      	ldr	r0, [r3, #0]
 800881c:	4301      	orrs	r1, r0
 800881e:	6019      	str	r1, [r3, #0]
  	__HAL_SYSCFG_REMAPMEMORY_SRAM();
 8008820:	6819      	ldr	r1, [r3, #0]
 8008822:	4391      	bics	r1, r2
 8008824:	6019      	str	r1, [r3, #0]
 8008826:	6819      	ldr	r1, [r3, #0]
 8008828:	430a      	orrs	r2, r1
 800882a:	601a      	str	r2, [r3, #0]

  }
 800882c:	4770      	bx	lr
 800882e:	46c0      	nop			; (mov r8, r8)
 8008830:	20000000 	.word	0x20000000
 8008834:	08008000 	.word	0x08008000
 8008838:	40021000 	.word	0x40021000
 800883c:	ff7fffff 	.word	0xff7fffff
 8008840:	fffdffff 	.word	0xfffdffff
 8008844:	40010000 	.word	0x40010000

08008848 <SystemClock_Config>:
/**
  * @brief System Clock Configuration
  * @retval None
  */
void SystemClock_Config(void)
{
 8008848:	b530      	push	{r4, r5, lr}
  RCC_OscInitTypeDef RCC_OscInitStruct = {0};
  RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
 800884a:	2510      	movs	r5, #16
{
 800884c:	b097      	sub	sp, #92	; 0x5c
  RCC_OscInitTypeDef RCC_OscInitStruct = {0};
 800884e:	2218      	movs	r2, #24
 8008850:	2100      	movs	r1, #0
 8008852:	a80c      	add	r0, sp, #48	; 0x30
 8008854:	f007 f953 	bl	800fafe <memset>
  RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
 8008858:	002a      	movs	r2, r5
 800885a:	2100      	movs	r1, #0
 800885c:	a801      	add	r0, sp, #4
 800885e:	f007 f94e 	bl	800fafe <memset>
  RCC_PeriphCLKInitTypeDef PeriphClkInit = {0};
 8008862:	2214      	movs	r2, #20
 8008864:	2100      	movs	r1, #0
 8008866:	a805      	add	r0, sp, #20
 8008868:	f007 f949 	bl	800fafe <memset>

  /** Initializes the RCC Oscillators according to the specified parameters
  * in the RCC_OscInitTypeDef structure.
  */
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI|RCC_OSCILLATORTYPE_HSI14
 800886c:	2313      	movs	r3, #19
 800886e:	930a      	str	r3, [sp, #40]	; 0x28
  RCC_OscInitStruct.HSIState = RCC_HSI_ON;
  RCC_OscInitStruct.HSI14State = RCC_HSI14_ON;
  RCC_OscInitStruct.HSICalibrationValue = RCC_HSICALIBRATION_DEFAULT;
  RCC_OscInitStruct.HSI14CalibrationValue = 16;
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
  RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
 8008870:	2380      	movs	r3, #128	; 0x80
 8008872:	025b      	lsls	r3, r3, #9
 8008874:	9313      	str	r3, [sp, #76]	; 0x4c
  RCC_OscInitStruct.PLL.PLLMUL = RCC_PLL_MUL6;
 8008876:	2380      	movs	r3, #128	; 0x80
 8008878:	035b      	lsls	r3, r3, #13
  RCC_OscInitStruct.HSEState = RCC_HSE_ON;
 800887a:	2401      	movs	r4, #1
  RCC_OscInitStruct.PLL.PLLMUL = RCC_PLL_MUL6;
 800887c:	9314      	str	r3, [sp, #80]	; 0x50
  RCC_OscInitStruct.PLL.PREDIV = RCC_PREDIV_DIV1;
 800887e:	2300      	movs	r3, #0
  RCC_OscInitStruct.HSICalibrationValue = RCC_HSICALIBRATION_DEFAULT;
 8008880:	950e      	str	r5, [sp, #56]	; 0x38
  RCC_OscInitStruct.HSI14CalibrationValue = 16;
 8008882:	9510      	str	r5, [sp, #64]	; 0x40
  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
 8008884:	a80a      	add	r0, sp, #40	; 0x28
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
 8008886:	3d0e      	subs	r5, #14
  RCC_OscInitStruct.HSEState = RCC_HSE_ON;
 8008888:	940b      	str	r4, [sp, #44]	; 0x2c
  RCC_OscInitStruct.HSIState = RCC_HSI_ON;
 800888a:	940d      	str	r4, [sp, #52]	; 0x34
  RCC_OscInitStruct.HSI14State = RCC_HSI14_ON;
 800888c:	940f      	str	r4, [sp, #60]	; 0x3c
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
 800888e:	9512      	str	r5, [sp, #72]	; 0x48
  RCC_OscInitStruct.PLL.PREDIV = RCC_PREDIV_DIV1;
 8008890:	9315      	str	r3, [sp, #84]	; 0x54
  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
 8008892:	f003 f897 	bl	800b9c4 <HAL_RCC_OscConfig>
 8008896:	2800      	cmp	r0, #0
 8008898:	d001      	beq.n	800889e <SystemClock_Config+0x56>
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 800889a:	b672      	cpsid	i
void Error_Handler(void)
{
  /* USER CODE BEGIN Error_Handler_Debug */
  /* User can add his own implementation to report the HAL error return state */
  __disable_irq();
  while (1)
 800889c:	e7fe      	b.n	800889c <SystemClock_Config+0x54>
  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
 800889e:	2307      	movs	r3, #7
  RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
 80088a0:	9003      	str	r0, [sp, #12]
  RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV1;
 80088a2:	9004      	str	r0, [sp, #16]
  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_1) != HAL_OK)
 80088a4:	0021      	movs	r1, r4
 80088a6:	a801      	add	r0, sp, #4
  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
 80088a8:	9301      	str	r3, [sp, #4]
  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
 80088aa:	9502      	str	r5, [sp, #8]
  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_1) != HAL_OK)
 80088ac:	f003 fb56 	bl	800bf5c <HAL_RCC_ClockConfig>
 80088b0:	2800      	cmp	r0, #0
 80088b2:	d001      	beq.n	80088b8 <SystemClock_Config+0x70>
 80088b4:	b672      	cpsid	i
  while (1)
 80088b6:	e7fe      	b.n	80088b6 <SystemClock_Config+0x6e>
  PeriphClkInit.PeriphClockSelection = RCC_PERIPHCLK_USB|RCC_PERIPHCLK_USART1
 80088b8:	4b07      	ldr	r3, [pc, #28]	; (80088d8 <SystemClock_Config+0x90>)
  PeriphClkInit.Usart1ClockSelection = RCC_USART1CLKSOURCE_PCLK1;
 80088ba:	9007      	str	r0, [sp, #28]
  PeriphClkInit.PeriphClockSelection = RCC_PERIPHCLK_USB|RCC_PERIPHCLK_USART1
 80088bc:	9305      	str	r3, [sp, #20]
  PeriphClkInit.UsbClockSelection = RCC_USBCLKSOURCE_PLL;
 80088be:	2380      	movs	r3, #128	; 0x80
  PeriphClkInit.I2c1ClockSelection = RCC_I2C1CLKSOURCE_HSI;
 80088c0:	9008      	str	r0, [sp, #32]
  if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInit) != HAL_OK)
 80088c2:	a805      	add	r0, sp, #20
  PeriphClkInit.UsbClockSelection = RCC_USBCLKSOURCE_PLL;
 80088c4:	9309      	str	r3, [sp, #36]	; 0x24
  if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInit) != HAL_OK)
 80088c6:	f003 fc5d 	bl	800c184 <HAL_RCCEx_PeriphCLKConfig>
 80088ca:	2800      	cmp	r0, #0
 80088cc:	d001      	beq.n	80088d2 <SystemClock_Config+0x8a>
 80088ce:	b672      	cpsid	i
  while (1)
 80088d0:	e7fe      	b.n	80088d0 <SystemClock_Config+0x88>
}
 80088d2:	b017      	add	sp, #92	; 0x5c
 80088d4:	bd30      	pop	{r4, r5, pc}
 80088d6:	46c0      	nop			; (mov r8, r8)
 80088d8:	00020021 	.word	0x00020021

080088dc <main>:
{
 80088dc:	b510      	push	{r4, lr}
  remap_vector_table();
 80088de:	f7ff ff79 	bl	80087d4 <remap_vector_table>
  HAL_Init();
 80088e2:	f001 f84d 	bl	8009980 <HAL_Init>
  SystemClock_Config();
 80088e6:	f7ff ffaf 	bl	8008848 <SystemClock_Config>
  MX_TIM3_Init();
 80088ea:	f000 f91b 	bl	8008b24 <MX_TIM3_Init>
  il_gpio_init();
 80088ee:	4b08      	ldr	r3, [pc, #32]	; (8008910 <main+0x34>)
 80088f0:	681b      	ldr	r3, [r3, #0]
 80088f2:	4798      	blx	r3
  il_dma_init();
 80088f4:	4b07      	ldr	r3, [pc, #28]	; (8008914 <main+0x38>)
 80088f6:	681b      	ldr	r3, [r3, #0]
 80088f8:	4798      	blx	r3
  il_adc_init();
 80088fa:	f000 fb27 	bl	8008f4c <il_adc_init>
  il_i2c_init();
 80088fe:	f000 fb3f 	bl	8008f80 <il_i2c_init>
  il_uart_init();
 8008902:	f000 fb6d 	bl	8008fe0 <il_uart_init>
  MX_FREERTOS_Init();
 8008906:	f7ff fe09 	bl	800851c <MX_FREERTOS_Init>
  osKernelStart();
 800890a:	f006 f911 	bl	800eb30 <osKernelStart>
  while (1)
 800890e:	e7fe      	b.n	800890e <main+0x32>
 8008910:	2000040c 	.word	0x2000040c
 8008914:	20000404 	.word	0x20000404

08008918 <HAL_TIM_PeriodElapsedCallback>:
  if (htim->Instance == TIM17) {
 8008918:	4b03      	ldr	r3, [pc, #12]	; (8008928 <HAL_TIM_PeriodElapsedCallback+0x10>)
 800891a:	6802      	ldr	r2, [r0, #0]
{
 800891c:	b510      	push	{r4, lr}
  if (htim->Instance == TIM17) {
 800891e:	429a      	cmp	r2, r3
 8008920:	d101      	bne.n	8008926 <HAL_TIM_PeriodElapsedCallback+0xe>
    HAL_IncTick();
 8008922:	f001 f83d 	bl	80099a0 <HAL_IncTick>
}
 8008926:	bd10      	pop	{r4, pc}
 8008928:	40014800 	.word	0x40014800

0800892c <Error_Handler>:
 800892c:	b672      	cpsid	i
  while (1)
 800892e:	e7fe      	b.n	800892e <Error_Handler+0x2>

08008930 <assert_failed>:
{
  /* USER CODE BEGIN 6 */
  /* User can add his own implementation to report the file name and line number,
     ex: printf("Wrong parameters value: file %s on line %d\r\n", file, line) */
  /* USER CODE END 6 */
}
 8008930:	4770      	bx	lr
	...

08008934 <HAL_MspInit>:
/* USER CODE END 0 */
/**
  * Initializes the Global MSP.
  */
void HAL_MspInit(void)
{
 8008934:	b507      	push	{r0, r1, r2, lr}
  /* USER CODE BEGIN MspInit 0 */

  /* USER CODE END MspInit 0 */

  __HAL_RCC_SYSCFG_CLK_ENABLE();
 8008936:	2001      	movs	r0, #1
 8008938:	4b13      	ldr	r3, [pc, #76]	; (8008988 <HAL_MspInit+0x54>)
 800893a:	6999      	ldr	r1, [r3, #24]
 800893c:	4301      	orrs	r1, r0
 800893e:	6199      	str	r1, [r3, #24]
  __HAL_RCC_PWR_CLK_ENABLE();
 8008940:	2180      	movs	r1, #128	; 0x80
  __HAL_RCC_SYSCFG_CLK_ENABLE();
 8008942:	699a      	ldr	r2, [r3, #24]
  __HAL_RCC_PWR_CLK_ENABLE();
 8008944:	0549      	lsls	r1, r1, #21
  __HAL_RCC_SYSCFG_CLK_ENABLE();
 8008946:	4002      	ands	r2, r0
 8008948:	9200      	str	r2, [sp, #0]
 800894a:	9a00      	ldr	r2, [sp, #0]
  __HAL_RCC_PWR_CLK_ENABLE();
 800894c:	69da      	ldr	r2, [r3, #28]

  /* System interrupt init*/
  /* PendSV_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(PendSV_IRQn, 3, 0);
 800894e:	1800      	adds	r0, r0, r0
  __HAL_RCC_PWR_CLK_ENABLE();
 8008950:	430a      	orrs	r2, r1
 8008952:	61da      	str	r2, [r3, #28]
 8008954:	69db      	ldr	r3, [r3, #28]
  HAL_NVIC_SetPriority(PendSV_IRQn, 3, 0);
 8008956:	2200      	movs	r2, #0
  __HAL_RCC_PWR_CLK_ENABLE();
 8008958:	400b      	ands	r3, r1
 800895a:	9301      	str	r3, [sp, #4]
  HAL_NVIC_SetPriority(PendSV_IRQn, 3, 0);
 800895c:	2103      	movs	r1, #3
 800895e:	4240      	negs	r0, r0
  __HAL_RCC_PWR_CLK_ENABLE();
 8008960:	9b01      	ldr	r3, [sp, #4]
  HAL_NVIC_SetPriority(PendSV_IRQn, 3, 0);
 8008962:	f001 faa9 	bl	8009eb8 <HAL_NVIC_SetPriority>

  /* Peripheral interrupt init */
  /* FLASH_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(FLASH_IRQn, 3, 0);
 8008966:	2103      	movs	r1, #3
 8008968:	2200      	movs	r2, #0
 800896a:	0008      	movs	r0, r1
 800896c:	f001 faa4 	bl	8009eb8 <HAL_NVIC_SetPriority>
  HAL_NVIC_EnableIRQ(FLASH_IRQn);
 8008970:	2003      	movs	r0, #3
 8008972:	f001 fad5 	bl	8009f20 <HAL_NVIC_EnableIRQ>
  /* RCC_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(RCC_IRQn, 3, 0);
 8008976:	2200      	movs	r2, #0
 8008978:	2103      	movs	r1, #3
 800897a:	2004      	movs	r0, #4
 800897c:	f001 fa9c 	bl	8009eb8 <HAL_NVIC_SetPriority>
  HAL_NVIC_EnableIRQ(RCC_IRQn);
 8008980:	2004      	movs	r0, #4
 8008982:	f001 facd 	bl	8009f20 <HAL_NVIC_EnableIRQ>

  /* USER CODE BEGIN MspInit 1 */

  /* USER CODE END MspInit 1 */
}
 8008986:	bd07      	pop	{r0, r1, r2, pc}
 8008988:	40021000 	.word	0x40021000

0800898c <HAL_InitTick>:
  *         reset by HAL_Init() or at any time when clock is configured, by HAL_RCC_ClockConfig().
  * @param  TickPriority: Tick interrupt priority.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_InitTick(uint32_t TickPriority)
{
 800898c:	b510      	push	{r4, lr}
 800898e:	0001      	movs	r1, r0
 8008990:	b086      	sub	sp, #24
  RCC_ClkInitTypeDef    clkconfig;
  uint32_t              uwTimclock = 0;
  uint32_t              uwPrescalerValue = 0;
  uint32_t              pFLatency;
  /*Configure the TIM17 IRQ priority */
  HAL_NVIC_SetPriority(TIM17_IRQn, TickPriority ,0);
 8008992:	2200      	movs	r2, #0
 8008994:	2016      	movs	r0, #22
 8008996:	f001 fa8f 	bl	8009eb8 <HAL_NVIC_SetPriority>

  /* Enable the TIM17 global Interrupt */
  HAL_NVIC_EnableIRQ(TIM17_IRQn);
 800899a:	2016      	movs	r0, #22
 800899c:	f001 fac0 	bl	8009f20 <HAL_NVIC_EnableIRQ>
  /* Enable TIM17 clock */
  __HAL_RCC_TIM17_CLK_ENABLE();
 80089a0:	2080      	movs	r0, #128	; 0x80
 80089a2:	4a14      	ldr	r2, [pc, #80]	; (80089f4 <HAL_InitTick+0x68>)
 80089a4:	02c0      	lsls	r0, r0, #11
 80089a6:	6991      	ldr	r1, [r2, #24]
 80089a8:	4301      	orrs	r1, r0
 80089aa:	6191      	str	r1, [r2, #24]
 80089ac:	6993      	ldr	r3, [r2, #24]

  /* Get clock configuration */
  HAL_RCC_GetClockConfig(&clkconfig, &pFLatency);
 80089ae:	4669      	mov	r1, sp
  __HAL_RCC_TIM17_CLK_ENABLE();
 80089b0:	4003      	ands	r3, r0
 80089b2:	9301      	str	r3, [sp, #4]
  HAL_RCC_GetClockConfig(&clkconfig, &pFLatency);
 80089b4:	a802      	add	r0, sp, #8
  __HAL_RCC_TIM17_CLK_ENABLE();
 80089b6:	9b01      	ldr	r3, [sp, #4]
  HAL_RCC_GetClockConfig(&clkconfig, &pFLatency);
 80089b8:	f003 fbb4 	bl	800c124 <HAL_RCC_GetClockConfig>

  /* Compute TIM17 clock */
  uwTimclock = HAL_RCC_GetPCLK1Freq();
 80089bc:	f003 fba2 	bl	800c104 <HAL_RCC_GetPCLK1Freq>
  /* Compute the prescaler value to have TIM17 counter clock equal to 1MHz */
  uwPrescalerValue = (uint32_t) ((uwTimclock / 1000000U) - 1U);

  /* Initialize TIM17 */
  htim17.Instance = TIM17;
 80089c0:	4c0d      	ldr	r4, [pc, #52]	; (80089f8 <HAL_InitTick+0x6c>)
 80089c2:	4b0e      	ldr	r3, [pc, #56]	; (80089fc <HAL_InitTick+0x70>)
  uwPrescalerValue = (uint32_t) ((uwTimclock / 1000000U) - 1U);
 80089c4:	490e      	ldr	r1, [pc, #56]	; (8008a00 <HAL_InitTick+0x74>)
  htim17.Instance = TIM17;
 80089c6:	6023      	str	r3, [r4, #0]
  + Period = [(TIM17CLK/1000) - 1]. to have a (1/1000) s time base.
  + Prescaler = (uwTimclock/1000000 - 1) to have a 1MHz counter clock.
  + ClockDivision = 0
  + Counter direction = Up
  */
  htim17.Init.Period = (1000000U / 1000U) - 1U;
 80089c8:	4b0e      	ldr	r3, [pc, #56]	; (8008a04 <HAL_InitTick+0x78>)
 80089ca:	60e3      	str	r3, [r4, #12]
  uwPrescalerValue = (uint32_t) ((uwTimclock / 1000000U) - 1U);
 80089cc:	f7ff fbcc 	bl	8008168 <__udivsi3>
  htim17.Init.Prescaler = uwPrescalerValue;
  htim17.Init.ClockDivision = 0;
 80089d0:	2300      	movs	r3, #0
  uwPrescalerValue = (uint32_t) ((uwTimclock / 1000000U) - 1U);
 80089d2:	3801      	subs	r0, #1
  htim17.Init.Prescaler = uwPrescalerValue;
 80089d4:	6060      	str	r0, [r4, #4]
  htim17.Init.CounterMode = TIM_COUNTERMODE_UP;
  if(HAL_TIM_Base_Init(&htim17) == HAL_OK)
 80089d6:	0020      	movs	r0, r4
  htim17.Init.ClockDivision = 0;
 80089d8:	6123      	str	r3, [r4, #16]
  htim17.Init.CounterMode = TIM_COUNTERMODE_UP;
 80089da:	60a3      	str	r3, [r4, #8]
  if(HAL_TIM_Base_Init(&htim17) == HAL_OK)
 80089dc:	f003 fe74 	bl	800c6c8 <HAL_TIM_Base_Init>
 80089e0:	0003      	movs	r3, r0
    /* Start the TIM time Base generation in interrupt mode */
    return HAL_TIM_Base_Start_IT(&htim17);
  }

  /* Return function status */
  return HAL_ERROR;
 80089e2:	2001      	movs	r0, #1
  if(HAL_TIM_Base_Init(&htim17) == HAL_OK)
 80089e4:	2b00      	cmp	r3, #0
 80089e6:	d102      	bne.n	80089ee <HAL_InitTick+0x62>
    return HAL_TIM_Base_Start_IT(&htim17);
 80089e8:	0020      	movs	r0, r4
 80089ea:	f003 fd27 	bl	800c43c <HAL_TIM_Base_Start_IT>
}
 80089ee:	b006      	add	sp, #24
 80089f0:	bd10      	pop	{r4, pc}
 80089f2:	46c0      	nop			; (mov r8, r8)
 80089f4:	40021000 	.word	0x40021000
 80089f8:	20001ba4 	.word	0x20001ba4
 80089fc:	40014800 	.word	0x40014800
 8008a00:	000f4240 	.word	0x000f4240
 8008a04:	000003e7 	.word	0x000003e7

08008a08 <NMI_Handler>:
{
  /* USER CODE BEGIN NonMaskableInt_IRQn 0 */

  /* USER CODE END NonMaskableInt_IRQn 0 */
  /* USER CODE BEGIN NonMaskableInt_IRQn 1 */
  while (1)
 8008a08:	e7fe      	b.n	8008a08 <NMI_Handler>

08008a0a <HardFault_Handler>:
void HardFault_Handler(void)
{
  /* USER CODE BEGIN HardFault_IRQn 0 */

  /* USER CODE END HardFault_IRQn 0 */
  while (1)
 8008a0a:	e7fe      	b.n	8008a0a <HardFault_Handler>

08008a0c <FLASH_IRQHandler>:

/**
  * @brief This function handles Flash global interrupt.
  */
void FLASH_IRQHandler(void)
{
 8008a0c:	b510      	push	{r4, lr}
  /* USER CODE BEGIN FLASH_IRQn 0 */

  /* USER CODE END FLASH_IRQn 0 */
  HAL_FLASH_IRQHandler();
 8008a0e:	f001 fbc9 	bl	800a1a4 <HAL_FLASH_IRQHandler>
  /* USER CODE BEGIN FLASH_IRQn 1 */

  /* USER CODE END FLASH_IRQn 1 */
}
 8008a12:	bd10      	pop	{r4, pc}

08008a14 <RCC_IRQHandler>:

  /* USER CODE END RCC_IRQn 0 */
  /* USER CODE BEGIN RCC_IRQn 1 */

  /* USER CODE END RCC_IRQn 1 */
}
 8008a14:	4770      	bx	lr

08008a16 <EXTI4_15_IRQHandler>:

/**
  * @brief This function handles EXTI line 4 to 15 interrupts.
  */
void EXTI4_15_IRQHandler(void)
{
 8008a16:	b510      	push	{r4, lr}
  /* USER CODE BEGIN EXTI4_15_IRQn 0 */

  /* USER CODE END EXTI4_15_IRQn 0 */
  HAL_GPIO_EXTI_IRQHandler(GPIO_PIN_5);
 8008a18:	2020      	movs	r0, #32
 8008a1a:	f001 fda7 	bl	800a56c <HAL_GPIO_EXTI_IRQHandler>
  /* USER CODE BEGIN EXTI4_15_IRQn 1 */

  /* USER CODE END EXTI4_15_IRQn 1 */
}
 8008a1e:	bd10      	pop	{r4, pc}

08008a20 <DMA1_Channel1_IRQHandler>:

/**
  * @brief This function handles DMA1 channel 1 global interrupt.
  */
void DMA1_Channel1_IRQHandler(void)
{
 8008a20:	b510      	push	{r4, lr}
  /* USER CODE BEGIN DMA1_Channel1_IRQn 0 */

  /* USER CODE END DMA1_Channel1_IRQn 0 */
  HAL_DMA_IRQHandler(&hdma_adc);
 8008a22:	4802      	ldr	r0, [pc, #8]	; (8008a2c <DMA1_Channel1_IRQHandler+0xc>)
 8008a24:	f001 fb51 	bl	800a0ca <HAL_DMA_IRQHandler>
  /* USER CODE BEGIN DMA1_Channel1_IRQn 1 */

  /* USER CODE END DMA1_Channel1_IRQn 1 */
}
 8008a28:	bd10      	pop	{r4, pc}
 8008a2a:	46c0      	nop			; (mov r8, r8)
 8008a2c:	20001a20 	.word	0x20001a20

08008a30 <ADC1_IRQHandler>:

/**
  * @brief This function handles ADC interrupt.
  */
void ADC1_IRQHandler(void)
{
 8008a30:	b510      	push	{r4, lr}
  /* USER CODE BEGIN ADC1_IRQn 0 */

  /* USER CODE END ADC1_IRQn 0 */
  HAL_ADC_IRQHandler(&hadc);
 8008a32:	4802      	ldr	r0, [pc, #8]	; (8008a3c <ADC1_IRQHandler+0xc>)
 8008a34:	f001 f902 	bl	8009c3c <HAL_ADC_IRQHandler>
  /* USER CODE BEGIN ADC1_IRQn 1 */

  /* USER CODE END ADC1_IRQn 1 */
}
 8008a38:	bd10      	pop	{r4, pc}
 8008a3a:	46c0      	nop			; (mov r8, r8)
 8008a3c:	20001a64 	.word	0x20001a64

08008a40 <TIM17_IRQHandler>:

/**
  * @brief This function handles TIM17 global interrupt.
  */
void TIM17_IRQHandler(void)
{
 8008a40:	b510      	push	{r4, lr}
  /* USER CODE BEGIN TIM17_IRQn 0 */

  /* USER CODE END TIM17_IRQn 0 */
  HAL_TIM_IRQHandler(&htim17);
 8008a42:	4802      	ldr	r0, [pc, #8]	; (8008a4c <TIM17_IRQHandler+0xc>)
 8008a44:	f003 fd54 	bl	800c4f0 <HAL_TIM_IRQHandler>
  /* USER CODE BEGIN TIM17_IRQn 1 */

  /* USER CODE END TIM17_IRQn 1 */
}
 8008a48:	bd10      	pop	{r4, pc}
 8008a4a:	46c0      	nop			; (mov r8, r8)
 8008a4c:	20001ba4 	.word	0x20001ba4

08008a50 <I2C1_IRQHandler>:
void I2C1_IRQHandler(void)
{
  /* USER CODE BEGIN I2C1_IRQn 0 */

  /* USER CODE END I2C1_IRQn 0 */
  if (hi2c1.Instance->ISR & (I2C_FLAG_BERR | I2C_FLAG_ARLO | I2C_FLAG_OVR)) {
 8008a50:	4806      	ldr	r0, [pc, #24]	; (8008a6c <I2C1_IRQHandler+0x1c>)
{
 8008a52:	b510      	push	{r4, lr}
  if (hi2c1.Instance->ISR & (I2C_FLAG_BERR | I2C_FLAG_ARLO | I2C_FLAG_OVR)) {
 8008a54:	6803      	ldr	r3, [r0, #0]
 8008a56:	699a      	ldr	r2, [r3, #24]
 8008a58:	23e0      	movs	r3, #224	; 0xe0
 8008a5a:	00db      	lsls	r3, r3, #3
 8008a5c:	421a      	tst	r2, r3
 8008a5e:	d002      	beq.n	8008a66 <I2C1_IRQHandler+0x16>
    HAL_I2C_ER_IRQHandler(&hi2c1);
 8008a60:	f002 f906 	bl	800ac70 <HAL_I2C_ER_IRQHandler>
    HAL_I2C_EV_IRQHandler(&hi2c1);
  }
  /* USER CODE BEGIN I2C1_IRQn 1 */

  /* USER CODE END I2C1_IRQn 1 */
}
 8008a64:	bd10      	pop	{r4, pc}
    HAL_I2C_EV_IRQHandler(&hi2c1);
 8008a66:	f001 fe69 	bl	800a73c <HAL_I2C_EV_IRQHandler>
}
 8008a6a:	e7fb      	b.n	8008a64 <I2C1_IRQHandler+0x14>
 8008a6c:	20001aa8 	.word	0x20001aa8

08008a70 <I2C2_IRQHandler>:
void I2C2_IRQHandler(void)
{
  /* USER CODE BEGIN I2C2_IRQn 0 */

  /* USER CODE END I2C2_IRQn 0 */
  if (hi2c2.Instance->ISR & (I2C_FLAG_BERR | I2C_FLAG_ARLO | I2C_FLAG_OVR)) {
 8008a70:	4806      	ldr	r0, [pc, #24]	; (8008a8c <I2C2_IRQHandler+0x1c>)
{
 8008a72:	b510      	push	{r4, lr}
  if (hi2c2.Instance->ISR & (I2C_FLAG_BERR | I2C_FLAG_ARLO | I2C_FLAG_OVR)) {
 8008a74:	6803      	ldr	r3, [r0, #0]
 8008a76:	699a      	ldr	r2, [r3, #24]
 8008a78:	23e0      	movs	r3, #224	; 0xe0
 8008a7a:	00db      	lsls	r3, r3, #3
 8008a7c:	421a      	tst	r2, r3
 8008a7e:	d002      	beq.n	8008a86 <I2C2_IRQHandler+0x16>
    HAL_I2C_ER_IRQHandler(&hi2c2);
 8008a80:	f002 f8f6 	bl	800ac70 <HAL_I2C_ER_IRQHandler>
    HAL_I2C_EV_IRQHandler(&hi2c2);
  }
  /* USER CODE BEGIN I2C2_IRQn 1 */

  /* USER CODE END I2C2_IRQn 1 */
}
 8008a84:	bd10      	pop	{r4, pc}
    HAL_I2C_EV_IRQHandler(&hi2c2);
 8008a86:	f001 fe59 	bl	800a73c <HAL_I2C_EV_IRQHandler>
}
 8008a8a:	e7fb      	b.n	8008a84 <I2C2_IRQHandler+0x14>
 8008a8c:	20001af4 	.word	0x20001af4

08008a90 <SPI1_IRQHandler>:

/**
  * @brief This function handles SPI1 global interrupt.
  */
void SPI1_IRQHandler(void)
{
 8008a90:	b510      	push	{r4, lr}
  /* USER CODE BEGIN SPI1_IRQn 0 */

  /* USER CODE END SPI1_IRQn 0 */
  HAL_SPI_IRQHandler(&hspi1);
 8008a92:	4802      	ldr	r0, [pc, #8]	; (8008a9c <SPI1_IRQHandler+0xc>)
 8008a94:	f003 fc38 	bl	800c308 <HAL_SPI_IRQHandler>
  /* USER CODE BEGIN SPI1_IRQn 1 */

  /* USER CODE END SPI1_IRQn 1 */
}
 8008a98:	bd10      	pop	{r4, pc}
 8008a9a:	46c0      	nop			; (mov r8, r8)
 8008a9c:	20001b40 	.word	0x20001b40

08008aa0 <USART1_IRQHandler>:

/**
  * @brief This function handles USART1 global interrupt.
  */
void USART1_IRQHandler(void)
{
 8008aa0:	b510      	push	{r4, lr}
  /* USER CODE BEGIN USART1_IRQn 0 */
	il_uart_irq_handler(&uart1);
 8008aa2:	4802      	ldr	r0, [pc, #8]	; (8008aac <USART1_IRQHandler+0xc>)
 8008aa4:	f000 fc04 	bl	80092b0 <il_uart_irq_handler>
  /* USER CODE END USART1_IRQn 0 */
//  HAL_UART_IRQHandler(&huart1);
  /* USER CODE BEGIN USART1_IRQn 1 */

  /* USER CODE END USART1_IRQn 1 */
}
 8008aa8:	bd10      	pop	{r4, pc}
 8008aaa:	46c0      	nop			; (mov r8, r8)
 8008aac:	20001f7c 	.word	0x20001f7c

08008ab0 <USART2_IRQHandler>:

/**
  * @brief This function handles USART2 global interrupt.
  */
void USART2_IRQHandler(void)
{
 8008ab0:	b510      	push	{r4, lr}
  /* USER CODE BEGIN USART2_IRQn 0 */
	il_uart_irq_handler(&gps);
 8008ab2:	4802      	ldr	r0, [pc, #8]	; (8008abc <USART2_IRQHandler+0xc>)
 8008ab4:	f000 fbfc 	bl	80092b0 <il_uart_irq_handler>
  /* USER CODE END USART2_IRQn 0 */
//  HAL_UART_IRQHandler(&huart2);
  /* USER CODE BEGIN USART2_IRQn 1 */

  /* USER CODE END USART2_IRQn 1 */
}
 8008ab8:	bd10      	pop	{r4, pc}
 8008aba:	46c0      	nop			; (mov r8, r8)
 8008abc:	20001e44 	.word	0x20001e44

08008ac0 <USART3_4_IRQHandler>:

/**
  * @brief This function handles USART3 and USART4 global interrupts.
  */
void USART3_4_IRQHandler(void)
{
 8008ac0:	b510      	push	{r4, lr}
  /* USER CODE BEGIN USART3_4_IRQn 0 */
	il_uart_irq_handler(&modem);
 8008ac2:	4802      	ldr	r0, [pc, #8]	; (8008acc <USART3_4_IRQHandler+0xc>)
 8008ac4:	f000 fbf4 	bl	80092b0 <il_uart_irq_handler>
//  HAL_UART_IRQHandler(&huart3);
//  HAL_UART_IRQHandler(&huart4);
  /* USER CODE BEGIN USART3_4_IRQn 1 */

  /* USER CODE END USART3_4_IRQn 1 */
}
 8008ac8:	bd10      	pop	{r4, pc}
 8008aca:	46c0      	nop			; (mov r8, r8)
 8008acc:	20001ee0 	.word	0x20001ee0

08008ad0 <USB_IRQHandler>:

/**
  * @brief This function handles USB global interrupt / USB wake-up interrupt through EXTI line 18.
  */
void USB_IRQHandler(void)
{
 8008ad0:	b510      	push	{r4, lr}
  /* USER CODE BEGIN USB_IRQn 0 */

  /* USER CODE END USB_IRQn 0 */
  HAL_PCD_IRQHandler(&hpcd_USB_FS);
 8008ad2:	4802      	ldr	r0, [pc, #8]	; (8008adc <USB_IRQHandler+0xc>)
 8008ad4:	f002 fa26 	bl	800af24 <HAL_PCD_IRQHandler>
  /* USER CODE BEGIN USB_IRQn 1 */

  /* USER CODE END USB_IRQn 1 */
}
 8008ad8:	bd10      	pop	{r4, pc}
 8008ada:	46c0      	nop			; (mov r8, r8)
 8008adc:	20002eec 	.word	0x20002eec

08008ae0 <_sbrk>:
void *_sbrk(ptrdiff_t incr)
{
  extern uint8_t _end; /* Symbol defined in the linker script */
  extern uint8_t _estack; /* Symbol defined in the linker script */
  extern uint32_t _Min_Stack_Size; /* Symbol defined in the linker script */
  const uint32_t stack_limit = (uint32_t)&_estack - (uint32_t)&_Min_Stack_Size;
 8008ae0:	4a0b      	ldr	r2, [pc, #44]	; (8008b10 <_sbrk+0x30>)
 8008ae2:	490c      	ldr	r1, [pc, #48]	; (8008b14 <_sbrk+0x34>)
{
 8008ae4:	0003      	movs	r3, r0
  const uint32_t stack_limit = (uint32_t)&_estack - (uint32_t)&_Min_Stack_Size;
 8008ae6:	1a89      	subs	r1, r1, r2
  const uint8_t *max_heap = (uint8_t *)stack_limit;
  uint8_t *prev_heap_end;

  /* Initialize heap end at first call */
  if (NULL == __sbrk_heap_end)
 8008ae8:	4a0b      	ldr	r2, [pc, #44]	; (8008b18 <_sbrk+0x38>)
{
 8008aea:	b510      	push	{r4, lr}
  if (NULL == __sbrk_heap_end)
 8008aec:	6810      	ldr	r0, [r2, #0]
 8008aee:	2800      	cmp	r0, #0
 8008af0:	d101      	bne.n	8008af6 <_sbrk+0x16>
  {
    __sbrk_heap_end = &_end;
 8008af2:	480a      	ldr	r0, [pc, #40]	; (8008b1c <_sbrk+0x3c>)
 8008af4:	6010      	str	r0, [r2, #0]
  }

  /* Protect heap from growing into the reserved MSP stack */
  if (__sbrk_heap_end + incr > max_heap)
 8008af6:	6810      	ldr	r0, [r2, #0]
 8008af8:	18c3      	adds	r3, r0, r3
 8008afa:	428b      	cmp	r3, r1
 8008afc:	d906      	bls.n	8008b0c <_sbrk+0x2c>
  {
    errno = ENOMEM;
 8008afe:	f006 ff97 	bl	800fa30 <__errno>
 8008b02:	230c      	movs	r3, #12
 8008b04:	6003      	str	r3, [r0, #0]
    return (void *)-1;
 8008b06:	2001      	movs	r0, #1
 8008b08:	4240      	negs	r0, r0

  prev_heap_end = __sbrk_heap_end;
  __sbrk_heap_end += incr;

  return (void *)prev_heap_end;
}
 8008b0a:	bd10      	pop	{r4, pc}
  __sbrk_heap_end += incr;
 8008b0c:	6013      	str	r3, [r2, #0]
  return (void *)prev_heap_end;
 8008b0e:	e7fc      	b.n	8008b0a <_sbrk+0x2a>
 8008b10:	00000400 	.word	0x00000400
 8008b14:	20004000 	.word	0x20004000
 8008b18:	20000ab0 	.word	0x20000ab0
 8008b1c:	200031f0 	.word	0x200031f0

08008b20 <SystemInit>:
                         before branch to main program. This call is made inside
                         the "startup_stm32f0xx.s" file.
                         User can setups the default system clock (System clock source, PLL Multiplier
                         and Divider factors, AHB/APBx prescalers and Flash settings).
   */
}
 8008b20:	4770      	bx	lr
	...

08008b24 <MX_TIM3_Init>:

TIM_HandleTypeDef htim3;

/* TIM3 init function */
void MX_TIM3_Init(void)
{
 8008b24:	b510      	push	{r4, lr}
 8008b26:	b086      	sub	sp, #24

  /* USER CODE BEGIN TIM3_Init 0 */

  /* USER CODE END TIM3_Init 0 */

  TIM_ClockConfigTypeDef sClockSourceConfig = {0};
 8008b28:	2210      	movs	r2, #16
 8008b2a:	2100      	movs	r1, #0
 8008b2c:	a802      	add	r0, sp, #8
 8008b2e:	f006 ffe6 	bl	800fafe <memset>
  TIM_MasterConfigTypeDef sMasterConfig = {0};
 8008b32:	2208      	movs	r2, #8
 8008b34:	2100      	movs	r1, #0
 8008b36:	4668      	mov	r0, sp
 8008b38:	f006 ffe1 	bl	800fafe <memset>

  /* USER CODE BEGIN TIM3_Init 1 */

  /* USER CODE END TIM3_Init 1 */
  htim3.Instance = TIM3;
 8008b3c:	4c14      	ldr	r4, [pc, #80]	; (8008b90 <MX_TIM3_Init+0x6c>)
 8008b3e:	4b15      	ldr	r3, [pc, #84]	; (8008b94 <MX_TIM3_Init+0x70>)
  htim3.Init.Prescaler = 48-1;
  htim3.Init.CounterMode = TIM_COUNTERMODE_UP;
  htim3.Init.Period = 65535;
 8008b40:	4a15      	ldr	r2, [pc, #84]	; (8008b98 <MX_TIM3_Init+0x74>)
  htim3.Instance = TIM3;
 8008b42:	6023      	str	r3, [r4, #0]
  htim3.Init.Prescaler = 48-1;
 8008b44:	232f      	movs	r3, #47	; 0x2f
 8008b46:	6063      	str	r3, [r4, #4]
  htim3.Init.CounterMode = TIM_COUNTERMODE_UP;
 8008b48:	2300      	movs	r3, #0
  htim3.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
  htim3.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
  if (HAL_TIM_Base_Init(&htim3) != HAL_OK)
 8008b4a:	0020      	movs	r0, r4
  htim3.Init.CounterMode = TIM_COUNTERMODE_UP;
 8008b4c:	60a3      	str	r3, [r4, #8]
  htim3.Init.Period = 65535;
 8008b4e:	60e2      	str	r2, [r4, #12]
  htim3.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
 8008b50:	6123      	str	r3, [r4, #16]
  htim3.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
 8008b52:	61a3      	str	r3, [r4, #24]
  if (HAL_TIM_Base_Init(&htim3) != HAL_OK)
 8008b54:	f003 fdb8 	bl	800c6c8 <HAL_TIM_Base_Init>
 8008b58:	2800      	cmp	r0, #0
 8008b5a:	d001      	beq.n	8008b60 <MX_TIM3_Init+0x3c>
  {
    Error_Handler();
 8008b5c:	f7ff fee6 	bl	800892c <Error_Handler>
  }
  sClockSourceConfig.ClockSource = TIM_CLOCKSOURCE_INTERNAL;
 8008b60:	2380      	movs	r3, #128	; 0x80
  if (HAL_TIM_ConfigClockSource(&htim3, &sClockSourceConfig) != HAL_OK)
 8008b62:	0020      	movs	r0, r4
  sClockSourceConfig.ClockSource = TIM_CLOCKSOURCE_INTERNAL;
 8008b64:	015b      	lsls	r3, r3, #5
  if (HAL_TIM_ConfigClockSource(&htim3, &sClockSourceConfig) != HAL_OK)
 8008b66:	a902      	add	r1, sp, #8
  sClockSourceConfig.ClockSource = TIM_CLOCKSOURCE_INTERNAL;
 8008b68:	9302      	str	r3, [sp, #8]
  if (HAL_TIM_ConfigClockSource(&htim3, &sClockSourceConfig) != HAL_OK)
 8008b6a:	f003 fe3b 	bl	800c7e4 <HAL_TIM_ConfigClockSource>
 8008b6e:	2800      	cmp	r0, #0
 8008b70:	d001      	beq.n	8008b76 <MX_TIM3_Init+0x52>
  {
    Error_Handler();
 8008b72:	f7ff fedb 	bl	800892c <Error_Handler>
  }
  sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;
 8008b76:	2300      	movs	r3, #0
  sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
  if (HAL_TIMEx_MasterConfigSynchronization(&htim3, &sMasterConfig) != HAL_OK)
 8008b78:	4669      	mov	r1, sp
 8008b7a:	0020      	movs	r0, r4
  sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;
 8008b7c:	9300      	str	r3, [sp, #0]
  sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
 8008b7e:	9301      	str	r3, [sp, #4]
  if (HAL_TIMEx_MasterConfigSynchronization(&htim3, &sMasterConfig) != HAL_OK)
 8008b80:	f004 f81a 	bl	800cbb8 <HAL_TIMEx_MasterConfigSynchronization>
 8008b84:	2800      	cmp	r0, #0
 8008b86:	d001      	beq.n	8008b8c <MX_TIM3_Init+0x68>
  {
    Error_Handler();
 8008b88:	f7ff fed0 	bl	800892c <Error_Handler>
  }
  /* USER CODE BEGIN TIM3_Init 2 */

  /* USER CODE END TIM3_Init 2 */

}
 8008b8c:	b006      	add	sp, #24
 8008b8e:	bd10      	pop	{r4, pc}
 8008b90:	20001bec 	.word	0x20001bec
 8008b94:	40000400 	.word	0x40000400
 8008b98:	0000ffff 	.word	0x0000ffff

08008b9c <HAL_TIM_Base_MspInit>:

void HAL_TIM_Base_MspInit(TIM_HandleTypeDef* tim_baseHandle)
{

  if(tim_baseHandle->Instance==TIM3)
 8008b9c:	4b07      	ldr	r3, [pc, #28]	; (8008bbc <HAL_TIM_Base_MspInit+0x20>)
 8008b9e:	6802      	ldr	r2, [r0, #0]
{
 8008ba0:	b082      	sub	sp, #8
  if(tim_baseHandle->Instance==TIM3)
 8008ba2:	429a      	cmp	r2, r3
 8008ba4:	d108      	bne.n	8008bb8 <HAL_TIM_Base_MspInit+0x1c>
  {
  /* USER CODE BEGIN TIM3_MspInit 0 */

  /* USER CODE END TIM3_MspInit 0 */
    /* TIM3 clock enable */
    __HAL_RCC_TIM3_CLK_ENABLE();
 8008ba6:	2002      	movs	r0, #2
 8008ba8:	4a05      	ldr	r2, [pc, #20]	; (8008bc0 <HAL_TIM_Base_MspInit+0x24>)
 8008baa:	69d1      	ldr	r1, [r2, #28]
 8008bac:	4301      	orrs	r1, r0
 8008bae:	61d1      	str	r1, [r2, #28]
 8008bb0:	69d3      	ldr	r3, [r2, #28]
 8008bb2:	4003      	ands	r3, r0
 8008bb4:	9301      	str	r3, [sp, #4]
 8008bb6:	9b01      	ldr	r3, [sp, #4]
  /* USER CODE BEGIN TIM3_MspInit 1 */

  /* USER CODE END TIM3_MspInit 1 */
  }
}
 8008bb8:	b002      	add	sp, #8
 8008bba:	4770      	bx	lr
 8008bbc:	40000400 	.word	0x40000400
 8008bc0:	40021000 	.word	0x40021000

08008bc4 <MX_USART1_UART_Init>:
  /* USER CODE END USART1_Init 0 */

  /* USER CODE BEGIN USART1_Init 1 */

  /* USER CODE END USART1_Init 1 */
  huart1.Instance = USART1;
 8008bc4:	480b      	ldr	r0, [pc, #44]	; (8008bf4 <MX_USART1_UART_Init+0x30>)
 8008bc6:	4b0c      	ldr	r3, [pc, #48]	; (8008bf8 <MX_USART1_UART_Init+0x34>)
{
 8008bc8:	b510      	push	{r4, lr}
  huart1.Instance = USART1;
 8008bca:	6003      	str	r3, [r0, #0]
  huart1.Init.BaudRate = 9600;
 8008bcc:	2396      	movs	r3, #150	; 0x96
 8008bce:	019b      	lsls	r3, r3, #6
  huart1.Init.WordLength = UART_WORDLENGTH_8B;
  huart1.Init.StopBits = UART_STOPBITS_1;
  huart1.Init.Parity = UART_PARITY_NONE;
  huart1.Init.Mode = UART_MODE_TX_RX;
 8008bd0:	220c      	movs	r2, #12
  huart1.Init.BaudRate = 9600;
 8008bd2:	6043      	str	r3, [r0, #4]
  huart1.Init.WordLength = UART_WORDLENGTH_8B;
 8008bd4:	2300      	movs	r3, #0
  huart1.Init.Mode = UART_MODE_TX_RX;
 8008bd6:	6142      	str	r2, [r0, #20]
  huart1.Init.WordLength = UART_WORDLENGTH_8B;
 8008bd8:	6083      	str	r3, [r0, #8]
  huart1.Init.StopBits = UART_STOPBITS_1;
 8008bda:	60c3      	str	r3, [r0, #12]
  huart1.Init.Parity = UART_PARITY_NONE;
 8008bdc:	6103      	str	r3, [r0, #16]
  huart1.Init.HwFlowCtl = UART_HWCONTROL_NONE;
 8008bde:	6183      	str	r3, [r0, #24]
  huart1.Init.OverSampling = UART_OVERSAMPLING_16;
 8008be0:	61c3      	str	r3, [r0, #28]
  huart1.Init.OneBitSampling = UART_ONE_BIT_SAMPLE_DISABLE;
 8008be2:	6203      	str	r3, [r0, #32]
  huart1.AdvancedInit.AdvFeatureInit = UART_ADVFEATURE_NO_INIT;
 8008be4:	6243      	str	r3, [r0, #36]	; 0x24
  if (HAL_UART_Init(&huart1) != HAL_OK)
 8008be6:	f004 fbe1 	bl	800d3ac <HAL_UART_Init>
 8008bea:	2800      	cmp	r0, #0
 8008bec:	d001      	beq.n	8008bf2 <MX_USART1_UART_Init+0x2e>
  {
    Error_Handler();
 8008bee:	f7ff fe9d 	bl	800892c <Error_Handler>
  }
  /* USER CODE BEGIN USART1_Init 2 */

  /* USER CODE END USART1_Init 2 */

}
 8008bf2:	bd10      	pop	{r4, pc}
 8008bf4:	20001cb8 	.word	0x20001cb8
 8008bf8:	40013800 	.word	0x40013800

08008bfc <MX_USART2_UART_Init>:
  /* USER CODE END USART2_Init 0 */

  /* USER CODE BEGIN USART2_Init 1 */

  /* USER CODE END USART2_Init 1 */
  huart2.Instance = USART2;
 8008bfc:	480b      	ldr	r0, [pc, #44]	; (8008c2c <MX_USART2_UART_Init+0x30>)
 8008bfe:	4b0c      	ldr	r3, [pc, #48]	; (8008c30 <MX_USART2_UART_Init+0x34>)
{
 8008c00:	b510      	push	{r4, lr}
  huart2.Instance = USART2;
 8008c02:	6003      	str	r3, [r0, #0]
  huart2.Init.BaudRate = 9600;
 8008c04:	2396      	movs	r3, #150	; 0x96
 8008c06:	019b      	lsls	r3, r3, #6
  huart2.Init.WordLength = UART_WORDLENGTH_8B;
  huart2.Init.StopBits = UART_STOPBITS_1;
  huart2.Init.Parity = UART_PARITY_NONE;
  huart2.Init.Mode = UART_MODE_TX_RX;
 8008c08:	220c      	movs	r2, #12
  huart2.Init.BaudRate = 9600;
 8008c0a:	6043      	str	r3, [r0, #4]
  huart2.Init.WordLength = UART_WORDLENGTH_8B;
 8008c0c:	2300      	movs	r3, #0
  huart2.Init.Mode = UART_MODE_TX_RX;
 8008c0e:	6142      	str	r2, [r0, #20]
  huart2.Init.WordLength = UART_WORDLENGTH_8B;
 8008c10:	6083      	str	r3, [r0, #8]
  huart2.Init.StopBits = UART_STOPBITS_1;
 8008c12:	60c3      	str	r3, [r0, #12]
  huart2.Init.Parity = UART_PARITY_NONE;
 8008c14:	6103      	str	r3, [r0, #16]
  huart2.Init.HwFlowCtl = UART_HWCONTROL_NONE;
 8008c16:	6183      	str	r3, [r0, #24]
  huart2.Init.OverSampling = UART_OVERSAMPLING_16;
 8008c18:	61c3      	str	r3, [r0, #28]
  huart2.Init.OneBitSampling = UART_ONE_BIT_SAMPLE_DISABLE;
 8008c1a:	6203      	str	r3, [r0, #32]
  huart2.AdvancedInit.AdvFeatureInit = UART_ADVFEATURE_NO_INIT;
 8008c1c:	6243      	str	r3, [r0, #36]	; 0x24
  if (HAL_UART_Init(&huart2) != HAL_OK)
 8008c1e:	f004 fbc5 	bl	800d3ac <HAL_UART_Init>
 8008c22:	2800      	cmp	r0, #0
 8008c24:	d001      	beq.n	8008c2a <MX_USART2_UART_Init+0x2e>
  {
    Error_Handler();
 8008c26:	f7ff fe81 	bl	800892c <Error_Handler>
  }
  /* USER CODE BEGIN USART2_Init 2 */

  /* USER CODE END USART2_Init 2 */

}
 8008c2a:	bd10      	pop	{r4, pc}
 8008c2c:	20001dc0 	.word	0x20001dc0
 8008c30:	40004400 	.word	0x40004400

08008c34 <MX_USART3_UART_Init>:
  /* USER CODE END USART3_Init 0 */

  /* USER CODE BEGIN USART3_Init 1 */

  /* USER CODE END USART3_Init 1 */
  huart3.Instance = USART3;
 8008c34:	480b      	ldr	r0, [pc, #44]	; (8008c64 <MX_USART3_UART_Init+0x30>)
 8008c36:	4b0c      	ldr	r3, [pc, #48]	; (8008c68 <MX_USART3_UART_Init+0x34>)
{
 8008c38:	b510      	push	{r4, lr}
  huart3.Instance = USART3;
 8008c3a:	6003      	str	r3, [r0, #0]
  huart3.Init.BaudRate = 57600;
 8008c3c:	23e1      	movs	r3, #225	; 0xe1
 8008c3e:	021b      	lsls	r3, r3, #8
  huart3.Init.WordLength = UART_WORDLENGTH_8B;
  huart3.Init.StopBits = UART_STOPBITS_1;
  huart3.Init.Parity = UART_PARITY_NONE;
  huart3.Init.Mode = UART_MODE_TX_RX;
 8008c40:	220c      	movs	r2, #12
  huart3.Init.BaudRate = 57600;
 8008c42:	6043      	str	r3, [r0, #4]
  huart3.Init.WordLength = UART_WORDLENGTH_8B;
 8008c44:	2300      	movs	r3, #0
  huart3.Init.Mode = UART_MODE_TX_RX;
 8008c46:	6142      	str	r2, [r0, #20]
  huart3.Init.WordLength = UART_WORDLENGTH_8B;
 8008c48:	6083      	str	r3, [r0, #8]
  huart3.Init.StopBits = UART_STOPBITS_1;
 8008c4a:	60c3      	str	r3, [r0, #12]
  huart3.Init.Parity = UART_PARITY_NONE;
 8008c4c:	6103      	str	r3, [r0, #16]
  huart3.Init.HwFlowCtl = UART_HWCONTROL_NONE;
 8008c4e:	6183      	str	r3, [r0, #24]
  huart3.Init.OverSampling = UART_OVERSAMPLING_16;
 8008c50:	61c3      	str	r3, [r0, #28]
  huart3.Init.OneBitSampling = UART_ONE_BIT_SAMPLE_DISABLE;
 8008c52:	6203      	str	r3, [r0, #32]
  huart3.AdvancedInit.AdvFeatureInit = UART_ADVFEATURE_NO_INIT;
 8008c54:	6243      	str	r3, [r0, #36]	; 0x24
  if (HAL_UART_Init(&huart3) != HAL_OK)
 8008c56:	f004 fba9 	bl	800d3ac <HAL_UART_Init>
 8008c5a:	2800      	cmp	r0, #0
 8008c5c:	d001      	beq.n	8008c62 <MX_USART3_UART_Init+0x2e>
  {
    Error_Handler();
 8008c5e:	f7ff fe65 	bl	800892c <Error_Handler>
  }
  /* USER CODE BEGIN USART3_Init 2 */

  /* USER CODE END USART3_Init 2 */

}
 8008c62:	bd10      	pop	{r4, pc}
 8008c64:	20001c34 	.word	0x20001c34
 8008c68:	40004800 	.word	0x40004800

08008c6c <MX_USART4_UART_Init>:
  /* USER CODE END USART4_Init 0 */

  /* USER CODE BEGIN USART4_Init 1 */

  /* USER CODE END USART4_Init 1 */
  huart4.Instance = USART4;
 8008c6c:	480c      	ldr	r0, [pc, #48]	; (8008ca0 <MX_USART4_UART_Init+0x34>)
 8008c6e:	4b0d      	ldr	r3, [pc, #52]	; (8008ca4 <MX_USART4_UART_Init+0x38>)
{
 8008c70:	b510      	push	{r4, lr}
  huart4.Init.BaudRate = 9600;
  huart4.Init.WordLength = UART_WORDLENGTH_8B;
  huart4.Init.StopBits = UART_STOPBITS_1;
  huart4.Init.Parity = UART_PARITY_NONE;
  huart4.Init.Mode = UART_MODE_TX_RX;
 8008c72:	220c      	movs	r2, #12
  huart4.Instance = USART4;
 8008c74:	6003      	str	r3, [r0, #0]
  huart4.Init.BaudRate = 9600;
 8008c76:	2396      	movs	r3, #150	; 0x96
  huart4.Init.Mode = UART_MODE_TX_RX;
 8008c78:	6142      	str	r2, [r0, #20]
  huart4.Init.BaudRate = 9600;
 8008c7a:	019b      	lsls	r3, r3, #6
  huart4.Init.HwFlowCtl = UART_HWCONTROL_RTS_CTS;
 8008c7c:	22c0      	movs	r2, #192	; 0xc0
  huart4.Init.BaudRate = 9600;
 8008c7e:	6043      	str	r3, [r0, #4]
  huart4.Init.WordLength = UART_WORDLENGTH_8B;
 8008c80:	2300      	movs	r3, #0
  huart4.Init.HwFlowCtl = UART_HWCONTROL_RTS_CTS;
 8008c82:	0092      	lsls	r2, r2, #2
  huart4.Init.WordLength = UART_WORDLENGTH_8B;
 8008c84:	6083      	str	r3, [r0, #8]
  huart4.Init.StopBits = UART_STOPBITS_1;
 8008c86:	60c3      	str	r3, [r0, #12]
  huart4.Init.Parity = UART_PARITY_NONE;
 8008c88:	6103      	str	r3, [r0, #16]
  huart4.Init.HwFlowCtl = UART_HWCONTROL_RTS_CTS;
 8008c8a:	6182      	str	r2, [r0, #24]
  huart4.Init.OverSampling = UART_OVERSAMPLING_16;
 8008c8c:	61c3      	str	r3, [r0, #28]
  huart4.Init.OneBitSampling = UART_ONE_BIT_SAMPLE_DISABLE;
 8008c8e:	6203      	str	r3, [r0, #32]
  huart4.AdvancedInit.AdvFeatureInit = UART_ADVFEATURE_NO_INIT;
 8008c90:	6243      	str	r3, [r0, #36]	; 0x24
  if (HAL_UART_Init(&huart4) != HAL_OK)
 8008c92:	f004 fb8b 	bl	800d3ac <HAL_UART_Init>
 8008c96:	2800      	cmp	r0, #0
 8008c98:	d001      	beq.n	8008c9e <MX_USART4_UART_Init+0x32>
  {
    Error_Handler();
 8008c9a:	f7ff fe47 	bl	800892c <Error_Handler>
  }
  /* USER CODE BEGIN USART4_Init 2 */

  /* USER CODE END USART4_Init 2 */

}
 8008c9e:	bd10      	pop	{r4, pc}
 8008ca0:	20001d3c 	.word	0x20001d3c
 8008ca4:	40004c00 	.word	0x40004c00

08008ca8 <HAL_UART_MspInit>:

void HAL_UART_MspInit(UART_HandleTypeDef* uartHandle)
{
 8008ca8:	b5f0      	push	{r4, r5, r6, r7, lr}
 8008caa:	0004      	movs	r4, r0
 8008cac:	b08f      	sub	sp, #60	; 0x3c

  GPIO_InitTypeDef GPIO_InitStruct = {0};
 8008cae:	2214      	movs	r2, #20
 8008cb0:	2100      	movs	r1, #0
 8008cb2:	a809      	add	r0, sp, #36	; 0x24
 8008cb4:	f006 ff23 	bl	800fafe <memset>
  if(uartHandle->Instance==USART1)
 8008cb8:	6823      	ldr	r3, [r4, #0]
 8008cba:	4a5c      	ldr	r2, [pc, #368]	; (8008e2c <HAL_UART_MspInit+0x184>)
 8008cbc:	4293      	cmp	r3, r2
 8008cbe:	d12c      	bne.n	8008d1a <HAL_UART_MspInit+0x72>
  {
  /* USER CODE BEGIN USART1_MspInit 0 */

  /* USER CODE END USART1_MspInit 0 */
    /* USART1 clock enable */
    __HAL_RCC_USART1_CLK_ENABLE();
 8008cc0:	2080      	movs	r0, #128	; 0x80
 8008cc2:	4b5b      	ldr	r3, [pc, #364]	; (8008e30 <HAL_UART_MspInit+0x188>)
 8008cc4:	01c0      	lsls	r0, r0, #7
 8008cc6:	6999      	ldr	r1, [r3, #24]
    PA9     ------> USART1_TX
    PA10     ------> USART1_RX
    */
    GPIO_InitStruct.Pin = UART1_TX_Pin|UART1_RX_Pin;
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 8008cc8:	2500      	movs	r5, #0
    __HAL_RCC_USART1_CLK_ENABLE();
 8008cca:	4301      	orrs	r1, r0
 8008ccc:	6199      	str	r1, [r3, #24]
    __HAL_RCC_GPIOA_CLK_ENABLE();
 8008cce:	2180      	movs	r1, #128	; 0x80
    __HAL_RCC_USART1_CLK_ENABLE();
 8008cd0:	699a      	ldr	r2, [r3, #24]
    __HAL_RCC_GPIOA_CLK_ENABLE();
 8008cd2:	0289      	lsls	r1, r1, #10
    __HAL_RCC_USART1_CLK_ENABLE();
 8008cd4:	4002      	ands	r2, r0
 8008cd6:	9200      	str	r2, [sp, #0]
 8008cd8:	9a00      	ldr	r2, [sp, #0]
    __HAL_RCC_GPIOA_CLK_ENABLE();
 8008cda:	695a      	ldr	r2, [r3, #20]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;
    GPIO_InitStruct.Alternate = GPIO_AF1_USART1;
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 8008cdc:	2090      	movs	r0, #144	; 0x90
    __HAL_RCC_GPIOA_CLK_ENABLE();
 8008cde:	430a      	orrs	r2, r1
 8008ce0:	615a      	str	r2, [r3, #20]
 8008ce2:	695b      	ldr	r3, [r3, #20]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;
 8008ce4:	2403      	movs	r4, #3
    __HAL_RCC_GPIOA_CLK_ENABLE();
 8008ce6:	400b      	ands	r3, r1
 8008ce8:	9301      	str	r3, [sp, #4]
 8008cea:	9b01      	ldr	r3, [sp, #4]
    GPIO_InitStruct.Pin = UART1_TX_Pin|UART1_RX_Pin;
 8008cec:	23c0      	movs	r3, #192	; 0xc0
 8008cee:	00db      	lsls	r3, r3, #3
 8008cf0:	9309      	str	r3, [sp, #36]	; 0x24
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8008cf2:	2302      	movs	r3, #2
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 8008cf4:	a909      	add	r1, sp, #36	; 0x24
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8008cf6:	930a      	str	r3, [sp, #40]	; 0x28
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 8008cf8:	05c0      	lsls	r0, r0, #23
    GPIO_InitStruct.Alternate = GPIO_AF1_USART1;
 8008cfa:	3b01      	subs	r3, #1
 8008cfc:	930d      	str	r3, [sp, #52]	; 0x34
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 8008cfe:	950b      	str	r5, [sp, #44]	; 0x2c
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;
 8008d00:	940c      	str	r4, [sp, #48]	; 0x30
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 8008d02:	f001 faef 	bl	800a2e4 <HAL_GPIO_Init>

    /* USART1 interrupt Init */
    HAL_NVIC_SetPriority(USART1_IRQn, 3, 0);
 8008d06:	201b      	movs	r0, #27
 8008d08:	002a      	movs	r2, r5
 8008d0a:	0021      	movs	r1, r4
 8008d0c:	f001 f8d4 	bl	8009eb8 <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(USART1_IRQn);
 8008d10:	201b      	movs	r0, #27
    GPIO_InitStruct.Alternate = GPIO_AF4_USART4;
    HAL_GPIO_Init(UART2_CTS_GPIO_Port, &GPIO_InitStruct);

    /* USART4 interrupt Init */
    HAL_NVIC_SetPriority(USART3_4_IRQn, 3, 0);
    HAL_NVIC_EnableIRQ(USART3_4_IRQn);
 8008d12:	f001 f905 	bl	8009f20 <HAL_NVIC_EnableIRQ>
  /* USER CODE BEGIN USART4_MspInit 1 */

  /* USER CODE END USART4_MspInit 1 */
  }
}
 8008d16:	b00f      	add	sp, #60	; 0x3c
 8008d18:	bdf0      	pop	{r4, r5, r6, r7, pc}
  else if(uartHandle->Instance==USART2)
 8008d1a:	4a46      	ldr	r2, [pc, #280]	; (8008e34 <HAL_UART_MspInit+0x18c>)
 8008d1c:	4293      	cmp	r3, r2
 8008d1e:	d126      	bne.n	8008d6e <HAL_UART_MspInit+0xc6>
    __HAL_RCC_USART2_CLK_ENABLE();
 8008d20:	2280      	movs	r2, #128	; 0x80
 8008d22:	4b43      	ldr	r3, [pc, #268]	; (8008e30 <HAL_UART_MspInit+0x188>)
 8008d24:	0292      	lsls	r2, r2, #10
 8008d26:	69d9      	ldr	r1, [r3, #28]
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 8008d28:	2090      	movs	r0, #144	; 0x90
    __HAL_RCC_USART2_CLK_ENABLE();
 8008d2a:	4311      	orrs	r1, r2
 8008d2c:	61d9      	str	r1, [r3, #28]
 8008d2e:	69d9      	ldr	r1, [r3, #28]
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 8008d30:	2500      	movs	r5, #0
    __HAL_RCC_USART2_CLK_ENABLE();
 8008d32:	4011      	ands	r1, r2
 8008d34:	9102      	str	r1, [sp, #8]
 8008d36:	9902      	ldr	r1, [sp, #8]
    __HAL_RCC_GPIOA_CLK_ENABLE();
 8008d38:	6959      	ldr	r1, [r3, #20]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;
 8008d3a:	2403      	movs	r4, #3
    __HAL_RCC_GPIOA_CLK_ENABLE();
 8008d3c:	4311      	orrs	r1, r2
 8008d3e:	6159      	str	r1, [r3, #20]
 8008d40:	695b      	ldr	r3, [r3, #20]
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 8008d42:	a909      	add	r1, sp, #36	; 0x24
    __HAL_RCC_GPIOA_CLK_ENABLE();
 8008d44:	401a      	ands	r2, r3
 8008d46:	9203      	str	r2, [sp, #12]
 8008d48:	9b03      	ldr	r3, [sp, #12]
    GPIO_InitStruct.Pin = GPS_TX_Pin|GPS_RX_Pin;
 8008d4a:	230c      	movs	r3, #12
 8008d4c:	9309      	str	r3, [sp, #36]	; 0x24
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8008d4e:	3b0a      	subs	r3, #10
 8008d50:	930a      	str	r3, [sp, #40]	; 0x28
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 8008d52:	05c0      	lsls	r0, r0, #23
    GPIO_InitStruct.Alternate = GPIO_AF1_USART2;
 8008d54:	3b01      	subs	r3, #1
 8008d56:	930d      	str	r3, [sp, #52]	; 0x34
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 8008d58:	950b      	str	r5, [sp, #44]	; 0x2c
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;
 8008d5a:	940c      	str	r4, [sp, #48]	; 0x30
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 8008d5c:	f001 fac2 	bl	800a2e4 <HAL_GPIO_Init>
    HAL_NVIC_SetPriority(USART2_IRQn, 3, 0);
 8008d60:	201c      	movs	r0, #28
 8008d62:	002a      	movs	r2, r5
 8008d64:	0021      	movs	r1, r4
 8008d66:	f001 f8a7 	bl	8009eb8 <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(USART2_IRQn);
 8008d6a:	201c      	movs	r0, #28
 8008d6c:	e7d1      	b.n	8008d12 <HAL_UART_MspInit+0x6a>
  else if(uartHandle->Instance==USART3)
 8008d6e:	4a32      	ldr	r2, [pc, #200]	; (8008e38 <HAL_UART_MspInit+0x190>)
 8008d70:	4293      	cmp	r3, r2
 8008d72:	d126      	bne.n	8008dc2 <HAL_UART_MspInit+0x11a>
    __HAL_RCC_USART3_CLK_ENABLE();
 8008d74:	2280      	movs	r2, #128	; 0x80
 8008d76:	4b2e      	ldr	r3, [pc, #184]	; (8008e30 <HAL_UART_MspInit+0x188>)
 8008d78:	02d2      	lsls	r2, r2, #11
 8008d7a:	69d9      	ldr	r1, [r3, #28]
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 8008d7c:	2500      	movs	r5, #0
    __HAL_RCC_USART3_CLK_ENABLE();
 8008d7e:	4311      	orrs	r1, r2
 8008d80:	61d9      	str	r1, [r3, #28]
 8008d82:	69d9      	ldr	r1, [r3, #28]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;
 8008d84:	2403      	movs	r4, #3
    __HAL_RCC_USART3_CLK_ENABLE();
 8008d86:	4011      	ands	r1, r2
 8008d88:	9104      	str	r1, [sp, #16]
 8008d8a:	9904      	ldr	r1, [sp, #16]
    __HAL_RCC_GPIOB_CLK_ENABLE();
 8008d8c:	6959      	ldr	r1, [r3, #20]
 8008d8e:	4311      	orrs	r1, r2
 8008d90:	6159      	str	r1, [r3, #20]
 8008d92:	695b      	ldr	r3, [r3, #20]
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 8008d94:	950b      	str	r5, [sp, #44]	; 0x2c
    __HAL_RCC_GPIOB_CLK_ENABLE();
 8008d96:	401a      	ands	r2, r3
 8008d98:	9205      	str	r2, [sp, #20]
 8008d9a:	9b05      	ldr	r3, [sp, #20]
    GPIO_InitStruct.Pin = MODEM_TX_Pin|MODEM_RX_Pin;
 8008d9c:	23c0      	movs	r3, #192	; 0xc0
 8008d9e:	011b      	lsls	r3, r3, #4
 8008da0:	9309      	str	r3, [sp, #36]	; 0x24
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8008da2:	2302      	movs	r3, #2
 8008da4:	930a      	str	r3, [sp, #40]	; 0x28
    GPIO_InitStruct.Alternate = GPIO_AF4_USART3;
 8008da6:	18db      	adds	r3, r3, r3
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;
 8008da8:	940c      	str	r4, [sp, #48]	; 0x30
    GPIO_InitStruct.Alternate = GPIO_AF4_USART3;
 8008daa:	930d      	str	r3, [sp, #52]	; 0x34
    HAL_GPIO_Init(UART2_CTS_GPIO_Port, &GPIO_InitStruct);
 8008dac:	4823      	ldr	r0, [pc, #140]	; (8008e3c <HAL_UART_MspInit+0x194>)
 8008dae:	a909      	add	r1, sp, #36	; 0x24
 8008db0:	f001 fa98 	bl	800a2e4 <HAL_GPIO_Init>
    HAL_NVIC_SetPriority(USART3_4_IRQn, 3, 0);
 8008db4:	201d      	movs	r0, #29
 8008db6:	002a      	movs	r2, r5
 8008db8:	0021      	movs	r1, r4
 8008dba:	f001 f87d 	bl	8009eb8 <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(USART3_4_IRQn);
 8008dbe:	201d      	movs	r0, #29
 8008dc0:	e7a7      	b.n	8008d12 <HAL_UART_MspInit+0x6a>
  else if(uartHandle->Instance==USART4)
 8008dc2:	4a1f      	ldr	r2, [pc, #124]	; (8008e40 <HAL_UART_MspInit+0x198>)
 8008dc4:	4293      	cmp	r3, r2
 8008dc6:	d1a6      	bne.n	8008d16 <HAL_UART_MspInit+0x6e>
    __HAL_RCC_USART4_CLK_ENABLE();
 8008dc8:	2080      	movs	r0, #128	; 0x80
 8008dca:	4b19      	ldr	r3, [pc, #100]	; (8008e30 <HAL_UART_MspInit+0x188>)
 8008dcc:	0300      	lsls	r0, r0, #12
 8008dce:	69d9      	ldr	r1, [r3, #28]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8008dd0:	2702      	movs	r7, #2
    __HAL_RCC_USART4_CLK_ENABLE();
 8008dd2:	4301      	orrs	r1, r0
 8008dd4:	61d9      	str	r1, [r3, #28]
 8008dd6:	69da      	ldr	r2, [r3, #28]
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 8008dd8:	2500      	movs	r5, #0
    __HAL_RCC_USART4_CLK_ENABLE();
 8008dda:	4002      	ands	r2, r0
    __HAL_RCC_GPIOA_CLK_ENABLE();
 8008ddc:	2080      	movs	r0, #128	; 0x80
    __HAL_RCC_USART4_CLK_ENABLE();
 8008dde:	9206      	str	r2, [sp, #24]
 8008de0:	9a06      	ldr	r2, [sp, #24]
    __HAL_RCC_GPIOA_CLK_ENABLE();
 8008de2:	6959      	ldr	r1, [r3, #20]
 8008de4:	0280      	lsls	r0, r0, #10
 8008de6:	4301      	orrs	r1, r0
 8008de8:	6159      	str	r1, [r3, #20]
    __HAL_RCC_GPIOB_CLK_ENABLE();
 8008dea:	2180      	movs	r1, #128	; 0x80
    __HAL_RCC_GPIOA_CLK_ENABLE();
 8008dec:	695a      	ldr	r2, [r3, #20]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;
 8008dee:	2403      	movs	r4, #3
    __HAL_RCC_GPIOA_CLK_ENABLE();
 8008df0:	4002      	ands	r2, r0
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 8008df2:	2090      	movs	r0, #144	; 0x90
    GPIO_InitStruct.Alternate = GPIO_AF4_USART4;
 8008df4:	2604      	movs	r6, #4
    __HAL_RCC_GPIOA_CLK_ENABLE();
 8008df6:	9207      	str	r2, [sp, #28]
 8008df8:	9a07      	ldr	r2, [sp, #28]
    __HAL_RCC_GPIOB_CLK_ENABLE();
 8008dfa:	695a      	ldr	r2, [r3, #20]
 8008dfc:	02c9      	lsls	r1, r1, #11
 8008dfe:	430a      	orrs	r2, r1
 8008e00:	615a      	str	r2, [r3, #20]
 8008e02:	695b      	ldr	r3, [r3, #20]
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 8008e04:	05c0      	lsls	r0, r0, #23
    __HAL_RCC_GPIOB_CLK_ENABLE();
 8008e06:	400b      	ands	r3, r1
 8008e08:	9308      	str	r3, [sp, #32]
 8008e0a:	9b08      	ldr	r3, [sp, #32]
    GPIO_InitStruct.Pin = UART2_TX_Pin|UART2_RX_Pin|UART2_RTS_Pin;
 8008e0c:	4b0d      	ldr	r3, [pc, #52]	; (8008e44 <HAL_UART_MspInit+0x19c>)
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 8008e0e:	a909      	add	r1, sp, #36	; 0x24
    GPIO_InitStruct.Pin = UART2_TX_Pin|UART2_RX_Pin|UART2_RTS_Pin;
 8008e10:	9309      	str	r3, [sp, #36]	; 0x24
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8008e12:	970a      	str	r7, [sp, #40]	; 0x28
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 8008e14:	950b      	str	r5, [sp, #44]	; 0x2c
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;
 8008e16:	940c      	str	r4, [sp, #48]	; 0x30
    GPIO_InitStruct.Alternate = GPIO_AF4_USART4;
 8008e18:	960d      	str	r6, [sp, #52]	; 0x34
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 8008e1a:	f001 fa63 	bl	800a2e4 <HAL_GPIO_Init>
    GPIO_InitStruct.Pin = UART2_CTS_Pin;
 8008e1e:	2380      	movs	r3, #128	; 0x80
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8008e20:	970a      	str	r7, [sp, #40]	; 0x28
    GPIO_InitStruct.Pin = UART2_CTS_Pin;
 8008e22:	9309      	str	r3, [sp, #36]	; 0x24
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 8008e24:	950b      	str	r5, [sp, #44]	; 0x2c
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;
 8008e26:	940c      	str	r4, [sp, #48]	; 0x30
    GPIO_InitStruct.Alternate = GPIO_AF4_USART4;
 8008e28:	960d      	str	r6, [sp, #52]	; 0x34
 8008e2a:	e7bf      	b.n	8008dac <HAL_UART_MspInit+0x104>
 8008e2c:	40013800 	.word	0x40013800
 8008e30:	40021000 	.word	0x40021000
 8008e34:	40004400 	.word	0x40004400
 8008e38:	40004800 	.word	0x40004800
 8008e3c:	48000400 	.word	0x48000400
 8008e40:	40004c00 	.word	0x40004c00
 8008e44:	00008003 	.word	0x00008003

08008e48 <Reset_Handler>:

  .section .text.Reset_Handler
  .weak Reset_Handler
  .type Reset_Handler, %function
Reset_Handler:
  ldr   r0, =_estack
 8008e48:	480d      	ldr	r0, [pc, #52]	; (8008e80 <LoopForever+0x2>)
  mov   sp, r0          /* set stack pointer */
 8008e4a:	4685      	mov	sp, r0

/* Copy the data segment initializers from flash to SRAM */
  ldr r0, =_sdata
 8008e4c:	480d      	ldr	r0, [pc, #52]	; (8008e84 <LoopForever+0x6>)
  ldr r1, =_edata
 8008e4e:	490e      	ldr	r1, [pc, #56]	; (8008e88 <LoopForever+0xa>)
  ldr r2, =_sidata
 8008e50:	4a0e      	ldr	r2, [pc, #56]	; (8008e8c <LoopForever+0xe>)
  movs r3, #0
 8008e52:	2300      	movs	r3, #0
  b LoopCopyDataInit
 8008e54:	e002      	b.n	8008e5c <LoopCopyDataInit>

08008e56 <CopyDataInit>:

CopyDataInit:
  ldr r4, [r2, r3]
 8008e56:	58d4      	ldr	r4, [r2, r3]
  str r4, [r0, r3]
 8008e58:	50c4      	str	r4, [r0, r3]
  adds r3, r3, #4
 8008e5a:	3304      	adds	r3, #4

08008e5c <LoopCopyDataInit>:

LoopCopyDataInit:
  adds r4, r0, r3
 8008e5c:	18c4      	adds	r4, r0, r3
  cmp r4, r1
 8008e5e:	428c      	cmp	r4, r1
  bcc CopyDataInit
 8008e60:	d3f9      	bcc.n	8008e56 <CopyDataInit>
  
/* Zero fill the bss segment. */
  ldr r2, =_sbss
 8008e62:	4a0b      	ldr	r2, [pc, #44]	; (8008e90 <LoopForever+0x12>)
  ldr r4, =_ebss
 8008e64:	4c0b      	ldr	r4, [pc, #44]	; (8008e94 <LoopForever+0x16>)
  movs r3, #0
 8008e66:	2300      	movs	r3, #0
  b LoopFillZerobss
 8008e68:	e001      	b.n	8008e6e <LoopFillZerobss>

08008e6a <FillZerobss>:

FillZerobss:
  str  r3, [r2]
 8008e6a:	6013      	str	r3, [r2, #0]
  adds r2, r2, #4
 8008e6c:	3204      	adds	r2, #4

08008e6e <LoopFillZerobss>:

LoopFillZerobss:
  cmp r2, r4
 8008e6e:	42a2      	cmp	r2, r4
  bcc FillZerobss
 8008e70:	d3fb      	bcc.n	8008e6a <FillZerobss>

/* Call the clock system intitialization function.*/
  bl  SystemInit
 8008e72:	f7ff fe55 	bl	8008b20 <SystemInit>
/* Call static constructors */
  bl __libc_init_array
 8008e76:	f006 fde1 	bl	800fa3c <__libc_init_array>
/* Call the application's entry point.*/
  bl main
 8008e7a:	f7ff fd2f 	bl	80088dc <main>

08008e7e <LoopForever>:

LoopForever:
    b LoopForever
 8008e7e:	e7fe      	b.n	8008e7e <LoopForever>
  ldr   r0, =_estack
 8008e80:	20004000 	.word	0x20004000
  ldr r0, =_sdata
 8008e84:	20000400 	.word	0x20000400
  ldr r1, =_edata
 8008e88:	2000063c 	.word	0x2000063c
  ldr r2, =_sidata
 8008e8c:	08010a9c 	.word	0x08010a9c
  ldr r2, =_sbss
 8008e90:	20000640 	.word	0x20000640
  ldr r4, =_ebss
 8008e94:	200031f0 	.word	0x200031f0

08008e98 <DMA1_Channel2_3_IRQHandler>:
 * @retval : None
*/
    .section .text.Default_Handler,"ax",%progbits
Default_Handler:
Infinite_Loop:
  b Infinite_Loop
 8008e98:	e7fe      	b.n	8008e98 <DMA1_Channel2_3_IRQHandler>

08008e9a <il_copy_buffer>:
 * @param target_buffer 			Pointer to buffer to be copied to 
 * @param buffer_size 				Buffer size to be copied
 * @return il_status_typedef 
 */
il_status_typedef il_copy_buffer(uint8_t *source_buffer, uint8_t *target_buffer, size_t buffer_size)
{
 8008e9a:	b570      	push	{r4, r5, r6, lr}
 8008e9c:	000c      	movs	r4, r1
 8008e9e:	0006      	movs	r6, r0
	uint8_t mem_check = 0;

	// Copy the source buffer into the target buffer
	memcpy(target_buffer, source_buffer, buffer_size);
 8008ea0:	0001      	movs	r1, r0
 8008ea2:	0020      	movs	r0, r4
{
 8008ea4:	0015      	movs	r5, r2
	memcpy(target_buffer, source_buffer, buffer_size);
 8008ea6:	f006 fe21 	bl	800faec <memcpy>

	// Set the last char in the at the end of the message to 0,
	// Important if message is shorter than the max array size being passed
	target_buffer[buffer_size] = 0;
 8008eaa:	2300      	movs	r3, #0

	// Check if the target_buffer is the same as the source_buffer
	mem_check = memcmp(target_buffer, source_buffer, buffer_size);
 8008eac:	002a      	movs	r2, r5
	target_buffer[buffer_size] = 0;
 8008eae:	5563      	strb	r3, [r4, r5]
	mem_check = memcmp(target_buffer, source_buffer, buffer_size);
 8008eb0:	0031      	movs	r1, r6
 8008eb2:	0020      	movs	r0, r4
 8008eb4:	f006 fe0c 	bl	800fad0 <memcmp>

	// If the two buffers aren't the same return error
	if (mem_check != 0)
 8008eb8:	b2c0      	uxtb	r0, r0
 8008eba:	1e43      	subs	r3, r0, #1
 8008ebc:	4198      	sbcs	r0, r3
	{
		return IL_ERROR;
	}

	return IL_OK;
}
 8008ebe:	b2c0      	uxtb	r0, r0
 8008ec0:	bd70      	pop	{r4, r5, r6, pc}

08008ec2 <il_clear_buffer>:
 * @param buffer 			Pointer to buffer to be cleared 
 * @param buffer_size 		Size of buffer to be cleared 
 */

void il_clear_buffer( void *buffer,size_t buffer_size)
{
 8008ec2:	b510      	push	{r4, lr}
 8008ec4:	000a      	movs	r2, r1
	memset(buffer, '\0', buffer_size);
 8008ec6:	2100      	movs	r1, #0
 8008ec8:	f006 fe19 	bl	800fafe <memset>
}
 8008ecc:	bd10      	pop	{r4, pc}
	...

08008ed0 <il_printf>:
 * @brief Ironlink printf function to send strings via the usb terminal 
 * @note Internal buffer size 256 bytes 
 * @param buff Format string to be parsed 
 * @param ...  Arguments to go in the format string  
 */
void il_printf(const char *buff, ...) {
 8008ed0:	b40f      	push	{r0, r1, r2, r3}
 8008ed2:	b500      	push	{lr}
 8008ed4:	b0c3      	sub	sp, #268	; 0x10c
 8008ed6:	ab44      	add	r3, sp, #272	; 0x110
 8008ed8:	cb04      	ldmia	r3!, {r2}
	char buffer[256];
	// Create list of args from inputs
    va_list args;
    va_start(args, buff);
	// Use the format string and args to create the string to be sent
    vsnprintf(buffer, sizeof(buffer)-1, buff, args);
 8008eda:	21ff      	movs	r1, #255	; 0xff
 8008edc:	a802      	add	r0, sp, #8
    va_start(args, buff);
 8008ede:	9301      	str	r3, [sp, #4]
    vsnprintf(buffer, sizeof(buffer)-1, buff, args);
 8008ee0:	f006 ff7e 	bl	800fde0 <vsniprintf>
	// Transmit the string
    il_usb_transmit((uint8_t*)buffer, strlen(buffer));
 8008ee4:	a802      	add	r0, sp, #8
 8008ee6:	f7ff f90f 	bl	8008108 <strlen>
 8008eea:	4b04      	ldr	r3, [pc, #16]	; (8008efc <il_printf+0x2c>)
 8008eec:	b281      	uxth	r1, r0
 8008eee:	681b      	ldr	r3, [r3, #0]
 8008ef0:	a802      	add	r0, sp, #8
 8008ef2:	4798      	blx	r3
	// Clean up args
    va_end(args);
}
 8008ef4:	b043      	add	sp, #268	; 0x10c
 8008ef6:	bc08      	pop	{r3}
 8008ef8:	b004      	add	sp, #16
 8008efa:	4718      	bx	r3
 8008efc:	20000458 	.word	0x20000458

08008f00 <il_gpio_write_pin>:
 * 
 * @param pin_name Pin name to be written to, can be GPIO1 - GPIO7
 * @param pin_state State to set the pin to, can be SET or RESET
 */
void il_gpio_write_pin(uint16_t pin_name, GPIO_PinState pin_state)
{
 8008f00:	000a      	movs	r2, r1
 8008f02:	b510      	push	{r4, lr}
	GPIO_TypeDef *GPIO_PORT;


	if(pin_name == GPIO1 || pin_name == GPIO2)
 8008f04:	2810      	cmp	r0, #16
 8008f06:	d015      	beq.n	8008f34 <il_gpio_write_pin+0x34>
 8008f08:	2180      	movs	r1, #128	; 0x80
 8008f0a:	0049      	lsls	r1, r1, #1
 8008f0c:	4288      	cmp	r0, r1
 8008f0e:	d011      	beq.n	8008f34 <il_gpio_write_pin+0x34>
	{
		GPIO_PORT = GPIOA;
	}
	else if(pin_name == GPIO3 || pin_name == GPIO4 || pin_name == GPIO5 || pin_name == GPIO7 || pin_name == IL_LORA_MODEM_RST_PIN)
 8008f10:	2801      	cmp	r0, #1
 8008f12:	d00d      	beq.n	8008f30 <il_gpio_write_pin+0x30>
 8008f14:	1f04      	subs	r4, r0, #4
 8008f16:	39fc      	subs	r1, #252	; 0xfc
 8008f18:	438c      	bics	r4, r1
 8008f1a:	b2a4      	uxth	r4, r4
 8008f1c:	2c00      	cmp	r4, #0
 8008f1e:	d007      	beq.n	8008f30 <il_gpio_write_pin+0x30>
 8008f20:	2180      	movs	r1, #128	; 0x80
 8008f22:	0209      	lsls	r1, r1, #8
 8008f24:	4288      	cmp	r0, r1
 8008f26:	d003      	beq.n	8008f30 <il_gpio_write_pin+0x30>
 8008f28:	2180      	movs	r1, #128	; 0x80
 8008f2a:	0149      	lsls	r1, r1, #5
 8008f2c:	4288      	cmp	r0, r1
 8008f2e:	d103      	bne.n	8008f38 <il_gpio_write_pin+0x38>
	{
		GPIO_PORT = GPIOB;
 8008f30:	4b04      	ldr	r3, [pc, #16]	; (8008f44 <il_gpio_write_pin+0x44>)
 8008f32:	e001      	b.n	8008f38 <il_gpio_write_pin+0x38>
		GPIO_PORT = GPIOA;
 8008f34:	2390      	movs	r3, #144	; 0x90
 8008f36:	05db      	lsls	r3, r3, #23
	}

	il_hal_gpio_write_pin(GPIO_PORT, pin_name, pin_state);
 8008f38:	4903      	ldr	r1, [pc, #12]	; (8008f48 <il_gpio_write_pin+0x48>)
 8008f3a:	680c      	ldr	r4, [r1, #0]
 8008f3c:	0001      	movs	r1, r0
 8008f3e:	0018      	movs	r0, r3
 8008f40:	47a0      	blx	r4
}
 8008f42:	bd10      	pop	{r4, pc}
 8008f44:	48000400 	.word	0x48000400
 8008f48:	20000418 	.word	0x20000418

08008f4c <il_adc_init>:
  * 		If defined in the header file auto start the ADC peripheral.
  * @params none
  * @retval none
  */
void il_adc_init(void)
{
 8008f4c:	b510      	push	{r4, lr}
	il_hal_adc_init();
 8008f4e:	4b02      	ldr	r3, [pc, #8]	; (8008f58 <il_adc_init+0xc>)
 8008f50:	681b      	ldr	r3, [r3, #0]
 8008f52:	4798      	blx	r3
}
 8008f54:	bd10      	pop	{r4, pc}
 8008f56:	46c0      	nop			; (mov r8, r8)
 8008f58:	20000414 	.word	0x20000414

08008f5c <il_i2c_map>:
  * @params none
  * @retval none
  */
void il_i2c_map(void)
{
	il_i2c_bus_1.i2c_channel = il_i2c1;
 8008f5c:	4b04      	ldr	r3, [pc, #16]	; (8008f70 <il_i2c_map+0x14>)
 8008f5e:	681a      	ldr	r2, [r3, #0]
 8008f60:	4b04      	ldr	r3, [pc, #16]	; (8008f74 <il_i2c_map+0x18>)
 8008f62:	601a      	str	r2, [r3, #0]
	il_i2c_bus_2.i2c_channel = il_i2c2;
 8008f64:	4b04      	ldr	r3, [pc, #16]	; (8008f78 <il_i2c_map+0x1c>)
 8008f66:	681a      	ldr	r2, [r3, #0]
 8008f68:	4b04      	ldr	r3, [pc, #16]	; (8008f7c <il_i2c_map+0x20>)
 8008f6a:	601a      	str	r2, [r3, #0]
}
 8008f6c:	4770      	bx	lr
 8008f6e:	46c0      	nop			; (mov r8, r8)
 8008f70:	20000438 	.word	0x20000438
 8008f74:	200021c0 	.word	0x200021c0
 8008f78:	20000440 	.word	0x20000440
 8008f7c:	20002018 	.word	0x20002018

08008f80 <il_i2c_init>:
	il_i2c1_init();
 8008f80:	4b04      	ldr	r3, [pc, #16]	; (8008f94 <il_i2c_init+0x14>)
{
 8008f82:	b510      	push	{r4, lr}
	il_i2c1_init();
 8008f84:	681b      	ldr	r3, [r3, #0]
 8008f86:	4798      	blx	r3
	il_i2c2_init();
 8008f88:	4b03      	ldr	r3, [pc, #12]	; (8008f98 <il_i2c_init+0x18>)
 8008f8a:	681b      	ldr	r3, [r3, #0]
 8008f8c:	4798      	blx	r3
	il_i2c_map();
 8008f8e:	f7ff ffe5 	bl	8008f5c <il_i2c_map>
}
 8008f92:	bd10      	pop	{r4, pc}
 8008f94:	2000043c 	.word	0x2000043c
 8008f98:	20000444 	.word	0x20000444

08008f9c <il_uart_port_map>:
  * @param None
  * @retval None
  */
void il_uart_port_map(void)
{
	gps.uart_port = il_gps_uart;
 8008f9c:	4b08      	ldr	r3, [pc, #32]	; (8008fc0 <il_uart_port_map+0x24>)
 8008f9e:	681a      	ldr	r2, [r3, #0]
 8008fa0:	4b08      	ldr	r3, [pc, #32]	; (8008fc4 <il_uart_port_map+0x28>)
 8008fa2:	601a      	str	r2, [r3, #0]
	uart1.uart_port = il_uart1;
 8008fa4:	4b08      	ldr	r3, [pc, #32]	; (8008fc8 <il_uart_port_map+0x2c>)
 8008fa6:	681a      	ldr	r2, [r3, #0]
 8008fa8:	4b08      	ldr	r3, [pc, #32]	; (8008fcc <il_uart_port_map+0x30>)
 8008faa:	601a      	str	r2, [r3, #0]
	uart2.uart_port = il_uart2;
 8008fac:	4b08      	ldr	r3, [pc, #32]	; (8008fd0 <il_uart_port_map+0x34>)
 8008fae:	681a      	ldr	r2, [r3, #0]
 8008fb0:	4b08      	ldr	r3, [pc, #32]	; (8008fd4 <il_uart_port_map+0x38>)
 8008fb2:	601a      	str	r2, [r3, #0]
	modem.uart_port = il_modem_uart;
 8008fb4:	4b08      	ldr	r3, [pc, #32]	; (8008fd8 <il_uart_port_map+0x3c>)
 8008fb6:	681a      	ldr	r2, [r3, #0]
 8008fb8:	4b08      	ldr	r3, [pc, #32]	; (8008fdc <il_uart_port_map+0x40>)
 8008fba:	601a      	str	r2, [r3, #0]

}
 8008fbc:	4770      	bx	lr
 8008fbe:	46c0      	nop			; (mov r8, r8)
 8008fc0:	20000410 	.word	0x20000410
 8008fc4:	20001e44 	.word	0x20001e44
 8008fc8:	2000044c 	.word	0x2000044c
 8008fcc:	20001f7c 	.word	0x20001f7c
 8008fd0:	20000450 	.word	0x20000450
 8008fd4:	20002124 	.word	0x20002124
 8008fd8:	20000448 	.word	0x20000448
 8008fdc:	20001ee0 	.word	0x20001ee0

08008fe0 <il_uart_init>:
	  il_hal_uart1_init();
 8008fe0:	4b07      	ldr	r3, [pc, #28]	; (8009000 <il_uart_init+0x20>)
{
 8008fe2:	b510      	push	{r4, lr}
	  il_hal_uart1_init();
 8008fe4:	681b      	ldr	r3, [r3, #0]
 8008fe6:	4798      	blx	r3
	  il_hal_uart2_init();
 8008fe8:	4b06      	ldr	r3, [pc, #24]	; (8009004 <il_uart_init+0x24>)
 8008fea:	681b      	ldr	r3, [r3, #0]
 8008fec:	4798      	blx	r3
	  il_hal_uart_modem_init();
 8008fee:	4b06      	ldr	r3, [pc, #24]	; (8009008 <il_uart_init+0x28>)
 8008ff0:	681b      	ldr	r3, [r3, #0]
 8008ff2:	4798      	blx	r3
	  il_hal_uart_gps_init();
 8008ff4:	4b05      	ldr	r3, [pc, #20]	; (800900c <il_uart_init+0x2c>)
 8008ff6:	681b      	ldr	r3, [r3, #0]
 8008ff8:	4798      	blx	r3
	  il_uart_port_map();
 8008ffa:	f7ff ffcf 	bl	8008f9c <il_uart_port_map>
}
 8008ffe:	bd10      	pop	{r4, pc}
 8009000:	2000041c 	.word	0x2000041c
 8009004:	20000420 	.word	0x20000420
 8009008:	2000042c 	.word	0x2000042c
 800900c:	20000428 	.word	0x20000428

08009010 <il_uart_flush_buffer>:
 * @brief Function to clear the rx and tx buffers in the uart object as well as resetting the head and tail variables 
 * 
 * @param il_uart ironlink uart object for uart communcation
 */
void il_uart_flush_buffer(il_uart_object *il_uart)
{
 8009010:	b510      	push	{r4, lr}
 8009012:	0004      	movs	r4, r0
		// Clear tx and rx buffer buffers
		il_clear_buffer(il_uart->buffer.rx_buffer.ch_buffer, MAX_BUFFER);
 8009014:	2140      	movs	r1, #64	; 0x40
 8009016:	3007      	adds	r0, #7
 8009018:	f7ff ff53 	bl	8008ec2 <il_clear_buffer>
		il_clear_buffer(il_uart->buffer.tx_buffer.ch_buffer, MAX_BUFFER);
 800901c:	0020      	movs	r0, r4
 800901e:	2140      	movs	r1, #64	; 0x40
 8009020:	304a      	adds	r0, #74	; 0x4a
 8009022:	f7ff ff4e 	bl	8008ec2 <il_clear_buffer>
		// Reset head and tail 
		il_uart->buffer.head = 0;
 8009026:	0022      	movs	r2, r4
 8009028:	2300      	movs	r3, #0
 800902a:	3296      	adds	r2, #150	; 0x96
		il_uart->buffer.tail = 0;
 800902c:	3498      	adds	r4, #152	; 0x98
		il_uart->buffer.head = 0;
 800902e:	8013      	strh	r3, [r2, #0]
		il_uart->buffer.tail = 0;
 8009030:	8023      	strh	r3, [r4, #0]
}
 8009032:	bd10      	pop	{r4, pc}

08009034 <il_uart_write_line>:
{
 8009034:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
	il_clear_buffer(il_uart->buffer.tx_buffer.u8_buffer, MAX_BUFFER);
 8009036:	0006      	movs	r6, r0
{
 8009038:	000d      	movs	r5, r1
	il_clear_buffer(il_uart->buffer.tx_buffer.u8_buffer, MAX_BUFFER);
 800903a:	364a      	adds	r6, #74	; 0x4a
{
 800903c:	0004      	movs	r4, r0
	il_clear_buffer(il_uart->buffer.tx_buffer.u8_buffer, MAX_BUFFER);
 800903e:	2140      	movs	r1, #64	; 0x40
 8009040:	0030      	movs	r0, r6
{
 8009042:	9201      	str	r2, [sp, #4]
	il_clear_buffer(il_uart->buffer.tx_buffer.u8_buffer, MAX_BUFFER);
 8009044:	f7ff ff3d 	bl	8008ec2 <il_clear_buffer>
	status = il_copy_buffer((uint8_t*)message, il_uart->buffer.tx_buffer.u8_buffer, strlen(message));
 8009048:	0028      	movs	r0, r5
 800904a:	f7ff f85d 	bl	8008108 <strlen>
 800904e:	0031      	movs	r1, r6
 8009050:	0002      	movs	r2, r0
 8009052:	0028      	movs	r0, r5
 8009054:	f7ff ff21 	bl	8008e9a <il_copy_buffer>
 8009058:	0005      	movs	r5, r0
	il_uart->buffer.tx_length = strlen(il_uart->buffer.tx_buffer.ch_buffer);
 800905a:	0030      	movs	r0, r6
 800905c:	f7ff f854 	bl	8008108 <strlen>
 8009060:	0023      	movs	r3, r4
	uint32_t t = il_get_tick()+timeout;
 8009062:	4f17      	ldr	r7, [pc, #92]	; (80090c0 <il_uart_write_line+0x8c>)
	il_uart->buffer.tx_length = strlen(il_uart->buffer.tx_buffer.ch_buffer);
 8009064:	3348      	adds	r3, #72	; 0x48
 8009066:	9300      	str	r3, [sp, #0]
 8009068:	8018      	strh	r0, [r3, #0]
	uint32_t t = il_get_tick()+timeout;
 800906a:	683b      	ldr	r3, [r7, #0]
 800906c:	4798      	blx	r3
 800906e:	9b01      	ldr	r3, [sp, #4]
	il_hal_uart_write_it(il_uart->uart_port, il_uart->buffer.tx_buffer.u8_buffer, il_uart->buffer.tx_length);
 8009070:	0031      	movs	r1, r6
	uint32_t t = il_get_tick()+timeout;
 8009072:	18c3      	adds	r3, r0, r3
 8009074:	9301      	str	r3, [sp, #4]
	il_hal_uart_write_it(il_uart->uart_port, il_uart->buffer.tx_buffer.u8_buffer, il_uart->buffer.tx_length);
 8009076:	9b00      	ldr	r3, [sp, #0]
 8009078:	6820      	ldr	r0, [r4, #0]
 800907a:	881a      	ldrh	r2, [r3, #0]
 800907c:	4b11      	ldr	r3, [pc, #68]	; (80090c4 <il_uart_write_line+0x90>)
 800907e:	681b      	ldr	r3, [r3, #0]
 8009080:	4798      	blx	r3
	while (il_uart->buffer.eot_flag != 1)
 8009082:	0026      	movs	r6, r4
 8009084:	3690      	adds	r6, #144	; 0x90
 8009086:	7833      	ldrb	r3, [r6, #0]
 8009088:	2b01      	cmp	r3, #1
 800908a:	d00d      	beq.n	80090a8 <il_uart_write_line+0x74>
		if (t < il_get_tick())
 800908c:	683b      	ldr	r3, [r7, #0]
 800908e:	4798      	blx	r3
 8009090:	9b01      	ldr	r3, [sp, #4]
 8009092:	4298      	cmp	r0, r3
 8009094:	d90f      	bls.n	80090b6 <il_uart_write_line+0x82>
			il_uart->buffer.timeout_flag = 1;
 8009096:	0023      	movs	r3, r4
 8009098:	2201      	movs	r2, #1
 800909a:	3393      	adds	r3, #147	; 0x93
 800909c:	701a      	strb	r2, [r3, #0]
			il_hal_uart_abort_write_it(il_uart->uart_port);
 800909e:	4b0a      	ldr	r3, [pc, #40]	; (80090c8 <il_uart_write_line+0x94>)
 80090a0:	6820      	ldr	r0, [r4, #0]
 80090a2:	681b      	ldr	r3, [r3, #0]
 80090a4:	4798      	blx	r3
			status = IL_TIMEOUT;
 80090a6:	2503      	movs	r5, #3
	il_uart->buffer.eot_flag = 0;
 80090a8:	2300      	movs	r3, #0
	il_uart_flush_buffer(il_uart);
 80090aa:	0020      	movs	r0, r4
	il_uart->buffer.eot_flag = 0;
 80090ac:	7033      	strb	r3, [r6, #0]
	il_uart_flush_buffer(il_uart);
 80090ae:	f7ff ffaf 	bl	8009010 <il_uart_flush_buffer>
}
 80090b2:	0028      	movs	r0, r5
 80090b4:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
		il_delay(1);
 80090b6:	4b05      	ldr	r3, [pc, #20]	; (80090cc <il_uart_write_line+0x98>)
 80090b8:	2001      	movs	r0, #1
 80090ba:	681b      	ldr	r3, [r3, #0]
 80090bc:	4798      	blx	r3
 80090be:	e7e0      	b.n	8009082 <il_uart_write_line+0x4e>
 80090c0:	20000408 	.word	0x20000408
 80090c4:	20000434 	.word	0x20000434
 80090c8:	20000424 	.word	0x20000424
 80090cc:	20000400 	.word	0x20000400

080090d0 <il_uart_read_line>:
{
 80090d0:	b5f0      	push	{r4, r5, r6, r7, lr}
 80090d2:	0004      	movs	r4, r0
	uint32_t t = il_get_tick()+timeout,
 80090d4:	4d27      	ldr	r5, [pc, #156]	; (8009174 <il_uart_read_line+0xa4>)
{
 80090d6:	b085      	sub	sp, #20
	uint32_t t = il_get_tick()+timeout,
 80090d8:	682b      	ldr	r3, [r5, #0]
{
 80090da:	0017      	movs	r7, r2
 80090dc:	9103      	str	r1, [sp, #12]
	uint32_t t = il_get_tick()+timeout,
 80090de:	4798      	blx	r3
		il_hal_uart_read_it(il_uart->uart_port, &il_uart->buffer.rx_buffer.u8_buffer[il_uart->buffer.tail], 1);
 80090e0:	0023      	movs	r3, r4
 80090e2:	3398      	adds	r3, #152	; 0x98
 80090e4:	9301      	str	r3, [sp, #4]
 80090e6:	8819      	ldrh	r1, [r3, #0]
 80090e8:	4b23      	ldr	r3, [pc, #140]	; (8009178 <il_uart_read_line+0xa8>)
 80090ea:	3107      	adds	r1, #7
 80090ec:	2201      	movs	r2, #1
 80090ee:	681b      	ldr	r3, [r3, #0]
	uint32_t t = il_get_tick()+timeout,
 80090f0:	19c7      	adds	r7, r0, r7
		il_hal_uart_read_it(il_uart->uart_port, &il_uart->buffer.rx_buffer.u8_buffer[il_uart->buffer.tail], 1);
 80090f2:	1861      	adds	r1, r4, r1
 80090f4:	6820      	ldr	r0, [r4, #0]
 80090f6:	4798      	blx	r3
	il_status_typedef status = IL_OK;
 80090f8:	2600      	movs	r6, #0
		while (il_uart->buffer.eot_flag != 1)
 80090fa:	0023      	movs	r3, r4
 80090fc:	3390      	adds	r3, #144	; 0x90
 80090fe:	9302      	str	r3, [sp, #8]
 8009100:	781a      	ldrb	r2, [r3, #0]
 8009102:	682b      	ldr	r3, [r5, #0]
 8009104:	2a01      	cmp	r2, #1
 8009106:	d11c      	bne.n	8009142 <il_uart_read_line+0x72>
		if (t > il_get_tick())
 8009108:	4798      	blx	r3
 800910a:	42b8      	cmp	r0, r7
 800910c:	d205      	bcs.n	800911a <il_uart_read_line+0x4a>
			t1 = t - il_get_tick();
 800910e:	682b      	ldr	r3, [r5, #0]
 8009110:	4798      	blx	r3
			il_delay(t1);
 8009112:	4b1a      	ldr	r3, [pc, #104]	; (800917c <il_uart_read_line+0xac>)
			t1 = t - il_get_tick();
 8009114:	1a38      	subs	r0, r7, r0
			il_delay(t1);
 8009116:	681b      	ldr	r3, [r3, #0]
 8009118:	4798      	blx	r3
		while(il_uart->buffer.head != il_uart->buffer.tail)
 800911a:	0022      	movs	r2, r4
 800911c:	9903      	ldr	r1, [sp, #12]
 800911e:	3296      	adds	r2, #150	; 0x96
 8009120:	9b01      	ldr	r3, [sp, #4]
 8009122:	8810      	ldrh	r0, [r2, #0]
 8009124:	881b      	ldrh	r3, [r3, #0]
 8009126:	4298      	cmp	r0, r3
 8009128:	d118      	bne.n	800915c <il_uart_read_line+0x8c>
		il_uart->buffer.eot_flag = 0;
 800912a:	2300      	movs	r3, #0
 800912c:	9a02      	ldr	r2, [sp, #8]
		il_uart_flush_buffer(il_uart);
 800912e:	0020      	movs	r0, r4
		il_uart->buffer.eot_flag = 0;
 8009130:	7013      	strb	r3, [r2, #0]
		il_uart->buffer.timeout_flag = 0;
 8009132:	0022      	movs	r2, r4
 8009134:	3293      	adds	r2, #147	; 0x93
 8009136:	7013      	strb	r3, [r2, #0]
		il_uart_flush_buffer(il_uart);
 8009138:	f7ff ff6a 	bl	8009010 <il_uart_flush_buffer>
}
 800913c:	0030      	movs	r0, r6
 800913e:	b005      	add	sp, #20
 8009140:	bdf0      	pop	{r4, r5, r6, r7, pc}
			if (t < il_get_tick())
 8009142:	4798      	blx	r3
 8009144:	42b8      	cmp	r0, r7
 8009146:	d904      	bls.n	8009152 <il_uart_read_line+0x82>
				il_uart->buffer.timeout_flag = 1;
 8009148:	0023      	movs	r3, r4
 800914a:	2201      	movs	r2, #1
				status = IL_TIMEOUT;
 800914c:	2603      	movs	r6, #3
				il_uart->buffer.timeout_flag = 1;
 800914e:	3393      	adds	r3, #147	; 0x93
 8009150:	701a      	strb	r2, [r3, #0]
			il_delay(1);
 8009152:	4b0a      	ldr	r3, [pc, #40]	; (800917c <il_uart_read_line+0xac>)
 8009154:	2001      	movs	r0, #1
 8009156:	681b      	ldr	r3, [r3, #0]
 8009158:	4798      	blx	r3
 800915a:	e7ce      	b.n	80090fa <il_uart_read_line+0x2a>
			char rx = il_uart->buffer.rx_buffer.ch_buffer[il_uart->buffer.head++];
 800915c:	8813      	ldrh	r3, [r2, #0]
 800915e:	1c58      	adds	r0, r3, #1
 8009160:	b280      	uxth	r0, r0
 8009162:	8010      	strh	r0, [r2, #0]
 8009164:	18e3      	adds	r3, r4, r3
 8009166:	79db      	ldrb	r3, [r3, #7]
			if (rx != '\0'){
 8009168:	2b00      	cmp	r3, #0
 800916a:	d0d9      	beq.n	8009120 <il_uart_read_line+0x50>
				*buffer++ = rx;
 800916c:	700b      	strb	r3, [r1, #0]
				length++;
 800916e:	3101      	adds	r1, #1
 8009170:	e7d6      	b.n	8009120 <il_uart_read_line+0x50>
 8009172:	46c0      	nop			; (mov r8, r8)
 8009174:	20000408 	.word	0x20000408
 8009178:	20000430 	.word	0x20000430
 800917c:	20000400 	.word	0x20000400

08009180 <il_uart_isr_receive>:
 * 
 * @param il_uart ironlink uart object for uart communcation
 * @param interrupt_status_register_flags the interrupt status register current values
 */
void il_uart_isr_receive(il_uart_object *il_uart, uint32_t interrupt_status_register_flags)
{
 8009180:	b570      	push	{r4, r5, r6, lr}
	if(++il_uart->buffer.tail >= MAX_BUFFER)
 8009182:	0004      	movs	r4, r0
 8009184:	3498      	adds	r4, #152	; 0x98
 8009186:	8823      	ldrh	r3, [r4, #0]
 8009188:	3301      	adds	r3, #1
 800918a:	b29b      	uxth	r3, r3
 800918c:	8023      	strh	r3, [r4, #0]
 800918e:	2b3f      	cmp	r3, #63	; 0x3f
 8009190:	d901      	bls.n	8009196 <il_uart_isr_receive+0x16>
	{
		il_uart->buffer.tail = 0;
 8009192:	2300      	movs	r3, #0
 8009194:	8023      	strh	r3, [r4, #0]
	}
	if ((interrupt_status_register_flags & USART_ISR_RXNE)!=0) // Has a new character been recieved 
 8009196:	2320      	movs	r3, #32
 8009198:	000d      	movs	r5, r1
 800919a:	401d      	ands	r5, r3
 800919c:	4219      	tst	r1, r3
 800919e:	d013      	beq.n	80091c8 <il_uart_isr_receive+0x48>
	{
			// Read the RDR register which contains the newest character

			il_uart->buffer.rx_char.ch_byte = (uint16_t)((READ_REG(il_uart->uart_port->Instance->RDR)) & (uint8_t)il_uart->uart_port->Mask);
 80091a0:	6803      	ldr	r3, [r0, #0]
 80091a2:	001e      	movs	r6, r3
 80091a4:	681a      	ldr	r2, [r3, #0]
 80091a6:	365c      	adds	r6, #92	; 0x5c
 80091a8:	8c92      	ldrh	r2, [r2, #36]	; 0x24
 80091aa:	8836      	ldrh	r6, [r6, #0]

			// Copy the latest char to the il_uart objects rx_char variable

			il_uart->buffer.rx_buffer.u8_buffer[il_uart->buffer.tail] = il_uart->buffer.rx_char.u8_byte;

			if(il_uart->uart_port->RxXferCount > 0U) // If the receive transfer counter is larger than 0
 80091ac:	335a      	adds	r3, #90	; 0x5a
			il_uart->buffer.rx_char.ch_byte = (uint16_t)((READ_REG(il_uart->uart_port->Instance->RDR)) & (uint8_t)il_uart->uart_port->Mask);
 80091ae:	4032      	ands	r2, r6
 80091b0:	b2d2      	uxtb	r2, r2
 80091b2:	7182      	strb	r2, [r0, #6]
			il_uart->buffer.rx_buffer.u8_buffer[il_uart->buffer.tail] = il_uart->buffer.rx_char.u8_byte;
 80091b4:	8824      	ldrh	r4, [r4, #0]
 80091b6:	1904      	adds	r4, r0, r4
 80091b8:	71e2      	strb	r2, [r4, #7]
			if(il_uart->uart_port->RxXferCount > 0U) // If the receive transfer counter is larger than 0
 80091ba:	881a      	ldrh	r2, [r3, #0]
 80091bc:	2a00      	cmp	r2, #0
 80091be:	d003      	beq.n	80091c8 <il_uart_isr_receive+0x48>
			{
				il_uart->uart_port->RxXferCount--;   // Decrement the receive transfer counter
 80091c0:	881a      	ldrh	r2, [r3, #0]
 80091c2:	3a01      	subs	r2, #1
 80091c4:	b292      	uxth	r2, r2
 80091c6:	801a      	strh	r2, [r3, #0]
			}

	}
	// If the UART IDLE interrupt is set and the Rx not empty interrupt is not set, set the end of transmission flag 
	if ((interrupt_status_register_flags & UART_IT_IDLE) !=0 && (interrupt_status_register_flags & USART_ISR_RXNE)!=0)
 80091c8:	4b04      	ldr	r3, [pc, #16]	; (80091dc <il_uart_isr_receive+0x5c>)
 80091ca:	4219      	tst	r1, r3
 80091cc:	d004      	beq.n	80091d8 <il_uart_isr_receive+0x58>
 80091ce:	2d00      	cmp	r5, #0
 80091d0:	d002      	beq.n	80091d8 <il_uart_isr_receive+0x58>
	{
		il_uart->buffer.eot_flag = 1;
 80091d2:	2301      	movs	r3, #1
 80091d4:	3090      	adds	r0, #144	; 0x90
 80091d6:	7003      	strb	r3, [r0, #0]
	}

}
 80091d8:	bd70      	pop	{r4, r5, r6, pc}
 80091da:	46c0      	nop			; (mov r8, r8)
 80091dc:	00000424 	.word	0x00000424

080091e0 <il_uart_isr_receive_end>:
 */
void il_uart_isr_receive_end(il_uart_object *il_uart)
{

	  /* Disable RXNE, PE and ERR (Frame error, noise error, overrun error) interrupts */
	  CLEAR_BIT(il_uart->uart_port->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE));
 80091e0:	6802      	ldr	r2, [r0, #0]
 80091e2:	4807      	ldr	r0, [pc, #28]	; (8009200 <il_uart_isr_receive_end+0x20>)
 80091e4:	6813      	ldr	r3, [r2, #0]
 80091e6:	6819      	ldr	r1, [r3, #0]
 80091e8:	4001      	ands	r1, r0
 80091ea:	6019      	str	r1, [r3, #0]
	  CLEAR_BIT(il_uart->uart_port->Instance->CR3, USART_CR3_EIE);
 80091ec:	6899      	ldr	r1, [r3, #8]
 80091ee:	3023      	adds	r0, #35	; 0x23
 80091f0:	30ff      	adds	r0, #255	; 0xff
 80091f2:	4381      	bics	r1, r0
 80091f4:	6099      	str	r1, [r3, #8]

	  /* At end of Rx process, restore huart->RxState to Ready */
	  il_uart->uart_port->RxState = HAL_UART_STATE_READY;
 80091f6:	2320      	movs	r3, #32
 80091f8:	67d3      	str	r3, [r2, #124]	; 0x7c

	  /* Reset RxIsr function pointer */
	  il_uart->uart_port->RxISR = NULL;
 80091fa:	2300      	movs	r3, #0
 80091fc:	6653      	str	r3, [r2, #100]	; 0x64
	  return;
}
 80091fe:	4770      	bx	lr
 8009200:	fffffedf 	.word	0xfffffedf

08009204 <il_uart_isr_transmit>:
 * @param il_uart ironlink uart object for uart communcation
 */
void il_uart_isr_transmit(il_uart_object *il_uart)
{

	  if (il_uart->uart_port->gState == HAL_UART_STATE_BUSY_TX)
 8009204:	6803      	ldr	r3, [r0, #0]
{
 8009206:	b510      	push	{r4, lr}
	  if (il_uart->uart_port->gState == HAL_UART_STATE_BUSY_TX)
 8009208:	6f9a      	ldr	r2, [r3, #120]	; 0x78
 800920a:	2a21      	cmp	r2, #33	; 0x21
 800920c:	d10d      	bne.n	800922a <il_uart_isr_transmit+0x26>
	  {
	    if (il_uart->uart_port->TxXferCount == 0U)
 800920e:	0018      	movs	r0, r3
 8009210:	3052      	adds	r0, #82	; 0x52
 8009212:	8801      	ldrh	r1, [r0, #0]
 8009214:	681a      	ldr	r2, [r3, #0]
 8009216:	2900      	cmp	r1, #0
 8009218:	d108      	bne.n	800922c <il_uart_isr_transmit+0x28>
	    {
	      /* Disable the UART Transmit Data Register Empty Interrupt */
	      CLEAR_BIT(il_uart->uart_port->Instance->CR1, USART_CR1_TXEIE);
 800921a:	6813      	ldr	r3, [r2, #0]
 800921c:	3180      	adds	r1, #128	; 0x80
 800921e:	438b      	bics	r3, r1
 8009220:	6013      	str	r3, [r2, #0]

	      /* Enable the UART Transmit Complete Interrupt */
	      SET_BIT(il_uart->uart_port->Instance->CR1, USART_CR1_TCIE);
 8009222:	2340      	movs	r3, #64	; 0x40
 8009224:	6811      	ldr	r1, [r2, #0]
 8009226:	430b      	orrs	r3, r1
 8009228:	6013      	str	r3, [r2, #0]
			il_uart->uart_port->TxXferCount--;
	    }
	  }
	  return;

}
 800922a:	bd10      	pop	{r4, pc}
			il_uart->uart_port->Instance->TDR = (uint8_t)(*il_uart->uart_port->pTxBuffPtr & (uint8_t)0xFF);
 800922c:	6cd9      	ldr	r1, [r3, #76]	; 0x4c
 800922e:	780c      	ldrb	r4, [r1, #0]
			il_uart->uart_port->pTxBuffPtr++;
 8009230:	3101      	adds	r1, #1
			il_uart->uart_port->Instance->TDR = (uint8_t)(*il_uart->uart_port->pTxBuffPtr & (uint8_t)0xFF);
 8009232:	8514      	strh	r4, [r2, #40]	; 0x28
			il_uart->uart_port->pTxBuffPtr++;
 8009234:	64d9      	str	r1, [r3, #76]	; 0x4c
			il_uart->uart_port->TxXferCount--;
 8009236:	8803      	ldrh	r3, [r0, #0]
 8009238:	3b01      	subs	r3, #1
 800923a:	b29b      	uxth	r3, r3
 800923c:	8003      	strh	r3, [r0, #0]
	  return;
 800923e:	e7f4      	b.n	800922a <il_uart_isr_transmit+0x26>

08009240 <il_uart_isr_tx_complete_callback>:
 * 
 * @param il_uart Ironlink uart object for uart communcation
 */
void il_uart_isr_tx_complete_callback(il_uart_handle_typedef *il_uart)
{
	if(il_uart->Instance == USART1)
 8009240:	6803      	ldr	r3, [r0, #0]
 8009242:	4a0c      	ldr	r2, [pc, #48]	; (8009274 <il_uart_isr_tx_complete_callback+0x34>)
 8009244:	4293      	cmp	r3, r2
 8009246:	d104      	bne.n	8009252 <il_uart_isr_tx_complete_callback+0x12>
	{
		uart1.buffer.eot_flag = 1;
 8009248:	4b0b      	ldr	r3, [pc, #44]	; (8009278 <il_uart_isr_tx_complete_callback+0x38>)
	{
		modem.buffer.eot_flag = 1;
	}
	if(il_uart->Instance == USART4)
	{
		uart2.buffer.eot_flag = 1;
 800924a:	2201      	movs	r2, #1
 800924c:	3390      	adds	r3, #144	; 0x90
 800924e:	701a      	strb	r2, [r3, #0]
	}
}
 8009250:	e008      	b.n	8009264 <il_uart_isr_tx_complete_callback+0x24>
	if(il_uart->Instance == USART2)
 8009252:	4a0a      	ldr	r2, [pc, #40]	; (800927c <il_uart_isr_tx_complete_callback+0x3c>)
 8009254:	4293      	cmp	r3, r2
 8009256:	d006      	beq.n	8009266 <il_uart_isr_tx_complete_callback+0x26>
	if(il_uart->Instance == USART3)
 8009258:	4a09      	ldr	r2, [pc, #36]	; (8009280 <il_uart_isr_tx_complete_callback+0x40>)
 800925a:	4293      	cmp	r3, r2
 800925c:	d005      	beq.n	800926a <il_uart_isr_tx_complete_callback+0x2a>
	if(il_uart->Instance == USART4)
 800925e:	4a09      	ldr	r2, [pc, #36]	; (8009284 <il_uart_isr_tx_complete_callback+0x44>)
 8009260:	4293      	cmp	r3, r2
 8009262:	d004      	beq.n	800926e <il_uart_isr_tx_complete_callback+0x2e>
}
 8009264:	4770      	bx	lr
		gps.buffer.eot_flag = 1;
 8009266:	4b08      	ldr	r3, [pc, #32]	; (8009288 <il_uart_isr_tx_complete_callback+0x48>)
 8009268:	e7ef      	b.n	800924a <il_uart_isr_tx_complete_callback+0xa>
		modem.buffer.eot_flag = 1;
 800926a:	4b08      	ldr	r3, [pc, #32]	; (800928c <il_uart_isr_tx_complete_callback+0x4c>)
 800926c:	e7ed      	b.n	800924a <il_uart_isr_tx_complete_callback+0xa>
		uart2.buffer.eot_flag = 1;
 800926e:	4b08      	ldr	r3, [pc, #32]	; (8009290 <il_uart_isr_tx_complete_callback+0x50>)
 8009270:	e7eb      	b.n	800924a <il_uart_isr_tx_complete_callback+0xa>
 8009272:	46c0      	nop			; (mov r8, r8)
 8009274:	40013800 	.word	0x40013800
 8009278:	20001f7c 	.word	0x20001f7c
 800927c:	40004400 	.word	0x40004400
 8009280:	40004800 	.word	0x40004800
 8009284:	40004c00 	.word	0x40004c00
 8009288:	20001e44 	.word	0x20001e44
 800928c:	20001ee0 	.word	0x20001ee0
 8009290:	20002124 	.word	0x20002124

08009294 <il_uart_isr_transmit_end>:
	  CLEAR_BIT(il_uart->uart_port->Instance->CR1, USART_CR1_TCIE);
 8009294:	2140      	movs	r1, #64	; 0x40
 8009296:	6800      	ldr	r0, [r0, #0]
{
 8009298:	b510      	push	{r4, lr}
	  CLEAR_BIT(il_uart->uart_port->Instance->CR1, USART_CR1_TCIE);
 800929a:	6802      	ldr	r2, [r0, #0]
 800929c:	6813      	ldr	r3, [r2, #0]
 800929e:	438b      	bics	r3, r1
 80092a0:	6013      	str	r3, [r2, #0]
	  il_uart->uart_port->gState = HAL_UART_STATE_READY;
 80092a2:	2320      	movs	r3, #32
 80092a4:	6783      	str	r3, [r0, #120]	; 0x78
	  il_uart->uart_port->TxISR = NULL;
 80092a6:	2300      	movs	r3, #0
 80092a8:	6683      	str	r3, [r0, #104]	; 0x68
	  il_uart_isr_tx_complete_callback(il_uart->uart_port);
 80092aa:	f7ff ffc9 	bl	8009240 <il_uart_isr_tx_complete_callback>
}
 80092ae:	bd10      	pop	{r4, pc}

080092b0 <il_uart_irq_handler>:
	  uint32_t interrupt_status_register_flags = READ_REG(il_uart->uart_port->Instance->ISR);
 80092b0:	6803      	ldr	r3, [r0, #0]
{
 80092b2:	b570      	push	{r4, r5, r6, lr}
	  uint32_t interrupt_status_register_flags = READ_REG(il_uart->uart_port->Instance->ISR);
 80092b4:	681b      	ldr	r3, [r3, #0]
{
 80092b6:	0004      	movs	r4, r0
	  uint32_t interrupt_status_register_flags = READ_REG(il_uart->uart_port->Instance->ISR);
 80092b8:	69dd      	ldr	r5, [r3, #28]
	  uint32_t control_register_1_interrupts   = READ_REG(il_uart->uart_port->Instance->CR1);
 80092ba:	681e      	ldr	r6, [r3, #0]
	  if (((interrupt_status_register_flags & USART_ISR_RXNE) != 0U)
 80092bc:	2320      	movs	r3, #32
 80092be:	421d      	tst	r5, r3
 80092c0:	d004      	beq.n	80092cc <il_uart_irq_handler+0x1c>
	      && ((control_register_1_interrupts & USART_CR1_RXNEIE) != 0U))
 80092c2:	421e      	tst	r6, r3
 80092c4:	d002      	beq.n	80092cc <il_uart_irq_handler+0x1c>
		  il_uart_isr_receive(il_uart, interrupt_status_register_flags);
 80092c6:	0029      	movs	r1, r5
 80092c8:	f7ff ff5a 	bl	8009180 <il_uart_isr_receive>
			  && (interrupt_status_register_flags & USART_ISR_FE) == 0U )
 80092cc:	230a      	movs	r3, #10
 80092ce:	402b      	ands	r3, r5
	  if((interrupt_status_register_flags & USART_ISR_ORE) != 0U
 80092d0:	2b08      	cmp	r3, #8
 80092d2:	d122      	bne.n	800931a <il_uart_irq_handler+0x6a>
		  __HAL_UART_CLEAR_FEFLAG(il_uart->uart_port);
 80092d4:	6822      	ldr	r2, [r4, #0]
 80092d6:	6812      	ldr	r2, [r2, #0]
 80092d8:	6213      	str	r3, [r2, #32]
		  il_uart_isr_receive(il_uart, interrupt_status_register_flags);
 80092da:	0029      	movs	r1, r5
 80092dc:	0020      	movs	r0, r4
 80092de:	f7ff ff4f 	bl	8009180 <il_uart_isr_receive>
		  __HAL_UNLOCK(il_uart->uart_port);
 80092e2:	2200      	movs	r2, #0
 80092e4:	6823      	ldr	r3, [r4, #0]
 80092e6:	3374      	adds	r3, #116	; 0x74
 80092e8:	701a      	strb	r2, [r3, #0]
	        && ((control_register_1_interrupts & USART_CR1_RXNEIE) == 0U))
 80092ea:	002b      	movs	r3, r5
 80092ec:	4333      	orrs	r3, r6
 80092ee:	069b      	lsls	r3, r3, #26
 80092f0:	d402      	bmi.n	80092f8 <il_uart_irq_handler+0x48>
		  il_uart_isr_receive_end(il_uart);
 80092f2:	0020      	movs	r0, r4
 80092f4:	f7ff ff74 	bl	80091e0 <il_uart_isr_receive_end>
	  if (((interrupt_status_register_flags & USART_ISR_TXE) != 0U)
 80092f8:	2380      	movs	r3, #128	; 0x80
 80092fa:	421d      	tst	r5, r3
 80092fc:	d004      	beq.n	8009308 <il_uart_irq_handler+0x58>
	      && ((control_register_1_interrupts & USART_CR1_TXEIE) != 0U))
 80092fe:	421e      	tst	r6, r3
 8009300:	d002      	beq.n	8009308 <il_uart_irq_handler+0x58>
		  il_uart_isr_transmit(il_uart);
 8009302:	0020      	movs	r0, r4
 8009304:	f7ff ff7e 	bl	8009204 <il_uart_isr_transmit>
	  if (((interrupt_status_register_flags & USART_ISR_TC) != 0U) &&
 8009308:	2340      	movs	r3, #64	; 0x40
 800930a:	421d      	tst	r5, r3
 800930c:	d004      	beq.n	8009318 <il_uart_irq_handler+0x68>
 800930e:	421e      	tst	r6, r3
 8009310:	d002      	beq.n	8009318 <il_uart_irq_handler+0x68>
		  il_uart_isr_transmit_end(il_uart);
 8009312:	0020      	movs	r0, r4
 8009314:	f7ff ffbe 	bl	8009294 <il_uart_isr_transmit_end>
}
 8009318:	bd70      	pop	{r4, r5, r6, pc}
	  if((interrupt_status_register_flags & USART_ISR_FE) != 0U
 800931a:	2b02      	cmp	r3, #2
 800931c:	d0da      	beq.n	80092d4 <il_uart_irq_handler+0x24>
	  if((interrupt_status_register_flags & USART_ISR_FE) != 0U
 800931e:	2b0a      	cmp	r3, #10
 8009320:	d1e3      	bne.n	80092ea <il_uart_irq_handler+0x3a>
		  __HAL_UART_CLEAR_OREFLAG(il_uart->uart_port);
 8009322:	2208      	movs	r2, #8
 8009324:	6823      	ldr	r3, [r4, #0]
 8009326:	681b      	ldr	r3, [r3, #0]
 8009328:	621a      	str	r2, [r3, #32]
		  __HAL_UART_CLEAR_FEFLAG(il_uart->uart_port);
 800932a:	3a06      	subs	r2, #6
 800932c:	621a      	str	r2, [r3, #32]
 800932e:	e7d4      	b.n	80092da <il_uart_irq_handler+0x2a>

08009330 <il_usb_set_sol_char>:
 * @param il_usb ironlink usb object for usb communcation
 * @param startofline_char charcter used by the interrupt to determine the start of the line
 */
void il_usb_set_sol_char(il_usb_object *il_usb, char startofline_char)
{
	il_usb->buffer.sol_char.ch_byte = startofline_char;
 8009330:	3090      	adds	r0, #144	; 0x90
 8009332:	7001      	strb	r1, [r0, #0]
	return;
}
 8009334:	4770      	bx	lr

08009336 <il_usb_set_eol_char>:
 * @param endofline_char charcter used by the interrupt to determine the end of the line
 */
void il_usb_set_eol_char(il_usb_object *il_usb, char endofline_char)
{

	il_usb->buffer.eol_char.ch_byte = endofline_char;
 8009336:	3091      	adds	r0, #145	; 0x91
 8009338:	7001      	strb	r1, [r0, #0]
	return;
}
 800933a:	4770      	bx	lr

0800933c <il_usb_read_line>:
 * @note This function is blocking
 * @param il_usb Ironlink usb object for usb communcation
 * @param rx_buffer Pointer to buffer used to recieve message
 */
void il_usb_read_line(il_usb_object *il_usb, char* rx_buffer)
{
 800933c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800933e:	0004      	movs	r4, r0
 8009340:	000d      	movs	r5, r1

	while (il_usb->buffer.eot_flag != 1)
 8009342:	0026      	movs	r6, r4
 8009344:	368c      	adds	r6, #140	; 0x8c
 8009346:	7833      	ldrb	r3, [r6, #0]
 8009348:	2b01      	cmp	r3, #1
 800934a:	d10e      	bne.n	800936a <il_usb_read_line+0x2e>
		__NOP();
		osDelay(1);
	}


	memcpy(rx_buffer, il_usb->buffer.rx_buffer.ch_buffer, il_usb->buffer.rx_index);
 800934c:	1ce7      	adds	r7, r4, #3
 800934e:	0039      	movs	r1, r7
 8009350:	0028      	movs	r0, r5
 8009352:	8822      	ldrh	r2, [r4, #0]
 8009354:	f006 fbca 	bl	800faec <memcpy>

	memset((void *)il_usb->buffer.rx_buffer.ch_buffer, '\0', MAX_BUFFER);
 8009358:	0038      	movs	r0, r7
 800935a:	2240      	movs	r2, #64	; 0x40
 800935c:	2100      	movs	r1, #0
 800935e:	f006 fbce 	bl	800fafe <memset>

	il_usb->buffer.eot_flag = 0;
 8009362:	2300      	movs	r3, #0
 8009364:	7033      	strb	r3, [r6, #0]

	il_usb->buffer.rx_index = 0;
 8009366:	8023      	strh	r3, [r4, #0]

	return;
}
 8009368:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		__NOP();
 800936a:	46c0      	nop			; (mov r8, r8)
		osDelay(1);
 800936c:	2001      	movs	r0, #1
 800936e:	f005 fc0f 	bl	800eb90 <osDelay>
 8009372:	e7e6      	b.n	8009342 <il_usb_read_line+0x6>

08009374 <il_usb_read_irq_handler_keyboard>:
{
	static uint16_t rx_index = 0;
	// Copy over the current char
	il_usb->buffer.rx_char.ch_byte = Buf[0];

	if ( (il_usb->buffer.rx_char.ch_byte == il_usb->buffer.eol_char.ch_byte)) // Is this an end-of-line condition, either will suffice?
 8009374:	0003      	movs	r3, r0
{
 8009376:	b530      	push	{r4, r5, lr}
	il_usb->buffer.rx_char.ch_byte = Buf[0];
 8009378:	780a      	ldrb	r2, [r1, #0]
	if ( (il_usb->buffer.rx_char.ch_byte == il_usb->buffer.eol_char.ch_byte)) // Is this an end-of-line condition, either will suffice?
 800937a:	3391      	adds	r3, #145	; 0x91
	il_usb->buffer.rx_char.ch_byte = Buf[0];
 800937c:	7082      	strb	r2, [r0, #2]
	if ( (il_usb->buffer.rx_char.ch_byte == il_usb->buffer.eol_char.ch_byte)) // Is this an end-of-line condition, either will suffice?
 800937e:	7819      	ldrb	r1, [r3, #0]
 8009380:	4b13      	ldr	r3, [pc, #76]	; (80093d0 <il_usb_read_irq_handler_keyboard+0x5c>)
 8009382:	4291      	cmp	r1, r2
 8009384:	d113      	bne.n	80093ae <il_usb_read_irq_handler_keyboard+0x3a>
	{
		// Make sure the line has some content
		if (rx_index != 0)
 8009386:	881a      	ldrh	r2, [r3, #0]
 8009388:	2a00      	cmp	r2, #0
 800938a:	d00f      	beq.n	80093ac <il_usb_read_irq_handler_keyboard+0x38>
		{
			// Make sure the rx index value is less than max buffer size -1 for padding purposes
			if (rx_index < MAX_BUFFER-1)
 800938c:	2a3e      	cmp	r2, #62	; 0x3e
 800938e:	d803      	bhi.n	8009398 <il_usb_read_irq_handler_keyboard+0x24>
				il_usb->buffer.rx_buffer.ch_buffer[rx_index++] = il_usb->buffer.rx_char.ch_byte;
 8009390:	1c54      	adds	r4, r2, #1
 8009392:	1882      	adds	r2, r0, r2
 8009394:	801c      	strh	r4, [r3, #0]
 8009396:	70d1      	strb	r1, [r2, #3]
			// Add terminating NUL
			il_usb->buffer.rx_buffer.ch_buffer[rx_index] = '\0';
 8009398:	2200      	movs	r2, #0
 800939a:	8819      	ldrh	r1, [r3, #0]
			// flag new line valid for processing
			il_usb->buffer.eot_flag = 1;
 800939c:	2501      	movs	r5, #1
			il_usb->buffer.rx_buffer.ch_buffer[rx_index] = '\0';
 800939e:	1844      	adds	r4, r0, r1
 80093a0:	70e2      	strb	r2, [r4, #3]
			il_usb->buffer.eot_flag = 1;
 80093a2:	0004      	movs	r4, r0
 80093a4:	348c      	adds	r4, #140	; 0x8c
 80093a6:	7025      	strb	r5, [r4, #0]
			// Copy message length to index
			il_usb->buffer.rx_index = rx_index;
			// Reset content pointer
			rx_index = 0;
 80093a8:	801a      	strh	r2, [r3, #0]
			il_usb->buffer.rx_index = rx_index;
 80093aa:	8001      	strh	r1, [r0, #0]
			rx_index = 0;
		// Copy to buffer
		il_usb->buffer.rx_buffer.ch_buffer[rx_index++] = il_usb->buffer.rx_char.ch_byte;
	}
	return;
}
 80093ac:	bd30      	pop	{r4, r5, pc}
		if ((il_usb->buffer.rx_char.ch_byte == il_usb->buffer.sol_char.ch_byte) || (rx_index == MAX_BUFFER))
 80093ae:	0001      	movs	r1, r0
 80093b0:	3190      	adds	r1, #144	; 0x90
 80093b2:	7809      	ldrb	r1, [r1, #0]
 80093b4:	4291      	cmp	r1, r2
 80093b6:	d002      	beq.n	80093be <il_usb_read_irq_handler_keyboard+0x4a>
 80093b8:	8819      	ldrh	r1, [r3, #0]
 80093ba:	2940      	cmp	r1, #64	; 0x40
 80093bc:	d101      	bne.n	80093c2 <il_usb_read_irq_handler_keyboard+0x4e>
			rx_index = 0;
 80093be:	2100      	movs	r1, #0
 80093c0:	8019      	strh	r1, [r3, #0]
		il_usb->buffer.rx_buffer.ch_buffer[rx_index++] = il_usb->buffer.rx_char.ch_byte;
 80093c2:	8819      	ldrh	r1, [r3, #0]
 80093c4:	1c4c      	adds	r4, r1, #1
 80093c6:	1840      	adds	r0, r0, r1
 80093c8:	801c      	strh	r4, [r3, #0]
 80093ca:	70c2      	strb	r2, [r0, #3]
	return;
 80093cc:	e7ee      	b.n	80093ac <il_usb_read_irq_handler_keyboard+0x38>
 80093ce:	46c0      	nop			; (mov r8, r8)
 80093d0:	20000ab4 	.word	0x20000ab4

080093d4 <il_lora_enable_modem>:
 * @brief Physically Enable The LoRa Modem And Check For Boot Message
 * 
 * @param LORATYPE Lora modem type RN2483 for 868MHz and RN2903 for 915MHz
 * @return uint8_t 
 */
il_lora_status il_lora_enable_modem(il_lora_modem_type LORATYPE) {
 80093d4:	b5f0      	push	{r4, r5, r6, r7, lr}

	il_usb_transmit((uint8_t*)"Turning Modem On . . . \r\n", sizeof("Turning Modem On . . . \r\n"));

	il_delay(5);

	uint8_t recv[50] = {'\0'};
 80093d6:	2700      	movs	r7, #0
	il_usb_transmit((uint8_t*)"Turning Modem On . . . \r\n", sizeof("Turning Modem On . . . \r\n"));
 80093d8:	4d3b      	ldr	r5, [pc, #236]	; (80094c8 <il_lora_enable_modem+0xf4>)
il_lora_status il_lora_enable_modem(il_lora_modem_type LORATYPE) {
 80093da:	b08f      	sub	sp, #60	; 0x3c
	il_usb_transmit((uint8_t*)"Turning Modem On . . . \r\n", sizeof("Turning Modem On . . . \r\n"));
 80093dc:	211a      	movs	r1, #26
il_lora_status il_lora_enable_modem(il_lora_modem_type LORATYPE) {
 80093de:	0004      	movs	r4, r0
	il_usb_transmit((uint8_t*)"Turning Modem On . . . \r\n", sizeof("Turning Modem On . . . \r\n"));
 80093e0:	682b      	ldr	r3, [r5, #0]
 80093e2:	483a      	ldr	r0, [pc, #232]	; (80094cc <il_lora_enable_modem+0xf8>)
 80093e4:	4798      	blx	r3
	il_delay(5);
 80093e6:	4e3a      	ldr	r6, [pc, #232]	; (80094d0 <il_lora_enable_modem+0xfc>)
 80093e8:	2005      	movs	r0, #5
 80093ea:	6833      	ldr	r3, [r6, #0]
 80093ec:	4798      	blx	r3
	uint8_t recv[50] = {'\0'};
 80093ee:	222e      	movs	r2, #46	; 0x2e
 80093f0:	0039      	movs	r1, r7
 80093f2:	a802      	add	r0, sp, #8
 80093f4:	9701      	str	r7, [sp, #4]
 80093f6:	f006 fb82 	bl	800fafe <memset>

	// Enable the modem by pulling the reset pin high
	il_gpio_write_pin(IL_LORA_MODEM_RST_PIN, SET);
 80093fa:	2080      	movs	r0, #128	; 0x80
 80093fc:	2101      	movs	r1, #1
 80093fe:	0140      	lsls	r0, r0, #5
 8009400:	f7ff fd7e 	bl	8008f00 <il_gpio_write_pin>

	// Needs to be over 1000 millisecs to ensure the message is recieved
	il_uart_read_line(&modem, (uint8_t *)recv, 1000);
 8009404:	22fa      	movs	r2, #250	; 0xfa
 8009406:	4833      	ldr	r0, [pc, #204]	; (80094d4 <il_lora_enable_modem+0x100>)
 8009408:	0092      	lsls	r2, r2, #2
 800940a:	a901      	add	r1, sp, #4
 800940c:	f7ff fe60 	bl	80090d0 <il_uart_read_line>
	il_delay(5);
 8009410:	2005      	movs	r0, #5
 8009412:	6833      	ldr	r3, [r6, #0]
 8009414:	4798      	blx	r3

	switch(LORATYPE)
 8009416:	42bc      	cmp	r4, r7
 8009418:	d007      	beq.n	800942a <il_lora_enable_modem+0x56>
 800941a:	2c01      	cmp	r4, #1
 800941c:	d02e      	beq.n	800947c <il_lora_enable_modem+0xa8>
				il_usb_transmit((uint8_t*)"BOOT LORA FAILED!\r\n", sizeof("BOOT LORA FAILED!\r\n"));
				NVIC_SystemReset();
				return IL_LORA_ERROR;
			}
		default:
			il_usb_transmit((uint8_t*)"MODE NOT SET!\r\n", sizeof("MODE NOT SET!\r\n"));
 800941e:	2110      	movs	r1, #16
 8009420:	682b      	ldr	r3, [r5, #0]
 8009422:	482d      	ldr	r0, [pc, #180]	; (80094d8 <il_lora_enable_modem+0x104>)
 8009424:	4798      	blx	r3
			return IL_LORA_ERROR;
 8009426:	2401      	movs	r4, #1
 8009428:	e010      	b.n	800944c <il_lora_enable_modem+0x78>
			if (strstr((char*)recv, "RN2483") != NULL) {
 800942a:	492c      	ldr	r1, [pc, #176]	; (80094dc <il_lora_enable_modem+0x108>)
 800942c:	a801      	add	r0, sp, #4
 800942e:	f006 fc5f 	bl	800fcf0 <strstr>
 8009432:	2800      	cmp	r0, #0
 8009434:	d00d      	beq.n	8009452 <il_lora_enable_modem+0x7e>
				il_usb_transmit(recv, 50);
 8009436:	2132      	movs	r1, #50	; 0x32
 8009438:	682b      	ldr	r3, [r5, #0]
 800943a:	a801      	add	r0, sp, #4
 800943c:	4798      	blx	r3
				il_delay(5);
 800943e:	6833      	ldr	r3, [r6, #0]
 8009440:	2005      	movs	r0, #5
 8009442:	4798      	blx	r3
				il_usb_transmit((uint8_t*)"BOOT LORA SUCCESSFUL!\r\n", sizeof("BOOT LORA SUCCESSFUL!\r\n"));
 8009444:	2118      	movs	r1, #24
 8009446:	682b      	ldr	r3, [r5, #0]
 8009448:	4825      	ldr	r0, [pc, #148]	; (80094e0 <il_lora_enable_modem+0x10c>)
 800944a:	4798      	blx	r3

	}

}
 800944c:	0020      	movs	r0, r4
 800944e:	b00f      	add	sp, #60	; 0x3c
 8009450:	bdf0      	pop	{r4, r5, r6, r7, pc}
				il_gpio_write_pin(IL_LORA_MODEM_RST_PIN, SET);
 8009452:	2080      	movs	r0, #128	; 0x80
 8009454:	2101      	movs	r1, #1
 8009456:	0140      	lsls	r0, r0, #5
 8009458:	f7ff fd52 	bl	8008f00 <il_gpio_write_pin>
				il_usb_transmit((uint8_t*)"BOOT LORA FAILED!\r\n", sizeof("BOOT LORA FAILED!\r\n"));
 800945c:	2114      	movs	r1, #20
 800945e:	682b      	ldr	r3, [r5, #0]
 8009460:	4820      	ldr	r0, [pc, #128]	; (80094e4 <il_lora_enable_modem+0x110>)
 8009462:	4798      	blx	r3
				il_delay(5);
 8009464:	6833      	ldr	r3, [r6, #0]
 8009466:	2005      	movs	r0, #5
 8009468:	4798      	blx	r3
  \details Acts as a special kind of Data Memory Barrier.
           It completes when all explicit memory accesses before this instruction complete.
 */
__STATIC_FORCEINLINE void __DSB(void)
{
  __ASM volatile ("dsb 0xF":::"memory");
 800946a:	f3bf 8f4f 	dsb	sy
 */
__NO_RETURN __STATIC_INLINE void __NVIC_SystemReset(void)
{
  __DSB();                                                          /* Ensure all outstanding memory accesses included
                                                                       buffered write are completed before reset */
  SCB->AIRCR  = ((0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
 800946e:	4b1e      	ldr	r3, [pc, #120]	; (80094e8 <il_lora_enable_modem+0x114>)
 8009470:	4a1e      	ldr	r2, [pc, #120]	; (80094ec <il_lora_enable_modem+0x118>)
 8009472:	60da      	str	r2, [r3, #12]
 8009474:	f3bf 8f4f 	dsb	sy
                 SCB_AIRCR_SYSRESETREQ_Msk);
  __DSB();                                                          /* Ensure completion of memory access */

  for(;;)                                                           /* wait until reset */
  {
    __NOP();
 8009478:	46c0      	nop			; (mov r8, r8)
  for(;;)                                                           /* wait until reset */
 800947a:	e7fd      	b.n	8009478 <il_lora_enable_modem+0xa4>
			if (strstr((char*)recv, "RN2903") != NULL) {
 800947c:	491c      	ldr	r1, [pc, #112]	; (80094f0 <il_lora_enable_modem+0x11c>)
 800947e:	a801      	add	r0, sp, #4
 8009480:	f006 fc36 	bl	800fcf0 <strstr>
 8009484:	2800      	cmp	r0, #0
 8009486:	d00c      	beq.n	80094a2 <il_lora_enable_modem+0xce>
				il_usb_transmit(recv, 50);
 8009488:	2132      	movs	r1, #50	; 0x32
 800948a:	682b      	ldr	r3, [r5, #0]
 800948c:	a801      	add	r0, sp, #4
 800948e:	4798      	blx	r3
				il_delay(5);
 8009490:	6833      	ldr	r3, [r6, #0]
 8009492:	2005      	movs	r0, #5
 8009494:	4798      	blx	r3
				il_usb_transmit((uint8_t*)"BOOT LORA SUCCESSFUL!\r\n", sizeof("BOOT LORA SUCCESSFUL!\r\n"));
 8009496:	2118      	movs	r1, #24
 8009498:	682b      	ldr	r3, [r5, #0]
 800949a:	4811      	ldr	r0, [pc, #68]	; (80094e0 <il_lora_enable_modem+0x10c>)
 800949c:	4798      	blx	r3
				return IL_LORA_OK;
 800949e:	003c      	movs	r4, r7
 80094a0:	e7d4      	b.n	800944c <il_lora_enable_modem+0x78>
				il_gpio_write_pin(IL_LORA_MODEM_RST_PIN, SET);
 80094a2:	2080      	movs	r0, #128	; 0x80
 80094a4:	0021      	movs	r1, r4
 80094a6:	0140      	lsls	r0, r0, #5
 80094a8:	f7ff fd2a 	bl	8008f00 <il_gpio_write_pin>
				il_usb_transmit((uint8_t*)"BOOT LORA FAILED!\r\n", sizeof("BOOT LORA FAILED!\r\n"));
 80094ac:	2114      	movs	r1, #20
 80094ae:	682b      	ldr	r3, [r5, #0]
 80094b0:	480c      	ldr	r0, [pc, #48]	; (80094e4 <il_lora_enable_modem+0x110>)
 80094b2:	4798      	blx	r3
 80094b4:	f3bf 8f4f 	dsb	sy
  SCB->AIRCR  = ((0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
 80094b8:	4b0b      	ldr	r3, [pc, #44]	; (80094e8 <il_lora_enable_modem+0x114>)
 80094ba:	4a0c      	ldr	r2, [pc, #48]	; (80094ec <il_lora_enable_modem+0x118>)
 80094bc:	60da      	str	r2, [r3, #12]
 80094be:	f3bf 8f4f 	dsb	sy
    __NOP();
 80094c2:	46c0      	nop			; (mov r8, r8)
  for(;;)                                                           /* wait until reset */
 80094c4:	e7fd      	b.n	80094c2 <il_lora_enable_modem+0xee>
 80094c6:	46c0      	nop			; (mov r8, r8)
 80094c8:	20000458 	.word	0x20000458
 80094cc:	08010579 	.word	0x08010579
 80094d0:	20000400 	.word	0x20000400
 80094d4:	20001ee0 	.word	0x20001ee0
 80094d8:	080105cd 	.word	0x080105cd
 80094dc:	08010593 	.word	0x08010593
 80094e0:	0801059a 	.word	0x0801059a
 80094e4:	080105b2 	.word	0x080105b2
 80094e8:	e000ed00 	.word	0xe000ed00
 80094ec:	05fa0004 	.word	0x05fa0004
 80094f0:	080105c6 	.word	0x080105c6

080094f4 <il_lora_modem_send_command>:
 * @param command command to send to modem, reference of allowed command are in the ironlink header file
 * @param value some commands have values to be sent with them, set to NULL if there is no value to be sent
 * @param timeout how long to wait for reply from command.
 * @return il_lora_status 
 */
il_lora_status il_lora_modem_send_command(char *command, char *value, uint16_t timeout) {
 80094f4:	b5f0      	push	{r4, r5, r6, r7, lr}
 80094f6:	000d      	movs	r5, r1

	char buffer[50] = {'\0'};
 80094f8:	2100      	movs	r1, #0
il_lora_status il_lora_modem_send_command(char *command, char *value, uint16_t timeout) {
 80094fa:	b08f      	sub	sp, #60	; 0x3c
 80094fc:	0004      	movs	r4, r0
 80094fe:	0017      	movs	r7, r2
	char buffer[50] = {'\0'};
 8009500:	a802      	add	r0, sp, #8
 8009502:	222e      	movs	r2, #46	; 0x2e
 8009504:	9101      	str	r1, [sp, #4]
 8009506:	f006 fafa 	bl	800fafe <memset>
	uint16_t len = 0;

	// Assemble the transmission string
	if (value != NULL) {
 800950a:	4e16      	ldr	r6, [pc, #88]	; (8009564 <il_lora_modem_send_command+0x70>)
 800950c:	2d00      	cmp	r5, #0
 800950e:	d023      	beq.n	8009558 <il_lora_modem_send_command+0x64>
		len = sprintf(buffer, "%s %s\r\n", command, value);
 8009510:	002b      	movs	r3, r5
 8009512:	0022      	movs	r2, r4
 8009514:	4914      	ldr	r1, [pc, #80]	; (8009568 <il_lora_modem_send_command+0x74>)
 8009516:	a801      	add	r0, sp, #4
 8009518:	f006 fbb4 	bl	800fc84 <siprintf>
		il_usb_transmit((uint8_t*)buffer, len);
	} else {
		len = sprintf(buffer, "%s\r\n", command);
		il_usb_transmit((uint8_t*)buffer, len);
 800951c:	6833      	ldr	r3, [r6, #0]
 800951e:	b281      	uxth	r1, r0
 8009520:	a801      	add	r0, sp, #4
 8009522:	4798      	blx	r3
}

	// Send command to the modem
	il_uart_write_line(&modem, (char *)buffer,200);
 8009524:	4c11      	ldr	r4, [pc, #68]	; (800956c <il_lora_modem_send_command+0x78>)
 8009526:	22c8      	movs	r2, #200	; 0xc8
 8009528:	a901      	add	r1, sp, #4
 800952a:	0020      	movs	r0, r4
 800952c:	f7ff fd82 	bl	8009034 <il_uart_write_line>


	// Clear the buffer
	il_clear_buffer(buffer, 50);
 8009530:	a801      	add	r0, sp, #4
 8009532:	2132      	movs	r1, #50	; 0x32
 8009534:	f7ff fcc5 	bl	8008ec2 <il_clear_buffer>


	// Wait for the incoming buffer
	il_uart_read_line(&modem,(uint8_t*)buffer, timeout);
 8009538:	003a      	movs	r2, r7
 800953a:	a901      	add	r1, sp, #4
 800953c:	0020      	movs	r0, r4
 800953e:	f7ff fdc7 	bl	80090d0 <il_uart_read_line>


	il_usb_transmit((uint8_t*)buffer, sizeof(buffer));
 8009542:	2132      	movs	r1, #50	; 0x32
 8009544:	6833      	ldr	r3, [r6, #0]
 8009546:	a801      	add	r0, sp, #4
 8009548:	4798      	blx	r3
	il_delay(5);
 800954a:	4b09      	ldr	r3, [pc, #36]	; (8009570 <il_lora_modem_send_command+0x7c>)
 800954c:	2005      	movs	r0, #5
 800954e:	681b      	ldr	r3, [r3, #0]
 8009550:	4798      	blx	r3

	return IL_LORA_OK;
}
 8009552:	2000      	movs	r0, #0
 8009554:	b00f      	add	sp, #60	; 0x3c
 8009556:	bdf0      	pop	{r4, r5, r6, r7, pc}
		len = sprintf(buffer, "%s\r\n", command);
 8009558:	0022      	movs	r2, r4
 800955a:	4906      	ldr	r1, [pc, #24]	; (8009574 <il_lora_modem_send_command+0x80>)
 800955c:	a801      	add	r0, sp, #4
 800955e:	f006 fb91 	bl	800fc84 <siprintf>
 8009562:	e7db      	b.n	800951c <il_lora_modem_send_command+0x28>
 8009564:	20000458 	.word	0x20000458
 8009568:	080105dd 	.word	0x080105dd
 800956c:	20001ee0 	.word	0x20001ee0
 8009570:	20000400 	.word	0x20000400
 8009574:	080105e0 	.word	0x080105e0

08009578 <il_lora_modem_read_command>:
 * @param return_buffer_size modem command response buffer size. 
 * @param timeout how long to wait for reply from command.
 * @return il_lora_status 
 */
il_lora_status il_lora_modem_read_command(char *command, char *value, char* return_buffer, uint16_t return_buffer_size, uint16_t timeout) 
{
 8009578:	b5f0      	push	{r4, r5, r6, r7, lr}
 800957a:	000d      	movs	r5, r1
	char buffer[50] = {'\0'};
 800957c:	2100      	movs	r1, #0
{
 800957e:	b091      	sub	sp, #68	; 0x44
 8009580:	001f      	movs	r7, r3
 8009582:	ab16      	add	r3, sp, #88	; 0x58
 8009584:	881b      	ldrh	r3, [r3, #0]
 8009586:	0004      	movs	r4, r0
 8009588:	9200      	str	r2, [sp, #0]
	char buffer[50] = {'\0'};
 800958a:	a804      	add	r0, sp, #16
 800958c:	222e      	movs	r2, #46	; 0x2e
{
 800958e:	9301      	str	r3, [sp, #4]
	char buffer[50] = {'\0'};
 8009590:	9103      	str	r1, [sp, #12]
 8009592:	f006 fab4 	bl	800fafe <memset>
	uint16_t len = 0;

	// Assemble the transmission string
	if (value != NULL) {
 8009596:	2d00      	cmp	r5, #0
 8009598:	d034      	beq.n	8009604 <il_lora_modem_read_command+0x8c>
		len = sprintf(buffer, "%s %s\r\n", command, value);
 800959a:	002b      	movs	r3, r5
 800959c:	0022      	movs	r2, r4
 800959e:	491c      	ldr	r1, [pc, #112]	; (8009610 <il_lora_modem_read_command+0x98>)
 80095a0:	a803      	add	r0, sp, #12
 80095a2:	f006 fb6f 	bl	800fc84 <siprintf>
		il_usb_transmit((uint8_t*)buffer, len);
	} else {
		len = sprintf(buffer, "%s\r\n", command);
		il_usb_transmit((uint8_t*)buffer, len);
 80095a6:	4b1b      	ldr	r3, [pc, #108]	; (8009614 <il_lora_modem_read_command+0x9c>)
		len = sprintf(buffer, "%s\r\n", command);
 80095a8:	b284      	uxth	r4, r0
		il_usb_transmit((uint8_t*)buffer, len);
 80095aa:	0021      	movs	r1, r4
 80095ac:	681b      	ldr	r3, [r3, #0]
 80095ae:	a803      	add	r0, sp, #12
 80095b0:	4798      	blx	r3
}

	// Send command to the modem
	il_usb_transmit((uint8_t*)buffer, len);
 80095b2:	4d18      	ldr	r5, [pc, #96]	; (8009614 <il_lora_modem_read_command+0x9c>)
 80095b4:	0021      	movs	r1, r4
 80095b6:	682b      	ldr	r3, [r5, #0]
 80095b8:	a803      	add	r0, sp, #12
 80095ba:	4798      	blx	r3
	il_delay(5);
 80095bc:	4c16      	ldr	r4, [pc, #88]	; (8009618 <il_lora_modem_read_command+0xa0>)
 80095be:	2005      	movs	r0, #5
 80095c0:	6823      	ldr	r3, [r4, #0]
 80095c2:	4798      	blx	r3
	il_uart_write_line(&modem, (char *)buffer,200);
 80095c4:	4e15      	ldr	r6, [pc, #84]	; (800961c <il_lora_modem_read_command+0xa4>)
 80095c6:	22c8      	movs	r2, #200	; 0xc8
 80095c8:	a903      	add	r1, sp, #12
 80095ca:	0030      	movs	r0, r6
 80095cc:	f7ff fd32 	bl	8009034 <il_uart_write_line>


	// Clear the buffer
	il_clear_buffer(buffer, 50);
 80095d0:	a803      	add	r0, sp, #12
 80095d2:	2132      	movs	r1, #50	; 0x32
 80095d4:	f7ff fc75 	bl	8008ec2 <il_clear_buffer>


	// Wait for the incoming buffer
	il_uart_read_line(&modem,(uint8_t*)buffer, timeout);
 80095d8:	9a01      	ldr	r2, [sp, #4]
 80095da:	a903      	add	r1, sp, #12
 80095dc:	0030      	movs	r0, r6
 80095de:	f7ff fd77 	bl	80090d0 <il_uart_read_line>


	il_usb_transmit((uint8_t*)buffer, sizeof(buffer));
 80095e2:	2132      	movs	r1, #50	; 0x32
 80095e4:	682b      	ldr	r3, [r5, #0]
 80095e6:	a803      	add	r0, sp, #12
 80095e8:	4798      	blx	r3
	il_delay(5);
 80095ea:	6823      	ldr	r3, [r4, #0]
 80095ec:	2005      	movs	r0, #5
 80095ee:	4798      	blx	r3

	// Copy the response to the response buffer.
	memcpy(return_buffer, buffer, return_buffer_size);
 80095f0:	003a      	movs	r2, r7
 80095f2:	9800      	ldr	r0, [sp, #0]
 80095f4:	a903      	add	r1, sp, #12
 80095f6:	f006 fa79 	bl	800faec <memcpy>
	return_buffer[return_buffer_size] = '\0';
 80095fa:	2000      	movs	r0, #0
 80095fc:	9b00      	ldr	r3, [sp, #0]
 80095fe:	55d8      	strb	r0, [r3, r7]

	return IL_LORA_OK;
}
 8009600:	b011      	add	sp, #68	; 0x44
 8009602:	bdf0      	pop	{r4, r5, r6, r7, pc}
		len = sprintf(buffer, "%s\r\n", command);
 8009604:	0022      	movs	r2, r4
 8009606:	4906      	ldr	r1, [pc, #24]	; (8009620 <il_lora_modem_read_command+0xa8>)
 8009608:	a803      	add	r0, sp, #12
 800960a:	f006 fb3b 	bl	800fc84 <siprintf>
 800960e:	e7ca      	b.n	80095a6 <il_lora_modem_read_command+0x2e>
 8009610:	080105dd 	.word	0x080105dd
 8009614:	20000458 	.word	0x20000458
 8009618:	20000400 	.word	0x20000400
 800961c:	20001ee0 	.word	0x20001ee0
 8009620:	080105e0 	.word	0x080105e0

08009624 <il_lora_modem_default_config>:
 * @param lora_config lora config object containing the config options 
 * @param LORATYPE lora modem model type RN2483 or RN2903
 * @return il_lora_status 
 */
il_lora_status il_lora_modem_default_config(il_lora_config *lora_config, il_lora_modem_type LORATYPE)
{
 8009624:	b537      	push	{r0, r1, r2, r4, r5, lr}
 8009626:	0004      	movs	r4, r0
	switch(LORATYPE)
 8009628:	2900      	cmp	r1, #0
 800962a:	d003      	beq.n	8009634 <il_lora_modem_default_config+0x10>
 800962c:	2901      	cmp	r1, #1
 800962e:	d015      	beq.n	800965c <il_lora_modem_default_config+0x38>
				il_lora_modem_read_command(RN_SYS_GET_HWEUI, NULL, lora_config->hweui, 16, 10000);
				break;

		}
	return IL_OK;
}
 8009630:	2000      	movs	r0, #0
 8009632:	bd3e      	pop	{r1, r2, r3, r4, r5, pc}
				lora_config->appEui 				= "0000000000000000";
 8009634:	4b0e      	ldr	r3, [pc, #56]	; (8009670 <il_lora_modem_default_config+0x4c>)
				lora_config->joinMode 				= IL_LORA_OTA;							// Choose the OTAA join mode. Requires appEui & appKey to be set.
 8009636:	8301      	strh	r1, [r0, #24]
				lora_config->appEui 				= "0000000000000000";
 8009638:	6083      	str	r3, [r0, #8]
				lora_config->frequency 				= IL_LORA_868;
 800963a:	4b0e      	ldr	r3, [pc, #56]	; (8009674 <il_lora_modem_default_config+0x50>)
 800963c:	6043      	str	r3, [r0, #4]
				lora_config->transmissionPower 		= 1;
 800963e:	4b0e      	ldr	r3, [pc, #56]	; (8009678 <il_lora_modem_default_config+0x54>)
 8009640:	6143      	str	r3, [r0, #20]
				lora_config->hweui = malloc(sizeof(char) * 17);
 8009642:	2011      	movs	r0, #17
 8009644:	f006 fa3a 	bl	800fabc <malloc>
				il_lora_modem_read_command(RN_SYS_GET_HWEUI, NULL, lora_config->hweui, 16, 10000);
 8009648:	4b0c      	ldr	r3, [pc, #48]	; (800967c <il_lora_modem_default_config+0x58>)
				lora_config->hweui = malloc(sizeof(char) * 17);
 800964a:	0002      	movs	r2, r0
 800964c:	6120      	str	r0, [r4, #16]
				il_lora_modem_read_command(RN_SYS_GET_HWEUI, NULL, lora_config->hweui, 16, 10000);
 800964e:	9300      	str	r3, [sp, #0]
 8009650:	2100      	movs	r1, #0
 8009652:	2310      	movs	r3, #16
 8009654:	480a      	ldr	r0, [pc, #40]	; (8009680 <il_lora_modem_default_config+0x5c>)
 8009656:	f7ff ff8f 	bl	8009578 <il_lora_modem_read_command>
				break;
 800965a:	e7e9      	b.n	8009630 <il_lora_modem_default_config+0xc>
				lora_config->appEui 				= "0000000000000000";
 800965c:	4b04      	ldr	r3, [pc, #16]	; (8009670 <il_lora_modem_default_config+0x4c>)
 800965e:	6083      	str	r3, [r0, #8]
				lora_config->frequency 				= IL_LORA_915;
 8009660:	4b08      	ldr	r3, [pc, #32]	; (8009684 <il_lora_modem_default_config+0x60>)
 8009662:	6043      	str	r3, [r0, #4]
				lora_config->transmissionPower 		= 1;
 8009664:	4b04      	ldr	r3, [pc, #16]	; (8009678 <il_lora_modem_default_config+0x54>)
 8009666:	6143      	str	r3, [r0, #20]
				lora_config->joinMode 				= IL_LORA_OTA;							// Choose the OTAA join mode. Requires appEui & appKey to be set.
 8009668:	2380      	movs	r3, #128	; 0x80
 800966a:	005b      	lsls	r3, r3, #1
 800966c:	8303      	strh	r3, [r0, #24]
 800966e:	e7e8      	b.n	8009642 <il_lora_modem_default_config+0x1e>
 8009670:	080104f7 	.word	0x080104f7
 8009674:	33bca100 	.word	0x33bca100
 8009678:	00010401 	.word	0x00010401
 800967c:	00002710 	.word	0x00002710
 8009680:	080105e5 	.word	0x080105e5
 8009684:	3689cac0 	.word	0x3689cac0

08009688 <il_lora_modem_init>:
 * @brief Initalise the lora modem
 * 
 * @param config il_lora_config struct with the lora modem configuration options
 * @return il_lora_status 
 */
il_lora_status il_lora_modem_init(il_lora_config *config) {
 8009688:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
 800968a:	0004      	movs	r4, r0

	// Reset the mac layer
	il_lora_modem_send_command(RN_MAC_RESET_CMD, NULL, 200);
 800968c:	22c8      	movs	r2, #200	; 0xc8
 800968e:	2100      	movs	r1, #0
 8009690:	4828      	ldr	r0, [pc, #160]	; (8009734 <il_lora_modem_init+0xac>)
 8009692:	f7ff ff2f 	bl	80094f4 <il_lora_modem_send_command>

	// Set the device address
	il_lora_modem_send_command(RN_MAC_SET_DEV_EUI, config->hweui, 200);
 8009696:	22c8      	movs	r2, #200	; 0xc8
 8009698:	6921      	ldr	r1, [r4, #16]
 800969a:	4827      	ldr	r0, [pc, #156]	; (8009738 <il_lora_modem_init+0xb0>)
 800969c:	f7ff ff2a 	bl	80094f4 <il_lora_modem_send_command>

	// Set the network key
	il_lora_modem_send_command(RN_MAC_SET_APP_KEY, config->appKey, 200);
 80096a0:	22c8      	movs	r2, #200	; 0xc8
 80096a2:	68e1      	ldr	r1, [r4, #12]
 80096a4:	4825      	ldr	r0, [pc, #148]	; (800973c <il_lora_modem_init+0xb4>)
 80096a6:	f7ff ff25 	bl	80094f4 <il_lora_modem_send_command>

	// Set the EUI
	il_lora_modem_send_command(RN_MAC_SET_APP_EUI, config->appEui, 200);
 80096aa:	22c8      	movs	r2, #200	; 0xc8
 80096ac:	68a1      	ldr	r1, [r4, #8]
 80096ae:	4824      	ldr	r0, [pc, #144]	; (8009740 <il_lora_modem_init+0xb8>)
 80096b0:	f7ff ff20 	bl	80094f4 <il_lora_modem_send_command>

	// Set the transmission power
	char power = 0;
 80096b4:	2500      	movs	r5, #0
 80096b6:	466b      	mov	r3, sp
 80096b8:	1d9e      	adds	r6, r3, #6
 80096ba:	719d      	strb	r5, [r3, #6]
	itoa(config->transmissionPower, &power, 10);
 80096bc:	0031      	movs	r1, r6
 80096be:	220a      	movs	r2, #10
 80096c0:	7d20      	ldrb	r0, [r4, #20]
 80096c2:	f006 f9f7 	bl	800fab4 <itoa>
	il_lora_modem_send_command(RN_MAC_SET_PWRIDX, &power, 200);
 80096c6:	0031      	movs	r1, r6
 80096c8:	22c8      	movs	r2, #200	; 0xc8
 80096ca:	481e      	ldr	r0, [pc, #120]	; (8009744 <il_lora_modem_init+0xbc>)
 80096cc:	f7ff ff12 	bl	80094f4 <il_lora_modem_send_command>

	char rate = 0;
 80096d0:	466b      	mov	r3, sp
 80096d2:	1dde      	adds	r6, r3, #7
 80096d4:	71dd      	strb	r5, [r3, #7]
	itoa(config->dataRate, &rate, 10);
 80096d6:	220a      	movs	r2, #10
 80096d8:	0031      	movs	r1, r6
 80096da:	7d60      	ldrb	r0, [r4, #21]
 80096dc:	f006 f9ea 	bl	800fab4 <itoa>
	il_lora_modem_send_command(RN_MAC_SET_DATARATE, &rate, 200);
 80096e0:	0031      	movs	r1, r6
 80096e2:	22c8      	movs	r2, #200	; 0xc8
 80096e4:	4818      	ldr	r0, [pc, #96]	; (8009748 <il_lora_modem_init+0xc0>)
 80096e6:	f7ff ff05 	bl	80094f4 <il_lora_modem_send_command>

	// Disable adaptive data rate
	char adr[4] = {'\0'};
	if(config->adaptiveRate == IL_LORA_ON) {
 80096ea:	7da3      	ldrb	r3, [r4, #22]
		sprintf(adr, "on");
 80096ec:	4917      	ldr	r1, [pc, #92]	; (800974c <il_lora_modem_init+0xc4>)
	char adr[4] = {'\0'};
 80096ee:	9502      	str	r5, [sp, #8]
	if(config->adaptiveRate == IL_LORA_ON) {
 80096f0:	2b01      	cmp	r3, #1
 80096f2:	d002      	beq.n	80096fa <il_lora_modem_init+0x72>
	}
	else if(config->adaptiveRate == IL_LORA_OFF) {
 80096f4:	2b00      	cmp	r3, #0
 80096f6:	d103      	bne.n	8009700 <il_lora_modem_init+0x78>
		sprintf(adr, "off");
 80096f8:	4915      	ldr	r1, [pc, #84]	; (8009750 <il_lora_modem_init+0xc8>)
 80096fa:	a802      	add	r0, sp, #8
 80096fc:	f006 faf0 	bl	800fce0 <strcpy>
	}
	il_lora_modem_send_command(RN_MAC_SET_ADR_ON_CMD, adr, 200);
 8009700:	a902      	add	r1, sp, #8
 8009702:	22c8      	movs	r2, #200	; 0xc8
 8009704:	4813      	ldr	r0, [pc, #76]	; (8009754 <il_lora_modem_init+0xcc>)
 8009706:	f7ff fef5 	bl	80094f4 <il_lora_modem_send_command>

	// Disable automatic replies
	char ar[4] = {'\0'};
 800970a:	2300      	movs	r3, #0
 800970c:	9303      	str	r3, [sp, #12]
	if(config->autoReplies == IL_LORA_ON) {
 800970e:	7de3      	ldrb	r3, [r4, #23]
		sprintf(ar, "on");
 8009710:	490e      	ldr	r1, [pc, #56]	; (800974c <il_lora_modem_init+0xc4>)
	if(config->autoReplies == IL_LORA_ON) {
 8009712:	2b01      	cmp	r3, #1
 8009714:	d002      	beq.n	800971c <il_lora_modem_init+0x94>
	}
	else if(config->autoReplies == IL_LORA_OFF) {
 8009716:	2b00      	cmp	r3, #0
 8009718:	d103      	bne.n	8009722 <il_lora_modem_init+0x9a>
		sprintf(ar, "off");
 800971a:	490d      	ldr	r1, [pc, #52]	; (8009750 <il_lora_modem_init+0xc8>)
 800971c:	a803      	add	r0, sp, #12
 800971e:	f006 fadf 	bl	800fce0 <strcpy>
	}
	il_lora_modem_send_command(RN_MAC_SET_AR_ON_CMD, ar, 200);
 8009722:	22c8      	movs	r2, #200	; 0xc8
 8009724:	a903      	add	r1, sp, #12
 8009726:	480c      	ldr	r0, [pc, #48]	; (8009758 <il_lora_modem_init+0xd0>)
 8009728:	f7ff fee4 	bl	80094f4 <il_lora_modem_send_command>

	return IL_LORA_OK;
}
 800972c:	2000      	movs	r0, #0
 800972e:	b004      	add	sp, #16
 8009730:	bd70      	pop	{r4, r5, r6, pc}
 8009732:	46c0      	nop			; (mov r8, r8)
 8009734:	080105f3 	.word	0x080105f3
 8009738:	08010601 	.word	0x08010601
 800973c:	08010610 	.word	0x08010610
 8009740:	0801061f 	.word	0x0801061f
 8009744:	0801062e 	.word	0x0801062e
 8009748:	0801063d 	.word	0x0801063d
 800974c:	08010648 	.word	0x08010648
 8009750:	0801064b 	.word	0x0801064b
 8009754:	0801064f 	.word	0x0801064f
 8009758:	0801065b 	.word	0x0801065b

0800975c <il_lora_modem_parse_response>:
 * @brief Function to parce response from the modem
 * 
 * @param response String to be parsed
 * @return il_lora_status 
 */
il_lora_status il_lora_modem_parse_response(char* response) {
 800975c:	b510      	push	{r4, lr}

	if (strstr(response, "mac_tx_ok\r\n") != NULL) {
 800975e:	4927      	ldr	r1, [pc, #156]	; (80097fc <il_lora_modem_parse_response+0xa0>)
il_lora_status il_lora_modem_parse_response(char* response) {
 8009760:	0004      	movs	r4, r0
	if (strstr(response, "mac_tx_ok\r\n") != NULL) {
 8009762:	f006 fac5 	bl	800fcf0 <strstr>
		return IL_LORA_MAC_TX_OK;
 8009766:	230d      	movs	r3, #13
	if (strstr(response, "mac_tx_ok\r\n") != NULL) {
 8009768:	2800      	cmp	r0, #0
 800976a:	d145      	bne.n	80097f8 <il_lora_modem_parse_response+0x9c>
	}

	else if (strstr(response, "accepted\r\n") != NULL) {
 800976c:	0020      	movs	r0, r4
 800976e:	4924      	ldr	r1, [pc, #144]	; (8009800 <il_lora_modem_parse_response+0xa4>)
 8009770:	f006 fabe 	bl	800fcf0 <strstr>
		return IL_LORA_ACCEPTED;
 8009774:	230a      	movs	r3, #10
	else if (strstr(response, "accepted\r\n") != NULL) {
 8009776:	2800      	cmp	r0, #0
 8009778:	d13e      	bne.n	80097f8 <il_lora_modem_parse_response+0x9c>
	}

	else if (strstr(response, "denied\r\n") != NULL) {
 800977a:	0020      	movs	r0, r4
 800977c:	4921      	ldr	r1, [pc, #132]	; (8009804 <il_lora_modem_parse_response+0xa8>)
 800977e:	f006 fab7 	bl	800fcf0 <strstr>
		return IL_LORA_DENIED;
 8009782:	230b      	movs	r3, #11
	else if (strstr(response, "denied\r\n") != NULL) {
 8009784:	2800      	cmp	r0, #0
 8009786:	d137      	bne.n	80097f8 <il_lora_modem_parse_response+0x9c>
	}

	else if (strstr(response, "invalid_param\r\n") != NULL) {
 8009788:	0020      	movs	r0, r4
 800978a:	491f      	ldr	r1, [pc, #124]	; (8009808 <il_lora_modem_parse_response+0xac>)
 800978c:	f006 fab0 	bl	800fcf0 <strstr>
		return IL_LORA_INVALID_PARAM;
 8009790:	2302      	movs	r3, #2
	else if (strstr(response, "invalid_param\r\n") != NULL) {
 8009792:	2800      	cmp	r0, #0
 8009794:	d130      	bne.n	80097f8 <il_lora_modem_parse_response+0x9c>
	}

	else if (strstr(response, "keys_not_init\r\n") != NULL) {
 8009796:	0020      	movs	r0, r4
 8009798:	491c      	ldr	r1, [pc, #112]	; (800980c <il_lora_modem_parse_response+0xb0>)
 800979a:	f006 faa9 	bl	800fcf0 <strstr>
		return IL_LORA_KEY_NOT_INIT;
 800979e:	230c      	movs	r3, #12
	else if (strstr(response, "keys_not_init\r\n") != NULL) {
 80097a0:	2800      	cmp	r0, #0
 80097a2:	d129      	bne.n	80097f8 <il_lora_modem_parse_response+0x9c>
	}

	else if (strstr(response, "no_free_ch\r\n") != NULL) {
 80097a4:	0020      	movs	r0, r4
 80097a6:	491a      	ldr	r1, [pc, #104]	; (8009810 <il_lora_modem_parse_response+0xb4>)
 80097a8:	f006 faa2 	bl	800fcf0 <strstr>
		return IL_LORA_NO_CHANNELS_FREE;
 80097ac:	2304      	movs	r3, #4
	else if (strstr(response, "no_free_ch\r\n") != NULL) {
 80097ae:	2800      	cmp	r0, #0
 80097b0:	d122      	bne.n	80097f8 <il_lora_modem_parse_response+0x9c>
	}

	else if (strstr(response, "silent\r\n") != NULL) {
 80097b2:	0020      	movs	r0, r4
 80097b4:	4917      	ldr	r1, [pc, #92]	; (8009814 <il_lora_modem_parse_response+0xb8>)
 80097b6:	f006 fa9b 	bl	800fcf0 <strstr>
		return IL_LORA_SILENT;
 80097ba:	2305      	movs	r3, #5
	else if (strstr(response, "silent\r\n") != NULL) {
 80097bc:	2800      	cmp	r0, #0
 80097be:	d11b      	bne.n	80097f8 <il_lora_modem_parse_response+0x9c>
	}

	else if (strstr(response, "busy\r\n") != NULL) {
 80097c0:	0020      	movs	r0, r4
 80097c2:	4915      	ldr	r1, [pc, #84]	; (8009818 <il_lora_modem_parse_response+0xbc>)
 80097c4:	f006 fa94 	bl	800fcf0 <strstr>
		return IL_LORA_BUSY;
 80097c8:	2307      	movs	r3, #7
	else if (strstr(response, "busy\r\n") != NULL) {
 80097ca:	2800      	cmp	r0, #0
 80097cc:	d114      	bne.n	80097f8 <il_lora_modem_parse_response+0x9c>
	}

	else if (strstr(response, "mac_paused\r\n") != NULL) {
 80097ce:	0020      	movs	r0, r4
 80097d0:	4912      	ldr	r1, [pc, #72]	; (800981c <il_lora_modem_parse_response+0xc0>)
 80097d2:	f006 fa8d 	bl	800fcf0 <strstr>
		return IL_LORA_MAC_PAUSED;
 80097d6:	2308      	movs	r3, #8
	else if (strstr(response, "mac_paused\r\n") != NULL) {
 80097d8:	2800      	cmp	r0, #0
 80097da:	d10d      	bne.n	80097f8 <il_lora_modem_parse_response+0x9c>
	}

	else if (strstr(response, "frame_counter_err_rejoin_needed\r\n") != NULL) {
 80097dc:	0020      	movs	r0, r4
 80097de:	4910      	ldr	r1, [pc, #64]	; (8009820 <il_lora_modem_parse_response+0xc4>)
 80097e0:	f006 fa86 	bl	800fcf0 <strstr>
		return IL_LORA_FRAME_COUNTER_ERR;
 80097e4:	2306      	movs	r3, #6
	else if (strstr(response, "frame_counter_err_rejoin_needed\r\n") != NULL) {
 80097e6:	2800      	cmp	r0, #0
 80097e8:	d106      	bne.n	80097f8 <il_lora_modem_parse_response+0x9c>
	}

	else if (strstr(response, "ok\r\n") != NULL) {
 80097ea:	0020      	movs	r0, r4
 80097ec:	490d      	ldr	r1, [pc, #52]	; (8009824 <il_lora_modem_parse_response+0xc8>)
 80097ee:	f006 fa7f 	bl	800fcf0 <strstr>
 80097f2:	4243      	negs	r3, r0
 80097f4:	4143      	adcs	r3, r0
		return IL_LORA_MAC_TX_OK;
 80097f6:	b2db      	uxtb	r3, r3
	}

	else {
		return IL_LORA_ERROR;
	}
}
 80097f8:	0018      	movs	r0, r3
 80097fa:	bd10      	pop	{r4, pc}
 80097fc:	08010666 	.word	0x08010666
 8009800:	08010672 	.word	0x08010672
 8009804:	0801067d 	.word	0x0801067d
 8009808:	08010686 	.word	0x08010686
 800980c:	08010696 	.word	0x08010696
 8009810:	080106a6 	.word	0x080106a6
 8009814:	080106b3 	.word	0x080106b3
 8009818:	080106bc 	.word	0x080106bc
 800981c:	080106c3 	.word	0x080106c3
 8009820:	080106d0 	.word	0x080106d0
 8009824:	0801066d 	.word	0x0801066d

08009828 <il_lora_modem_join_network>:
 * @param config il_lora_config struct with the lora modem configuration options
 * @return il_lora_status 
 */
il_lora_status il_lora_modem_join_network(il_lora_config *config) {

	char buffer[50] = {'\0'};
 8009828:	2100      	movs	r1, #0
il_lora_status il_lora_modem_join_network(il_lora_config *config) {
 800982a:	b570      	push	{r4, r5, r6, lr}
 800982c:	b090      	sub	sp, #64	; 0x40
	char buffer[50] = {'\0'};
 800982e:	222e      	movs	r2, #46	; 0x2e
 8009830:	a804      	add	r0, sp, #16
 8009832:	9103      	str	r1, [sp, #12]

	while(1) {
		
		//Send join request in over the air activation mode

		il_lora_modem_read_command(RN_JOIN_OTAA_MODE, NULL, buffer, 50, 5000);
 8009834:	2432      	movs	r4, #50	; 0x32
	char buffer[50] = {'\0'};
 8009836:	f006 f962 	bl	800fafe <memset>
		il_lora_modem_read_command(RN_JOIN_OTAA_MODE, NULL, buffer, 50, 5000);
 800983a:	4b1e      	ldr	r3, [pc, #120]	; (80098b4 <il_lora_modem_join_network+0x8c>)
 800983c:	2100      	movs	r1, #0
 800983e:	9300      	str	r3, [sp, #0]
 8009840:	aa03      	add	r2, sp, #12
 8009842:	0023      	movs	r3, r4
 8009844:	481c      	ldr	r0, [pc, #112]	; (80098b8 <il_lora_modem_join_network+0x90>)
 8009846:	f7ff fe97 	bl	8009578 <il_lora_modem_read_command>

		if (strstr(buffer, "ok\r\n") != NULL) {
 800984a:	491c      	ldr	r1, [pc, #112]	; (80098bc <il_lora_modem_join_network+0x94>)
 800984c:	a803      	add	r0, sp, #12
 800984e:	f006 fa4f 	bl	800fcf0 <strstr>
 8009852:	4e1b      	ldr	r6, [pc, #108]	; (80098c0 <il_lora_modem_join_network+0x98>)
 8009854:	4d1b      	ldr	r5, [pc, #108]	; (80098c4 <il_lora_modem_join_network+0x9c>)
 8009856:	2800      	cmp	r0, #0
 8009858:	d006      	beq.n	8009868 <il_lora_modem_join_network+0x40>

			il_usb_transmit((uint8_t*)buffer, 50);
 800985a:	6833      	ldr	r3, [r6, #0]
 800985c:	0021      	movs	r1, r4
 800985e:	a803      	add	r0, sp, #12
 8009860:	4798      	blx	r3
			il_delay(5);
 8009862:	2005      	movs	r0, #5
 8009864:	682b      	ldr	r3, [r5, #0]
 8009866:	4798      	blx	r3
		}

		// Wait for network acceptance

		il_clear_buffer(buffer, 50);
 8009868:	0021      	movs	r1, r4
 800986a:	a803      	add	r0, sp, #12
 800986c:	f7ff fb29 	bl	8008ec2 <il_clear_buffer>

		il_uart_read_line(&modem,(uint8_t*)buffer, 10000);
 8009870:	4a15      	ldr	r2, [pc, #84]	; (80098c8 <il_lora_modem_join_network+0xa0>)
 8009872:	a903      	add	r1, sp, #12
 8009874:	4815      	ldr	r0, [pc, #84]	; (80098cc <il_lora_modem_join_network+0xa4>)
 8009876:	f7ff fc2b 	bl	80090d0 <il_uart_read_line>

		if (strstr(buffer, "accepted\r\n") != NULL) {
 800987a:	4915      	ldr	r1, [pc, #84]	; (80098d0 <il_lora_modem_join_network+0xa8>)
 800987c:	a803      	add	r0, sp, #12
 800987e:	f006 fa37 	bl	800fcf0 <strstr>
			il_usb_transmit((uint8_t*)buffer, 50);
 8009882:	6833      	ldr	r3, [r6, #0]
		if (strstr(buffer, "accepted\r\n") != NULL) {
 8009884:	2800      	cmp	r0, #0
 8009886:	d00a      	beq.n	800989e <il_lora_modem_join_network+0x76>
			il_usb_transmit((uint8_t*)buffer, 50);
 8009888:	2132      	movs	r1, #50	; 0x32
 800988a:	a803      	add	r0, sp, #12
 800988c:	4798      	blx	r3
			il_delay(5);
 800988e:	682b      	ldr	r3, [r5, #0]
 8009890:	2005      	movs	r0, #5
 8009892:	4798      	blx	r3

		il_clear_buffer(buffer, 50);

	}

	return il_lora_modem_parse_response(buffer);
 8009894:	a803      	add	r0, sp, #12
 8009896:	f7ff ff61 	bl	800975c <il_lora_modem_parse_response>
}
 800989a:	b010      	add	sp, #64	; 0x40
 800989c:	bd70      	pop	{r4, r5, r6, pc}
			il_usb_transmit((uint8_t*)buffer, 50);
 800989e:	0021      	movs	r1, r4
 80098a0:	a803      	add	r0, sp, #12
 80098a2:	4798      	blx	r3
			il_delay(5);
 80098a4:	682b      	ldr	r3, [r5, #0]
 80098a6:	2005      	movs	r0, #5
 80098a8:	4798      	blx	r3
		il_clear_buffer(buffer, 50);
 80098aa:	0021      	movs	r1, r4
 80098ac:	a803      	add	r0, sp, #12
 80098ae:	f7ff fb08 	bl	8008ec2 <il_clear_buffer>
		il_lora_modem_read_command(RN_JOIN_OTAA_MODE, NULL, buffer, 50, 5000);
 80098b2:	e7c2      	b.n	800983a <il_lora_modem_join_network+0x12>
 80098b4:	00001388 	.word	0x00001388
 80098b8:	080106f2 	.word	0x080106f2
 80098bc:	0801066d 	.word	0x0801066d
 80098c0:	20000458 	.word	0x20000458
 80098c4:	20000400 	.word	0x20000400
 80098c8:	00002710 	.word	0x00002710
 80098cc:	20001ee0 	.word	0x20001ee0
 80098d0:	08010672 	.word	0x08010672

080098d4 <il_lora_modem_send_packet_u32>:
 * @param value Data to be sent, Data Type: 32bit unsigned interger
 * @param port Port to sent the data over 
 * @param packet_type confirmed : RN_MAC_TX_CONFIRMED or unconfirmed : RN_MAC_TX_UNCONFIRMED
 * @return il_lora_status 
 */
il_lora_status il_lora_modem_send_packet_u32(uint32_t value, uint8_t port, char* packet_type) {
 80098d4:	b5f0      	push	{r4, r5, r6, r7, lr}

	char buffer[50] = {'\0'};
 80098d6:	2400      	movs	r4, #0
il_lora_status il_lora_modem_send_packet_u32(uint32_t value, uint8_t port, char* packet_type) {
 80098d8:	0005      	movs	r5, r0
 80098da:	b095      	sub	sp, #84	; 0x54
 80098dc:	9102      	str	r1, [sp, #8]
 80098de:	9203      	str	r2, [sp, #12]
	char buffer[50] = {'\0'};
 80098e0:	0021      	movs	r1, r4
 80098e2:	222e      	movs	r2, #46	; 0x2e
 80098e4:	a808      	add	r0, sp, #32
 80098e6:	9407      	str	r4, [sp, #28]
 80098e8:	f006 f909 	bl	800fafe <memset>
	char value_str[8] = {'\0'};
	uint8_t len = 0;

	itoa(value, value_str, 16);
 80098ec:	2210      	movs	r2, #16
 80098ee:	0028      	movs	r0, r5
 80098f0:	a905      	add	r1, sp, #20
	char value_str[8] = {'\0'};
 80098f2:	9405      	str	r4, [sp, #20]
 80098f4:	9406      	str	r4, [sp, #24]
	itoa(value, value_str, 16);
 80098f6:	f006 f8dd 	bl	800fab4 <itoa>

		il_usb_transmit((uint8_t*)buffer, len);
		il_uart_write_line(&modem, (char *)buffer, 200);


		il_clear_buffer(buffer, 50);
 80098fa:	3432      	adds	r4, #50	; 0x32
		len = sprintf(buffer, "mac tx %s %u %X\r\n", packet_type, port, (unsigned int)value);
 80098fc:	9a03      	ldr	r2, [sp, #12]
 80098fe:	9b02      	ldr	r3, [sp, #8]
 8009900:	491a      	ldr	r1, [pc, #104]	; (800996c <il_lora_modem_send_packet_u32+0x98>)
 8009902:	9500      	str	r5, [sp, #0]
 8009904:	a807      	add	r0, sp, #28
 8009906:	f006 f9bd 	bl	800fc84 <siprintf>
		il_usb_transmit((uint8_t*)buffer, len);
 800990a:	4e19      	ldr	r6, [pc, #100]	; (8009970 <il_lora_modem_send_packet_u32+0x9c>)
 800990c:	b2c1      	uxtb	r1, r0
 800990e:	6833      	ldr	r3, [r6, #0]
 8009910:	a807      	add	r0, sp, #28
 8009912:	4798      	blx	r3
		il_uart_write_line(&modem, (char *)buffer, 200);
 8009914:	4f17      	ldr	r7, [pc, #92]	; (8009974 <il_lora_modem_send_packet_u32+0xa0>)
 8009916:	22c8      	movs	r2, #200	; 0xc8
 8009918:	a907      	add	r1, sp, #28
 800991a:	0038      	movs	r0, r7
 800991c:	f7ff fb8a 	bl	8009034 <il_uart_write_line>
		il_clear_buffer(buffer, 50);
 8009920:	0021      	movs	r1, r4
 8009922:	a807      	add	r0, sp, #28
 8009924:	f7ff facd 	bl	8008ec2 <il_clear_buffer>


		il_uart_read_line(&modem,(uint8_t*)buffer, 5000);
 8009928:	4a13      	ldr	r2, [pc, #76]	; (8009978 <il_lora_modem_send_packet_u32+0xa4>)
 800992a:	a907      	add	r1, sp, #28
 800992c:	0038      	movs	r0, r7
 800992e:	f7ff fbcf 	bl	80090d0 <il_uart_read_line>
		il_usb_transmit((uint8_t*)buffer, 50);
 8009932:	6833      	ldr	r3, [r6, #0]
 8009934:	0021      	movs	r1, r4
 8009936:	a807      	add	r0, sp, #28
 8009938:	4798      	blx	r3


		il_uart_read_line(&modem,(uint8_t*)buffer, 5000);
 800993a:	4a0f      	ldr	r2, [pc, #60]	; (8009978 <il_lora_modem_send_packet_u32+0xa4>)
 800993c:	a907      	add	r1, sp, #28
 800993e:	0038      	movs	r0, r7
 8009940:	f7ff fbc6 	bl	80090d0 <il_uart_read_line>
		il_usb_transmit((uint8_t*)buffer, 50);
 8009944:	0021      	movs	r1, r4
 8009946:	6833      	ldr	r3, [r6, #0]
 8009948:	a807      	add	r0, sp, #28
 800994a:	4798      	blx	r3



		if(strstr(buffer, "mac_tx_ok") != NULL) {
 800994c:	490b      	ldr	r1, [pc, #44]	; (800997c <il_lora_modem_send_packet_u32+0xa8>)
 800994e:	a807      	add	r0, sp, #28
 8009950:	f006 f9ce 	bl	800fcf0 <strstr>
 8009954:	2800      	cmp	r0, #0
 8009956:	d104      	bne.n	8009962 <il_lora_modem_send_packet_u32+0x8e>
			break;
		}

		il_clear_buffer(buffer, 50);
 8009958:	0021      	movs	r1, r4
 800995a:	a807      	add	r0, sp, #28
 800995c:	f7ff fab1 	bl	8008ec2 <il_clear_buffer>
		len = sprintf(buffer, "mac tx %s %u %X\r\n", packet_type, port, (unsigned int)value);
 8009960:	e7cc      	b.n	80098fc <il_lora_modem_send_packet_u32+0x28>

	}

	return il_lora_modem_parse_response(buffer);
 8009962:	a807      	add	r0, sp, #28
 8009964:	f7ff fefa 	bl	800975c <il_lora_modem_parse_response>
}
 8009968:	b015      	add	sp, #84	; 0x54
 800996a:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800996c:	08010700 	.word	0x08010700
 8009970:	20000458 	.word	0x20000458
 8009974:	20001ee0 	.word	0x20001ee0
 8009978:	00001388 	.word	0x00001388
 800997c:	08010712 	.word	0x08010712

08009980 <HAL_Init>:
  */
HAL_StatusTypeDef HAL_Init(void)
{
  /* Configure Flash prefetch */ 
#if (PREFETCH_ENABLE != 0)
  __HAL_FLASH_PREFETCH_BUFFER_ENABLE();
 8009980:	2310      	movs	r3, #16
 8009982:	4a06      	ldr	r2, [pc, #24]	; (800999c <HAL_Init+0x1c>)
{
 8009984:	b510      	push	{r4, lr}
  __HAL_FLASH_PREFETCH_BUFFER_ENABLE();
 8009986:	6811      	ldr	r1, [r2, #0]
#endif /* PREFETCH_ENABLE */

  /* Use systick as time base source and configure 1ms tick (default clock after Reset is HSI) */

  HAL_InitTick(TICK_INT_PRIORITY);
 8009988:	2000      	movs	r0, #0
  __HAL_FLASH_PREFETCH_BUFFER_ENABLE();
 800998a:	430b      	orrs	r3, r1
 800998c:	6013      	str	r3, [r2, #0]
  HAL_InitTick(TICK_INT_PRIORITY);
 800998e:	f7fe fffd 	bl	800898c <HAL_InitTick>

  /* Init the low level hardware */
  HAL_MspInit();
 8009992:	f7fe ffcf 	bl	8008934 <HAL_MspInit>

  /* Return function status */
  return HAL_OK;
}
 8009996:	2000      	movs	r0, #0
 8009998:	bd10      	pop	{r4, pc}
 800999a:	46c0      	nop			; (mov r8, r8)
 800999c:	40022000 	.word	0x40022000

080099a0 <HAL_IncTick>:
  *       implementations in user file.
  * @retval None
  */
__weak void HAL_IncTick(void)
{
  uwTick += uwTickFreq;
 80099a0:	4a03      	ldr	r2, [pc, #12]	; (80099b0 <HAL_IncTick+0x10>)
 80099a2:	4b04      	ldr	r3, [pc, #16]	; (80099b4 <HAL_IncTick+0x14>)
 80099a4:	6811      	ldr	r1, [r2, #0]
 80099a6:	781b      	ldrb	r3, [r3, #0]
 80099a8:	185b      	adds	r3, r3, r1
 80099aa:	6013      	str	r3, [r2, #0]
}
 80099ac:	4770      	bx	lr
 80099ae:	46c0      	nop			; (mov r8, r8)
 80099b0:	20002234 	.word	0x20002234
 80099b4:	20000460 	.word	0x20000460

080099b8 <HAL_GetTick>:
  *       implementations in user file.
  * @retval tick value
  */
__weak uint32_t HAL_GetTick(void)
{
  return uwTick;
 80099b8:	4b01      	ldr	r3, [pc, #4]	; (80099c0 <HAL_GetTick+0x8>)
 80099ba:	6818      	ldr	r0, [r3, #0]
}
 80099bc:	4770      	bx	lr
 80099be:	46c0      	nop			; (mov r8, r8)
 80099c0:	20002234 	.word	0x20002234

080099c4 <HAL_ADC_Init>:
  *         of structure "ADC_InitTypeDef".
  * @param  hadc ADC handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_ADC_Init(ADC_HandleTypeDef* hadc)
{
 80099c4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80099c6:	0004      	movs	r4, r0
  uint32_t tmpCFGR1 = 0U;

  /* Check ADC handle */
  if(hadc == NULL)
  {
    return HAL_ERROR;
 80099c8:	2001      	movs	r0, #1
  if(hadc == NULL)
 80099ca:	2c00      	cmp	r4, #0
 80099cc:	d100      	bne.n	80099d0 <HAL_ADC_Init+0xc>
 80099ce:	e108      	b.n	8009be2 <HAL_ADC_Init+0x21e>
  }
  
  /* Check the parameters */
  assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));
 80099d0:	4b91      	ldr	r3, [pc, #580]	; (8009c18 <HAL_ADC_Init+0x254>)
 80099d2:	6822      	ldr	r2, [r4, #0]
 80099d4:	429a      	cmp	r2, r3
 80099d6:	d004      	beq.n	80099e2 <HAL_ADC_Init+0x1e>
 80099d8:	21d1      	movs	r1, #209	; 0xd1
 80099da:	4890      	ldr	r0, [pc, #576]	; (8009c1c <HAL_ADC_Init+0x258>)
 80099dc:	0049      	lsls	r1, r1, #1
 80099de:	f7fe ffa7 	bl	8008930 <assert_failed>
  assert_param(IS_ADC_CLOCKPRESCALER(hadc->Init.ClockPrescaler));
 80099e2:	6863      	ldr	r3, [r4, #4]
 80099e4:	4a8e      	ldr	r2, [pc, #568]	; (8009c20 <HAL_ADC_Init+0x25c>)
 80099e6:	4213      	tst	r3, r2
 80099e8:	d008      	beq.n	80099fc <HAL_ADC_Init+0x38>
 80099ea:	2280      	movs	r2, #128	; 0x80
 80099ec:	0612      	lsls	r2, r2, #24
 80099ee:	4293      	cmp	r3, r2
 80099f0:	d004      	beq.n	80099fc <HAL_ADC_Init+0x38>
 80099f2:	21a4      	movs	r1, #164	; 0xa4
 80099f4:	4889      	ldr	r0, [pc, #548]	; (8009c1c <HAL_ADC_Init+0x258>)
 80099f6:	31ff      	adds	r1, #255	; 0xff
 80099f8:	f7fe ff9a 	bl	8008930 <assert_failed>
  assert_param(IS_ADC_RESOLUTION(hadc->Init.Resolution));
 80099fc:	2318      	movs	r3, #24
 80099fe:	68a2      	ldr	r2, [r4, #8]
 8009a00:	439a      	bics	r2, r3
 8009a02:	d004      	beq.n	8009a0e <HAL_ADC_Init+0x4a>
 8009a04:	21d2      	movs	r1, #210	; 0xd2
 8009a06:	4885      	ldr	r0, [pc, #532]	; (8009c1c <HAL_ADC_Init+0x258>)
 8009a08:	0049      	lsls	r1, r1, #1
 8009a0a:	f7fe ff91 	bl	8008930 <assert_failed>
  assert_param(IS_ADC_DATA_ALIGN(hadc->Init.DataAlign)); 
 8009a0e:	2320      	movs	r3, #32
 8009a10:	68e2      	ldr	r2, [r4, #12]
 8009a12:	439a      	bics	r2, r3
 8009a14:	d004      	beq.n	8009a20 <HAL_ADC_Init+0x5c>
 8009a16:	21a6      	movs	r1, #166	; 0xa6
 8009a18:	4880      	ldr	r0, [pc, #512]	; (8009c1c <HAL_ADC_Init+0x258>)
 8009a1a:	31ff      	adds	r1, #255	; 0xff
 8009a1c:	f7fe ff88 	bl	8008930 <assert_failed>
  assert_param(IS_ADC_SCAN_MODE(hadc->Init.ScanConvMode));
 8009a20:	6923      	ldr	r3, [r4, #16]
 8009a22:	3b01      	subs	r3, #1
 8009a24:	2b01      	cmp	r3, #1
 8009a26:	d904      	bls.n	8009a32 <HAL_ADC_Init+0x6e>
 8009a28:	21d3      	movs	r1, #211	; 0xd3
 8009a2a:	487c      	ldr	r0, [pc, #496]	; (8009c1c <HAL_ADC_Init+0x258>)
 8009a2c:	0049      	lsls	r1, r1, #1
 8009a2e:	f7fe ff7f 	bl	8008930 <assert_failed>
  assert_param(IS_FUNCTIONAL_STATE(hadc->Init.ContinuousConvMode));
 8009a32:	7ea3      	ldrb	r3, [r4, #26]
 8009a34:	2b01      	cmp	r3, #1
 8009a36:	d904      	bls.n	8009a42 <HAL_ADC_Init+0x7e>
 8009a38:	21a8      	movs	r1, #168	; 0xa8
 8009a3a:	4878      	ldr	r0, [pc, #480]	; (8009c1c <HAL_ADC_Init+0x258>)
 8009a3c:	31ff      	adds	r1, #255	; 0xff
 8009a3e:	f7fe ff77 	bl	8008930 <assert_failed>
  assert_param(IS_FUNCTIONAL_STATE(hadc->Init.DiscontinuousConvMode));
 8009a42:	7ee3      	ldrb	r3, [r4, #27]
 8009a44:	2b01      	cmp	r3, #1
 8009a46:	d904      	bls.n	8009a52 <HAL_ADC_Init+0x8e>
 8009a48:	21d4      	movs	r1, #212	; 0xd4
 8009a4a:	4874      	ldr	r0, [pc, #464]	; (8009c1c <HAL_ADC_Init+0x258>)
 8009a4c:	0049      	lsls	r1, r1, #1
 8009a4e:	f7fe ff6f 	bl	8008930 <assert_failed>
  assert_param(IS_ADC_EXTTRIG_EDGE(hadc->Init.ExternalTrigConvEdge));   
 8009a52:	4b74      	ldr	r3, [pc, #464]	; (8009c24 <HAL_ADC_Init+0x260>)
 8009a54:	6a22      	ldr	r2, [r4, #32]
 8009a56:	421a      	tst	r2, r3
 8009a58:	d004      	beq.n	8009a64 <HAL_ADC_Init+0xa0>
 8009a5a:	21aa      	movs	r1, #170	; 0xaa
 8009a5c:	486f      	ldr	r0, [pc, #444]	; (8009c1c <HAL_ADC_Init+0x258>)
 8009a5e:	31ff      	adds	r1, #255	; 0xff
 8009a60:	f7fe ff66 	bl	8008930 <assert_failed>
  assert_param(IS_ADC_EXTTRIG(hadc->Init.ExternalTrigConv));   
 8009a64:	69e3      	ldr	r3, [r4, #28]
 8009a66:	2140      	movs	r1, #64	; 0x40
 8009a68:	001a      	movs	r2, r3
 8009a6a:	438a      	bics	r2, r1
 8009a6c:	d00c      	beq.n	8009a88 <HAL_ADC_Init+0xc4>
 8009a6e:	001a      	movs	r2, r3
 8009a70:	3ac0      	subs	r2, #192	; 0xc0
 8009a72:	438a      	bics	r2, r1
 8009a74:	d008      	beq.n	8009a88 <HAL_ADC_Init+0xc4>
 8009a76:	22c2      	movs	r2, #194	; 0xc2
 8009a78:	32ff      	adds	r2, #255	; 0xff
 8009a7a:	4293      	cmp	r3, r2
 8009a7c:	d004      	beq.n	8009a88 <HAL_ADC_Init+0xc4>
 8009a7e:	316b      	adds	r1, #107	; 0x6b
 8009a80:	4866      	ldr	r0, [pc, #408]	; (8009c1c <HAL_ADC_Init+0x258>)
 8009a82:	31ff      	adds	r1, #255	; 0xff
 8009a84:	f7fe ff54 	bl	8008930 <assert_failed>
  assert_param(IS_FUNCTIONAL_STATE(hadc->Init.DMAContinuousRequests));
 8009a88:	1d65      	adds	r5, r4, #5
 8009a8a:	7feb      	ldrb	r3, [r5, #31]
 8009a8c:	2b01      	cmp	r3, #1
 8009a8e:	d904      	bls.n	8009a9a <HAL_ADC_Init+0xd6>
 8009a90:	21ac      	movs	r1, #172	; 0xac
 8009a92:	4862      	ldr	r0, [pc, #392]	; (8009c1c <HAL_ADC_Init+0x258>)
 8009a94:	31ff      	adds	r1, #255	; 0xff
 8009a96:	f7fe ff4b 	bl	8008930 <assert_failed>
  assert_param(IS_ADC_EOC_SELECTION(hadc->Init.EOCSelection));
 8009a9a:	2204      	movs	r2, #4
 8009a9c:	6963      	ldr	r3, [r4, #20]
 8009a9e:	3b04      	subs	r3, #4
 8009aa0:	4393      	bics	r3, r2
 8009aa2:	d004      	beq.n	8009aae <HAL_ADC_Init+0xea>
 8009aa4:	21d6      	movs	r1, #214	; 0xd6
 8009aa6:	485d      	ldr	r0, [pc, #372]	; (8009c1c <HAL_ADC_Init+0x258>)
 8009aa8:	0049      	lsls	r1, r1, #1
 8009aaa:	f7fe ff41 	bl	8008930 <assert_failed>
  assert_param(IS_ADC_OVERRUN(hadc->Init.Overrun));
 8009aae:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 8009ab0:	2b01      	cmp	r3, #1
 8009ab2:	d904      	bls.n	8009abe <HAL_ADC_Init+0xfa>
 8009ab4:	21ae      	movs	r1, #174	; 0xae
 8009ab6:	4859      	ldr	r0, [pc, #356]	; (8009c1c <HAL_ADC_Init+0x258>)
 8009ab8:	31ff      	adds	r1, #255	; 0xff
 8009aba:	f7fe ff39 	bl	8008930 <assert_failed>
  assert_param(IS_FUNCTIONAL_STATE(hadc->Init.LowPowerAutoWait));
 8009abe:	7e23      	ldrb	r3, [r4, #24]
 8009ac0:	2b01      	cmp	r3, #1
 8009ac2:	d904      	bls.n	8009ace <HAL_ADC_Init+0x10a>
 8009ac4:	21d7      	movs	r1, #215	; 0xd7
 8009ac6:	4855      	ldr	r0, [pc, #340]	; (8009c1c <HAL_ADC_Init+0x258>)
 8009ac8:	0049      	lsls	r1, r1, #1
 8009aca:	f7fe ff31 	bl	8008930 <assert_failed>
  assert_param(IS_FUNCTIONAL_STATE(hadc->Init.LowPowerAutoPowerOff));
 8009ace:	7e63      	ldrb	r3, [r4, #25]
 8009ad0:	2b01      	cmp	r3, #1
 8009ad2:	d904      	bls.n	8009ade <HAL_ADC_Init+0x11a>
 8009ad4:	21b0      	movs	r1, #176	; 0xb0
 8009ad6:	4851      	ldr	r0, [pc, #324]	; (8009c1c <HAL_ADC_Init+0x258>)
 8009ad8:	31ff      	adds	r1, #255	; 0xff
 8009ada:	f7fe ff29 	bl	8008930 <assert_failed>
  /* Refer to header of this file for more details on clock enabling procedure*/
  
  /* Actions performed only if ADC is coming from state reset:                */
  /* - Initialization of ADC MSP                                              */
  /* - ADC voltage regulator enable                                           */
  if (hadc->State == HAL_ADC_STATE_RESET)
 8009ade:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 8009ae0:	2b00      	cmp	r3, #0
 8009ae2:	d106      	bne.n	8009af2 <HAL_ADC_Init+0x12e>
  {
    /* Initialize ADC error code */
    ADC_CLEAR_ERRORCODE(hadc);
    
    /* Allocate lock resource and initialize it */
    hadc->Lock = HAL_UNLOCKED;
 8009ae4:	0022      	movs	r2, r4
 8009ae6:	3234      	adds	r2, #52	; 0x34
    ADC_CLEAR_ERRORCODE(hadc);
 8009ae8:	63e3      	str	r3, [r4, #60]	; 0x3c
    
    /* Init the low level hardware */
    hadc->MspInitCallback(hadc);
#else
    /* Init the low level hardware */
    HAL_ADC_MspInit(hadc);
 8009aea:	0020      	movs	r0, r4
    hadc->Lock = HAL_UNLOCKED;
 8009aec:	7013      	strb	r3, [r2, #0]
    HAL_ADC_MspInit(hadc);
 8009aee:	f7fe fc07 	bl	8008300 <HAL_ADC_MspInit>
  /* Configuration of ADC parameters if previous preliminary actions are      */ 
  /* correctly completed.                                                     */
  /* and if there is no conversion on going on regular group (ADC can be      */ 
  /* enabled anyway, in case of call of this function to update a parameter   */
  /* on the fly).                                                             */
  if (HAL_IS_BIT_CLR(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL) &&
 8009af2:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 8009af4:	06db      	lsls	r3, r3, #27
 8009af6:	d500      	bpl.n	8009afa <HAL_ADC_Init+0x136>
 8009af8:	e088      	b.n	8009c0c <HAL_ADC_Init+0x248>
      (tmp_hal_status == HAL_OK)                                &&
      (ADC_IS_CONVERSION_ONGOING_REGULAR(hadc) == RESET)          )
 8009afa:	6823      	ldr	r3, [r4, #0]
 8009afc:	2204      	movs	r2, #4
 8009afe:	6899      	ldr	r1, [r3, #8]
 8009b00:	0008      	movs	r0, r1
 8009b02:	4010      	ands	r0, r2
      (tmp_hal_status == HAL_OK)                                &&
 8009b04:	4211      	tst	r1, r2
 8009b06:	d000      	beq.n	8009b0a <HAL_ADC_Init+0x146>
 8009b08:	e080      	b.n	8009c0c <HAL_ADC_Init+0x248>
  {
    /* Set ADC state */
    ADC_STATE_CLR_SET(hadc->State,
 8009b0a:	6ba2      	ldr	r2, [r4, #56]	; 0x38
 8009b0c:	4946      	ldr	r1, [pc, #280]	; (8009c28 <HAL_ADC_Init+0x264>)
 8009b0e:	4011      	ands	r1, r2
 8009b10:	2202      	movs	r2, #2
 8009b12:	430a      	orrs	r2, r1
    /* Parameters update conditioned to ADC state:                            */
    /* Parameters that can be updated only when ADC is disabled:              */
    /*  - ADC clock mode                                                      */
    /*  - ADC clock prescaler                                                 */
    /*  - ADC resolution                                                      */
    if (ADC_IS_ENABLE(hadc) == RESET)
 8009b14:	2103      	movs	r1, #3
    ADC_STATE_CLR_SET(hadc->State,
 8009b16:	63a2      	str	r2, [r4, #56]	; 0x38
    if (ADC_IS_ENABLE(hadc) == RESET)
 8009b18:	689a      	ldr	r2, [r3, #8]
 8009b1a:	400a      	ands	r2, r1
 8009b1c:	2a01      	cmp	r2, #1
 8009b1e:	d105      	bne.n	8009b2c <HAL_ADC_Init+0x168>
 8009b20:	6819      	ldr	r1, [r3, #0]
 8009b22:	4211      	tst	r1, r2
 8009b24:	d10e      	bne.n	8009b44 <HAL_ADC_Init+0x180>
 8009b26:	68da      	ldr	r2, [r3, #12]
 8009b28:	0412      	lsls	r2, r2, #16
 8009b2a:	d40b      	bmi.n	8009b44 <HAL_ADC_Init+0x180>
      /* parameters):                                                         */
      /*   - internal measurement paths: Vbat, temperature sensor, Vref       */
      /*     (set into HAL_ADC_ConfigChannel() )                              */
     
      /* Configuration of ADC resolution                                      */
      MODIFY_REG(hadc->Instance->CFGR1,
 8009b2c:	2118      	movs	r1, #24
 8009b2e:	68da      	ldr	r2, [r3, #12]
 8009b30:	438a      	bics	r2, r1
 8009b32:	68a1      	ldr	r1, [r4, #8]
 8009b34:	430a      	orrs	r2, r1
 8009b36:	60da      	str	r2, [r3, #12]
                 ADC_CFGR1_RES        ,
                 hadc->Init.Resolution );
      
      /* Configuration of ADC clock mode: clock source AHB or HSI with        */
      /* selectable prescaler                                                 */
      MODIFY_REG(hadc->Instance->CFGR2    ,
 8009b38:	691a      	ldr	r2, [r3, #16]
 8009b3a:	6861      	ldr	r1, [r4, #4]
 8009b3c:	0092      	lsls	r2, r2, #2
 8009b3e:	0892      	lsrs	r2, r2, #2
 8009b40:	430a      	orrs	r2, r1
 8009b42:	611a      	str	r2, [r3, #16]
    /*  - external trigger polarity                                           */
    /*  - data alignment                                                      */
    /*  - resolution                                                          */
    /*  - scan direction                                                      */
    /*  - DMA continuous request                                              */
    hadc->Instance->CFGR1 &= ~( ADC_CFGR1_DISCEN  |
 8009b44:	68da      	ldr	r2, [r3, #12]
 8009b46:	4939      	ldr	r1, [pc, #228]	; (8009c2c <HAL_ADC_Init+0x268>)
 8009b48:	400a      	ands	r2, r1
 8009b4a:	60da      	str	r2, [r3, #12]
                                ADC_CFGR1_EXTEN   |
                                ADC_CFGR1_ALIGN   |
                                ADC_CFGR1_SCANDIR |
                                ADC_CFGR1_DMACFG   );

    tmpCFGR1 |= (ADC_CFGR1_AUTOWAIT((uint32_t)hadc->Init.LowPowerAutoWait)        |
 8009b4c:	7e27      	ldrb	r7, [r4, #24]
                 ADC_CFGR1_AUTOOFF((uint32_t)hadc->Init.LowPowerAutoPowerOff)     |
 8009b4e:	7e62      	ldrb	r2, [r4, #25]
                 ADC_CFGR1_CONTINUOUS((uint32_t)hadc->Init.ContinuousConvMode)    |
 8009b50:	7ea1      	ldrb	r1, [r4, #26]
                 ADC_CFGR1_AUTOOFF((uint32_t)hadc->Init.LowPowerAutoPowerOff)     |
 8009b52:	03d2      	lsls	r2, r2, #15
    tmpCFGR1 |= (ADC_CFGR1_AUTOWAIT((uint32_t)hadc->Init.LowPowerAutoWait)        |
 8009b54:	03bf      	lsls	r7, r7, #14
 8009b56:	4317      	orrs	r7, r2
                 ADC_CFGR1_CONTINUOUS((uint32_t)hadc->Init.ContinuousConvMode)    |
 8009b58:	034a      	lsls	r2, r1, #13
 8009b5a:	4694      	mov	ip, r2
                 ADC_CFGR1_OVERRUN(hadc->Init.Overrun)                            |
 8009b5c:	6aa2      	ldr	r2, [r4, #40]	; 0x28
 8009b5e:	3a01      	subs	r2, #1
 8009b60:	1e56      	subs	r6, r2, #1
 8009b62:	41b2      	sbcs	r2, r6
 8009b64:	0316      	lsls	r6, r2, #12
 8009b66:	68e2      	ldr	r2, [r4, #12]
 8009b68:	4317      	orrs	r7, r2
 8009b6a:	4662      	mov	r2, ip
 8009b6c:	4317      	orrs	r7, r2
                 hadc->Init.DataAlign                                             |
                 ADC_SCANDIR(hadc->Init.ScanConvMode)                             |
 8009b6e:	6922      	ldr	r2, [r4, #16]
 8009b70:	2a02      	cmp	r2, #2
 8009b72:	d100      	bne.n	8009b76 <HAL_ADC_Init+0x1b2>
 8009b74:	2004      	movs	r0, #4
                 ADC_CFGR1_DMACONTREQ((uint32_t)hadc->Init.DMAContinuousRequests)  );
 8009b76:	7fea      	ldrb	r2, [r5, #31]
 8009b78:	0052      	lsls	r2, r2, #1
                 ADC_SCANDIR(hadc->Init.ScanConvMode)                             |
 8009b7a:	433a      	orrs	r2, r7
 8009b7c:	4332      	orrs	r2, r6
 8009b7e:	4302      	orrs	r2, r0
    
    /* Enable discontinuous mode only if continuous mode is disabled */
    if (hadc->Init.DiscontinuousConvMode == ENABLE)
 8009b80:	7ee0      	ldrb	r0, [r4, #27]
 8009b82:	2801      	cmp	r0, #1
 8009b84:	d104      	bne.n	8009b90 <HAL_ADC_Init+0x1cc>
    {
      if (hadc->Init.ContinuousConvMode == DISABLE)
 8009b86:	2900      	cmp	r1, #0
 8009b88:	d12c      	bne.n	8009be4 <HAL_ADC_Init+0x220>
      {
        /* Enable the selected ADC group regular discontinuous mode */
        tmpCFGR1 |= ADC_CFGR1_DISCEN;
 8009b8a:	2180      	movs	r1, #128	; 0x80
 8009b8c:	0249      	lsls	r1, r1, #9
 8009b8e:	430a      	orrs	r2, r1
    /* Enable external trigger if trigger selection is different of software  */
    /* start.                                                                 */
    /* Note: This configuration keeps the hardware feature of parameter       */
    /*       ExternalTrigConvEdge "trigger edge none" equivalent to           */
    /*       software start.                                                  */
    if (hadc->Init.ExternalTrigConv != ADC_SOFTWARE_START)
 8009b90:	20c2      	movs	r0, #194	; 0xc2
 8009b92:	69e1      	ldr	r1, [r4, #28]
 8009b94:	30ff      	adds	r0, #255	; 0xff
 8009b96:	4281      	cmp	r1, r0
 8009b98:	d002      	beq.n	8009ba0 <HAL_ADC_Init+0x1dc>
    {
      tmpCFGR1 |= ( hadc->Init.ExternalTrigConv    |
 8009b9a:	6a20      	ldr	r0, [r4, #32]
 8009b9c:	4301      	orrs	r1, r0
 8009b9e:	430a      	orrs	r2, r1
    /* Management of parameters "SamplingTimeCommon" and "SamplingTime"       */
    /* (obsolete): sampling time set in this function if parameter            */
    /*  "SamplingTimeCommon" has been set to a valid sampling time.           */
    /* Otherwise, sampling time is set into ADC channel initialization        */
    /* structure with parameter "SamplingTime" (obsolete).                    */
    if (IS_ADC_SAMPLE_TIME(hadc->Init.SamplingTimeCommon))
 8009ba0:	2080      	movs	r0, #128	; 0x80
    hadc->Instance->CFGR1 |= tmpCFGR1;
 8009ba2:	68d9      	ldr	r1, [r3, #12]
    if (IS_ADC_SAMPLE_TIME(hadc->Init.SamplingTimeCommon))
 8009ba4:	0540      	lsls	r0, r0, #21
    hadc->Instance->CFGR1 |= tmpCFGR1;
 8009ba6:	4311      	orrs	r1, r2
 8009ba8:	60d9      	str	r1, [r3, #12]
    if (IS_ADC_SAMPLE_TIME(hadc->Init.SamplingTimeCommon))
 8009baa:	6ae1      	ldr	r1, [r4, #44]	; 0x2c
 8009bac:	4281      	cmp	r1, r0
 8009bae:	d002      	beq.n	8009bb6 <HAL_ADC_Init+0x1f2>
 8009bb0:	1e48      	subs	r0, r1, #1
 8009bb2:	2806      	cmp	r0, #6
 8009bb4:	d807      	bhi.n	8009bc6 <HAL_ADC_Init+0x202>
    {
      /* Channel sampling time configuration */
      /* Clear the old sample time */
      hadc->Instance->SMPR &= ~(ADC_SMPR_SMP);
 8009bb6:	2507      	movs	r5, #7
 8009bb8:	6958      	ldr	r0, [r3, #20]
      
      /* Set the new sample time */
      hadc->Instance->SMPR |= ADC_SMPR_SET(hadc->Init.SamplingTimeCommon);
 8009bba:	4029      	ands	r1, r5
      hadc->Instance->SMPR &= ~(ADC_SMPR_SMP);
 8009bbc:	43a8      	bics	r0, r5
 8009bbe:	6158      	str	r0, [r3, #20]
      hadc->Instance->SMPR |= ADC_SMPR_SET(hadc->Init.SamplingTimeCommon);
 8009bc0:	6958      	ldr	r0, [r3, #20]
 8009bc2:	4301      	orrs	r1, r0
 8009bc4:	6159      	str	r1, [r3, #20]
    /* Check back that ADC registers have effectively been configured to      */
    /* ensure of no potential problem of ADC core IP clocking.                */
    /* Check through register CFGR1 (excluding analog watchdog configuration: */
    /* set into separate dedicated function, and bits of ADC resolution set   */
    /* out of temporary variable 'tmpCFGR1').                                 */
    if ((hadc->Instance->CFGR1 & ~(ADC_CFGR1_AWDCH | ADC_CFGR1_AWDEN | ADC_CFGR1_AWDSGL | ADC_CFGR1_RES))
 8009bc6:	68db      	ldr	r3, [r3, #12]
 8009bc8:	4919      	ldr	r1, [pc, #100]	; (8009c30 <HAL_ADC_Init+0x26c>)
 8009bca:	400b      	ands	r3, r1
 8009bcc:	4293      	cmp	r3, r2
 8009bce:	d111      	bne.n	8009bf4 <HAL_ADC_Init+0x230>
         == tmpCFGR1)
    {
      /* Set ADC error code to none */
      ADC_CLEAR_ERRORCODE(hadc);
 8009bd0:	2000      	movs	r0, #0
      
      /* Set the ADC state */
      ADC_STATE_CLR_SET(hadc->State,
 8009bd2:	2203      	movs	r2, #3
      ADC_CLEAR_ERRORCODE(hadc);
 8009bd4:	63e0      	str	r0, [r4, #60]	; 0x3c
      ADC_STATE_CLR_SET(hadc->State,
 8009bd6:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 8009bd8:	4393      	bics	r3, r2
 8009bda:	001a      	movs	r2, r3
 8009bdc:	2301      	movs	r3, #1
 8009bde:	4313      	orrs	r3, r2
 8009be0:	63a3      	str	r3, [r4, #56]	; 0x38
    tmp_hal_status = HAL_ERROR;
  }
  
  /* Return function status */
  return tmp_hal_status;
}
 8009be2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_CONFIG);
 8009be4:	2120      	movs	r1, #32
 8009be6:	6ba5      	ldr	r5, [r4, #56]	; 0x38
 8009be8:	4329      	orrs	r1, r5
 8009bea:	63a1      	str	r1, [r4, #56]	; 0x38
        SET_BIT(hadc->ErrorCode, HAL_ADC_ERROR_INTERNAL);
 8009bec:	6be1      	ldr	r1, [r4, #60]	; 0x3c
 8009bee:	4308      	orrs	r0, r1
 8009bf0:	63e0      	str	r0, [r4, #60]	; 0x3c
 8009bf2:	e7cd      	b.n	8009b90 <HAL_ADC_Init+0x1cc>
      ADC_STATE_CLR_SET(hadc->State,
 8009bf4:	2212      	movs	r2, #18
 8009bf6:	6ba3      	ldr	r3, [r4, #56]	; 0x38
      SET_BIT(hadc->ErrorCode, HAL_ADC_ERROR_INTERNAL);
 8009bf8:	2001      	movs	r0, #1
      ADC_STATE_CLR_SET(hadc->State,
 8009bfa:	4393      	bics	r3, r2
 8009bfc:	001a      	movs	r2, r3
 8009bfe:	2310      	movs	r3, #16
 8009c00:	4313      	orrs	r3, r2
 8009c02:	63a3      	str	r3, [r4, #56]	; 0x38
      SET_BIT(hadc->ErrorCode, HAL_ADC_ERROR_INTERNAL);
 8009c04:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 8009c06:	4303      	orrs	r3, r0
 8009c08:	63e3      	str	r3, [r4, #60]	; 0x3c
      tmp_hal_status = HAL_ERROR;
 8009c0a:	e7ea      	b.n	8009be2 <HAL_ADC_Init+0x21e>
    SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL);
 8009c0c:	2310      	movs	r3, #16
 8009c0e:	6ba2      	ldr	r2, [r4, #56]	; 0x38
    tmp_hal_status = HAL_ERROR;
 8009c10:	2001      	movs	r0, #1
    SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL);
 8009c12:	4313      	orrs	r3, r2
 8009c14:	63a3      	str	r3, [r4, #56]	; 0x38
    tmp_hal_status = HAL_ERROR;
 8009c16:	e7e4      	b.n	8009be2 <HAL_ADC_Init+0x21e>
 8009c18:	40012400 	.word	0x40012400
 8009c1c:	0801071c 	.word	0x0801071c
 8009c20:	bfffffff 	.word	0xbfffffff
 8009c24:	fffff3ff 	.word	0xfffff3ff
 8009c28:	fffffefd 	.word	0xfffffefd
 8009c2c:	fffe0219 	.word	0xfffe0219
 8009c30:	833fffe7 	.word	0x833fffe7

08009c34 <HAL_ADC_ConvCpltCallback>:
 8009c34:	4770      	bx	lr

08009c36 <HAL_ADC_LevelOutOfWindowCallback>:
 8009c36:	4770      	bx	lr

08009c38 <HAL_ADC_ErrorCallback>:
 8009c38:	4770      	bx	lr
	...

08009c3c <HAL_ADC_IRQHandler>:
  * @retval None
  */
void HAL_ADC_IRQHandler(ADC_HandleTypeDef* hadc)
{
  /* Check the parameters */
  assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));
 8009c3c:	4b42      	ldr	r3, [pc, #264]	; (8009d48 <HAL_ADC_IRQHandler+0x10c>)
 8009c3e:	6802      	ldr	r2, [r0, #0]
{
 8009c40:	b570      	push	{r4, r5, r6, lr}
 8009c42:	0004      	movs	r4, r0
  assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));
 8009c44:	429a      	cmp	r2, r3
 8009c46:	d003      	beq.n	8009c50 <HAL_ADC_IRQHandler+0x14>
 8009c48:	4940      	ldr	r1, [pc, #256]	; (8009d4c <HAL_ADC_IRQHandler+0x110>)
 8009c4a:	4841      	ldr	r0, [pc, #260]	; (8009d50 <HAL_ADC_IRQHandler+0x114>)
 8009c4c:	f7fe fe70 	bl	8008930 <assert_failed>
  assert_param(IS_FUNCTIONAL_STATE(hadc->Init.ContinuousConvMode));
 8009c50:	7ea3      	ldrb	r3, [r4, #26]
 8009c52:	2b01      	cmp	r3, #1
 8009c54:	d903      	bls.n	8009c5e <HAL_ADC_IRQHandler+0x22>
 8009c56:	493f      	ldr	r1, [pc, #252]	; (8009d54 <HAL_ADC_IRQHandler+0x118>)
 8009c58:	483d      	ldr	r0, [pc, #244]	; (8009d50 <HAL_ADC_IRQHandler+0x114>)
 8009c5a:	f7fe fe69 	bl	8008930 <assert_failed>
  assert_param(IS_ADC_EOC_SELECTION(hadc->Init.EOCSelection));
 8009c5e:	2204      	movs	r2, #4
 8009c60:	6963      	ldr	r3, [r4, #20]
 8009c62:	3b04      	subs	r3, #4
 8009c64:	4393      	bics	r3, r2
 8009c66:	d004      	beq.n	8009c72 <HAL_ADC_IRQHandler+0x36>
 8009c68:	21d1      	movs	r1, #209	; 0xd1
 8009c6a:	4839      	ldr	r0, [pc, #228]	; (8009d50 <HAL_ADC_IRQHandler+0x114>)
 8009c6c:	00c9      	lsls	r1, r1, #3
 8009c6e:	f7fe fe5f 	bl	8008930 <assert_failed>
  
  /* ========== Check End of Conversion flag for regular group ========== */
  if( (__HAL_ADC_GET_FLAG(hadc, ADC_FLAG_EOC) && __HAL_ADC_GET_IT_SOURCE(hadc, ADC_IT_EOC)) || 
 8009c72:	2204      	movs	r2, #4
 8009c74:	6823      	ldr	r3, [r4, #0]
 8009c76:	6819      	ldr	r1, [r3, #0]
 8009c78:	4211      	tst	r1, r2
 8009c7a:	d002      	beq.n	8009c82 <HAL_ADC_IRQHandler+0x46>
 8009c7c:	6859      	ldr	r1, [r3, #4]
 8009c7e:	4211      	tst	r1, r2
 8009c80:	d106      	bne.n	8009c90 <HAL_ADC_IRQHandler+0x54>
      (__HAL_ADC_GET_FLAG(hadc, ADC_FLAG_EOS) && __HAL_ADC_GET_IT_SOURCE(hadc, ADC_IT_EOS))   )
 8009c82:	2208      	movs	r2, #8
 8009c84:	6819      	ldr	r1, [r3, #0]
  if( (__HAL_ADC_GET_FLAG(hadc, ADC_FLAG_EOC) && __HAL_ADC_GET_IT_SOURCE(hadc, ADC_IT_EOC)) || 
 8009c86:	4211      	tst	r1, r2
 8009c88:	d028      	beq.n	8009cdc <HAL_ADC_IRQHandler+0xa0>
      (__HAL_ADC_GET_FLAG(hadc, ADC_FLAG_EOS) && __HAL_ADC_GET_IT_SOURCE(hadc, ADC_IT_EOS))   )
 8009c8a:	6859      	ldr	r1, [r3, #4]
 8009c8c:	4211      	tst	r1, r2
 8009c8e:	d025      	beq.n	8009cdc <HAL_ADC_IRQHandler+0xa0>
  {
    /* Update state machine on conversion status if not in error state */
    if (HAL_IS_BIT_CLR(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL))
 8009c90:	6ba2      	ldr	r2, [r4, #56]	; 0x38
 8009c92:	06d2      	lsls	r2, r2, #27
 8009c94:	d404      	bmi.n	8009ca0 <HAL_ADC_IRQHandler+0x64>
    {
      /* Set ADC state */
      SET_BIT(hadc->State, HAL_ADC_STATE_REG_EOC); 
 8009c96:	2280      	movs	r2, #128	; 0x80
 8009c98:	6ba1      	ldr	r1, [r4, #56]	; 0x38
 8009c9a:	0092      	lsls	r2, r2, #2
 8009c9c:	430a      	orrs	r2, r1
 8009c9e:	63a2      	str	r2, [r4, #56]	; 0x38
    }
    
    /* Determine whether any further conversion upcoming on group regular     */
    /* by external trigger, continuous mode or scan sequence on going.        */
    if(ADC_IS_SOFTWARE_START_REGULAR(hadc)        && 
 8009ca0:	22c0      	movs	r2, #192	; 0xc0
 8009ca2:	68d9      	ldr	r1, [r3, #12]
 8009ca4:	0112      	lsls	r2, r2, #4
 8009ca6:	4211      	tst	r1, r2
 8009ca8:	d112      	bne.n	8009cd0 <HAL_ADC_IRQHandler+0x94>
 8009caa:	7ea2      	ldrb	r2, [r4, #26]
 8009cac:	2a00      	cmp	r2, #0
 8009cae:	d10f      	bne.n	8009cd0 <HAL_ADC_IRQHandler+0x94>
       (hadc->Init.ContinuousConvMode == DISABLE)   )
    {
      /* If End of Sequence is reached, disable interrupts */
      if( __HAL_ADC_GET_FLAG(hadc, ADC_FLAG_EOS) )
 8009cb0:	681a      	ldr	r2, [r3, #0]
 8009cb2:	0712      	lsls	r2, r2, #28
 8009cb4:	d50c      	bpl.n	8009cd0 <HAL_ADC_IRQHandler+0x94>
      {
        /* Allowed to modify bits ADC_IT_EOC/ADC_IT_EOS only if bit           */
        /* ADSTART==0 (no conversion on going)                                */
        if (ADC_IS_CONVERSION_ONGOING_REGULAR(hadc) == RESET)
 8009cb6:	689a      	ldr	r2, [r3, #8]
 8009cb8:	0752      	lsls	r2, r2, #29
 8009cba:	d43c      	bmi.n	8009d36 <HAL_ADC_IRQHandler+0xfa>
        {
          /* Disable ADC end of single conversion interrupt on group regular */
          /* Note: Overrun interrupt was enabled with EOC interrupt in        */
          /* HAL_Start_IT(), but is not disabled here because can be used     */
          /* by overrun IRQ process below.                                    */
          __HAL_ADC_DISABLE_IT(hadc, ADC_IT_EOC | ADC_IT_EOS);
 8009cbc:	210c      	movs	r1, #12
 8009cbe:	685a      	ldr	r2, [r3, #4]
 8009cc0:	438a      	bics	r2, r1
 8009cc2:	605a      	str	r2, [r3, #4]
          
          /* Set ADC state */
          ADC_STATE_CLR_SET(hadc->State,
 8009cc4:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 8009cc6:	4a24      	ldr	r2, [pc, #144]	; (8009d58 <HAL_ADC_IRQHandler+0x11c>)
 8009cc8:	401a      	ands	r2, r3
 8009cca:	2301      	movs	r3, #1
 8009ccc:	4313      	orrs	r3, r2
 8009cce:	63a3      	str	r3, [r4, #56]	; 0x38
    /*       from EOC or EOS, possibility to use:                             */
    /*        " if( __HAL_ADC_GET_FLAG(&hadc, ADC_FLAG_EOS)) "                */
#if (USE_HAL_ADC_REGISTER_CALLBACKS == 1)
      hadc->ConvCpltCallback(hadc);
#else
    HAL_ADC_ConvCpltCallback(hadc);
 8009cd0:	0020      	movs	r0, r4
 8009cd2:	f7ff ffaf 	bl	8009c34 <HAL_ADC_ConvCpltCallback>
    /* Clear regular group conversion flag */
    /* Note: in case of overrun set to ADC_OVR_DATA_PRESERVED, end of         */
    /*       conversion flags clear induces the release of the preserved data.*/
    /*       Therefore, if the preserved data value is needed, it must be     */
    /*       read preliminarily into HAL_ADC_ConvCpltCallback().              */
    __HAL_ADC_CLEAR_FLAG(hadc, (ADC_FLAG_EOC | ADC_FLAG_EOS) );
 8009cd6:	220c      	movs	r2, #12
 8009cd8:	6823      	ldr	r3, [r4, #0]
 8009cda:	601a      	str	r2, [r3, #0]
  }
   
  /* ========== Check Analog watchdog flags ========== */
  if(__HAL_ADC_GET_FLAG(hadc, ADC_FLAG_AWD) && __HAL_ADC_GET_IT_SOURCE(hadc, ADC_IT_AWD))
 8009cdc:	2580      	movs	r5, #128	; 0x80
 8009cde:	6823      	ldr	r3, [r4, #0]
 8009ce0:	681a      	ldr	r2, [r3, #0]
 8009ce2:	422a      	tst	r2, r5
 8009ce4:	d00c      	beq.n	8009d00 <HAL_ADC_IRQHandler+0xc4>
 8009ce6:	685b      	ldr	r3, [r3, #4]
 8009ce8:	422b      	tst	r3, r5
 8009cea:	d009      	beq.n	8009d00 <HAL_ADC_IRQHandler+0xc4>
  {
      /* Set ADC state */
      SET_BIT(hadc->State, HAL_ADC_STATE_AWD1);
 8009cec:	2380      	movs	r3, #128	; 0x80
 8009cee:	6ba2      	ldr	r2, [r4, #56]	; 0x38
 8009cf0:	025b      	lsls	r3, r3, #9
 8009cf2:	4313      	orrs	r3, r2
 8009cf4:	63a3      	str	r3, [r4, #56]	; 0x38

#if (USE_HAL_ADC_REGISTER_CALLBACKS == 1)
      hadc->LevelOutOfWindowCallback(hadc);
#else
    HAL_ADC_LevelOutOfWindowCallback(hadc);
 8009cf6:	0020      	movs	r0, r4
 8009cf8:	f7ff ff9d 	bl	8009c36 <HAL_ADC_LevelOutOfWindowCallback>
#endif /* USE_HAL_ADC_REGISTER_CALLBACKS */
    
    /* Clear ADC Analog watchdog flag */
    __HAL_ADC_CLEAR_FLAG(hadc, ADC_FLAG_AWD);
 8009cfc:	6823      	ldr	r3, [r4, #0]
 8009cfe:	601d      	str	r5, [r3, #0]
   
  }
  
  
  /* ========== Check Overrun flag ========== */
  if(__HAL_ADC_GET_FLAG(hadc, ADC_FLAG_OVR) && __HAL_ADC_GET_IT_SOURCE(hadc, ADC_IT_OVR))
 8009d00:	2210      	movs	r2, #16
 8009d02:	6823      	ldr	r3, [r4, #0]
 8009d04:	6819      	ldr	r1, [r3, #0]
 8009d06:	4211      	tst	r1, r2
 8009d08:	d014      	beq.n	8009d34 <HAL_ADC_IRQHandler+0xf8>
 8009d0a:	6859      	ldr	r1, [r3, #4]
 8009d0c:	4211      	tst	r1, r2
 8009d0e:	d011      	beq.n	8009d34 <HAL_ADC_IRQHandler+0xf8>
    /* overrun event is not considered as an error.                           */
    /* (cf ref manual "Managing conversions without using the DMA and without */
    /* overrun ")                                                             */
    /* Exception for usage with DMA overrun event always considered as an     */
    /* error.                                                                 */
    if ((hadc->Init.Overrun == ADC_OVR_DATA_PRESERVED)            ||
 8009d10:	6aa2      	ldr	r2, [r4, #40]	; 0x28
 8009d12:	2a01      	cmp	r2, #1
 8009d14:	d002      	beq.n	8009d1c <HAL_ADC_IRQHandler+0xe0>
        HAL_IS_BIT_SET(hadc->Instance->CFGR1, ADC_CFGR1_DMAEN)  )
 8009d16:	68da      	ldr	r2, [r3, #12]
    if ((hadc->Init.Overrun == ADC_OVR_DATA_PRESERVED)            ||
 8009d18:	07d2      	lsls	r2, r2, #31
 8009d1a:	d508      	bpl.n	8009d2e <HAL_ADC_IRQHandler+0xf2>
    {
      /* Set ADC error code to overrun */
      SET_BIT(hadc->ErrorCode, HAL_ADC_ERROR_OVR);
 8009d1c:	2202      	movs	r2, #2
 8009d1e:	6be1      	ldr	r1, [r4, #60]	; 0x3c
      __HAL_ADC_CLEAR_FLAG(hadc, ADC_FLAG_OVR);
      
#if (USE_HAL_ADC_REGISTER_CALLBACKS == 1)
      hadc->ErrorCallback(hadc);
#else
      HAL_ADC_ErrorCallback(hadc);
 8009d20:	0020      	movs	r0, r4
      SET_BIT(hadc->ErrorCode, HAL_ADC_ERROR_OVR);
 8009d22:	430a      	orrs	r2, r1
 8009d24:	63e2      	str	r2, [r4, #60]	; 0x3c
      __HAL_ADC_CLEAR_FLAG(hadc, ADC_FLAG_OVR);
 8009d26:	2210      	movs	r2, #16
 8009d28:	601a      	str	r2, [r3, #0]
      HAL_ADC_ErrorCallback(hadc);
 8009d2a:	f7ff ff85 	bl	8009c38 <HAL_ADC_ErrorCallback>
#endif /* USE_HAL_ADC_REGISTER_CALLBACKS */
    }
    
    /* Clear the Overrun flag */
    __HAL_ADC_CLEAR_FLAG(hadc, ADC_FLAG_OVR);
 8009d2e:	2210      	movs	r2, #16
 8009d30:	6823      	ldr	r3, [r4, #0]
 8009d32:	601a      	str	r2, [r3, #0]
  }

}
 8009d34:	bd70      	pop	{r4, r5, r6, pc}
          SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_CONFIG);
 8009d36:	2320      	movs	r3, #32
 8009d38:	6ba2      	ldr	r2, [r4, #56]	; 0x38
 8009d3a:	4313      	orrs	r3, r2
 8009d3c:	63a3      	str	r3, [r4, #56]	; 0x38
          SET_BIT(hadc->ErrorCode, HAL_ADC_ERROR_INTERNAL);
 8009d3e:	2301      	movs	r3, #1
 8009d40:	6be2      	ldr	r2, [r4, #60]	; 0x3c
 8009d42:	4313      	orrs	r3, r2
 8009d44:	63e3      	str	r3, [r4, #60]	; 0x3c
 8009d46:	e7c3      	b.n	8009cd0 <HAL_ADC_IRQHandler+0x94>
 8009d48:	40012400 	.word	0x40012400
 8009d4c:	00000686 	.word	0x00000686
 8009d50:	0801071c 	.word	0x0801071c
 8009d54:	00000687 	.word	0x00000687
 8009d58:	fffffefe 	.word	0xfffffefe

08009d5c <HAL_ADC_ConfigChannel>:
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_ADC_ConfigChannel(ADC_HandleTypeDef* hadc, ADC_ChannelConfTypeDef* sConfig)
{
  HAL_StatusTypeDef tmp_hal_status = HAL_OK;
  __IO uint32_t wait_loop_index = 0U;
 8009d5c:	2300      	movs	r3, #0
{
 8009d5e:	b5f0      	push	{r4, r5, r6, r7, lr}
 8009d60:	b085      	sub	sp, #20
  __IO uint32_t wait_loop_index = 0U;
 8009d62:	9303      	str	r3, [sp, #12]

  /* Check the parameters */
  assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));
 8009d64:	6802      	ldr	r2, [r0, #0]
 8009d66:	4b49      	ldr	r3, [pc, #292]	; (8009e8c <HAL_ADC_ConfigChannel+0x130>)
{
 8009d68:	0005      	movs	r5, r0
 8009d6a:	000e      	movs	r6, r1
  assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));
 8009d6c:	429a      	cmp	r2, r3
 8009d6e:	d003      	beq.n	8009d78 <HAL_ADC_ConfigChannel+0x1c>
 8009d70:	4947      	ldr	r1, [pc, #284]	; (8009e90 <HAL_ADC_ConfigChannel+0x134>)
 8009d72:	4848      	ldr	r0, [pc, #288]	; (8009e94 <HAL_ADC_ConfigChannel+0x138>)
 8009d74:	f7fe fddc 	bl	8008930 <assert_failed>
  assert_param(IS_ADC_CHANNEL(sConfig->Channel));
 8009d78:	6833      	ldr	r3, [r6, #0]
 8009d7a:	2b11      	cmp	r3, #17
 8009d7c:	d903      	bls.n	8009d86 <HAL_ADC_ConfigChannel+0x2a>
 8009d7e:	4946      	ldr	r1, [pc, #280]	; (8009e98 <HAL_ADC_ConfigChannel+0x13c>)
 8009d80:	4844      	ldr	r0, [pc, #272]	; (8009e94 <HAL_ADC_ConfigChannel+0x138>)
 8009d82:	f7fe fdd5 	bl	8008930 <assert_failed>
  assert_param(IS_ADC_RANK(sConfig->Rank));
 8009d86:	6873      	ldr	r3, [r6, #4]
 8009d88:	4a44      	ldr	r2, [pc, #272]	; (8009e9c <HAL_ADC_ConfigChannel+0x140>)
 8009d8a:	189b      	adds	r3, r3, r2
 8009d8c:	2b01      	cmp	r3, #1
 8009d8e:	d903      	bls.n	8009d98 <HAL_ADC_ConfigChannel+0x3c>
 8009d90:	4943      	ldr	r1, [pc, #268]	; (8009ea0 <HAL_ADC_ConfigChannel+0x144>)
 8009d92:	4840      	ldr	r0, [pc, #256]	; (8009e94 <HAL_ADC_ConfigChannel+0x138>)
 8009d94:	f7fe fdcc 	bl	8008930 <assert_failed>
  
  if (! IS_ADC_SAMPLE_TIME(hadc->Init.SamplingTimeCommon))
 8009d98:	2280      	movs	r2, #128	; 0x80
 8009d9a:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
 8009d9c:	0552      	lsls	r2, r2, #21
 8009d9e:	4293      	cmp	r3, r2
 8009da0:	d00d      	beq.n	8009dbe <HAL_ADC_ConfigChannel+0x62>
 8009da2:	3b01      	subs	r3, #1
 8009da4:	2b06      	cmp	r3, #6
 8009da6:	d90a      	bls.n	8009dbe <HAL_ADC_ConfigChannel+0x62>
  {
    assert_param(IS_ADC_SAMPLE_TIME(sConfig->SamplingTime));
 8009da8:	68b3      	ldr	r3, [r6, #8]
 8009daa:	4293      	cmp	r3, r2
 8009dac:	d007      	beq.n	8009dbe <HAL_ADC_ConfigChannel+0x62>
 8009dae:	3b01      	subs	r3, #1
 8009db0:	2b06      	cmp	r3, #6
 8009db2:	d904      	bls.n	8009dbe <HAL_ADC_ConfigChannel+0x62>
 8009db4:	21ee      	movs	r1, #238	; 0xee
 8009db6:	4837      	ldr	r0, [pc, #220]	; (8009e94 <HAL_ADC_ConfigChannel+0x138>)
 8009db8:	00c9      	lsls	r1, r1, #3
 8009dba:	f7fe fdb9 	bl	8008930 <assert_failed>
  }
  
  /* Process locked */
  __HAL_LOCK(hadc);
 8009dbe:	002c      	movs	r4, r5
 8009dc0:	3434      	adds	r4, #52	; 0x34
 8009dc2:	7823      	ldrb	r3, [r4, #0]
 8009dc4:	2002      	movs	r0, #2
 8009dc6:	2b01      	cmp	r3, #1
 8009dc8:	d02f      	beq.n	8009e2a <HAL_ADC_ConfigChannel+0xce>
 8009dca:	3801      	subs	r0, #1
 8009dcc:	7020      	strb	r0, [r4, #0]
  /* Parameters that can be updated when ADC is disabled or enabled without   */
  /* conversion on going on regular group:                                    */
  /*  - Channel number                                                        */
  /*  - Channel sampling time                                                 */
  /*  - Management of internal measurement channels: VrefInt/TempSensor/Vbat  */
  if (ADC_IS_CONVERSION_ONGOING_REGULAR(hadc) == RESET)
 8009dce:	682b      	ldr	r3, [r5, #0]
 8009dd0:	2204      	movs	r2, #4
 8009dd2:	689f      	ldr	r7, [r3, #8]
 8009dd4:	0039      	movs	r1, r7
 8009dd6:	4011      	ands	r1, r2
 8009dd8:	9101      	str	r1, [sp, #4]
 8009dda:	4217      	tst	r7, r2
 8009ddc:	d151      	bne.n	8009e82 <HAL_ADC_ConfigChannel+0x126>
  {
    /* Configure channel: depending on rank setting, add it or remove it from */
    /* ADC conversion sequencer.                                              */
    if (sConfig->Rank != ADC_RANK_NONE)
 8009dde:	6837      	ldr	r7, [r6, #0]
 8009de0:	4930      	ldr	r1, [pc, #192]	; (8009ea4 <HAL_ADC_ConfigChannel+0x148>)
 8009de2:	003a      	movs	r2, r7
 8009de4:	468c      	mov	ip, r1
 8009de6:	6871      	ldr	r1, [r6, #4]
 8009de8:	40b8      	lsls	r0, r7
 8009dea:	3a10      	subs	r2, #16
 8009dec:	4561      	cmp	r1, ip
 8009dee:	d038      	beq.n	8009e62 <HAL_ADC_ConfigChannel+0x106>
    {
      /* Regular sequence configuration */
      /* Set the channel selection register from the selected channel */
      hadc->Instance->CHSELR |= ADC_CHSELR_CHANNEL(sConfig->Channel);
 8009df0:	6a99      	ldr	r1, [r3, #40]	; 0x28
 8009df2:	4308      	orrs	r0, r1
 8009df4:	6298      	str	r0, [r3, #40]	; 0x28
      /* Channel sampling time configuration */
      /* Management of parameters "SamplingTimeCommon" and "SamplingTime"     */
      /* (obsolete): sampling time set in this function with                  */
      /* parameter "SamplingTime" (obsolete) only if not already set into     */
      /* ADC initialization structure with parameter "SamplingTimeCommon".    */
      if (! IS_ADC_SAMPLE_TIME(hadc->Init.SamplingTimeCommon))
 8009df6:	2080      	movs	r0, #128	; 0x80
 8009df8:	6ae9      	ldr	r1, [r5, #44]	; 0x2c
 8009dfa:	0540      	lsls	r0, r0, #21
 8009dfc:	4281      	cmp	r1, r0
 8009dfe:	d00f      	beq.n	8009e20 <HAL_ADC_ConfigChannel+0xc4>
 8009e00:	3901      	subs	r1, #1
 8009e02:	2906      	cmp	r1, #6
 8009e04:	d90c      	bls.n	8009e20 <HAL_ADC_ConfigChannel+0xc4>
      {
        /* Modify sampling time if needed (not needed in case of reoccurrence */
        /* for several channels programmed consecutively into the sequencer)  */
        if (sConfig->SamplingTime != ADC_GET_SAMPLINGTIME(hadc))
 8009e06:	2007      	movs	r0, #7
 8009e08:	695d      	ldr	r5, [r3, #20]
 8009e0a:	68b1      	ldr	r1, [r6, #8]
 8009e0c:	4005      	ands	r5, r0
 8009e0e:	42a9      	cmp	r1, r5
 8009e10:	d006      	beq.n	8009e20 <HAL_ADC_ConfigChannel+0xc4>
        {
          /* Channel sampling time configuration */
          /* Clear the old sample time */
          hadc->Instance->SMPR &= ~(ADC_SMPR_SMP);
 8009e12:	695d      	ldr	r5, [r3, #20]
          
          /* Set the new sample time */
          hadc->Instance->SMPR |= ADC_SMPR_SET(sConfig->SamplingTime);
 8009e14:	4001      	ands	r1, r0
          hadc->Instance->SMPR &= ~(ADC_SMPR_SMP);
 8009e16:	4385      	bics	r5, r0
 8009e18:	615d      	str	r5, [r3, #20]
          hadc->Instance->SMPR |= ADC_SMPR_SET(sConfig->SamplingTime);
 8009e1a:	695d      	ldr	r5, [r3, #20]
 8009e1c:	4329      	orrs	r1, r5
 8009e1e:	6159      	str	r1, [r3, #20]
      /* internal measurement paths enable: If internal channel selected,     */
      /* enable dedicated internal buffers and path.                          */
      /* Note: these internal measurement paths can be disabled using         */
      /*       HAL_ADC_DeInit() or removing the channel from sequencer with   */
      /*       channel configuration parameter "Rank".                        */
      if(ADC_IS_CHANNEL_INTERNAL(sConfig->Channel))
 8009e20:	2a01      	cmp	r2, #1
 8009e22:	d904      	bls.n	8009e2e <HAL_ADC_ConfigChannel+0xd2>
  HAL_StatusTypeDef tmp_hal_status = HAL_OK;
 8009e24:	2000      	movs	r0, #0
    
    tmp_hal_status = HAL_ERROR;
  }
  
  /* Process unlocked */
  __HAL_UNLOCK(hadc);
 8009e26:	2300      	movs	r3, #0
 8009e28:	7023      	strb	r3, [r4, #0]
  
  /* Return function status */
  return tmp_hal_status;
}
 8009e2a:	b005      	add	sp, #20
 8009e2c:	bdf0      	pop	{r4, r5, r6, r7, pc}
        ADC->CCR |= ADC_CHANNEL_INTERNAL_PATH(sConfig->Channel);
 8009e2e:	4b1e      	ldr	r3, [pc, #120]	; (8009ea8 <HAL_ADC_ConfigChannel+0x14c>)
 8009e30:	2180      	movs	r1, #128	; 0x80
 8009e32:	681a      	ldr	r2, [r3, #0]
 8009e34:	2f10      	cmp	r7, #16
 8009e36:	d012      	beq.n	8009e5e <HAL_ADC_ConfigChannel+0x102>
 8009e38:	03c9      	lsls	r1, r1, #15
 8009e3a:	430a      	orrs	r2, r1
 8009e3c:	601a      	str	r2, [r3, #0]
        if (sConfig->Channel == ADC_CHANNEL_TEMPSENSOR)
 8009e3e:	2f10      	cmp	r7, #16
 8009e40:	d1f0      	bne.n	8009e24 <HAL_ADC_ConfigChannel+0xc8>
          wait_loop_index = (ADC_TEMPSENSOR_DELAY_US * (SystemCoreClock / 1000000U));
 8009e42:	4b1a      	ldr	r3, [pc, #104]	; (8009eac <HAL_ADC_ConfigChannel+0x150>)
 8009e44:	491a      	ldr	r1, [pc, #104]	; (8009eb0 <HAL_ADC_ConfigChannel+0x154>)
 8009e46:	6818      	ldr	r0, [r3, #0]
 8009e48:	f7fe f98e 	bl	8008168 <__udivsi3>
 8009e4c:	230a      	movs	r3, #10
 8009e4e:	4343      	muls	r3, r0
            wait_loop_index--;
 8009e50:	9303      	str	r3, [sp, #12]
          while(wait_loop_index != 0U)
 8009e52:	9b03      	ldr	r3, [sp, #12]
 8009e54:	2b00      	cmp	r3, #0
 8009e56:	d0e5      	beq.n	8009e24 <HAL_ADC_ConfigChannel+0xc8>
            wait_loop_index--;
 8009e58:	9b03      	ldr	r3, [sp, #12]
 8009e5a:	3b01      	subs	r3, #1
 8009e5c:	e7f8      	b.n	8009e50 <HAL_ADC_ConfigChannel+0xf4>
        ADC->CCR |= ADC_CHANNEL_INTERNAL_PATH(sConfig->Channel);
 8009e5e:	0409      	lsls	r1, r1, #16
 8009e60:	e7eb      	b.n	8009e3a <HAL_ADC_ConfigChannel+0xde>
      hadc->Instance->CHSELR &= ~ADC_CHSELR_CHANNEL(sConfig->Channel);
 8009e62:	6a9d      	ldr	r5, [r3, #40]	; 0x28
 8009e64:	4385      	bics	r5, r0
 8009e66:	629d      	str	r5, [r3, #40]	; 0x28
      if(ADC_IS_CHANNEL_INTERNAL(sConfig->Channel))
 8009e68:	2a01      	cmp	r2, #1
 8009e6a:	d8db      	bhi.n	8009e24 <HAL_ADC_ConfigChannel+0xc8>
        ADC->CCR &= ~ADC_CHANNEL_INTERNAL_PATH(sConfig->Channel);
 8009e6c:	4253      	negs	r3, r2
 8009e6e:	415a      	adcs	r2, r3
 8009e70:	480d      	ldr	r0, [pc, #52]	; (8009ea8 <HAL_ADC_ConfigChannel+0x14c>)
 8009e72:	4253      	negs	r3, r2
 8009e74:	4a0f      	ldr	r2, [pc, #60]	; (8009eb4 <HAL_ADC_ConfigChannel+0x158>)
 8009e76:	6805      	ldr	r5, [r0, #0]
 8009e78:	059b      	lsls	r3, r3, #22
 8009e7a:	189b      	adds	r3, r3, r2
 8009e7c:	402b      	ands	r3, r5
 8009e7e:	6003      	str	r3, [r0, #0]
 8009e80:	e7d0      	b.n	8009e24 <HAL_ADC_ConfigChannel+0xc8>
    SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_CONFIG);
 8009e82:	2320      	movs	r3, #32
 8009e84:	6baa      	ldr	r2, [r5, #56]	; 0x38
 8009e86:	4313      	orrs	r3, r2
 8009e88:	63ab      	str	r3, [r5, #56]	; 0x38
    tmp_hal_status = HAL_ERROR;
 8009e8a:	e7cc      	b.n	8009e26 <HAL_ADC_ConfigChannel+0xca>
 8009e8c:	40012400 	.word	0x40012400
 8009e90:	0000076a 	.word	0x0000076a
 8009e94:	0801071c 	.word	0x0801071c
 8009e98:	0000076b 	.word	0x0000076b
 8009e9c:	fffff000 	.word	0xfffff000
 8009ea0:	0000076c 	.word	0x0000076c
 8009ea4:	00001001 	.word	0x00001001
 8009ea8:	40012708 	.word	0x40012708
 8009eac:	2000045c 	.word	0x2000045c
 8009eb0:	000f4240 	.word	0x000f4240
 8009eb4:	ffbfffff 	.word	0xffbfffff

08009eb8 <HAL_NVIC_SetPriority>:
  *         with stm32f0xx devices, this parameter is a dummy value and it is ignored, because 
  *         no subpriority supported in Cortex M0 based products.   
  * @retval None
  */
void HAL_NVIC_SetPriority(IRQn_Type IRQn, uint32_t PreemptPriority, uint32_t SubPriority)
{ 
 8009eb8:	b570      	push	{r4, r5, r6, lr}
 8009eba:	0004      	movs	r4, r0
 8009ebc:	000d      	movs	r5, r1
  /* Check the parameters */
  assert_param(IS_NVIC_PREEMPTION_PRIORITY(PreemptPriority));
 8009ebe:	2903      	cmp	r1, #3
 8009ec0:	d903      	bls.n	8009eca <HAL_NVIC_SetPriority+0x12>
 8009ec2:	218b      	movs	r1, #139	; 0x8b
 8009ec4:	4813      	ldr	r0, [pc, #76]	; (8009f14 <HAL_NVIC_SetPriority+0x5c>)
 8009ec6:	f7fe fd33 	bl	8008930 <assert_failed>
  if ((int32_t)(IRQn) >= 0)
 8009eca:	26ff      	movs	r6, #255	; 0xff
 8009ecc:	2003      	movs	r0, #3
 8009ece:	0032      	movs	r2, r6
 8009ed0:	4020      	ands	r0, r4
 8009ed2:	00c0      	lsls	r0, r0, #3
 8009ed4:	4082      	lsls	r2, r0
 8009ed6:	01a9      	lsls	r1, r5, #6
 8009ed8:	4031      	ands	r1, r6
 8009eda:	43d2      	mvns	r2, r2
 8009edc:	4081      	lsls	r1, r0
 8009ede:	b2e3      	uxtb	r3, r4
 8009ee0:	2c00      	cmp	r4, #0
 8009ee2:	db0a      	blt.n	8009efa <HAL_NVIC_SetPriority+0x42>
    NVIC->IP[_IP_IDX(IRQn)]  = ((uint32_t)(NVIC->IP[_IP_IDX(IRQn)]  & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
 8009ee4:	20c0      	movs	r0, #192	; 0xc0
 8009ee6:	4b0c      	ldr	r3, [pc, #48]	; (8009f18 <HAL_NVIC_SetPriority+0x60>)
 8009ee8:	08a4      	lsrs	r4, r4, #2
 8009eea:	00a4      	lsls	r4, r4, #2
 8009eec:	18e4      	adds	r4, r4, r3
 8009eee:	0080      	lsls	r0, r0, #2
 8009ef0:	5823      	ldr	r3, [r4, r0]
 8009ef2:	401a      	ands	r2, r3
 8009ef4:	4311      	orrs	r1, r2
 8009ef6:	5021      	str	r1, [r4, r0]
  NVIC_SetPriority(IRQn,PreemptPriority);
}
 8009ef8:	bd70      	pop	{r4, r5, r6, pc}
    SCB->SHP[_SHP_IDX(IRQn)] = ((uint32_t)(SCB->SHP[_SHP_IDX(IRQn)] & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
 8009efa:	200f      	movs	r0, #15
 8009efc:	4003      	ands	r3, r0
 8009efe:	3b08      	subs	r3, #8
 8009f00:	4806      	ldr	r0, [pc, #24]	; (8009f1c <HAL_NVIC_SetPriority+0x64>)
 8009f02:	089b      	lsrs	r3, r3, #2
 8009f04:	009b      	lsls	r3, r3, #2
 8009f06:	181b      	adds	r3, r3, r0
 8009f08:	69d8      	ldr	r0, [r3, #28]
 8009f0a:	4002      	ands	r2, r0
 8009f0c:	4311      	orrs	r1, r2
 8009f0e:	61d9      	str	r1, [r3, #28]
 8009f10:	e7f2      	b.n	8009ef8 <HAL_NVIC_SetPriority+0x40>
 8009f12:	46c0      	nop			; (mov r8, r8)
 8009f14:	08010754 	.word	0x08010754
 8009f18:	e000e100 	.word	0xe000e100
 8009f1c:	e000ed00 	.word	0xe000ed00

08009f20 <HAL_NVIC_EnableIRQ>:
  *         This parameter can be an enumerator of IRQn_Type enumeration
  *         (For the complete STM32 Devices IRQ Channels list, please refer to the appropriate CMSIS device file (stm32f0xxxx.h))
  * @retval None
  */
void HAL_NVIC_EnableIRQ(IRQn_Type IRQn)
{
 8009f20:	b510      	push	{r4, lr}
  /* Check the parameters */
  assert_param(IS_NVIC_DEVICE_IRQ(IRQn));
 8009f22:	2800      	cmp	r0, #0
 8009f24:	da04      	bge.n	8009f30 <HAL_NVIC_EnableIRQ+0x10>
 8009f26:	219b      	movs	r1, #155	; 0x9b
 8009f28:	4805      	ldr	r0, [pc, #20]	; (8009f40 <HAL_NVIC_EnableIRQ+0x20>)
 8009f2a:	f7fe fd01 	bl	8008930 <assert_failed>
  
  /* Enable interrupt */
  NVIC_EnableIRQ(IRQn);
}
 8009f2e:	bd10      	pop	{r4, pc}
    NVIC->ISER[0U] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
 8009f30:	231f      	movs	r3, #31
 8009f32:	4018      	ands	r0, r3
 8009f34:	3b1e      	subs	r3, #30
 8009f36:	4083      	lsls	r3, r0
 8009f38:	4a02      	ldr	r2, [pc, #8]	; (8009f44 <HAL_NVIC_EnableIRQ+0x24>)
 8009f3a:	6013      	str	r3, [r2, #0]
 8009f3c:	e7f7      	b.n	8009f2e <HAL_NVIC_EnableIRQ+0xe>
 8009f3e:	46c0      	nop			; (mov r8, r8)
 8009f40:	08010754 	.word	0x08010754
 8009f44:	e000e100 	.word	0xe000e100

08009f48 <HAL_DMA_Init>:
  * @param  hdma Pointer to a DMA_HandleTypeDef structure that contains
  *               the configuration information for the specified DMA Channel.  
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DMA_Init(DMA_HandleTypeDef *hdma)
{ 
 8009f48:	b570      	push	{r4, r5, r6, lr}
 8009f4a:	0004      	movs	r4, r0
  uint32_t tmp = 0U;
  
  /* Check the DMA handle allocation */
  if(NULL == hdma)
  {
    return HAL_ERROR;
 8009f4c:	2001      	movs	r0, #1
  if(NULL == hdma)
 8009f4e:	2c00      	cmp	r4, #0
 8009f50:	d100      	bne.n	8009f54 <HAL_DMA_Init+0xc>
 8009f52:	e07d      	b.n	800a050 <HAL_DMA_Init+0x108>
  }
  
  /* Check the parameters */
  assert_param(IS_DMA_ALL_INSTANCE(hdma->Instance));
 8009f54:	6823      	ldr	r3, [r4, #0]
 8009f56:	4a3f      	ldr	r2, [pc, #252]	; (800a054 <HAL_DMA_Init+0x10c>)
 8009f58:	4293      	cmp	r3, r2
 8009f5a:	d00f      	beq.n	8009f7c <HAL_DMA_Init+0x34>
 8009f5c:	4a3e      	ldr	r2, [pc, #248]	; (800a058 <HAL_DMA_Init+0x110>)
 8009f5e:	4293      	cmp	r3, r2
 8009f60:	d00c      	beq.n	8009f7c <HAL_DMA_Init+0x34>
 8009f62:	4a3e      	ldr	r2, [pc, #248]	; (800a05c <HAL_DMA_Init+0x114>)
 8009f64:	4293      	cmp	r3, r2
 8009f66:	d009      	beq.n	8009f7c <HAL_DMA_Init+0x34>
 8009f68:	4a3d      	ldr	r2, [pc, #244]	; (800a060 <HAL_DMA_Init+0x118>)
 8009f6a:	4293      	cmp	r3, r2
 8009f6c:	d006      	beq.n	8009f7c <HAL_DMA_Init+0x34>
 8009f6e:	4a3d      	ldr	r2, [pc, #244]	; (800a064 <HAL_DMA_Init+0x11c>)
 8009f70:	4293      	cmp	r3, r2
 8009f72:	d003      	beq.n	8009f7c <HAL_DMA_Init+0x34>
 8009f74:	2195      	movs	r1, #149	; 0x95
 8009f76:	483c      	ldr	r0, [pc, #240]	; (800a068 <HAL_DMA_Init+0x120>)
 8009f78:	f7fe fcda 	bl	8008930 <assert_failed>
  assert_param(IS_DMA_DIRECTION(hdma->Init.Direction));
 8009f7c:	6863      	ldr	r3, [r4, #4]
 8009f7e:	2210      	movs	r2, #16
 8009f80:	0019      	movs	r1, r3
 8009f82:	4391      	bics	r1, r2
 8009f84:	d007      	beq.n	8009f96 <HAL_DMA_Init+0x4e>
 8009f86:	2280      	movs	r2, #128	; 0x80
 8009f88:	01d2      	lsls	r2, r2, #7
 8009f8a:	4293      	cmp	r3, r2
 8009f8c:	d003      	beq.n	8009f96 <HAL_DMA_Init+0x4e>
 8009f8e:	2196      	movs	r1, #150	; 0x96
 8009f90:	4835      	ldr	r0, [pc, #212]	; (800a068 <HAL_DMA_Init+0x120>)
 8009f92:	f7fe fccd 	bl	8008930 <assert_failed>
  assert_param(IS_DMA_PERIPHERAL_INC_STATE(hdma->Init.PeriphInc));
 8009f96:	2340      	movs	r3, #64	; 0x40
 8009f98:	68a2      	ldr	r2, [r4, #8]
 8009f9a:	439a      	bics	r2, r3
 8009f9c:	d003      	beq.n	8009fa6 <HAL_DMA_Init+0x5e>
 8009f9e:	2197      	movs	r1, #151	; 0x97
 8009fa0:	4831      	ldr	r0, [pc, #196]	; (800a068 <HAL_DMA_Init+0x120>)
 8009fa2:	f7fe fcc5 	bl	8008930 <assert_failed>
  assert_param(IS_DMA_MEMORY_INC_STATE(hdma->Init.MemInc));
 8009fa6:	2380      	movs	r3, #128	; 0x80
 8009fa8:	68e2      	ldr	r2, [r4, #12]
 8009faa:	439a      	bics	r2, r3
 8009fac:	d003      	beq.n	8009fb6 <HAL_DMA_Init+0x6e>
 8009fae:	2198      	movs	r1, #152	; 0x98
 8009fb0:	482d      	ldr	r0, [pc, #180]	; (800a068 <HAL_DMA_Init+0x120>)
 8009fb2:	f7fe fcbd 	bl	8008930 <assert_failed>
  assert_param(IS_DMA_PERIPHERAL_DATA_SIZE(hdma->Init.PeriphDataAlignment));
 8009fb6:	6923      	ldr	r3, [r4, #16]
 8009fb8:	4a2c      	ldr	r2, [pc, #176]	; (800a06c <HAL_DMA_Init+0x124>)
 8009fba:	4213      	tst	r3, r2
 8009fbc:	d007      	beq.n	8009fce <HAL_DMA_Init+0x86>
 8009fbe:	2280      	movs	r2, #128	; 0x80
 8009fc0:	0092      	lsls	r2, r2, #2
 8009fc2:	4293      	cmp	r3, r2
 8009fc4:	d003      	beq.n	8009fce <HAL_DMA_Init+0x86>
 8009fc6:	2199      	movs	r1, #153	; 0x99
 8009fc8:	4827      	ldr	r0, [pc, #156]	; (800a068 <HAL_DMA_Init+0x120>)
 8009fca:	f7fe fcb1 	bl	8008930 <assert_failed>
  assert_param(IS_DMA_MEMORY_DATA_SIZE(hdma->Init.MemDataAlignment));
 8009fce:	6963      	ldr	r3, [r4, #20]
 8009fd0:	4a27      	ldr	r2, [pc, #156]	; (800a070 <HAL_DMA_Init+0x128>)
 8009fd2:	4213      	tst	r3, r2
 8009fd4:	d007      	beq.n	8009fe6 <HAL_DMA_Init+0x9e>
 8009fd6:	2280      	movs	r2, #128	; 0x80
 8009fd8:	0112      	lsls	r2, r2, #4
 8009fda:	4293      	cmp	r3, r2
 8009fdc:	d003      	beq.n	8009fe6 <HAL_DMA_Init+0x9e>
 8009fde:	219a      	movs	r1, #154	; 0x9a
 8009fe0:	4821      	ldr	r0, [pc, #132]	; (800a068 <HAL_DMA_Init+0x120>)
 8009fe2:	f7fe fca5 	bl	8008930 <assert_failed>
  assert_param(IS_DMA_MODE(hdma->Init.Mode));
 8009fe6:	2320      	movs	r3, #32
 8009fe8:	69a2      	ldr	r2, [r4, #24]
 8009fea:	439a      	bics	r2, r3
 8009fec:	d003      	beq.n	8009ff6 <HAL_DMA_Init+0xae>
 8009fee:	219b      	movs	r1, #155	; 0x9b
 8009ff0:	481d      	ldr	r0, [pc, #116]	; (800a068 <HAL_DMA_Init+0x120>)
 8009ff2:	f7fe fc9d 	bl	8008930 <assert_failed>
  assert_param(IS_DMA_PRIORITY(hdma->Init.Priority));
 8009ff6:	4b1f      	ldr	r3, [pc, #124]	; (800a074 <HAL_DMA_Init+0x12c>)
 8009ff8:	69e2      	ldr	r2, [r4, #28]
 8009ffa:	421a      	tst	r2, r3
 8009ffc:	d003      	beq.n	800a006 <HAL_DMA_Init+0xbe>
 8009ffe:	219c      	movs	r1, #156	; 0x9c
 800a000:	4819      	ldr	r0, [pc, #100]	; (800a068 <HAL_DMA_Init+0x120>)
 800a002:	f7fe fc95 	bl	8008930 <assert_failed>
  
  /* Change DMA peripheral state */
  hdma->State = HAL_DMA_STATE_BUSY;
 800a006:	2302      	movs	r3, #2
 800a008:	1ca5      	adds	r5, r4, #2
 800a00a:	77eb      	strb	r3, [r5, #31]

  /* Get the CR register value */
  tmp = hdma->Instance->CCR;
 800a00c:	6820      	ldr	r0, [r4, #0]
  
  /* Clear PL, MSIZE, PSIZE, MINC, PINC, CIRC, DIR bits */
  tmp &= ((uint32_t)~(DMA_CCR_PL    | DMA_CCR_MSIZE  | DMA_CCR_PSIZE  | \
 800a00e:	4b1a      	ldr	r3, [pc, #104]	; (800a078 <HAL_DMA_Init+0x130>)
  tmp = hdma->Instance->CCR;
 800a010:	6802      	ldr	r2, [r0, #0]
                      DMA_CCR_MINC  | DMA_CCR_PINC   | DMA_CCR_CIRC   | \
                      DMA_CCR_DIR));
  
  /* Prepare the DMA Channel configuration */
  tmp |=  hdma->Init.Direction        |
 800a012:	68a1      	ldr	r1, [r4, #8]
  tmp &= ((uint32_t)~(DMA_CCR_PL    | DMA_CCR_MSIZE  | DMA_CCR_PSIZE  | \
 800a014:	401a      	ands	r2, r3
  tmp |=  hdma->Init.Direction        |
 800a016:	6863      	ldr	r3, [r4, #4]
 800a018:	430b      	orrs	r3, r1
          hdma->Init.PeriphInc           | hdma->Init.MemInc           |
 800a01a:	68e1      	ldr	r1, [r4, #12]
 800a01c:	430b      	orrs	r3, r1
 800a01e:	6921      	ldr	r1, [r4, #16]
 800a020:	430b      	orrs	r3, r1
          hdma->Init.PeriphDataAlignment | hdma->Init.MemDataAlignment |
 800a022:	6961      	ldr	r1, [r4, #20]
 800a024:	430b      	orrs	r3, r1
 800a026:	69a1      	ldr	r1, [r4, #24]
 800a028:	430b      	orrs	r3, r1
          hdma->Init.Mode                | hdma->Init.Priority;
 800a02a:	69e1      	ldr	r1, [r4, #28]
 800a02c:	430b      	orrs	r3, r1
  tmp |=  hdma->Init.Direction        |
 800a02e:	4313      	orrs	r3, r2

  /* Write to DMA Channel CR register */
  hdma->Instance->CCR = tmp;  
 800a030:	6003      	str	r3, [r0, #0]
    hdma->DmaBaseAddress = DMA2;
  }
#else
  /* calculation of the channel index */
  /* DMA1 */
  hdma->ChannelIndex = (((uint32_t)hdma->Instance - (uint32_t)DMA1_Channel1) / ((uint32_t)DMA1_Channel2 - (uint32_t)DMA1_Channel1)) << 2U;
 800a032:	4b12      	ldr	r3, [pc, #72]	; (800a07c <HAL_DMA_Init+0x134>)
 800a034:	2114      	movs	r1, #20
 800a036:	18c0      	adds	r0, r0, r3
 800a038:	f7fe f896 	bl	8008168 <__udivsi3>
  hdma->DmaBaseAddress = DMA1;
 800a03c:	4b10      	ldr	r3, [pc, #64]	; (800a080 <HAL_DMA_Init+0x138>)
  hdma->ChannelIndex = (((uint32_t)hdma->Instance - (uint32_t)DMA1_Channel1) / ((uint32_t)DMA1_Channel2 - (uint32_t)DMA1_Channel1)) << 2U;
 800a03e:	0080      	lsls	r0, r0, #2
 800a040:	6420      	str	r0, [r4, #64]	; 0x40
  hdma->DmaBaseAddress = DMA1;
 800a042:	63e3      	str	r3, [r4, #60]	; 0x3c
  hdma->ErrorCode = HAL_DMA_ERROR_NONE;
 800a044:	2000      	movs	r0, #0
  hdma->State = HAL_DMA_STATE_READY;
 800a046:	2301      	movs	r3, #1
  hdma->ErrorCode = HAL_DMA_ERROR_NONE;
 800a048:	63a0      	str	r0, [r4, #56]	; 0x38
  hdma->Lock = HAL_UNLOCKED;
 800a04a:	18e4      	adds	r4, r4, r3
  hdma->State = HAL_DMA_STATE_READY;
 800a04c:	77eb      	strb	r3, [r5, #31]
  hdma->Lock = HAL_UNLOCKED;
 800a04e:	77e0      	strb	r0, [r4, #31]
}  
 800a050:	bd70      	pop	{r4, r5, r6, pc}
 800a052:	46c0      	nop			; (mov r8, r8)
 800a054:	40020008 	.word	0x40020008
 800a058:	4002001c 	.word	0x4002001c
 800a05c:	40020030 	.word	0x40020030
 800a060:	40020044 	.word	0x40020044
 800a064:	40020058 	.word	0x40020058
 800a068:	0801078f 	.word	0x0801078f
 800a06c:	fffffeff 	.word	0xfffffeff
 800a070:	fffffbff 	.word	0xfffffbff
 800a074:	ffffcfff 	.word	0xffffcfff
 800a078:	ffffc00f 	.word	0xffffc00f
 800a07c:	bffdfff8 	.word	0xbffdfff8
 800a080:	40020000 	.word	0x40020000

0800a084 <HAL_DMA_Abort_IT>:
{  
 800a084:	b570      	push	{r4, r5, r6, lr}
  if(HAL_DMA_STATE_BUSY != hdma->State)
 800a086:	1c84      	adds	r4, r0, #2
 800a088:	7fe3      	ldrb	r3, [r4, #31]
 800a08a:	2b02      	cmp	r3, #2
 800a08c:	d004      	beq.n	800a098 <HAL_DMA_Abort_IT+0x14>
    hdma->ErrorCode = HAL_DMA_ERROR_NO_XFER;
 800a08e:	2304      	movs	r3, #4
 800a090:	6383      	str	r3, [r0, #56]	; 0x38
    status = HAL_ERROR;
 800a092:	3b03      	subs	r3, #3
}
 800a094:	0018      	movs	r0, r3
 800a096:	bd70      	pop	{r4, r5, r6, pc}
    hdma->Instance->CCR &= ~(DMA_IT_TC | DMA_IT_HT | DMA_IT_TE);
 800a098:	210e      	movs	r1, #14
 800a09a:	6803      	ldr	r3, [r0, #0]
    hdma->DmaBaseAddress->IFCR = DMA_FLAG_GL1 << hdma->ChannelIndex;
 800a09c:	6c05      	ldr	r5, [r0, #64]	; 0x40
    hdma->Instance->CCR &= ~(DMA_IT_TC | DMA_IT_HT | DMA_IT_TE);
 800a09e:	681a      	ldr	r2, [r3, #0]
 800a0a0:	438a      	bics	r2, r1
 800a0a2:	601a      	str	r2, [r3, #0]
    hdma->Instance->CCR &= ~DMA_CCR_EN;
 800a0a4:	2201      	movs	r2, #1
 800a0a6:	6819      	ldr	r1, [r3, #0]
 800a0a8:	4391      	bics	r1, r2
 800a0aa:	6019      	str	r1, [r3, #0]
    hdma->DmaBaseAddress->IFCR = DMA_FLAG_GL1 << hdma->ChannelIndex;
 800a0ac:	0011      	movs	r1, r2
 800a0ae:	40a9      	lsls	r1, r5
 800a0b0:	6bc3      	ldr	r3, [r0, #60]	; 0x3c
 800a0b2:	6059      	str	r1, [r3, #4]
    hdma->State = HAL_DMA_STATE_READY;
 800a0b4:	77e2      	strb	r2, [r4, #31]
    __HAL_UNLOCK(hdma);
 800a0b6:	2400      	movs	r4, #0
 800a0b8:	1883      	adds	r3, r0, r2
 800a0ba:	77dc      	strb	r4, [r3, #31]
    if(hdma->XferAbortCallback != NULL)
 800a0bc:	6b42      	ldr	r2, [r0, #52]	; 0x34
  HAL_StatusTypeDef status = HAL_OK;
 800a0be:	0013      	movs	r3, r2
    if(hdma->XferAbortCallback != NULL)
 800a0c0:	42a2      	cmp	r2, r4
 800a0c2:	d0e7      	beq.n	800a094 <HAL_DMA_Abort_IT+0x10>
      hdma->XferAbortCallback(hdma);
 800a0c4:	4790      	blx	r2
  HAL_StatusTypeDef status = HAL_OK;
 800a0c6:	0023      	movs	r3, r4
 800a0c8:	e7e4      	b.n	800a094 <HAL_DMA_Abort_IT+0x10>

0800a0ca <HAL_DMA_IRQHandler>:
{
 800a0ca:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  if ((RESET != (flag_it & (DMA_FLAG_HT1 << hdma->ChannelIndex))) && (RESET != (source_it & DMA_IT_HT)))
 800a0cc:	2704      	movs	r7, #4
 800a0ce:	003e      	movs	r6, r7
 800a0d0:	6c01      	ldr	r1, [r0, #64]	; 0x40
	uint32_t flag_it = hdma->DmaBaseAddress->ISR;
 800a0d2:	6bc2      	ldr	r2, [r0, #60]	; 0x3c
  if ((RESET != (flag_it & (DMA_FLAG_HT1 << hdma->ChannelIndex))) && (RESET != (source_it & DMA_IT_HT)))
 800a0d4:	408e      	lsls	r6, r1
	uint32_t flag_it = hdma->DmaBaseAddress->ISR;
 800a0d6:	6815      	ldr	r5, [r2, #0]
  uint32_t source_it = hdma->Instance->CCR;
 800a0d8:	6803      	ldr	r3, [r0, #0]
 800a0da:	681c      	ldr	r4, [r3, #0]
  if ((RESET != (flag_it & (DMA_FLAG_HT1 << hdma->ChannelIndex))) && (RESET != (source_it & DMA_IT_HT)))
 800a0dc:	4235      	tst	r5, r6
 800a0de:	d00d      	beq.n	800a0fc <HAL_DMA_IRQHandler+0x32>
 800a0e0:	423c      	tst	r4, r7
 800a0e2:	d00b      	beq.n	800a0fc <HAL_DMA_IRQHandler+0x32>
  	if((hdma->Instance->CCR & DMA_CCR_CIRC) == 0U)
 800a0e4:	6819      	ldr	r1, [r3, #0]
 800a0e6:	0689      	lsls	r1, r1, #26
 800a0e8:	d402      	bmi.n	800a0f0 <HAL_DMA_IRQHandler+0x26>
  		hdma->Instance->CCR &= ~DMA_IT_HT;
 800a0ea:	6819      	ldr	r1, [r3, #0]
 800a0ec:	43b9      	bics	r1, r7
 800a0ee:	6019      	str	r1, [r3, #0]
  	if(hdma->XferHalfCpltCallback != NULL)
 800a0f0:	6ac3      	ldr	r3, [r0, #44]	; 0x2c
  	hdma->DmaBaseAddress->IFCR = DMA_FLAG_HT1 << hdma->ChannelIndex;
 800a0f2:	6056      	str	r6, [r2, #4]
  	if(hdma->XferHalfCpltCallback != NULL)
 800a0f4:	2b00      	cmp	r3, #0
 800a0f6:	d019      	beq.n	800a12c <HAL_DMA_IRQHandler+0x62>
    	hdma->XferErrorCallback(hdma);
 800a0f8:	4798      	blx	r3
}  
 800a0fa:	e017      	b.n	800a12c <HAL_DMA_IRQHandler+0x62>
  else if ((RESET != (flag_it & (DMA_FLAG_TC1 << hdma->ChannelIndex))) && (RESET != (source_it & DMA_IT_TC)))
 800a0fc:	2702      	movs	r7, #2
 800a0fe:	003e      	movs	r6, r7
 800a100:	408e      	lsls	r6, r1
 800a102:	4235      	tst	r5, r6
 800a104:	d013      	beq.n	800a12e <HAL_DMA_IRQHandler+0x64>
 800a106:	423c      	tst	r4, r7
 800a108:	d011      	beq.n	800a12e <HAL_DMA_IRQHandler+0x64>
  	if((hdma->Instance->CCR & DMA_CCR_CIRC) == 0U)
 800a10a:	6819      	ldr	r1, [r3, #0]
 800a10c:	0689      	lsls	r1, r1, #26
 800a10e:	d406      	bmi.n	800a11e <HAL_DMA_IRQHandler+0x54>
  		hdma->Instance->CCR &= ~(DMA_IT_TC | DMA_IT_TE);
 800a110:	240a      	movs	r4, #10
 800a112:	6819      	ldr	r1, [r3, #0]
 800a114:	43a1      	bics	r1, r4
 800a116:	6019      	str	r1, [r3, #0]
  		hdma->State = HAL_DMA_STATE_READY;
 800a118:	2101      	movs	r1, #1
 800a11a:	19c3      	adds	r3, r0, r7
 800a11c:	77d9      	strb	r1, [r3, #31]
  	hdma->DmaBaseAddress->IFCR = DMA_FLAG_TC1 << hdma->ChannelIndex;
 800a11e:	6056      	str	r6, [r2, #4]
  	__HAL_UNLOCK(hdma);
 800a120:	2200      	movs	r2, #0
 800a122:	1c43      	adds	r3, r0, #1
 800a124:	77da      	strb	r2, [r3, #31]
  	if(hdma->XferCpltCallback != NULL)
 800a126:	6a83      	ldr	r3, [r0, #40]	; 0x28
    if(hdma->XferErrorCallback != NULL)
 800a128:	4293      	cmp	r3, r2
 800a12a:	d1e5      	bne.n	800a0f8 <HAL_DMA_IRQHandler+0x2e>
}  
 800a12c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  else if (( RESET != (flag_it & (DMA_FLAG_TE1 << hdma->ChannelIndex))) && (RESET != (source_it & DMA_IT_TE)))
 800a12e:	2608      	movs	r6, #8
 800a130:	0037      	movs	r7, r6
 800a132:	408f      	lsls	r7, r1
 800a134:	423d      	tst	r5, r7
 800a136:	d0f9      	beq.n	800a12c <HAL_DMA_IRQHandler+0x62>
 800a138:	4234      	tst	r4, r6
 800a13a:	d0f7      	beq.n	800a12c <HAL_DMA_IRQHandler+0x62>
    hdma->Instance->CCR &= ~(DMA_IT_TC | DMA_IT_HT | DMA_IT_TE);
 800a13c:	250e      	movs	r5, #14
 800a13e:	681c      	ldr	r4, [r3, #0]
 800a140:	43ac      	bics	r4, r5
 800a142:	601c      	str	r4, [r3, #0]
    hdma->DmaBaseAddress->IFCR = DMA_FLAG_GL1 << hdma->ChannelIndex;
 800a144:	2301      	movs	r3, #1
 800a146:	001c      	movs	r4, r3
 800a148:	408c      	lsls	r4, r1
 800a14a:	6054      	str	r4, [r2, #4]
    hdma->State = HAL_DMA_STATE_READY;    
 800a14c:	1c82      	adds	r2, r0, #2
    hdma->ErrorCode = HAL_DMA_ERROR_TE;
 800a14e:	6383      	str	r3, [r0, #56]	; 0x38
    hdma->State = HAL_DMA_STATE_READY;    
 800a150:	77d3      	strb	r3, [r2, #31]
    __HAL_UNLOCK(hdma); 
 800a152:	2200      	movs	r2, #0
 800a154:	18c3      	adds	r3, r0, r3
 800a156:	77da      	strb	r2, [r3, #31]
    if(hdma->XferErrorCallback != NULL)
 800a158:	6b03      	ldr	r3, [r0, #48]	; 0x30
 800a15a:	e7e5      	b.n	800a128 <HAL_DMA_IRQHandler+0x5e>

0800a15c <HAL_DMA_GetState>:
  return hdma->State;
 800a15c:	3002      	adds	r0, #2
 800a15e:	7fc0      	ldrb	r0, [r0, #31]
 800a160:	b2c0      	uxtb	r0, r0
}
 800a162:	4770      	bx	lr

0800a164 <FLASH_SetErrorCode>:
  */
static void FLASH_SetErrorCode(void)
{
  uint32_t flags = 0U;
  
  if(__HAL_FLASH_GET_FLAG(FLASH_FLAG_WRPERR))
 800a164:	4b0c      	ldr	r3, [pc, #48]	; (800a198 <FLASH_SetErrorCode+0x34>)
 800a166:	2110      	movs	r1, #16
 800a168:	68d8      	ldr	r0, [r3, #12]
{
 800a16a:	b530      	push	{r4, r5, lr}
  if(__HAL_FLASH_GET_FLAG(FLASH_FLAG_WRPERR))
 800a16c:	0002      	movs	r2, r0
 800a16e:	400a      	ands	r2, r1
 800a170:	4208      	tst	r0, r1
 800a172:	d005      	beq.n	800a180 <FLASH_SetErrorCode+0x1c>
  {
    pFlash.ErrorCode |= HAL_FLASH_ERROR_WRP;
 800a174:	2202      	movs	r2, #2
 800a176:	4809      	ldr	r0, [pc, #36]	; (800a19c <FLASH_SetErrorCode+0x38>)
 800a178:	69c4      	ldr	r4, [r0, #28]
 800a17a:	4322      	orrs	r2, r4
 800a17c:	61c2      	str	r2, [r0, #28]
    flags |= FLASH_FLAG_WRPERR;
 800a17e:	000a      	movs	r2, r1
  }
  if(__HAL_FLASH_GET_FLAG(FLASH_FLAG_PGERR))
 800a180:	2004      	movs	r0, #4
 800a182:	68d9      	ldr	r1, [r3, #12]
 800a184:	4201      	tst	r1, r0
 800a186:	d005      	beq.n	800a194 <FLASH_SetErrorCode+0x30>
  {
    pFlash.ErrorCode |= HAL_FLASH_ERROR_PROG;
 800a188:	2101      	movs	r1, #1
 800a18a:	4c04      	ldr	r4, [pc, #16]	; (800a19c <FLASH_SetErrorCode+0x38>)
    flags |= FLASH_FLAG_PGERR;
 800a18c:	4302      	orrs	r2, r0
    pFlash.ErrorCode |= HAL_FLASH_ERROR_PROG;
 800a18e:	69e5      	ldr	r5, [r4, #28]
 800a190:	4329      	orrs	r1, r5
 800a192:	61e1      	str	r1, [r4, #28]
  }
  /* Clear FLASH error pending bits */
  __HAL_FLASH_CLEAR_FLAG(flags);
 800a194:	60da      	str	r2, [r3, #12]
}  
 800a196:	bd30      	pop	{r4, r5, pc}
 800a198:	40022000 	.word	0x40022000
 800a19c:	20002238 	.word	0x20002238

0800a1a0 <HAL_FLASH_EndOfOperationCallback>:
}
 800a1a0:	4770      	bx	lr

0800a1a2 <HAL_FLASH_OperationErrorCallback>:
 800a1a2:	4770      	bx	lr

0800a1a4 <HAL_FLASH_IRQHandler>:
{
 800a1a4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  if(__HAL_FLASH_GET_FLAG(FLASH_FLAG_WRPERR) ||__HAL_FLASH_GET_FLAG(FLASH_FLAG_PGERR))
 800a1a6:	4d43      	ldr	r5, [pc, #268]	; (800a2b4 <HAL_FLASH_IRQHandler+0x110>)
 800a1a8:	4c43      	ldr	r4, [pc, #268]	; (800a2b8 <HAL_FLASH_IRQHandler+0x114>)
 800a1aa:	68eb      	ldr	r3, [r5, #12]
 800a1ac:	06db      	lsls	r3, r3, #27
 800a1ae:	d402      	bmi.n	800a1b6 <HAL_FLASH_IRQHandler+0x12>
 800a1b0:	68eb      	ldr	r3, [r5, #12]
 800a1b2:	075b      	lsls	r3, r3, #29
 800a1b4:	d50a      	bpl.n	800a1cc <HAL_FLASH_IRQHandler+0x28>
    pFlash.Address = 0xFFFFFFFFU;
 800a1b6:	2301      	movs	r3, #1
    addresstmp = pFlash.Address;
 800a1b8:	68a6      	ldr	r6, [r4, #8]
    pFlash.Address = 0xFFFFFFFFU;
 800a1ba:	425b      	negs	r3, r3
 800a1bc:	60a3      	str	r3, [r4, #8]
    FLASH_SetErrorCode();
 800a1be:	f7ff ffd1 	bl	800a164 <FLASH_SetErrorCode>
    HAL_FLASH_OperationErrorCallback(addresstmp);
 800a1c2:	0030      	movs	r0, r6
 800a1c4:	f7ff ffed 	bl	800a1a2 <HAL_FLASH_OperationErrorCallback>
    pFlash.ProcedureOnGoing = FLASH_PROC_NONE;
 800a1c8:	2300      	movs	r3, #0
 800a1ca:	7023      	strb	r3, [r4, #0]
  if(__HAL_FLASH_GET_FLAG(FLASH_FLAG_EOP))
 800a1cc:	2320      	movs	r3, #32
 800a1ce:	68ea      	ldr	r2, [r5, #12]
 800a1d0:	421a      	tst	r2, r3
 800a1d2:	d01a      	beq.n	800a20a <HAL_FLASH_IRQHandler+0x66>
    __HAL_FLASH_CLEAR_FLAG(FLASH_FLAG_EOP);
 800a1d4:	60eb      	str	r3, [r5, #12]
    if(pFlash.ProcedureOnGoing != FLASH_PROC_NONE)
 800a1d6:	7823      	ldrb	r3, [r4, #0]
 800a1d8:	2b00      	cmp	r3, #0
 800a1da:	d016      	beq.n	800a20a <HAL_FLASH_IRQHandler+0x66>
      if(pFlash.ProcedureOnGoing == FLASH_PROC_PAGEERASE)
 800a1dc:	7823      	ldrb	r3, [r4, #0]
 800a1de:	2b01      	cmp	r3, #1
 800a1e0:	d128      	bne.n	800a234 <HAL_FLASH_IRQHandler+0x90>
        pFlash.DataRemaining--;
 800a1e2:	6863      	ldr	r3, [r4, #4]
 800a1e4:	3b01      	subs	r3, #1
 800a1e6:	6063      	str	r3, [r4, #4]
        if(pFlash.DataRemaining != 0U)
 800a1e8:	6863      	ldr	r3, [r4, #4]
 800a1ea:	2b00      	cmp	r3, #0
 800a1ec:	d01b      	beq.n	800a226 <HAL_FLASH_IRQHandler+0x82>
          addresstmp = pFlash.Address;
 800a1ee:	68a0      	ldr	r0, [r4, #8]
          HAL_FLASH_EndOfOperationCallback(addresstmp);
 800a1f0:	f7ff ffd6 	bl	800a1a0 <HAL_FLASH_EndOfOperationCallback>
          addresstmp = pFlash.Address + FLASH_PAGE_SIZE;
 800a1f4:	2380      	movs	r3, #128	; 0x80
          CLEAR_BIT(FLASH->CR, FLASH_CR_PER);
 800a1f6:	2202      	movs	r2, #2
          addresstmp = pFlash.Address + FLASH_PAGE_SIZE;
 800a1f8:	68a0      	ldr	r0, [r4, #8]
 800a1fa:	011b      	lsls	r3, r3, #4
 800a1fc:	18c0      	adds	r0, r0, r3
          pFlash.Address = addresstmp;
 800a1fe:	60a0      	str	r0, [r4, #8]
          CLEAR_BIT(FLASH->CR, FLASH_CR_PER);
 800a200:	692b      	ldr	r3, [r5, #16]
 800a202:	4393      	bics	r3, r2
 800a204:	612b      	str	r3, [r5, #16]
          FLASH_PageErase(addresstmp);
 800a206:	f000 f85b 	bl	800a2c0 <FLASH_PageErase>
  if(pFlash.ProcedureOnGoing == FLASH_PROC_NONE)
 800a20a:	7823      	ldrb	r3, [r4, #0]
 800a20c:	b2da      	uxtb	r2, r3
 800a20e:	2b00      	cmp	r3, #0
 800a210:	d108      	bne.n	800a224 <HAL_FLASH_IRQHandler+0x80>
    CLEAR_BIT(FLASH->CR, (FLASH_CR_PG | FLASH_CR_PER | FLASH_CR_MER));
 800a212:	2107      	movs	r1, #7
 800a214:	692b      	ldr	r3, [r5, #16]
 800a216:	438b      	bics	r3, r1
 800a218:	612b      	str	r3, [r5, #16]
    __HAL_FLASH_DISABLE_IT(FLASH_IT_EOP | FLASH_IT_ERR);
 800a21a:	692b      	ldr	r3, [r5, #16]
 800a21c:	4927      	ldr	r1, [pc, #156]	; (800a2bc <HAL_FLASH_IRQHandler+0x118>)
 800a21e:	400b      	ands	r3, r1
 800a220:	612b      	str	r3, [r5, #16]
    __HAL_UNLOCK(&pFlash);
 800a222:	7622      	strb	r2, [r4, #24]
}
 800a224:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
          pFlash.Address = addresstmp = 0xFFFFFFFFU;
 800a226:	2001      	movs	r0, #1
 800a228:	4240      	negs	r0, r0
 800a22a:	60a0      	str	r0, [r4, #8]
          pFlash.ProcedureOnGoing = FLASH_PROC_NONE;
 800a22c:	7023      	strb	r3, [r4, #0]
          HAL_FLASH_EndOfOperationCallback(addresstmp);
 800a22e:	f7ff ffb7 	bl	800a1a0 <HAL_FLASH_EndOfOperationCallback>
 800a232:	e7ea      	b.n	800a20a <HAL_FLASH_IRQHandler+0x66>
      else if(pFlash.ProcedureOnGoing == FLASH_PROC_MASSERASE)
 800a234:	7823      	ldrb	r3, [r4, #0]
 800a236:	2b02      	cmp	r3, #2
 800a238:	d109      	bne.n	800a24e <HAL_FLASH_IRQHandler+0xaa>
        CLEAR_BIT(FLASH->CR, FLASH_CR_MER);
 800a23a:	2204      	movs	r2, #4
 800a23c:	692b      	ldr	r3, [r5, #16]
          HAL_FLASH_EndOfOperationCallback(0);
 800a23e:	2000      	movs	r0, #0
        CLEAR_BIT(FLASH->CR, FLASH_CR_MER);
 800a240:	4393      	bics	r3, r2
 800a242:	612b      	str	r3, [r5, #16]
          HAL_FLASH_EndOfOperationCallback(0);
 800a244:	f7ff ffac 	bl	800a1a0 <HAL_FLASH_EndOfOperationCallback>
          pFlash.ProcedureOnGoing = FLASH_PROC_NONE;
 800a248:	2300      	movs	r3, #0
 800a24a:	7023      	strb	r3, [r4, #0]
 800a24c:	e7dd      	b.n	800a20a <HAL_FLASH_IRQHandler+0x66>
        pFlash.DataRemaining--;
 800a24e:	6863      	ldr	r3, [r4, #4]
 800a250:	3b01      	subs	r3, #1
 800a252:	6063      	str	r3, [r4, #4]
        if(pFlash.DataRemaining != 0U)
 800a254:	6863      	ldr	r3, [r4, #4]
 800a256:	2b00      	cmp	r3, #0
 800a258:	d019      	beq.n	800a28e <HAL_FLASH_IRQHandler+0xea>
          pFlash.Address += 2;
 800a25a:	68a3      	ldr	r3, [r4, #8]
 800a25c:	3302      	adds	r3, #2
 800a25e:	60a3      	str	r3, [r4, #8]
          addresstmp = pFlash.Address;
 800a260:	68a6      	ldr	r6, [r4, #8]
          pFlash.Data = (pFlash.Data >> 16U);
 800a262:	6920      	ldr	r0, [r4, #16]
 800a264:	6961      	ldr	r1, [r4, #20]
 800a266:	0c0b      	lsrs	r3, r1, #16
 800a268:	040f      	lsls	r7, r1, #16
          CLEAR_BIT(FLASH->CR, FLASH_CR_PG);
 800a26a:	2101      	movs	r1, #1
          pFlash.Data = (pFlash.Data >> 16U);
 800a26c:	0c02      	lsrs	r2, r0, #16
 800a26e:	433a      	orrs	r2, r7
 800a270:	6122      	str	r2, [r4, #16]
 800a272:	6163      	str	r3, [r4, #20]
          CLEAR_BIT(FLASH->CR, FLASH_CR_PG);
 800a274:	692b      	ldr	r3, [r5, #16]
 800a276:	438b      	bics	r3, r1
 800a278:	612b      	str	r3, [r5, #16]
          FLASH_Program_HalfWord(addresstmp, (uint16_t)pFlash.Data);
 800a27a:	6922      	ldr	r2, [r4, #16]
 800a27c:	6963      	ldr	r3, [r4, #20]
  pFlash.ErrorCode = HAL_FLASH_ERROR_NONE;
 800a27e:	2300      	movs	r3, #0
 800a280:	61e3      	str	r3, [r4, #28]
    SET_BIT(FLASH->CR, FLASH_CR_PG);
 800a282:	692b      	ldr	r3, [r5, #16]
          FLASH_Program_HalfWord(addresstmp, (uint16_t)pFlash.Data);
 800a284:	b292      	uxth	r2, r2
    SET_BIT(FLASH->CR, FLASH_CR_PG);
 800a286:	4319      	orrs	r1, r3
 800a288:	6129      	str	r1, [r5, #16]
  *(__IO uint16_t*)Address = Data;
 800a28a:	8032      	strh	r2, [r6, #0]
}
 800a28c:	e7bd      	b.n	800a20a <HAL_FLASH_IRQHandler+0x66>
          if (pFlash.ProcedureOnGoing == FLASH_PROC_PROGRAMHALFWORD)
 800a28e:	7823      	ldrb	r3, [r4, #0]
 800a290:	2b03      	cmp	r3, #3
 800a292:	d106      	bne.n	800a2a2 <HAL_FLASH_IRQHandler+0xfe>
            HAL_FLASH_EndOfOperationCallback(pFlash.Address);
 800a294:	68a0      	ldr	r0, [r4, #8]
            HAL_FLASH_EndOfOperationCallback(pFlash.Address - 6U);
 800a296:	f7ff ff83 	bl	800a1a0 <HAL_FLASH_EndOfOperationCallback>
          pFlash.Address = 0xFFFFFFFFU;
 800a29a:	2301      	movs	r3, #1
 800a29c:	425b      	negs	r3, r3
 800a29e:	60a3      	str	r3, [r4, #8]
 800a2a0:	e7d2      	b.n	800a248 <HAL_FLASH_IRQHandler+0xa4>
          else if (pFlash.ProcedureOnGoing == FLASH_PROC_PROGRAMWORD)
 800a2a2:	7823      	ldrb	r3, [r4, #0]
            HAL_FLASH_EndOfOperationCallback(pFlash.Address - 2U);
 800a2a4:	68a0      	ldr	r0, [r4, #8]
          else if (pFlash.ProcedureOnGoing == FLASH_PROC_PROGRAMWORD)
 800a2a6:	2b04      	cmp	r3, #4
 800a2a8:	d101      	bne.n	800a2ae <HAL_FLASH_IRQHandler+0x10a>
            HAL_FLASH_EndOfOperationCallback(pFlash.Address - 2U);
 800a2aa:	3802      	subs	r0, #2
 800a2ac:	e7f3      	b.n	800a296 <HAL_FLASH_IRQHandler+0xf2>
            HAL_FLASH_EndOfOperationCallback(pFlash.Address - 6U);
 800a2ae:	3806      	subs	r0, #6
 800a2b0:	e7f1      	b.n	800a296 <HAL_FLASH_IRQHandler+0xf2>
 800a2b2:	46c0      	nop			; (mov r8, r8)
 800a2b4:	40022000 	.word	0x40022000
 800a2b8:	20002238 	.word	0x20002238
 800a2bc:	ffffebff 	.word	0xffffebff

0800a2c0 <FLASH_PageErase>:
  * @retval None
  */
void FLASH_PageErase(uint32_t PageAddress)
{
  /* Clean the error context */
  pFlash.ErrorCode = HAL_FLASH_ERROR_NONE;
 800a2c0:	2200      	movs	r2, #0
 800a2c2:	4b06      	ldr	r3, [pc, #24]	; (800a2dc <FLASH_PageErase+0x1c>)
 800a2c4:	61da      	str	r2, [r3, #28]

    /* Proceed to erase the page */
    SET_BIT(FLASH->CR, FLASH_CR_PER);
 800a2c6:	4b06      	ldr	r3, [pc, #24]	; (800a2e0 <FLASH_PageErase+0x20>)
 800a2c8:	3202      	adds	r2, #2
 800a2ca:	6919      	ldr	r1, [r3, #16]
 800a2cc:	430a      	orrs	r2, r1
 800a2ce:	611a      	str	r2, [r3, #16]
    WRITE_REG(FLASH->AR, PageAddress);
    SET_BIT(FLASH->CR, FLASH_CR_STRT);
 800a2d0:	2240      	movs	r2, #64	; 0x40
    WRITE_REG(FLASH->AR, PageAddress);
 800a2d2:	6158      	str	r0, [r3, #20]
    SET_BIT(FLASH->CR, FLASH_CR_STRT);
 800a2d4:	6919      	ldr	r1, [r3, #16]
 800a2d6:	430a      	orrs	r2, r1
 800a2d8:	611a      	str	r2, [r3, #16]
}
 800a2da:	4770      	bx	lr
 800a2dc:	20002238 	.word	0x20002238
 800a2e0:	40022000 	.word	0x40022000

0800a2e4 <HAL_GPIO_Init>:
  uint32_t position = 0x00u;
  uint32_t iocurrent;
  uint32_t temp;

  /* Check the parameters */
  assert_param(IS_GPIO_ALL_INSTANCE(GPIOx));
 800a2e4:	2390      	movs	r3, #144	; 0x90
{ 
 800a2e6:	b5f0      	push	{r4, r5, r6, r7, lr}
  assert_param(IS_GPIO_ALL_INSTANCE(GPIOx));
 800a2e8:	05db      	lsls	r3, r3, #23
{ 
 800a2ea:	0004      	movs	r4, r0
 800a2ec:	000d      	movs	r5, r1
 800a2ee:	b085      	sub	sp, #20
  assert_param(IS_GPIO_ALL_INSTANCE(GPIOx));
 800a2f0:	4298      	cmp	r0, r3
 800a2f2:	d00f      	beq.n	800a314 <HAL_GPIO_Init+0x30>
 800a2f4:	4b83      	ldr	r3, [pc, #524]	; (800a504 <HAL_GPIO_Init+0x220>)
 800a2f6:	4298      	cmp	r0, r3
 800a2f8:	d00c      	beq.n	800a314 <HAL_GPIO_Init+0x30>
 800a2fa:	4b83      	ldr	r3, [pc, #524]	; (800a508 <HAL_GPIO_Init+0x224>)
 800a2fc:	4298      	cmp	r0, r3
 800a2fe:	d009      	beq.n	800a314 <HAL_GPIO_Init+0x30>
 800a300:	4b82      	ldr	r3, [pc, #520]	; (800a50c <HAL_GPIO_Init+0x228>)
 800a302:	4298      	cmp	r0, r3
 800a304:	d006      	beq.n	800a314 <HAL_GPIO_Init+0x30>
 800a306:	4b82      	ldr	r3, [pc, #520]	; (800a510 <HAL_GPIO_Init+0x22c>)
 800a308:	4298      	cmp	r0, r3
 800a30a:	d003      	beq.n	800a314 <HAL_GPIO_Init+0x30>
 800a30c:	21b8      	movs	r1, #184	; 0xb8
 800a30e:	4881      	ldr	r0, [pc, #516]	; (800a514 <HAL_GPIO_Init+0x230>)
 800a310:	f7fe fb0e 	bl	8008930 <assert_failed>
  assert_param(IS_GPIO_PIN(GPIO_Init->Pin));
 800a314:	682b      	ldr	r3, [r5, #0]
 800a316:	b29a      	uxth	r2, r3
 800a318:	2a00      	cmp	r2, #0
 800a31a:	d001      	beq.n	800a320 <HAL_GPIO_Init+0x3c>
 800a31c:	0c1b      	lsrs	r3, r3, #16
 800a31e:	d003      	beq.n	800a328 <HAL_GPIO_Init+0x44>
 800a320:	21b9      	movs	r1, #185	; 0xb9
 800a322:	487c      	ldr	r0, [pc, #496]	; (800a514 <HAL_GPIO_Init+0x230>)
 800a324:	f7fe fb04 	bl	8008930 <assert_failed>
  assert_param(IS_GPIO_MODE(GPIO_Init->Mode));
 800a328:	686b      	ldr	r3, [r5, #4]
 800a32a:	2b03      	cmp	r3, #3
 800a32c:	d912      	bls.n	800a354 <HAL_GPIO_Init+0x70>
 800a32e:	001a      	movs	r2, r3
 800a330:	3a11      	subs	r2, #17
 800a332:	2a01      	cmp	r2, #1
 800a334:	d90e      	bls.n	800a354 <HAL_GPIO_Init+0x70>
 800a336:	4a78      	ldr	r2, [pc, #480]	; (800a518 <HAL_GPIO_Init+0x234>)
 800a338:	4978      	ldr	r1, [pc, #480]	; (800a51c <HAL_GPIO_Init+0x238>)
 800a33a:	401a      	ands	r2, r3
 800a33c:	1852      	adds	r2, r2, r1
 800a33e:	4978      	ldr	r1, [pc, #480]	; (800a520 <HAL_GPIO_Init+0x23c>)
 800a340:	420a      	tst	r2, r1
 800a342:	d007      	beq.n	800a354 <HAL_GPIO_Init+0x70>
 800a344:	4a77      	ldr	r2, [pc, #476]	; (800a524 <HAL_GPIO_Init+0x240>)
 800a346:	189b      	adds	r3, r3, r2
 800a348:	420b      	tst	r3, r1
 800a34a:	d003      	beq.n	800a354 <HAL_GPIO_Init+0x70>
 800a34c:	21ba      	movs	r1, #186	; 0xba
 800a34e:	4871      	ldr	r0, [pc, #452]	; (800a514 <HAL_GPIO_Init+0x230>)
 800a350:	f7fe faee 	bl	8008930 <assert_failed>
  assert_param(IS_GPIO_PULL(GPIO_Init->Pull));
 800a354:	68ab      	ldr	r3, [r5, #8]
 800a356:	2b02      	cmp	r3, #2
 800a358:	d903      	bls.n	800a362 <HAL_GPIO_Init+0x7e>
 800a35a:	21bb      	movs	r1, #187	; 0xbb
 800a35c:	486d      	ldr	r0, [pc, #436]	; (800a514 <HAL_GPIO_Init+0x230>)
 800a35e:	f7fe fae7 	bl	8008930 <assert_failed>
        /* Enable SYSCFG Clock */
        __HAL_RCC_SYSCFG_CLK_ENABLE();

        temp = SYSCFG->EXTICR[position >> 2u];
        temp &= ~(0x0FuL << (4u * (position & 0x03u)));
        temp |= (GPIO_GET_INDEX(GPIOx) << (4u * (position & 0x03u)));
 800a362:	2700      	movs	r7, #0
  while (((GPIO_Init->Pin) >> position) != 0x00u)
 800a364:	682b      	ldr	r3, [r5, #0]
 800a366:	001a      	movs	r2, r3
 800a368:	40fa      	lsrs	r2, r7
 800a36a:	d101      	bne.n	800a370 <HAL_GPIO_Init+0x8c>
      }
    }

    position++;
  } 
}
 800a36c:	b005      	add	sp, #20
 800a36e:	bdf0      	pop	{r4, r5, r6, r7, pc}
    iocurrent = (GPIO_Init->Pin) & (1uL << position);
 800a370:	2201      	movs	r2, #1
 800a372:	40ba      	lsls	r2, r7
 800a374:	9201      	str	r2, [sp, #4]
 800a376:	401a      	ands	r2, r3
 800a378:	9200      	str	r2, [sp, #0]
    if (iocurrent != 0x00u)
 800a37a:	9a01      	ldr	r2, [sp, #4]
 800a37c:	4213      	tst	r3, r2
 800a37e:	d100      	bne.n	800a382 <HAL_GPIO_Init+0x9e>
 800a380:	e0be      	b.n	800a500 <HAL_GPIO_Init+0x21c>
      if((GPIO_Init->Mode == GPIO_MODE_OUTPUT_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_PP) ||
 800a382:	2210      	movs	r2, #16
 800a384:	686b      	ldr	r3, [r5, #4]
 800a386:	007e      	lsls	r6, r7, #1
 800a388:	4393      	bics	r3, r2
 800a38a:	3b01      	subs	r3, #1
 800a38c:	2b01      	cmp	r3, #1
 800a38e:	d81b      	bhi.n	800a3c8 <HAL_GPIO_Init+0xe4>
        assert_param(IS_GPIO_SPEED(GPIO_Init->Speed));
 800a390:	68eb      	ldr	r3, [r5, #12]
 800a392:	2b01      	cmp	r3, #1
 800a394:	d905      	bls.n	800a3a2 <HAL_GPIO_Init+0xbe>
 800a396:	2b03      	cmp	r3, #3
 800a398:	d003      	beq.n	800a3a2 <HAL_GPIO_Init+0xbe>
 800a39a:	21cb      	movs	r1, #203	; 0xcb
 800a39c:	485d      	ldr	r0, [pc, #372]	; (800a514 <HAL_GPIO_Init+0x230>)
 800a39e:	f7fe fac7 	bl	8008930 <assert_failed>
        temp &= ~(GPIO_OSPEEDER_OSPEEDR0 << (position * 2u));
 800a3a2:	2203      	movs	r2, #3
 800a3a4:	40b2      	lsls	r2, r6
        temp = GPIOx->OSPEEDR;
 800a3a6:	68a3      	ldr	r3, [r4, #8]
        temp |= (((GPIO_Init->Mode & GPIO_OUTPUT_TYPE) >> 4u) << position);
 800a3a8:	2101      	movs	r1, #1
        temp &= ~(GPIO_OSPEEDER_OSPEEDR0 << (position * 2u));
 800a3aa:	4393      	bics	r3, r2
 800a3ac:	001a      	movs	r2, r3
        temp |= (GPIO_Init->Speed << (position * 2u));
 800a3ae:	68eb      	ldr	r3, [r5, #12]
 800a3b0:	40b3      	lsls	r3, r6
 800a3b2:	4313      	orrs	r3, r2
        GPIOx->OSPEEDR = temp;
 800a3b4:	60a3      	str	r3, [r4, #8]
        temp = GPIOx->OTYPER;
 800a3b6:	6862      	ldr	r2, [r4, #4]
        temp &= ~(GPIO_OTYPER_OT_0 << position) ;
 800a3b8:	9b01      	ldr	r3, [sp, #4]
 800a3ba:	439a      	bics	r2, r3
        temp |= (((GPIO_Init->Mode & GPIO_OUTPUT_TYPE) >> 4u) << position);
 800a3bc:	686b      	ldr	r3, [r5, #4]
 800a3be:	091b      	lsrs	r3, r3, #4
 800a3c0:	400b      	ands	r3, r1
 800a3c2:	40bb      	lsls	r3, r7
 800a3c4:	4313      	orrs	r3, r2
        GPIOx->OTYPER = temp;
 800a3c6:	6063      	str	r3, [r4, #4]
      temp &= ~(GPIO_PUPDR_PUPDR0 << (position * 2u));
 800a3c8:	2203      	movs	r2, #3
 800a3ca:	40b2      	lsls	r2, r6
      temp = GPIOx->PUPDR;
 800a3cc:	68e3      	ldr	r3, [r4, #12]
      temp &= ~(GPIO_PUPDR_PUPDR0 << (position * 2u));
 800a3ce:	43d1      	mvns	r1, r2
 800a3d0:	4393      	bics	r3, r2
 800a3d2:	001a      	movs	r2, r3
      temp |= ((GPIO_Init->Pull) << (position * 2u));
 800a3d4:	68ab      	ldr	r3, [r5, #8]
      temp &= ~(GPIO_PUPDR_PUPDR0 << (position * 2u));
 800a3d6:	9101      	str	r1, [sp, #4]
      temp |= ((GPIO_Init->Pull) << (position * 2u));
 800a3d8:	40b3      	lsls	r3, r6
 800a3da:	4313      	orrs	r3, r2
      if((GPIO_Init->Mode == GPIO_MODE_AF_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_OD))
 800a3dc:	2210      	movs	r2, #16
      GPIOx->PUPDR = temp;
 800a3de:	60e3      	str	r3, [r4, #12]
      if((GPIO_Init->Mode == GPIO_MODE_AF_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_OD))
 800a3e0:	686b      	ldr	r3, [r5, #4]
 800a3e2:	4393      	bics	r3, r2
 800a3e4:	2b02      	cmp	r3, #2
 800a3e6:	d129      	bne.n	800a43c <HAL_GPIO_Init+0x158>
        assert_param(IS_GPIO_AF_INSTANCE(GPIOx));
 800a3e8:	2390      	movs	r3, #144	; 0x90
 800a3ea:	05db      	lsls	r3, r3, #23
 800a3ec:	429c      	cmp	r4, r3
 800a3ee:	d00f      	beq.n	800a410 <HAL_GPIO_Init+0x12c>
 800a3f0:	4b44      	ldr	r3, [pc, #272]	; (800a504 <HAL_GPIO_Init+0x220>)
 800a3f2:	429c      	cmp	r4, r3
 800a3f4:	d00c      	beq.n	800a410 <HAL_GPIO_Init+0x12c>
 800a3f6:	4b44      	ldr	r3, [pc, #272]	; (800a508 <HAL_GPIO_Init+0x224>)
 800a3f8:	429c      	cmp	r4, r3
 800a3fa:	d009      	beq.n	800a410 <HAL_GPIO_Init+0x12c>
 800a3fc:	4b43      	ldr	r3, [pc, #268]	; (800a50c <HAL_GPIO_Init+0x228>)
 800a3fe:	429c      	cmp	r4, r3
 800a400:	d006      	beq.n	800a410 <HAL_GPIO_Init+0x12c>
 800a402:	4b43      	ldr	r3, [pc, #268]	; (800a510 <HAL_GPIO_Init+0x22c>)
 800a404:	429c      	cmp	r4, r3
 800a406:	d003      	beq.n	800a410 <HAL_GPIO_Init+0x12c>
 800a408:	21e3      	movs	r1, #227	; 0xe3
 800a40a:	4842      	ldr	r0, [pc, #264]	; (800a514 <HAL_GPIO_Init+0x230>)
 800a40c:	f7fe fa90 	bl	8008930 <assert_failed>
        assert_param(IS_GPIO_AF(GPIO_Init->Alternate));
 800a410:	692b      	ldr	r3, [r5, #16]
 800a412:	2b06      	cmp	r3, #6
 800a414:	d903      	bls.n	800a41e <HAL_GPIO_Init+0x13a>
 800a416:	21e4      	movs	r1, #228	; 0xe4
 800a418:	483e      	ldr	r0, [pc, #248]	; (800a514 <HAL_GPIO_Init+0x230>)
 800a41a:	f7fe fa89 	bl	8008930 <assert_failed>
        temp &= ~(0xFu << ((position & 0x07u) * 4u));
 800a41e:	2207      	movs	r2, #7
 800a420:	200f      	movs	r0, #15
 800a422:	403a      	ands	r2, r7
 800a424:	0092      	lsls	r2, r2, #2
 800a426:	4090      	lsls	r0, r2
        temp = GPIOx->AFR[position >> 3u];
 800a428:	08fb      	lsrs	r3, r7, #3
 800a42a:	009b      	lsls	r3, r3, #2
 800a42c:	18e3      	adds	r3, r4, r3
 800a42e:	6a19      	ldr	r1, [r3, #32]
        temp &= ~(0xFu << ((position & 0x07u) * 4u));
 800a430:	4381      	bics	r1, r0
        temp |= ((GPIO_Init->Alternate) << ((position & 0x07u) * 4u));
 800a432:	6928      	ldr	r0, [r5, #16]
 800a434:	4090      	lsls	r0, r2
 800a436:	0002      	movs	r2, r0
 800a438:	430a      	orrs	r2, r1
        GPIOx->AFR[position >> 3u] = temp;
 800a43a:	621a      	str	r2, [r3, #32]
      temp = GPIOx->MODER;
 800a43c:	6821      	ldr	r1, [r4, #0]
      temp &= ~(GPIO_MODER_MODER0 << (position * 2u));
 800a43e:	9b01      	ldr	r3, [sp, #4]
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2u));
 800a440:	686a      	ldr	r2, [r5, #4]
      temp &= ~(GPIO_MODER_MODER0 << (position * 2u));
 800a442:	4019      	ands	r1, r3
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2u));
 800a444:	2303      	movs	r3, #3
 800a446:	469c      	mov	ip, r3
 800a448:	4013      	ands	r3, r2
 800a44a:	40b3      	lsls	r3, r6
 800a44c:	430b      	orrs	r3, r1
      GPIOx->MODER = temp;
 800a44e:	6023      	str	r3, [r4, #0]
      if((GPIO_Init->Mode & EXTI_MODE) == EXTI_MODE)
 800a450:	00d3      	lsls	r3, r2, #3
 800a452:	d555      	bpl.n	800a500 <HAL_GPIO_Init+0x21c>
        __HAL_RCC_SYSCFG_CLK_ENABLE();
 800a454:	2001      	movs	r0, #1
 800a456:	4b34      	ldr	r3, [pc, #208]	; (800a528 <HAL_GPIO_Init+0x244>)
        temp &= ~(0x0FuL << (4u * (position & 0x03u)));
 800a458:	260f      	movs	r6, #15
        __HAL_RCC_SYSCFG_CLK_ENABLE();
 800a45a:	6999      	ldr	r1, [r3, #24]
 800a45c:	4301      	orrs	r1, r0
 800a45e:	6199      	str	r1, [r3, #24]
 800a460:	699b      	ldr	r3, [r3, #24]
        temp = SYSCFG->EXTICR[position >> 2u];
 800a462:	08b9      	lsrs	r1, r7, #2
        __HAL_RCC_SYSCFG_CLK_ENABLE();
 800a464:	4003      	ands	r3, r0
        temp &= ~(0x0FuL << (4u * (position & 0x03u)));
 800a466:	4660      	mov	r0, ip
 800a468:	4038      	ands	r0, r7
 800a46a:	0080      	lsls	r0, r0, #2
 800a46c:	4086      	lsls	r6, r0
        __HAL_RCC_SYSCFG_CLK_ENABLE();
 800a46e:	9303      	str	r3, [sp, #12]
 800a470:	9b03      	ldr	r3, [sp, #12]
        temp = SYSCFG->EXTICR[position >> 2u];
 800a472:	4b2e      	ldr	r3, [pc, #184]	; (800a52c <HAL_GPIO_Init+0x248>)
 800a474:	0089      	lsls	r1, r1, #2
 800a476:	18c9      	adds	r1, r1, r3
 800a478:	688b      	ldr	r3, [r1, #8]
        temp &= ~(0x0FuL << (4u * (position & 0x03u)));
 800a47a:	43b3      	bics	r3, r6
        temp |= (GPIO_GET_INDEX(GPIOx) << (4u * (position & 0x03u)));
 800a47c:	2690      	movs	r6, #144	; 0x90
        temp &= ~(0x0FuL << (4u * (position & 0x03u)));
 800a47e:	9301      	str	r3, [sp, #4]
        temp |= (GPIO_GET_INDEX(GPIOx) << (4u * (position & 0x03u)));
 800a480:	05f6      	lsls	r6, r6, #23
 800a482:	2300      	movs	r3, #0
 800a484:	42b4      	cmp	r4, r6
 800a486:	d00c      	beq.n	800a4a2 <HAL_GPIO_Init+0x1be>
 800a488:	4e1e      	ldr	r6, [pc, #120]	; (800a504 <HAL_GPIO_Init+0x220>)
 800a48a:	3301      	adds	r3, #1
 800a48c:	42b4      	cmp	r4, r6
 800a48e:	d008      	beq.n	800a4a2 <HAL_GPIO_Init+0x1be>
 800a490:	4e1d      	ldr	r6, [pc, #116]	; (800a508 <HAL_GPIO_Init+0x224>)
 800a492:	3301      	adds	r3, #1
 800a494:	42b4      	cmp	r4, r6
 800a496:	d004      	beq.n	800a4a2 <HAL_GPIO_Init+0x1be>
 800a498:	4e1c      	ldr	r6, [pc, #112]	; (800a50c <HAL_GPIO_Init+0x228>)
 800a49a:	4663      	mov	r3, ip
 800a49c:	42b4      	cmp	r4, r6
 800a49e:	d000      	beq.n	800a4a2 <HAL_GPIO_Init+0x1be>
 800a4a0:	3302      	adds	r3, #2
 800a4a2:	4083      	lsls	r3, r0
 800a4a4:	9801      	ldr	r0, [sp, #4]
 800a4a6:	4303      	orrs	r3, r0
        SYSCFG->EXTICR[position >> 2u] = temp;
 800a4a8:	608b      	str	r3, [r1, #8]
        temp = EXTI->IMR;
 800a4aa:	4b21      	ldr	r3, [pc, #132]	; (800a530 <HAL_GPIO_Init+0x24c>)
        temp &= ~(iocurrent);
 800a4ac:	9900      	ldr	r1, [sp, #0]
        temp = EXTI->IMR;
 800a4ae:	681e      	ldr	r6, [r3, #0]
        temp &= ~(iocurrent);
 800a4b0:	43c8      	mvns	r0, r1
          temp |= iocurrent;
 800a4b2:	4331      	orrs	r1, r6
 800a4b4:	468c      	mov	ip, r1
        if((GPIO_Init->Mode & GPIO_MODE_IT) == GPIO_MODE_IT)
 800a4b6:	03d1      	lsls	r1, r2, #15
 800a4b8:	d402      	bmi.n	800a4c0 <HAL_GPIO_Init+0x1dc>
        temp &= ~(iocurrent);
 800a4ba:	0031      	movs	r1, r6
 800a4bc:	4001      	ands	r1, r0
 800a4be:	468c      	mov	ip, r1
        EXTI->IMR = temp;
 800a4c0:	4661      	mov	r1, ip
 800a4c2:	6019      	str	r1, [r3, #0]
        temp = EXTI->EMR;
 800a4c4:	685e      	ldr	r6, [r3, #4]
          temp |= iocurrent;
 800a4c6:	9900      	ldr	r1, [sp, #0]
 800a4c8:	4331      	orrs	r1, r6
 800a4ca:	468c      	mov	ip, r1
        if((GPIO_Init->Mode & GPIO_MODE_EVT) == GPIO_MODE_EVT)
 800a4cc:	0391      	lsls	r1, r2, #14
 800a4ce:	d402      	bmi.n	800a4d6 <HAL_GPIO_Init+0x1f2>
        temp &= ~(iocurrent);
 800a4d0:	0031      	movs	r1, r6
 800a4d2:	4001      	ands	r1, r0
 800a4d4:	468c      	mov	ip, r1
        EXTI->EMR = temp;
 800a4d6:	4661      	mov	r1, ip
 800a4d8:	6059      	str	r1, [r3, #4]
        temp = EXTI->RTSR;
 800a4da:	689e      	ldr	r6, [r3, #8]
          temp |= iocurrent;
 800a4dc:	9900      	ldr	r1, [sp, #0]
 800a4de:	4331      	orrs	r1, r6
 800a4e0:	468c      	mov	ip, r1
        if((GPIO_Init->Mode & RISING_EDGE) == RISING_EDGE)
 800a4e2:	02d1      	lsls	r1, r2, #11
 800a4e4:	d402      	bmi.n	800a4ec <HAL_GPIO_Init+0x208>
        temp &= ~(iocurrent);
 800a4e6:	0031      	movs	r1, r6
 800a4e8:	4001      	ands	r1, r0
 800a4ea:	468c      	mov	ip, r1
        EXTI->RTSR = temp;
 800a4ec:	4661      	mov	r1, ip
 800a4ee:	6099      	str	r1, [r3, #8]
        temp = EXTI->FTSR;
 800a4f0:	68de      	ldr	r6, [r3, #12]
          temp |= iocurrent;
 800a4f2:	9900      	ldr	r1, [sp, #0]
 800a4f4:	4331      	orrs	r1, r6
        if((GPIO_Init->Mode & FALLING_EDGE) == FALLING_EDGE)
 800a4f6:	0292      	lsls	r2, r2, #10
 800a4f8:	d401      	bmi.n	800a4fe <HAL_GPIO_Init+0x21a>
        temp &= ~(iocurrent);
 800a4fa:	0031      	movs	r1, r6
 800a4fc:	4001      	ands	r1, r0
        EXTI->FTSR = temp;
 800a4fe:	60d9      	str	r1, [r3, #12]
    position++;
 800a500:	3701      	adds	r7, #1
 800a502:	e72f      	b.n	800a364 <HAL_GPIO_Init+0x80>
 800a504:	48000400 	.word	0x48000400
 800a508:	48000800 	.word	0x48000800
 800a50c:	48000c00 	.word	0x48000c00
 800a510:	48001400 	.word	0x48001400
 800a514:	080107c7 	.word	0x080107c7
 800a518:	ffdfffff 	.word	0xffdfffff
 800a51c:	efef0000 	.word	0xefef0000
 800a520:	fffeffff 	.word	0xfffeffff
 800a524:	efdf0000 	.word	0xefdf0000
 800a528:	40021000 	.word	0x40021000
 800a52c:	40010000 	.word	0x40010000
 800a530:	40010400 	.word	0x40010400

0800a534 <HAL_GPIO_WritePin>:
  *            @arg GPIO_PIN_RESET: to clear the port pin
  *            @arg GPIO_PIN_SET: to set the port pin
  * @retval None
  */
void HAL_GPIO_WritePin(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin, GPIO_PinState PinState)
{
 800a534:	b570      	push	{r4, r5, r6, lr}
 800a536:	0005      	movs	r5, r0
 800a538:	000c      	movs	r4, r1
 800a53a:	0016      	movs	r6, r2
  /* Check the parameters */
  assert_param(IS_GPIO_PIN(GPIO_Pin));
 800a53c:	2900      	cmp	r1, #0
 800a53e:	d104      	bne.n	800a54a <HAL_GPIO_WritePin+0x16>
 800a540:	21a6      	movs	r1, #166	; 0xa6
 800a542:	4808      	ldr	r0, [pc, #32]	; (800a564 <HAL_GPIO_WritePin+0x30>)
 800a544:	31ff      	adds	r1, #255	; 0xff
 800a546:	f7fe f9f3 	bl	8008930 <assert_failed>
  assert_param(IS_GPIO_PIN_ACTION(PinState));
 800a54a:	2e01      	cmp	r6, #1
 800a54c:	d906      	bls.n	800a55c <HAL_GPIO_WritePin+0x28>
 800a54e:	21d3      	movs	r1, #211	; 0xd3
 800a550:	4804      	ldr	r0, [pc, #16]	; (800a564 <HAL_GPIO_WritePin+0x30>)
 800a552:	0049      	lsls	r1, r1, #1
 800a554:	f7fe f9ec 	bl	8008930 <assert_failed>

  if (PinState != GPIO_PIN_RESET)
  {
    GPIOx->BSRR = (uint32_t)GPIO_Pin;
 800a558:	61ac      	str	r4, [r5, #24]
  }
  else
  {
    GPIOx->BRR = (uint32_t)GPIO_Pin;
  }
}
 800a55a:	bd70      	pop	{r4, r5, r6, pc}
  if (PinState != GPIO_PIN_RESET)
 800a55c:	2e00      	cmp	r6, #0
 800a55e:	d1fb      	bne.n	800a558 <HAL_GPIO_WritePin+0x24>
    GPIOx->BRR = (uint32_t)GPIO_Pin;
 800a560:	62ac      	str	r4, [r5, #40]	; 0x28
}
 800a562:	e7fa      	b.n	800a55a <HAL_GPIO_WritePin+0x26>
 800a564:	080107c7 	.word	0x080107c7

0800a568 <HAL_GPIO_EXTI_Callback>:
  UNUSED(GPIO_Pin);

  /* NOTE: This function should not be modified, when the callback is needed,
            the HAL_GPIO_EXTI_Callback could be implemented in the user file
   */ 
}
 800a568:	4770      	bx	lr
	...

0800a56c <HAL_GPIO_EXTI_IRQHandler>:
  if(__HAL_GPIO_EXTI_GET_IT(GPIO_Pin) != 0x00u)
 800a56c:	4b04      	ldr	r3, [pc, #16]	; (800a580 <HAL_GPIO_EXTI_IRQHandler+0x14>)
{
 800a56e:	b510      	push	{r4, lr}
  if(__HAL_GPIO_EXTI_GET_IT(GPIO_Pin) != 0x00u)
 800a570:	695a      	ldr	r2, [r3, #20]
 800a572:	4210      	tst	r0, r2
 800a574:	d002      	beq.n	800a57c <HAL_GPIO_EXTI_IRQHandler+0x10>
    __HAL_GPIO_EXTI_CLEAR_IT(GPIO_Pin);
 800a576:	6158      	str	r0, [r3, #20]
    HAL_GPIO_EXTI_Callback(GPIO_Pin);
 800a578:	f7ff fff6 	bl	800a568 <HAL_GPIO_EXTI_Callback>
}
 800a57c:	bd10      	pop	{r4, pc}
 800a57e:	46c0      	nop			; (mov r8, r8)
 800a580:	40010400 	.word	0x40010400

0800a584 <I2C_Flush_TXDR>:
  */
static void I2C_Flush_TXDR(I2C_HandleTypeDef *hi2c)
{
  /* If a pending TXIS flag is set */
  /* Write a dummy data in TXDR to clear it */
  if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXIS) != RESET)
 800a584:	6803      	ldr	r3, [r0, #0]
 800a586:	699a      	ldr	r2, [r3, #24]
 800a588:	0792      	lsls	r2, r2, #30
 800a58a:	d501      	bpl.n	800a590 <I2C_Flush_TXDR+0xc>
  {
    hi2c->Instance->TXDR = 0x00U;
 800a58c:	2200      	movs	r2, #0
 800a58e:	629a      	str	r2, [r3, #40]	; 0x28
  }

  /* Flush TX register if not empty */
  if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXE) == RESET)
 800a590:	2201      	movs	r2, #1
 800a592:	6999      	ldr	r1, [r3, #24]
 800a594:	4211      	tst	r1, r2
 800a596:	d102      	bne.n	800a59e <I2C_Flush_TXDR+0x1a>
  {
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_TXE);
 800a598:	6999      	ldr	r1, [r3, #24]
 800a59a:	430a      	orrs	r2, r1
 800a59c:	619a      	str	r2, [r3, #24]
  }
}
 800a59e:	4770      	bx	lr

0800a5a0 <I2C_Disable_IRQ>:
  * @param  InterruptRequest Value of @ref I2C_Interrupt_configuration_definition.
  * @retval None
  */
static void I2C_Disable_IRQ(I2C_HandleTypeDef *hi2c, uint16_t InterruptRequest)
{
  uint32_t tmpisr = 0U;
 800a5a0:	2300      	movs	r3, #0
{
 800a5a2:	b510      	push	{r4, lr}

  if ((InterruptRequest & I2C_XFER_TX_IT) == I2C_XFER_TX_IT)
 800a5a4:	07ca      	lsls	r2, r1, #31
 800a5a6:	d508      	bpl.n	800a5ba <I2C_Disable_IRQ+0x1a>
  {
    /* Disable TC and TXI interrupts */
    tmpisr |= I2C_IT_TCI | I2C_IT_TXI;

    if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) != (uint32_t)HAL_I2C_STATE_LISTEN)
 800a5a8:	0003      	movs	r3, r0
 800a5aa:	3341      	adds	r3, #65	; 0x41
 800a5ac:	781a      	ldrb	r2, [r3, #0]
 800a5ae:	2328      	movs	r3, #40	; 0x28
 800a5b0:	401a      	ands	r2, r3
    tmpisr |= I2C_IT_TCI | I2C_IT_TXI;
 800a5b2:	331a      	adds	r3, #26
    if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) != (uint32_t)HAL_I2C_STATE_LISTEN)
 800a5b4:	2a28      	cmp	r2, #40	; 0x28
 800a5b6:	d000      	beq.n	800a5ba <I2C_Disable_IRQ+0x1a>
    {
      /* Disable NACK and STOP interrupts */
      tmpisr |= I2C_IT_STOPI | I2C_IT_NACKI | I2C_IT_ERRI;
 800a5b8:	33b0      	adds	r3, #176	; 0xb0
    }
  }

  if ((InterruptRequest & I2C_XFER_RX_IT) == I2C_XFER_RX_IT)
 800a5ba:	078a      	lsls	r2, r1, #30
 800a5bc:	d508      	bpl.n	800a5d0 <I2C_Disable_IRQ+0x30>
  {
    /* Disable TC and RXI interrupts */
    tmpisr |= I2C_IT_TCI | I2C_IT_RXI;

    if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) != (uint32_t)HAL_I2C_STATE_LISTEN)
 800a5be:	0002      	movs	r2, r0
 800a5c0:	2428      	movs	r4, #40	; 0x28
 800a5c2:	3241      	adds	r2, #65	; 0x41
 800a5c4:	7812      	ldrb	r2, [r2, #0]
 800a5c6:	4022      	ands	r2, r4
 800a5c8:	42a2      	cmp	r2, r4
 800a5ca:	d10b      	bne.n	800a5e4 <I2C_Disable_IRQ+0x44>
    tmpisr |= I2C_IT_TCI | I2C_IT_RXI;
 800a5cc:	2244      	movs	r2, #68	; 0x44
    {
      /* Disable NACK and STOP interrupts */
      tmpisr |= I2C_IT_STOPI | I2C_IT_NACKI | I2C_IT_ERRI;
 800a5ce:	4313      	orrs	r3, r2
    }
  }

  if ((InterruptRequest & I2C_XFER_LISTEN_IT) == I2C_XFER_LISTEN_IT)
 800a5d0:	b209      	sxth	r1, r1
 800a5d2:	2900      	cmp	r1, #0
 800a5d4:	da01      	bge.n	800a5da <I2C_Disable_IRQ+0x3a>
  {
    /* Disable ADDR, NACK and STOP interrupts */
    tmpisr |= I2C_IT_ADDRI | I2C_IT_STOPI | I2C_IT_NACKI | I2C_IT_ERRI;
 800a5d6:	22b8      	movs	r2, #184	; 0xb8
 800a5d8:	4313      	orrs	r3, r2
  }

  /* Disable interrupts only at the end */
  /* to avoid a breaking situation like at "t" time */
  /* all disable interrupts request are not done */
  __HAL_I2C_DISABLE_IT(hi2c, tmpisr);
 800a5da:	6801      	ldr	r1, [r0, #0]
 800a5dc:	680a      	ldr	r2, [r1, #0]
 800a5de:	439a      	bics	r2, r3
 800a5e0:	600a      	str	r2, [r1, #0]
}
 800a5e2:	bd10      	pop	{r4, pc}
      tmpisr |= I2C_IT_STOPI | I2C_IT_NACKI | I2C_IT_ERRI;
 800a5e4:	22f4      	movs	r2, #244	; 0xf4
 800a5e6:	e7f2      	b.n	800a5ce <I2C_Disable_IRQ+0x2e>

0800a5e8 <HAL_I2C_Init>:
{
 800a5e8:	b570      	push	{r4, r5, r6, lr}
 800a5ea:	0004      	movs	r4, r0
    return HAL_ERROR;
 800a5ec:	2001      	movs	r0, #1
  if (hi2c == NULL)
 800a5ee:	2c00      	cmp	r4, #0
 800a5f0:	d100      	bne.n	800a5f4 <HAL_I2C_Init+0xc>
 800a5f2:	e088      	b.n	800a706 <HAL_I2C_Init+0x11e>
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
 800a5f4:	6823      	ldr	r3, [r4, #0]
 800a5f6:	4a49      	ldr	r2, [pc, #292]	; (800a71c <HAL_I2C_Init+0x134>)
 800a5f8:	4293      	cmp	r3, r2
 800a5fa:	d007      	beq.n	800a60c <HAL_I2C_Init+0x24>
 800a5fc:	4a48      	ldr	r2, [pc, #288]	; (800a720 <HAL_I2C_Init+0x138>)
 800a5fe:	4293      	cmp	r3, r2
 800a600:	d004      	beq.n	800a60c <HAL_I2C_Init+0x24>
 800a602:	21e6      	movs	r1, #230	; 0xe6
 800a604:	4847      	ldr	r0, [pc, #284]	; (800a724 <HAL_I2C_Init+0x13c>)
 800a606:	31ff      	adds	r1, #255	; 0xff
 800a608:	f7fe f992 	bl	8008930 <assert_failed>
  assert_param(IS_I2C_OWN_ADDRESS1(hi2c->Init.OwnAddress1));
 800a60c:	2380      	movs	r3, #128	; 0x80
 800a60e:	68a2      	ldr	r2, [r4, #8]
 800a610:	00db      	lsls	r3, r3, #3
 800a612:	429a      	cmp	r2, r3
 800a614:	d304      	bcc.n	800a620 <HAL_I2C_Init+0x38>
 800a616:	21f3      	movs	r1, #243	; 0xf3
 800a618:	4842      	ldr	r0, [pc, #264]	; (800a724 <HAL_I2C_Init+0x13c>)
 800a61a:	0049      	lsls	r1, r1, #1
 800a61c:	f7fe f988 	bl	8008930 <assert_failed>
  assert_param(IS_I2C_ADDRESSING_MODE(hi2c->Init.AddressingMode));
 800a620:	68e3      	ldr	r3, [r4, #12]
 800a622:	3b01      	subs	r3, #1
 800a624:	2b01      	cmp	r3, #1
 800a626:	d904      	bls.n	800a632 <HAL_I2C_Init+0x4a>
 800a628:	21e8      	movs	r1, #232	; 0xe8
 800a62a:	483e      	ldr	r0, [pc, #248]	; (800a724 <HAL_I2C_Init+0x13c>)
 800a62c:	31ff      	adds	r1, #255	; 0xff
 800a62e:	f7fe f97f 	bl	8008930 <assert_failed>
  assert_param(IS_I2C_DUAL_ADDRESS(hi2c->Init.DualAddressMode));
 800a632:	4e3d      	ldr	r6, [pc, #244]	; (800a728 <HAL_I2C_Init+0x140>)
 800a634:	6923      	ldr	r3, [r4, #16]
 800a636:	4233      	tst	r3, r6
 800a638:	d004      	beq.n	800a644 <HAL_I2C_Init+0x5c>
 800a63a:	21f4      	movs	r1, #244	; 0xf4
 800a63c:	4839      	ldr	r0, [pc, #228]	; (800a724 <HAL_I2C_Init+0x13c>)
 800a63e:	0049      	lsls	r1, r1, #1
 800a640:	f7fe f976 	bl	8008930 <assert_failed>
  assert_param(IS_I2C_OWN_ADDRESS2(hi2c->Init.OwnAddress2));
 800a644:	6963      	ldr	r3, [r4, #20]
 800a646:	2bff      	cmp	r3, #255	; 0xff
 800a648:	d904      	bls.n	800a654 <HAL_I2C_Init+0x6c>
 800a64a:	21ea      	movs	r1, #234	; 0xea
 800a64c:	4835      	ldr	r0, [pc, #212]	; (800a724 <HAL_I2C_Init+0x13c>)
 800a64e:	31ff      	adds	r1, #255	; 0xff
 800a650:	f7fe f96e 	bl	8008930 <assert_failed>
  assert_param(IS_I2C_OWN_ADDRESS2_MASK(hi2c->Init.OwnAddress2Masks));
 800a654:	69a3      	ldr	r3, [r4, #24]
 800a656:	2b07      	cmp	r3, #7
 800a658:	d904      	bls.n	800a664 <HAL_I2C_Init+0x7c>
 800a65a:	21f5      	movs	r1, #245	; 0xf5
 800a65c:	4831      	ldr	r0, [pc, #196]	; (800a724 <HAL_I2C_Init+0x13c>)
 800a65e:	0049      	lsls	r1, r1, #1
 800a660:	f7fe f966 	bl	8008930 <assert_failed>
  assert_param(IS_I2C_GENERAL_CALL(hi2c->Init.GeneralCallMode));
 800a664:	4b31      	ldr	r3, [pc, #196]	; (800a72c <HAL_I2C_Init+0x144>)
 800a666:	69e2      	ldr	r2, [r4, #28]
 800a668:	421a      	tst	r2, r3
 800a66a:	d004      	beq.n	800a676 <HAL_I2C_Init+0x8e>
 800a66c:	21ec      	movs	r1, #236	; 0xec
 800a66e:	482d      	ldr	r0, [pc, #180]	; (800a724 <HAL_I2C_Init+0x13c>)
 800a670:	31ff      	adds	r1, #255	; 0xff
 800a672:	f7fe f95d 	bl	8008930 <assert_failed>
  assert_param(IS_I2C_NO_STRETCH(hi2c->Init.NoStretchMode));
 800a676:	4b2e      	ldr	r3, [pc, #184]	; (800a730 <HAL_I2C_Init+0x148>)
 800a678:	6a22      	ldr	r2, [r4, #32]
 800a67a:	421a      	tst	r2, r3
 800a67c:	d004      	beq.n	800a688 <HAL_I2C_Init+0xa0>
 800a67e:	21f6      	movs	r1, #246	; 0xf6
 800a680:	4828      	ldr	r0, [pc, #160]	; (800a724 <HAL_I2C_Init+0x13c>)
 800a682:	0049      	lsls	r1, r1, #1
 800a684:	f7fe f954 	bl	8008930 <assert_failed>
  if (hi2c->State == HAL_I2C_STATE_RESET)
 800a688:	0025      	movs	r5, r4
 800a68a:	3541      	adds	r5, #65	; 0x41
 800a68c:	782b      	ldrb	r3, [r5, #0]
 800a68e:	b2da      	uxtb	r2, r3
 800a690:	2b00      	cmp	r3, #0
 800a692:	d105      	bne.n	800a6a0 <HAL_I2C_Init+0xb8>
    hi2c->Lock = HAL_UNLOCKED;
 800a694:	0023      	movs	r3, r4
 800a696:	3340      	adds	r3, #64	; 0x40
    HAL_I2C_MspInit(hi2c);
 800a698:	0020      	movs	r0, r4
    hi2c->Lock = HAL_UNLOCKED;
 800a69a:	701a      	strb	r2, [r3, #0]
    HAL_I2C_MspInit(hi2c);
 800a69c:	f7fe f82e 	bl	80086fc <HAL_I2C_MspInit>
  hi2c->State = HAL_I2C_STATE_BUSY;
 800a6a0:	2324      	movs	r3, #36	; 0x24
  __HAL_I2C_DISABLE(hi2c);
 800a6a2:	2101      	movs	r1, #1
  hi2c->State = HAL_I2C_STATE_BUSY;
 800a6a4:	702b      	strb	r3, [r5, #0]
  __HAL_I2C_DISABLE(hi2c);
 800a6a6:	6823      	ldr	r3, [r4, #0]
 800a6a8:	68a0      	ldr	r0, [r4, #8]
 800a6aa:	681a      	ldr	r2, [r3, #0]
 800a6ac:	438a      	bics	r2, r1
 800a6ae:	601a      	str	r2, [r3, #0]
  hi2c->Instance->TIMINGR = hi2c->Init.Timing & TIMING_CLEAR_MASK;
 800a6b0:	6861      	ldr	r1, [r4, #4]
 800a6b2:	4a20      	ldr	r2, [pc, #128]	; (800a734 <HAL_I2C_Init+0x14c>)
 800a6b4:	400a      	ands	r2, r1
 800a6b6:	611a      	str	r2, [r3, #16]
  hi2c->Instance->OAR1 &= ~I2C_OAR1_OA1EN;
 800a6b8:	689a      	ldr	r2, [r3, #8]
  if (hi2c->Init.AddressingMode == I2C_ADDRESSINGMODE_7BIT)
 800a6ba:	68e1      	ldr	r1, [r4, #12]
  hi2c->Instance->OAR1 &= ~I2C_OAR1_OA1EN;
 800a6bc:	4032      	ands	r2, r6
 800a6be:	609a      	str	r2, [r3, #8]
  if (hi2c->Init.AddressingMode == I2C_ADDRESSINGMODE_7BIT)
 800a6c0:	2901      	cmp	r1, #1
 800a6c2:	d121      	bne.n	800a708 <HAL_I2C_Init+0x120>
    hi2c->Instance->OAR1 = (I2C_OAR1_OA1EN | hi2c->Init.OwnAddress1);
 800a6c4:	2280      	movs	r2, #128	; 0x80
 800a6c6:	0212      	lsls	r2, r2, #8
 800a6c8:	4302      	orrs	r2, r0
 800a6ca:	609a      	str	r2, [r3, #8]
  hi2c->Instance->CR2 |= (I2C_CR2_AUTOEND | I2C_CR2_NACK);
 800a6cc:	6859      	ldr	r1, [r3, #4]
 800a6ce:	4a1a      	ldr	r2, [pc, #104]	; (800a738 <HAL_I2C_Init+0x150>)
  hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
 800a6d0:	2000      	movs	r0, #0
  hi2c->Instance->CR2 |= (I2C_CR2_AUTOEND | I2C_CR2_NACK);
 800a6d2:	430a      	orrs	r2, r1
 800a6d4:	605a      	str	r2, [r3, #4]
  hi2c->Instance->OAR2 &= ~I2C_DUALADDRESS_ENABLE;
 800a6d6:	68da      	ldr	r2, [r3, #12]
  hi2c->Instance->OAR2 = (hi2c->Init.DualAddressMode | hi2c->Init.OwnAddress2 | (hi2c->Init.OwnAddress2Masks << 8));
 800a6d8:	6961      	ldr	r1, [r4, #20]
  hi2c->Instance->OAR2 &= ~I2C_DUALADDRESS_ENABLE;
 800a6da:	4032      	ands	r2, r6
 800a6dc:	60da      	str	r2, [r3, #12]
  hi2c->Instance->OAR2 = (hi2c->Init.DualAddressMode | hi2c->Init.OwnAddress2 | (hi2c->Init.OwnAddress2Masks << 8));
 800a6de:	6922      	ldr	r2, [r4, #16]
 800a6e0:	430a      	orrs	r2, r1
 800a6e2:	69a1      	ldr	r1, [r4, #24]
 800a6e4:	0209      	lsls	r1, r1, #8
 800a6e6:	430a      	orrs	r2, r1
 800a6e8:	60da      	str	r2, [r3, #12]
  hi2c->Instance->CR1 = (hi2c->Init.GeneralCallMode | hi2c->Init.NoStretchMode);
 800a6ea:	6a21      	ldr	r1, [r4, #32]
 800a6ec:	69e2      	ldr	r2, [r4, #28]
 800a6ee:	430a      	orrs	r2, r1
 800a6f0:	601a      	str	r2, [r3, #0]
  __HAL_I2C_ENABLE(hi2c);
 800a6f2:	2201      	movs	r2, #1
 800a6f4:	6819      	ldr	r1, [r3, #0]
 800a6f6:	430a      	orrs	r2, r1
 800a6f8:	601a      	str	r2, [r3, #0]
  hi2c->State = HAL_I2C_STATE_READY;
 800a6fa:	2320      	movs	r3, #32
  hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
 800a6fc:	6460      	str	r0, [r4, #68]	; 0x44
  hi2c->State = HAL_I2C_STATE_READY;
 800a6fe:	702b      	strb	r3, [r5, #0]
  hi2c->PreviousState = I2C_STATE_NONE;
 800a700:	6320      	str	r0, [r4, #48]	; 0x30
  hi2c->Mode = HAL_I2C_MODE_NONE;
 800a702:	3442      	adds	r4, #66	; 0x42
 800a704:	7020      	strb	r0, [r4, #0]
}
 800a706:	bd70      	pop	{r4, r5, r6, pc}
    hi2c->Instance->OAR1 = (I2C_OAR1_OA1EN | I2C_OAR1_OA1MODE | hi2c->Init.OwnAddress1);
 800a708:	2284      	movs	r2, #132	; 0x84
 800a70a:	0212      	lsls	r2, r2, #8
 800a70c:	4302      	orrs	r2, r0
 800a70e:	609a      	str	r2, [r3, #8]
  if (hi2c->Init.AddressingMode == I2C_ADDRESSINGMODE_10BIT)
 800a710:	2902      	cmp	r1, #2
 800a712:	d1db      	bne.n	800a6cc <HAL_I2C_Init+0xe4>
    hi2c->Instance->CR2 = (I2C_CR2_ADD10);
 800a714:	2280      	movs	r2, #128	; 0x80
 800a716:	0112      	lsls	r2, r2, #4
 800a718:	605a      	str	r2, [r3, #4]
 800a71a:	e7d7      	b.n	800a6cc <HAL_I2C_Init+0xe4>
 800a71c:	40005400 	.word	0x40005400
 800a720:	40005800 	.word	0x40005800
 800a724:	08010800 	.word	0x08010800
 800a728:	ffff7fff 	.word	0xffff7fff
 800a72c:	fff7ffff 	.word	0xfff7ffff
 800a730:	fffdffff 	.word	0xfffdffff
 800a734:	f0ffffff 	.word	0xf0ffffff
 800a738:	02008000 	.word	0x02008000

0800a73c <HAL_I2C_EV_IRQHandler>:
  uint32_t itflags   = READ_REG(hi2c->Instance->ISR);
 800a73c:	6803      	ldr	r3, [r0, #0]
{
 800a73e:	b510      	push	{r4, lr}
  uint32_t itflags   = READ_REG(hi2c->Instance->ISR);
 800a740:	6999      	ldr	r1, [r3, #24]
  uint32_t itsources = READ_REG(hi2c->Instance->CR1);
 800a742:	681a      	ldr	r2, [r3, #0]
  if (hi2c->XferISR != NULL)
 800a744:	6b43      	ldr	r3, [r0, #52]	; 0x34
 800a746:	2b00      	cmp	r3, #0
 800a748:	d000      	beq.n	800a74c <HAL_I2C_EV_IRQHandler+0x10>
    hi2c->XferISR(hi2c, itflags, itsources);
 800a74a:	4798      	blx	r3
}
 800a74c:	bd10      	pop	{r4, pc}

0800a74e <HAL_I2C_SlaveTxCpltCallback>:
 800a74e:	4770      	bx	lr

0800a750 <HAL_I2C_SlaveRxCpltCallback>:
 800a750:	4770      	bx	lr
	...

0800a754 <I2C_ITSlaveSeqCplt>:
  hi2c->Mode = HAL_I2C_MODE_NONE;
 800a754:	0001      	movs	r1, r0
  uint32_t tmpcr1value = READ_REG(hi2c->Instance->CR1);
 800a756:	6803      	ldr	r3, [r0, #0]
{
 800a758:	b510      	push	{r4, lr}
 800a75a:	0004      	movs	r4, r0
  hi2c->Mode = HAL_I2C_MODE_NONE;
 800a75c:	2000      	movs	r0, #0
  uint32_t tmpcr1value = READ_REG(hi2c->Instance->CR1);
 800a75e:	681a      	ldr	r2, [r3, #0]
  hi2c->Mode = HAL_I2C_MODE_NONE;
 800a760:	3142      	adds	r1, #66	; 0x42
 800a762:	7008      	strb	r0, [r1, #0]
  if (I2C_CHECK_IT_SOURCE(tmpcr1value, I2C_CR1_TXDMAEN) != RESET)
 800a764:	2101      	movs	r1, #1
 800a766:	0450      	lsls	r0, r2, #17
 800a768:	d518      	bpl.n	800a79c <I2C_ITSlaveSeqCplt+0x48>
    hi2c->Instance->CR1 &= ~I2C_CR1_TXDMAEN;
 800a76a:	681a      	ldr	r2, [r3, #0]
 800a76c:	4918      	ldr	r1, [pc, #96]	; (800a7d0 <I2C_ITSlaveSeqCplt+0x7c>)
    hi2c->Instance->CR1 &= ~I2C_CR1_RXDMAEN;
 800a76e:	400a      	ands	r2, r1
 800a770:	601a      	str	r2, [r3, #0]
  if (hi2c->State == HAL_I2C_STATE_BUSY_TX_LISTEN)
 800a772:	0023      	movs	r3, r4
 800a774:	3341      	adds	r3, #65	; 0x41
 800a776:	781a      	ldrb	r2, [r3, #0]
 800a778:	2a29      	cmp	r2, #41	; 0x29
 800a77a:	d115      	bne.n	800a7a8 <I2C_ITSlaveSeqCplt+0x54>
    hi2c->State         = HAL_I2C_STATE_LISTEN;
 800a77c:	3a01      	subs	r2, #1
 800a77e:	701a      	strb	r2, [r3, #0]
    hi2c->PreviousState = I2C_STATE_SLAVE_BUSY_TX;
 800a780:	2321      	movs	r3, #33	; 0x21
    I2C_Disable_IRQ(hi2c, I2C_XFER_TX_IT);
 800a782:	0020      	movs	r0, r4
    hi2c->PreviousState = I2C_STATE_SLAVE_BUSY_TX;
 800a784:	6323      	str	r3, [r4, #48]	; 0x30
    I2C_Disable_IRQ(hi2c, I2C_XFER_TX_IT);
 800a786:	2101      	movs	r1, #1
 800a788:	f7ff ff0a 	bl	800a5a0 <I2C_Disable_IRQ>
    __HAL_UNLOCK(hi2c);
 800a78c:	0023      	movs	r3, r4
 800a78e:	2200      	movs	r2, #0
 800a790:	3340      	adds	r3, #64	; 0x40
    HAL_I2C_SlaveTxCpltCallback(hi2c);
 800a792:	0020      	movs	r0, r4
    __HAL_UNLOCK(hi2c);
 800a794:	701a      	strb	r2, [r3, #0]
    HAL_I2C_SlaveTxCpltCallback(hi2c);
 800a796:	f7ff ffda 	bl	800a74e <HAL_I2C_SlaveTxCpltCallback>
}
 800a79a:	bd10      	pop	{r4, pc}
  else if (I2C_CHECK_IT_SOURCE(tmpcr1value, I2C_CR1_RXDMAEN) != RESET)
 800a79c:	0bd2      	lsrs	r2, r2, #15
 800a79e:	420a      	tst	r2, r1
 800a7a0:	d0e7      	beq.n	800a772 <I2C_ITSlaveSeqCplt+0x1e>
    hi2c->Instance->CR1 &= ~I2C_CR1_RXDMAEN;
 800a7a2:	681a      	ldr	r2, [r3, #0]
 800a7a4:	490b      	ldr	r1, [pc, #44]	; (800a7d4 <I2C_ITSlaveSeqCplt+0x80>)
 800a7a6:	e7e2      	b.n	800a76e <I2C_ITSlaveSeqCplt+0x1a>
  else if (hi2c->State == HAL_I2C_STATE_BUSY_RX_LISTEN)
 800a7a8:	781a      	ldrb	r2, [r3, #0]
 800a7aa:	2a2a      	cmp	r2, #42	; 0x2a
 800a7ac:	d1f5      	bne.n	800a79a <I2C_ITSlaveSeqCplt+0x46>
    hi2c->State         = HAL_I2C_STATE_LISTEN;
 800a7ae:	3a02      	subs	r2, #2
 800a7b0:	701a      	strb	r2, [r3, #0]
    hi2c->PreviousState = I2C_STATE_SLAVE_BUSY_RX;
 800a7b2:	2322      	movs	r3, #34	; 0x22
    I2C_Disable_IRQ(hi2c, I2C_XFER_RX_IT);
 800a7b4:	0020      	movs	r0, r4
    hi2c->PreviousState = I2C_STATE_SLAVE_BUSY_RX;
 800a7b6:	6323      	str	r3, [r4, #48]	; 0x30
    I2C_Disable_IRQ(hi2c, I2C_XFER_RX_IT);
 800a7b8:	2102      	movs	r1, #2
 800a7ba:	f7ff fef1 	bl	800a5a0 <I2C_Disable_IRQ>
    __HAL_UNLOCK(hi2c);
 800a7be:	0023      	movs	r3, r4
 800a7c0:	2200      	movs	r2, #0
 800a7c2:	3340      	adds	r3, #64	; 0x40
    HAL_I2C_SlaveRxCpltCallback(hi2c);
 800a7c4:	0020      	movs	r0, r4
    __HAL_UNLOCK(hi2c);
 800a7c6:	701a      	strb	r2, [r3, #0]
    HAL_I2C_SlaveRxCpltCallback(hi2c);
 800a7c8:	f7ff ffc2 	bl	800a750 <HAL_I2C_SlaveRxCpltCallback>
}
 800a7cc:	e7e5      	b.n	800a79a <I2C_ITSlaveSeqCplt+0x46>
 800a7ce:	46c0      	nop			; (mov r8, r8)
 800a7d0:	ffffbfff 	.word	0xffffbfff
 800a7d4:	ffff7fff 	.word	0xffff7fff

0800a7d8 <HAL_I2C_AddrCallback>:
}
 800a7d8:	4770      	bx	lr

0800a7da <I2C_ITAddrCplt.isra.0>:
  if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) == (uint32_t)HAL_I2C_STATE_LISTEN)
 800a7da:	0003      	movs	r3, r0
static void I2C_ITAddrCplt(I2C_HandleTypeDef *hi2c, uint32_t ITFlags)
 800a7dc:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
  if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) == (uint32_t)HAL_I2C_STATE_LISTEN)
 800a7de:	2228      	movs	r2, #40	; 0x28
 800a7e0:	3341      	adds	r3, #65	; 0x41
 800a7e2:	781b      	ldrb	r3, [r3, #0]
static void I2C_ITAddrCplt(I2C_HandleTypeDef *hi2c, uint32_t ITFlags)
 800a7e4:	0004      	movs	r4, r0
 800a7e6:	6801      	ldr	r1, [r0, #0]
  if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) == (uint32_t)HAL_I2C_STATE_LISTEN)
 800a7e8:	4013      	ands	r3, r2
 800a7ea:	4293      	cmp	r3, r2
 800a7ec:	d13c      	bne.n	800a868 <I2C_ITAddrCplt.isra.0+0x8e>
    slaveaddrcode     = I2C_GET_ADDR_MATCH(hi2c);
 800a7ee:	27fe      	movs	r7, #254	; 0xfe
    transferdirection = I2C_GET_DIR(hi2c);
 800a7f0:	698d      	ldr	r5, [r1, #24]
    slaveaddrcode     = I2C_GET_ADDR_MATCH(hi2c);
 800a7f2:	698e      	ldr	r6, [r1, #24]
    ownadd1code       = I2C_GET_OWN_ADDRESS1(hi2c);
 800a7f4:	688b      	ldr	r3, [r1, #8]
    ownadd2code       = I2C_GET_OWN_ADDRESS2(hi2c);
 800a7f6:	68ca      	ldr	r2, [r1, #12]
    transferdirection = I2C_GET_DIR(hi2c);
 800a7f8:	03ed      	lsls	r5, r5, #15
    ownadd2code       = I2C_GET_OWN_ADDRESS2(hi2c);
 800a7fa:	9201      	str	r2, [sp, #4]
    if (hi2c->Init.AddressingMode == I2C_ADDRESSINGMODE_10BIT)
 800a7fc:	68c2      	ldr	r2, [r0, #12]
    slaveaddrcode     = I2C_GET_ADDR_MATCH(hi2c);
 800a7fe:	0c36      	lsrs	r6, r6, #16
    transferdirection = I2C_GET_DIR(hi2c);
 800a800:	0fed      	lsrs	r5, r5, #31
    slaveaddrcode     = I2C_GET_ADDR_MATCH(hi2c);
 800a802:	403e      	ands	r6, r7
    if (hi2c->Init.AddressingMode == I2C_ADDRESSINGMODE_10BIT)
 800a804:	2a02      	cmp	r2, #2
 800a806:	d125      	bne.n	800a854 <I2C_ITAddrCplt.isra.0+0x7a>
    ownadd1code       = I2C_GET_OWN_ADDRESS1(hi2c);
 800a808:	059b      	lsls	r3, r3, #22
 800a80a:	0d9a      	lsrs	r2, r3, #22
      if ((slaveaddrcode & SlaveAddr_MSK) == ((ownadd1code >> SlaveAddr_SHIFT) & SlaveAddr_MSK))
 800a80c:	0f5b      	lsrs	r3, r3, #29
 800a80e:	405e      	eors	r6, r3
 800a810:	0030      	movs	r0, r6
 800a812:	2306      	movs	r3, #6
 800a814:	4018      	ands	r0, r3
 800a816:	421e      	tst	r6, r3
 800a818:	d110      	bne.n	800a83c <I2C_ITAddrCplt.isra.0+0x62>
        hi2c->AddrEventCount++;
 800a81a:	6ca3      	ldr	r3, [r4, #72]	; 0x48
 800a81c:	3301      	adds	r3, #1
 800a81e:	64a3      	str	r3, [r4, #72]	; 0x48
        if (hi2c->AddrEventCount == 2U)
 800a820:	6ca3      	ldr	r3, [r4, #72]	; 0x48
 800a822:	2b02      	cmp	r3, #2
 800a824:	d109      	bne.n	800a83a <I2C_ITAddrCplt.isra.0+0x60>
          __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_ADDR);
 800a826:	3306      	adds	r3, #6
          hi2c->AddrEventCount = 0U;
 800a828:	64a0      	str	r0, [r4, #72]	; 0x48
          __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_ADDR);
 800a82a:	61cb      	str	r3, [r1, #28]
          __HAL_UNLOCK(hi2c);
 800a82c:	0023      	movs	r3, r4
 800a82e:	3340      	adds	r3, #64	; 0x40
 800a830:	7018      	strb	r0, [r3, #0]
      HAL_I2C_AddrCallback(hi2c, transferdirection, slaveaddrcode);
 800a832:	0029      	movs	r1, r5
 800a834:	0020      	movs	r0, r4
 800a836:	f7ff ffcf 	bl	800a7d8 <HAL_I2C_AddrCallback>
}
 800a83a:	bdf7      	pop	{r0, r1, r2, r4, r5, r6, r7, pc}
        I2C_Disable_IRQ(hi2c, I2C_XFER_LISTEN_IT);
 800a83c:	2180      	movs	r1, #128	; 0x80
 800a83e:	0020      	movs	r0, r4
 800a840:	0209      	lsls	r1, r1, #8
 800a842:	f7ff fead 	bl	800a5a0 <I2C_Disable_IRQ>
        __HAL_UNLOCK(hi2c);
 800a846:	0023      	movs	r3, r4
 800a848:	2200      	movs	r2, #0
 800a84a:	3340      	adds	r3, #64	; 0x40
 800a84c:	701a      	strb	r2, [r3, #0]
        HAL_I2C_AddrCallback(hi2c, transferdirection, slaveaddrcode);
 800a84e:	9a01      	ldr	r2, [sp, #4]
 800a850:	403a      	ands	r2, r7
 800a852:	e7ee      	b.n	800a832 <I2C_ITAddrCplt.isra.0+0x58>
      I2C_Disable_IRQ(hi2c, I2C_XFER_LISTEN_IT);
 800a854:	2180      	movs	r1, #128	; 0x80
 800a856:	0209      	lsls	r1, r1, #8
 800a858:	f7ff fea2 	bl	800a5a0 <I2C_Disable_IRQ>
      __HAL_UNLOCK(hi2c);
 800a85c:	0023      	movs	r3, r4
 800a85e:	2200      	movs	r2, #0
 800a860:	3340      	adds	r3, #64	; 0x40
 800a862:	701a      	strb	r2, [r3, #0]
      HAL_I2C_AddrCallback(hi2c, transferdirection, slaveaddrcode);
 800a864:	0032      	movs	r2, r6
 800a866:	e7e4      	b.n	800a832 <I2C_ITAddrCplt.isra.0+0x58>
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_ADDR);
 800a868:	2308      	movs	r3, #8
 800a86a:	61cb      	str	r3, [r1, #28]
    __HAL_UNLOCK(hi2c);
 800a86c:	2300      	movs	r3, #0
 800a86e:	3440      	adds	r4, #64	; 0x40
 800a870:	7023      	strb	r3, [r4, #0]
}
 800a872:	e7e2      	b.n	800a83a <I2C_ITAddrCplt.isra.0+0x60>

0800a874 <HAL_I2C_ListenCpltCallback>:
 800a874:	4770      	bx	lr
	...

0800a878 <I2C_ITListenCplt>:
  hi2c->XferOptions = I2C_NO_OPTION_FRAME;
 800a878:	4b18      	ldr	r3, [pc, #96]	; (800a8dc <I2C_ITListenCplt+0x64>)
{
 800a87a:	b510      	push	{r4, lr}
  hi2c->XferOptions = I2C_NO_OPTION_FRAME;
 800a87c:	62c3      	str	r3, [r0, #44]	; 0x2c
  hi2c->PreviousState = I2C_STATE_NONE;
 800a87e:	2300      	movs	r3, #0
  hi2c->State = HAL_I2C_STATE_READY;
 800a880:	0002      	movs	r2, r0
  hi2c->PreviousState = I2C_STATE_NONE;
 800a882:	6303      	str	r3, [r0, #48]	; 0x30
{
 800a884:	0004      	movs	r4, r0
  hi2c->State = HAL_I2C_STATE_READY;
 800a886:	2020      	movs	r0, #32
 800a888:	3241      	adds	r2, #65	; 0x41
 800a88a:	7010      	strb	r0, [r2, #0]
  hi2c->Mode = HAL_I2C_MODE_NONE;
 800a88c:	7053      	strb	r3, [r2, #1]
  hi2c->XferISR = NULL;
 800a88e:	6363      	str	r3, [r4, #52]	; 0x34
  if (I2C_CHECK_FLAG(ITFlags, I2C_FLAG_RXNE) != RESET)
 800a890:	074b      	lsls	r3, r1, #29
 800a892:	d513      	bpl.n	800a8bc <I2C_ITListenCplt+0x44>
    *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->RXDR;
 800a894:	6823      	ldr	r3, [r4, #0]
 800a896:	6a62      	ldr	r2, [r4, #36]	; 0x24
 800a898:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800a89a:	7013      	strb	r3, [r2, #0]
    hi2c->pBuffPtr++;
 800a89c:	6a63      	ldr	r3, [r4, #36]	; 0x24
 800a89e:	3301      	adds	r3, #1
 800a8a0:	6263      	str	r3, [r4, #36]	; 0x24
    if ((hi2c->XferSize > 0U))
 800a8a2:	8d23      	ldrh	r3, [r4, #40]	; 0x28
 800a8a4:	2b00      	cmp	r3, #0
 800a8a6:	d009      	beq.n	800a8bc <I2C_ITListenCplt+0x44>
      hi2c->XferSize--;
 800a8a8:	3b01      	subs	r3, #1
 800a8aa:	8523      	strh	r3, [r4, #40]	; 0x28
      hi2c->XferCount--;
 800a8ac:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
 800a8ae:	3b01      	subs	r3, #1
 800a8b0:	b29b      	uxth	r3, r3
 800a8b2:	8563      	strh	r3, [r4, #42]	; 0x2a
      hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
 800a8b4:	2304      	movs	r3, #4
 800a8b6:	6c62      	ldr	r2, [r4, #68]	; 0x44
 800a8b8:	4313      	orrs	r3, r2
 800a8ba:	6463      	str	r3, [r4, #68]	; 0x44
  I2C_Disable_IRQ(hi2c, I2C_XFER_LISTEN_IT | I2C_XFER_RX_IT | I2C_XFER_TX_IT);
 800a8bc:	0020      	movs	r0, r4
 800a8be:	4908      	ldr	r1, [pc, #32]	; (800a8e0 <I2C_ITListenCplt+0x68>)
 800a8c0:	f7ff fe6e 	bl	800a5a0 <I2C_Disable_IRQ>
  __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
 800a8c4:	2210      	movs	r2, #16
 800a8c6:	6823      	ldr	r3, [r4, #0]
  HAL_I2C_ListenCpltCallback(hi2c);
 800a8c8:	0020      	movs	r0, r4
  __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
 800a8ca:	61da      	str	r2, [r3, #28]
  __HAL_UNLOCK(hi2c);
 800a8cc:	0023      	movs	r3, r4
 800a8ce:	2200      	movs	r2, #0
 800a8d0:	3340      	adds	r3, #64	; 0x40
 800a8d2:	701a      	strb	r2, [r3, #0]
  HAL_I2C_ListenCpltCallback(hi2c);
 800a8d4:	f7ff ffce 	bl	800a874 <HAL_I2C_ListenCpltCallback>
}
 800a8d8:	bd10      	pop	{r4, pc}
 800a8da:	46c0      	nop			; (mov r8, r8)
 800a8dc:	ffff0000 	.word	0xffff0000
 800a8e0:	00008003 	.word	0x00008003

0800a8e4 <HAL_I2C_ErrorCallback>:
 800a8e4:	4770      	bx	lr

0800a8e6 <HAL_I2C_AbortCpltCallback>:
 800a8e6:	4770      	bx	lr

0800a8e8 <I2C_TreatErrorCallback>:
  if (hi2c->State == HAL_I2C_STATE_ABORT)
 800a8e8:	0001      	movs	r1, r0
 800a8ea:	0002      	movs	r2, r0
{
 800a8ec:	b510      	push	{r4, lr}
  if (hi2c->State == HAL_I2C_STATE_ABORT)
 800a8ee:	3141      	adds	r1, #65	; 0x41
 800a8f0:	780c      	ldrb	r4, [r1, #0]
 800a8f2:	2300      	movs	r3, #0
 800a8f4:	3240      	adds	r2, #64	; 0x40
 800a8f6:	2c60      	cmp	r4, #96	; 0x60
 800a8f8:	d106      	bne.n	800a908 <I2C_TreatErrorCallback+0x20>
    hi2c->State = HAL_I2C_STATE_READY;
 800a8fa:	3c40      	subs	r4, #64	; 0x40
 800a8fc:	700c      	strb	r4, [r1, #0]
    hi2c->PreviousState = I2C_STATE_NONE;
 800a8fe:	6303      	str	r3, [r0, #48]	; 0x30
    __HAL_UNLOCK(hi2c);
 800a900:	7013      	strb	r3, [r2, #0]
    HAL_I2C_AbortCpltCallback(hi2c);
 800a902:	f7ff fff0 	bl	800a8e6 <HAL_I2C_AbortCpltCallback>
}
 800a906:	bd10      	pop	{r4, pc}
    hi2c->PreviousState = I2C_STATE_NONE;
 800a908:	6303      	str	r3, [r0, #48]	; 0x30
    __HAL_UNLOCK(hi2c);
 800a90a:	7013      	strb	r3, [r2, #0]
    HAL_I2C_ErrorCallback(hi2c);
 800a90c:	f7ff ffea 	bl	800a8e4 <HAL_I2C_ErrorCallback>
}
 800a910:	e7f9      	b.n	800a906 <I2C_TreatErrorCallback+0x1e>
	...

0800a914 <I2C_ITError>:
{
 800a914:	b570      	push	{r4, r5, r6, lr}
  hi2c->Mode          = HAL_I2C_MODE_NONE;
 800a916:	0002      	movs	r2, r0
  HAL_I2C_StateTypeDef tmpstate = hi2c->State;
 800a918:	0005      	movs	r5, r0
{
 800a91a:	0004      	movs	r4, r0
  hi2c->Mode          = HAL_I2C_MODE_NONE;
 800a91c:	2000      	movs	r0, #0
 800a91e:	3242      	adds	r2, #66	; 0x42
  HAL_I2C_StateTypeDef tmpstate = hi2c->State;
 800a920:	3541      	adds	r5, #65	; 0x41
 800a922:	782b      	ldrb	r3, [r5, #0]
  hi2c->Mode          = HAL_I2C_MODE_NONE;
 800a924:	7010      	strb	r0, [r2, #0]
  hi2c->XferOptions   = I2C_NO_OPTION_FRAME;
 800a926:	4a32      	ldr	r2, [pc, #200]	; (800a9f0 <I2C_ITError+0xdc>)
  if ((tmpstate == HAL_I2C_STATE_LISTEN)         ||
 800a928:	3b28      	subs	r3, #40	; 0x28
  hi2c->XferOptions   = I2C_NO_OPTION_FRAME;
 800a92a:	62e2      	str	r2, [r4, #44]	; 0x2c
  hi2c->XferCount     = 0U;
 800a92c:	8560      	strh	r0, [r4, #42]	; 0x2a
  hi2c->ErrorCode |= ErrorCode;
 800a92e:	6c62      	ldr	r2, [r4, #68]	; 0x44
 800a930:	430a      	orrs	r2, r1
 800a932:	6462      	str	r2, [r4, #68]	; 0x44
  if ((tmpstate == HAL_I2C_STATE_LISTEN)         ||
 800a934:	2b02      	cmp	r3, #2
 800a936:	d82b      	bhi.n	800a990 <I2C_ITError+0x7c>
    I2C_Disable_IRQ(hi2c, I2C_XFER_RX_IT | I2C_XFER_TX_IT);
 800a938:	2103      	movs	r1, #3
 800a93a:	0020      	movs	r0, r4
 800a93c:	f7ff fe30 	bl	800a5a0 <I2C_Disable_IRQ>
    hi2c->State         = HAL_I2C_STATE_LISTEN;
 800a940:	2328      	movs	r3, #40	; 0x28
 800a942:	702b      	strb	r3, [r5, #0]
    hi2c->XferISR       = I2C_Slave_ISR_IT;
 800a944:	4b2b      	ldr	r3, [pc, #172]	; (800a9f4 <I2C_ITError+0xe0>)
  if ((hi2c->hdmatx != NULL) && ((tmppreviousstate == I2C_STATE_MASTER_BUSY_TX) || \
 800a946:	6ba0      	ldr	r0, [r4, #56]	; 0x38
    hi2c->XferISR       = NULL;
 800a948:	6363      	str	r3, [r4, #52]	; 0x34
  tmppreviousstate = hi2c->PreviousState;
 800a94a:	6b23      	ldr	r3, [r4, #48]	; 0x30
  if ((hi2c->hdmatx != NULL) && ((tmppreviousstate == I2C_STATE_MASTER_BUSY_TX) || \
 800a94c:	2800      	cmp	r0, #0
 800a94e:	d02e      	beq.n	800a9ae <I2C_ITError+0x9a>
 800a950:	001a      	movs	r2, r3
 800a952:	2110      	movs	r1, #16
 800a954:	3a11      	subs	r2, #17
 800a956:	438a      	bics	r2, r1
 800a958:	d129      	bne.n	800a9ae <I2C_ITError+0x9a>
    if ((hi2c->Instance->CR1 & I2C_CR1_TXDMAEN) == I2C_CR1_TXDMAEN)
 800a95a:	6823      	ldr	r3, [r4, #0]
 800a95c:	681a      	ldr	r2, [r3, #0]
 800a95e:	0452      	lsls	r2, r2, #17
 800a960:	d503      	bpl.n	800a96a <I2C_ITError+0x56>
      hi2c->Instance->CR1 &= ~I2C_CR1_TXDMAEN;
 800a962:	681a      	ldr	r2, [r3, #0]
 800a964:	4924      	ldr	r1, [pc, #144]	; (800a9f8 <I2C_ITError+0xe4>)
 800a966:	400a      	ands	r2, r1
 800a968:	601a      	str	r2, [r3, #0]
    if (HAL_DMA_GetState(hi2c->hdmatx) != HAL_DMA_STATE_READY)
 800a96a:	f7ff fbf7 	bl	800a15c <HAL_DMA_GetState>
 800a96e:	2801      	cmp	r0, #1
 800a970:	d019      	beq.n	800a9a6 <I2C_ITError+0x92>
      hi2c->hdmatx->XferAbortCallback = I2C_DMAAbort;
 800a972:	6ba0      	ldr	r0, [r4, #56]	; 0x38
 800a974:	4b21      	ldr	r3, [pc, #132]	; (800a9fc <I2C_ITError+0xe8>)
      __HAL_UNLOCK(hi2c);
 800a976:	2200      	movs	r2, #0
      hi2c->hdmatx->XferAbortCallback = I2C_DMAAbort;
 800a978:	6343      	str	r3, [r0, #52]	; 0x34
      __HAL_UNLOCK(hi2c);
 800a97a:	0023      	movs	r3, r4
 800a97c:	3340      	adds	r3, #64	; 0x40
 800a97e:	701a      	strb	r2, [r3, #0]
      if (HAL_DMA_Abort_IT(hi2c->hdmatx) != HAL_OK)
 800a980:	f7ff fb80 	bl	800a084 <HAL_DMA_Abort_IT>
 800a984:	2800      	cmp	r0, #0
 800a986:	d011      	beq.n	800a9ac <I2C_ITError+0x98>
        hi2c->hdmatx->XferAbortCallback(hi2c->hdmatx);
 800a988:	6ba0      	ldr	r0, [r4, #56]	; 0x38
        hi2c->hdmarx->XferAbortCallback(hi2c->hdmarx);
 800a98a:	6b43      	ldr	r3, [r0, #52]	; 0x34
 800a98c:	4798      	blx	r3
}
 800a98e:	e00d      	b.n	800a9ac <I2C_ITError+0x98>
    I2C_Disable_IRQ(hi2c, I2C_XFER_LISTEN_IT | I2C_XFER_RX_IT | I2C_XFER_TX_IT);
 800a990:	0020      	movs	r0, r4
 800a992:	491b      	ldr	r1, [pc, #108]	; (800aa00 <I2C_ITError+0xec>)
 800a994:	f7ff fe04 	bl	800a5a0 <I2C_Disable_IRQ>
    if (hi2c->State != HAL_I2C_STATE_ABORT)
 800a998:	782b      	ldrb	r3, [r5, #0]
 800a99a:	2b60      	cmp	r3, #96	; 0x60
 800a99c:	d001      	beq.n	800a9a2 <I2C_ITError+0x8e>
      hi2c->State         = HAL_I2C_STATE_READY;
 800a99e:	2320      	movs	r3, #32
 800a9a0:	702b      	strb	r3, [r5, #0]
    hi2c->XferISR       = NULL;
 800a9a2:	2300      	movs	r3, #0
 800a9a4:	e7cf      	b.n	800a946 <I2C_ITError+0x32>
      I2C_TreatErrorCallback(hi2c);
 800a9a6:	0020      	movs	r0, r4
 800a9a8:	f7ff ff9e 	bl	800a8e8 <I2C_TreatErrorCallback>
}
 800a9ac:	bd70      	pop	{r4, r5, r6, pc}
  else if ((hi2c->hdmarx != NULL) && ((tmppreviousstate == I2C_STATE_MASTER_BUSY_RX) || \
 800a9ae:	6be0      	ldr	r0, [r4, #60]	; 0x3c
 800a9b0:	2800      	cmp	r0, #0
 800a9b2:	d0f8      	beq.n	800a9a6 <I2C_ITError+0x92>
 800a9b4:	2210      	movs	r2, #16
 800a9b6:	3b12      	subs	r3, #18
 800a9b8:	4393      	bics	r3, r2
 800a9ba:	d1f4      	bne.n	800a9a6 <I2C_ITError+0x92>
    if ((hi2c->Instance->CR1 & I2C_CR1_RXDMAEN) == I2C_CR1_RXDMAEN)
 800a9bc:	6823      	ldr	r3, [r4, #0]
 800a9be:	681a      	ldr	r2, [r3, #0]
 800a9c0:	0412      	lsls	r2, r2, #16
 800a9c2:	d503      	bpl.n	800a9cc <I2C_ITError+0xb8>
      hi2c->Instance->CR1 &= ~I2C_CR1_RXDMAEN;
 800a9c4:	681a      	ldr	r2, [r3, #0]
 800a9c6:	490f      	ldr	r1, [pc, #60]	; (800aa04 <I2C_ITError+0xf0>)
 800a9c8:	400a      	ands	r2, r1
 800a9ca:	601a      	str	r2, [r3, #0]
    if (HAL_DMA_GetState(hi2c->hdmarx) != HAL_DMA_STATE_READY)
 800a9cc:	f7ff fbc6 	bl	800a15c <HAL_DMA_GetState>
 800a9d0:	2801      	cmp	r0, #1
 800a9d2:	d0e8      	beq.n	800a9a6 <I2C_ITError+0x92>
      hi2c->hdmarx->XferAbortCallback = I2C_DMAAbort;
 800a9d4:	6be0      	ldr	r0, [r4, #60]	; 0x3c
 800a9d6:	4b09      	ldr	r3, [pc, #36]	; (800a9fc <I2C_ITError+0xe8>)
      __HAL_UNLOCK(hi2c);
 800a9d8:	2200      	movs	r2, #0
      hi2c->hdmarx->XferAbortCallback = I2C_DMAAbort;
 800a9da:	6343      	str	r3, [r0, #52]	; 0x34
      __HAL_UNLOCK(hi2c);
 800a9dc:	0023      	movs	r3, r4
 800a9de:	3340      	adds	r3, #64	; 0x40
 800a9e0:	701a      	strb	r2, [r3, #0]
      if (HAL_DMA_Abort_IT(hi2c->hdmarx) != HAL_OK)
 800a9e2:	f7ff fb4f 	bl	800a084 <HAL_DMA_Abort_IT>
 800a9e6:	2800      	cmp	r0, #0
 800a9e8:	d0e0      	beq.n	800a9ac <I2C_ITError+0x98>
        hi2c->hdmarx->XferAbortCallback(hi2c->hdmarx);
 800a9ea:	6be0      	ldr	r0, [r4, #60]	; 0x3c
 800a9ec:	e7cd      	b.n	800a98a <I2C_ITError+0x76>
 800a9ee:	46c0      	nop			; (mov r8, r8)
 800a9f0:	ffff0000 	.word	0xffff0000
 800a9f4:	0800ab41 	.word	0x0800ab41
 800a9f8:	ffffbfff 	.word	0xffffbfff
 800a9fc:	0800acd3 	.word	0x0800acd3
 800aa00:	00008003 	.word	0x00008003
 800aa04:	ffff7fff 	.word	0xffff7fff

0800aa08 <I2C_ITSlaveCplt>:
{
 800aa08:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
  uint32_t tmpcr1value = READ_REG(hi2c->Instance->CR1);
 800aa0a:	6803      	ldr	r3, [r0, #0]
  HAL_I2C_StateTypeDef tmpstate = hi2c->State;
 800aa0c:	0006      	movs	r6, r0
  uint32_t tmpcr1value = READ_REG(hi2c->Instance->CR1);
 800aa0e:	681a      	ldr	r2, [r3, #0]
  HAL_I2C_StateTypeDef tmpstate = hi2c->State;
 800aa10:	3641      	adds	r6, #65	; 0x41
  uint32_t tmpcr1value = READ_REG(hi2c->Instance->CR1);
 800aa12:	9201      	str	r2, [sp, #4]
  __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
 800aa14:	2220      	movs	r2, #32
  HAL_I2C_StateTypeDef tmpstate = hi2c->State;
 800aa16:	7835      	ldrb	r5, [r6, #0]
  __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
 800aa18:	61da      	str	r2, [r3, #28]
  if ((tmpstate == HAL_I2C_STATE_BUSY_TX) || (tmpstate == HAL_I2C_STATE_BUSY_TX_LISTEN))
 800aa1a:	2308      	movs	r3, #8
{
 800aa1c:	0004      	movs	r4, r0
 800aa1e:	000f      	movs	r7, r1
  if ((tmpstate == HAL_I2C_STATE_BUSY_TX) || (tmpstate == HAL_I2C_STATE_BUSY_TX_LISTEN))
 800aa20:	439d      	bics	r5, r3
 800aa22:	2d21      	cmp	r5, #33	; 0x21
 800aa24:	d150      	bne.n	800aac8 <I2C_ITSlaveCplt+0xc0>
    I2C_Disable_IRQ(hi2c, I2C_XFER_LISTEN_IT | I2C_XFER_TX_IT);
 800aa26:	4940      	ldr	r1, [pc, #256]	; (800ab28 <I2C_ITSlaveCplt+0x120>)
    I2C_Disable_IRQ(hi2c, I2C_XFER_LISTEN_IT | I2C_XFER_RX_IT);
 800aa28:	0020      	movs	r0, r4
 800aa2a:	f7ff fdb9 	bl	800a5a0 <I2C_Disable_IRQ>
    hi2c->PreviousState = I2C_STATE_SLAVE_BUSY_RX;
 800aa2e:	6325      	str	r5, [r4, #48]	; 0x30
  hi2c->Instance->CR2 |= I2C_CR2_NACK;
 800aa30:	2280      	movs	r2, #128	; 0x80
 800aa32:	6823      	ldr	r3, [r4, #0]
 800aa34:	0212      	lsls	r2, r2, #8
 800aa36:	6859      	ldr	r1, [r3, #4]
  I2C_Flush_TXDR(hi2c);
 800aa38:	0020      	movs	r0, r4
  hi2c->Instance->CR2 |= I2C_CR2_NACK;
 800aa3a:	430a      	orrs	r2, r1
 800aa3c:	605a      	str	r2, [r3, #4]
  I2C_RESET_CR2(hi2c);
 800aa3e:	685a      	ldr	r2, [r3, #4]
 800aa40:	493a      	ldr	r1, [pc, #232]	; (800ab2c <I2C_ITSlaveCplt+0x124>)
 800aa42:	400a      	ands	r2, r1
 800aa44:	605a      	str	r2, [r3, #4]
  I2C_Flush_TXDR(hi2c);
 800aa46:	f7ff fd9d 	bl	800a584 <I2C_Flush_TXDR>
  if (I2C_CHECK_IT_SOURCE(tmpcr1value, I2C_CR1_TXDMAEN) != RESET)
 800aa4a:	9b01      	ldr	r3, [sp, #4]
 800aa4c:	2201      	movs	r2, #1
 800aa4e:	045b      	lsls	r3, r3, #17
 800aa50:	d53e      	bpl.n	800aad0 <I2C_ITSlaveCplt+0xc8>
    hi2c->Instance->CR1 &= ~I2C_CR1_TXDMAEN;
 800aa52:	6822      	ldr	r2, [r4, #0]
 800aa54:	4936      	ldr	r1, [pc, #216]	; (800ab30 <I2C_ITSlaveCplt+0x128>)
 800aa56:	6813      	ldr	r3, [r2, #0]
 800aa58:	400b      	ands	r3, r1
 800aa5a:	6013      	str	r3, [r2, #0]
    if (hi2c->hdmatx != NULL)
 800aa5c:	6ba3      	ldr	r3, [r4, #56]	; 0x38
    if (hi2c->hdmarx != NULL)
 800aa5e:	2b00      	cmp	r3, #0
 800aa60:	d003      	beq.n	800aa6a <I2C_ITSlaveCplt+0x62>
      hi2c->XferCount = (uint16_t)__HAL_DMA_GET_COUNTER(hi2c->hdmarx);
 800aa62:	681b      	ldr	r3, [r3, #0]
 800aa64:	685b      	ldr	r3, [r3, #4]
 800aa66:	b29b      	uxth	r3, r3
 800aa68:	8563      	strh	r3, [r4, #42]	; 0x2a
  if (I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_RXNE) != RESET)
 800aa6a:	077b      	lsls	r3, r7, #29
 800aa6c:	d511      	bpl.n	800aa92 <I2C_ITSlaveCplt+0x8a>
    tmpITFlags &= ~I2C_FLAG_RXNE;
 800aa6e:	2304      	movs	r3, #4
 800aa70:	439f      	bics	r7, r3
    *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->RXDR;
 800aa72:	6823      	ldr	r3, [r4, #0]
 800aa74:	6a62      	ldr	r2, [r4, #36]	; 0x24
 800aa76:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800aa78:	7013      	strb	r3, [r2, #0]
    hi2c->pBuffPtr++;
 800aa7a:	6a63      	ldr	r3, [r4, #36]	; 0x24
 800aa7c:	3301      	adds	r3, #1
 800aa7e:	6263      	str	r3, [r4, #36]	; 0x24
    if ((hi2c->XferSize > 0U))
 800aa80:	8d23      	ldrh	r3, [r4, #40]	; 0x28
 800aa82:	2b00      	cmp	r3, #0
 800aa84:	d005      	beq.n	800aa92 <I2C_ITSlaveCplt+0x8a>
      hi2c->XferSize--;
 800aa86:	3b01      	subs	r3, #1
 800aa88:	8523      	strh	r3, [r4, #40]	; 0x28
      hi2c->XferCount--;
 800aa8a:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
 800aa8c:	3b01      	subs	r3, #1
 800aa8e:	b29b      	uxth	r3, r3
 800aa90:	8563      	strh	r3, [r4, #42]	; 0x2a
  if (hi2c->XferCount != 0U)
 800aa92:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
 800aa94:	2b00      	cmp	r3, #0
 800aa96:	d003      	beq.n	800aaa0 <I2C_ITSlaveCplt+0x98>
    hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
 800aa98:	2304      	movs	r3, #4
 800aa9a:	6c62      	ldr	r2, [r4, #68]	; 0x44
 800aa9c:	4313      	orrs	r3, r2
 800aa9e:	6463      	str	r3, [r4, #68]	; 0x44
  hi2c->Mode = HAL_I2C_MODE_NONE;
 800aaa0:	0023      	movs	r3, r4
 800aaa2:	2200      	movs	r2, #0
 800aaa4:	3342      	adds	r3, #66	; 0x42
 800aaa6:	701a      	strb	r2, [r3, #0]
  if (hi2c->ErrorCode != HAL_I2C_ERROR_NONE)
 800aaa8:	6c65      	ldr	r5, [r4, #68]	; 0x44
  hi2c->XferISR = NULL;
 800aaaa:	6362      	str	r2, [r4, #52]	; 0x34
  if (hi2c->ErrorCode != HAL_I2C_ERROR_NONE)
 800aaac:	4295      	cmp	r5, r2
 800aaae:	d01a      	beq.n	800aae6 <I2C_ITSlaveCplt+0xde>
    I2C_ITError(hi2c, hi2c->ErrorCode);
 800aab0:	0020      	movs	r0, r4
 800aab2:	6c61      	ldr	r1, [r4, #68]	; 0x44
 800aab4:	f7ff ff2e 	bl	800a914 <I2C_ITError>
    if (hi2c->State == HAL_I2C_STATE_LISTEN)
 800aab8:	7833      	ldrb	r3, [r6, #0]
 800aaba:	2b28      	cmp	r3, #40	; 0x28
 800aabc:	d103      	bne.n	800aac6 <I2C_ITSlaveCplt+0xbe>
      I2C_ITListenCplt(hi2c, tmpITFlags);
 800aabe:	0039      	movs	r1, r7
 800aac0:	0020      	movs	r0, r4
 800aac2:	f7ff fed9 	bl	800a878 <I2C_ITListenCplt>
}
 800aac6:	bdf7      	pop	{r0, r1, r2, r4, r5, r6, r7, pc}
  else if ((tmpstate == HAL_I2C_STATE_BUSY_RX) || (tmpstate == HAL_I2C_STATE_BUSY_RX_LISTEN))
 800aac8:	2d22      	cmp	r5, #34	; 0x22
 800aaca:	d1b1      	bne.n	800aa30 <I2C_ITSlaveCplt+0x28>
    I2C_Disable_IRQ(hi2c, I2C_XFER_LISTEN_IT | I2C_XFER_RX_IT);
 800aacc:	4919      	ldr	r1, [pc, #100]	; (800ab34 <I2C_ITSlaveCplt+0x12c>)
 800aace:	e7ab      	b.n	800aa28 <I2C_ITSlaveCplt+0x20>
  else if (I2C_CHECK_IT_SOURCE(tmpcr1value, I2C_CR1_RXDMAEN) != RESET)
 800aad0:	9b01      	ldr	r3, [sp, #4]
 800aad2:	0bdb      	lsrs	r3, r3, #15
 800aad4:	4213      	tst	r3, r2
 800aad6:	d0c8      	beq.n	800aa6a <I2C_ITSlaveCplt+0x62>
    hi2c->Instance->CR1 &= ~I2C_CR1_RXDMAEN;
 800aad8:	6822      	ldr	r2, [r4, #0]
 800aada:	4917      	ldr	r1, [pc, #92]	; (800ab38 <I2C_ITSlaveCplt+0x130>)
 800aadc:	6813      	ldr	r3, [r2, #0]
 800aade:	400b      	ands	r3, r1
 800aae0:	6013      	str	r3, [r2, #0]
    if (hi2c->hdmarx != NULL)
 800aae2:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 800aae4:	e7bb      	b.n	800aa5e <I2C_ITSlaveCplt+0x56>
  else if (hi2c->XferOptions != I2C_NO_OPTION_FRAME)
 800aae6:	0027      	movs	r7, r4
 800aae8:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 800aaea:	4a14      	ldr	r2, [pc, #80]	; (800ab3c <I2C_ITSlaveCplt+0x134>)
 800aaec:	3740      	adds	r7, #64	; 0x40
 800aaee:	4293      	cmp	r3, r2
 800aaf0:	d00c      	beq.n	800ab0c <I2C_ITSlaveCplt+0x104>
    I2C_ITSlaveSeqCplt(hi2c);
 800aaf2:	0020      	movs	r0, r4
 800aaf4:	f7ff fe2e 	bl	800a754 <I2C_ITSlaveSeqCplt>
    hi2c->State = HAL_I2C_STATE_READY;
 800aaf8:	2320      	movs	r3, #32
    hi2c->XferOptions = I2C_NO_OPTION_FRAME;
 800aafa:	4a10      	ldr	r2, [pc, #64]	; (800ab3c <I2C_ITSlaveCplt+0x134>)
    HAL_I2C_ListenCpltCallback(hi2c);
 800aafc:	0020      	movs	r0, r4
    hi2c->XferOptions = I2C_NO_OPTION_FRAME;
 800aafe:	62e2      	str	r2, [r4, #44]	; 0x2c
    hi2c->State = HAL_I2C_STATE_READY;
 800ab00:	7033      	strb	r3, [r6, #0]
    hi2c->PreviousState = I2C_STATE_NONE;
 800ab02:	6325      	str	r5, [r4, #48]	; 0x30
    __HAL_UNLOCK(hi2c);
 800ab04:	703d      	strb	r5, [r7, #0]
    HAL_I2C_ListenCpltCallback(hi2c);
 800ab06:	f7ff feb5 	bl	800a874 <HAL_I2C_ListenCpltCallback>
 800ab0a:	e7dc      	b.n	800aac6 <I2C_ITSlaveCplt+0xbe>
  else if (hi2c->State == HAL_I2C_STATE_BUSY_RX)
 800ab0c:	2320      	movs	r3, #32
 800ab0e:	7832      	ldrb	r2, [r6, #0]
    HAL_I2C_SlaveRxCpltCallback(hi2c);
 800ab10:	0020      	movs	r0, r4
    hi2c->State = HAL_I2C_STATE_READY;
 800ab12:	7033      	strb	r3, [r6, #0]
    hi2c->PreviousState = I2C_STATE_NONE;
 800ab14:	6325      	str	r5, [r4, #48]	; 0x30
    __HAL_UNLOCK(hi2c);
 800ab16:	703d      	strb	r5, [r7, #0]
  else if (hi2c->State == HAL_I2C_STATE_BUSY_RX)
 800ab18:	2a22      	cmp	r2, #34	; 0x22
 800ab1a:	d102      	bne.n	800ab22 <I2C_ITSlaveCplt+0x11a>
    HAL_I2C_SlaveRxCpltCallback(hi2c);
 800ab1c:	f7ff fe18 	bl	800a750 <HAL_I2C_SlaveRxCpltCallback>
 800ab20:	e7d1      	b.n	800aac6 <I2C_ITSlaveCplt+0xbe>
    HAL_I2C_SlaveTxCpltCallback(hi2c);
 800ab22:	f7ff fe14 	bl	800a74e <HAL_I2C_SlaveTxCpltCallback>
}
 800ab26:	e7ce      	b.n	800aac6 <I2C_ITSlaveCplt+0xbe>
 800ab28:	00008001 	.word	0x00008001
 800ab2c:	fe00e800 	.word	0xfe00e800
 800ab30:	ffffbfff 	.word	0xffffbfff
 800ab34:	00008002 	.word	0x00008002
 800ab38:	ffff7fff 	.word	0xffff7fff
 800ab3c:	ffff0000 	.word	0xffff0000

0800ab40 <I2C_Slave_ISR_IT>:
  __HAL_LOCK(hi2c);
 800ab40:	0003      	movs	r3, r0
{
 800ab42:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
  __HAL_LOCK(hi2c);
 800ab44:	3340      	adds	r3, #64	; 0x40
 800ab46:	9301      	str	r3, [sp, #4]
 800ab48:	781b      	ldrb	r3, [r3, #0]
{
 800ab4a:	0004      	movs	r4, r0
  uint32_t tmpoptions = hi2c->XferOptions;
 800ab4c:	6ac7      	ldr	r7, [r0, #44]	; 0x2c
{
 800ab4e:	000e      	movs	r6, r1
 800ab50:	0015      	movs	r5, r2
  __HAL_LOCK(hi2c);
 800ab52:	2002      	movs	r0, #2
 800ab54:	2b01      	cmp	r3, #1
 800ab56:	d024      	beq.n	800aba2 <I2C_Slave_ISR_IT+0x62>
 800ab58:	2301      	movs	r3, #1
 800ab5a:	9a01      	ldr	r2, [sp, #4]
 800ab5c:	7013      	strb	r3, [r2, #0]
  if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_STOPF) != RESET) && (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_STOPI) != RESET))
 800ab5e:	094a      	lsrs	r2, r1, #5
 800ab60:	421a      	tst	r2, r3
 800ab62:	d005      	beq.n	800ab70 <I2C_Slave_ISR_IT+0x30>
 800ab64:	096a      	lsrs	r2, r5, #5
 800ab66:	421a      	tst	r2, r3
 800ab68:	d002      	beq.n	800ab70 <I2C_Slave_ISR_IT+0x30>
    I2C_ITSlaveCplt(hi2c, tmpITFlags);
 800ab6a:	0020      	movs	r0, r4
 800ab6c:	f7ff ff4c 	bl	800aa08 <I2C_ITSlaveCplt>
  if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_AF) != RESET) && (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_NACKI) != RESET))
 800ab70:	2301      	movs	r3, #1
 800ab72:	06f2      	lsls	r2, r6, #27
 800ab74:	d535      	bpl.n	800abe2 <I2C_Slave_ISR_IT+0xa2>
 800ab76:	092a      	lsrs	r2, r5, #4
 800ab78:	421a      	tst	r2, r3
 800ab7a:	d032      	beq.n	800abe2 <I2C_Slave_ISR_IT+0xa2>
    if (hi2c->XferCount == 0U)
 800ab7c:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
 800ab7e:	2b00      	cmp	r3, #0
 800ab80:	d120      	bne.n	800abc4 <I2C_Slave_ISR_IT+0x84>
      if ((hi2c->State == HAL_I2C_STATE_LISTEN) && (tmpoptions == I2C_FIRST_AND_LAST_FRAME))
 800ab82:	0023      	movs	r3, r4
 800ab84:	3341      	adds	r3, #65	; 0x41
 800ab86:	781a      	ldrb	r2, [r3, #0]
 800ab88:	2a28      	cmp	r2, #40	; 0x28
 800ab8a:	d10b      	bne.n	800aba4 <I2C_Slave_ISR_IT+0x64>
 800ab8c:	2280      	movs	r2, #128	; 0x80
 800ab8e:	0492      	lsls	r2, r2, #18
 800ab90:	4297      	cmp	r7, r2
 800ab92:	d107      	bne.n	800aba4 <I2C_Slave_ISR_IT+0x64>
        I2C_ITListenCplt(hi2c, tmpITFlags);
 800ab94:	0031      	movs	r1, r6
 800ab96:	0020      	movs	r0, r4
 800ab98:	f7ff fe6e 	bl	800a878 <I2C_ITListenCplt>
  __HAL_UNLOCK(hi2c);
 800ab9c:	2000      	movs	r0, #0
 800ab9e:	9b01      	ldr	r3, [sp, #4]
 800aba0:	7018      	strb	r0, [r3, #0]
}
 800aba2:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
      else if ((hi2c->State == HAL_I2C_STATE_BUSY_TX_LISTEN) && (tmpoptions != I2C_NO_OPTION_FRAME))
 800aba4:	2210      	movs	r2, #16
 800aba6:	7819      	ldrb	r1, [r3, #0]
 800aba8:	6823      	ldr	r3, [r4, #0]
        __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
 800abaa:	61da      	str	r2, [r3, #28]
      else if ((hi2c->State == HAL_I2C_STATE_BUSY_TX_LISTEN) && (tmpoptions != I2C_NO_OPTION_FRAME))
 800abac:	2929      	cmp	r1, #41	; 0x29
 800abae:	d1f5      	bne.n	800ab9c <I2C_Slave_ISR_IT+0x5c>
 800abb0:	492d      	ldr	r1, [pc, #180]	; (800ac68 <I2C_Slave_ISR_IT+0x128>)
 800abb2:	428f      	cmp	r7, r1
 800abb4:	d0f2      	beq.n	800ab9c <I2C_Slave_ISR_IT+0x5c>
        I2C_Flush_TXDR(hi2c);
 800abb6:	0020      	movs	r0, r4
 800abb8:	f7ff fce4 	bl	800a584 <I2C_Flush_TXDR>
      I2C_ITSlaveSeqCplt(hi2c);
 800abbc:	0020      	movs	r0, r4
 800abbe:	f7ff fdc9 	bl	800a754 <I2C_ITSlaveSeqCplt>
 800abc2:	e7eb      	b.n	800ab9c <I2C_Slave_ISR_IT+0x5c>
      __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
 800abc4:	2210      	movs	r2, #16
 800abc6:	6823      	ldr	r3, [r4, #0]
 800abc8:	61da      	str	r2, [r3, #28]
      hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
 800abca:	2304      	movs	r3, #4
 800abcc:	6c62      	ldr	r2, [r4, #68]	; 0x44
 800abce:	4313      	orrs	r3, r2
 800abd0:	6463      	str	r3, [r4, #68]	; 0x44
      if ((tmpoptions == I2C_FIRST_FRAME) || (tmpoptions == I2C_NEXT_FRAME))
 800abd2:	4b26      	ldr	r3, [pc, #152]	; (800ac6c <I2C_Slave_ISR_IT+0x12c>)
 800abd4:	421f      	tst	r7, r3
 800abd6:	d1e1      	bne.n	800ab9c <I2C_Slave_ISR_IT+0x5c>
        I2C_ITError(hi2c, hi2c->ErrorCode);
 800abd8:	0020      	movs	r0, r4
 800abda:	6c61      	ldr	r1, [r4, #68]	; 0x44
 800abdc:	f7ff fe9a 	bl	800a914 <I2C_ITError>
 800abe0:	e7dc      	b.n	800ab9c <I2C_Slave_ISR_IT+0x5c>
  else if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_RXNE) != RESET) && (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_RXI) != RESET))
 800abe2:	2301      	movs	r3, #1
 800abe4:	0772      	lsls	r2, r6, #29
 800abe6:	d51a      	bpl.n	800ac1e <I2C_Slave_ISR_IT+0xde>
 800abe8:	08aa      	lsrs	r2, r5, #2
 800abea:	421a      	tst	r2, r3
 800abec:	d017      	beq.n	800ac1e <I2C_Slave_ISR_IT+0xde>
    if (hi2c->XferCount > 0U)
 800abee:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
 800abf0:	2b00      	cmp	r3, #0
 800abf2:	d00d      	beq.n	800ac10 <I2C_Slave_ISR_IT+0xd0>
      *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->RXDR;
 800abf4:	6823      	ldr	r3, [r4, #0]
 800abf6:	6a62      	ldr	r2, [r4, #36]	; 0x24
 800abf8:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800abfa:	7013      	strb	r3, [r2, #0]
      hi2c->pBuffPtr++;
 800abfc:	6a63      	ldr	r3, [r4, #36]	; 0x24
 800abfe:	3301      	adds	r3, #1
 800ac00:	6263      	str	r3, [r4, #36]	; 0x24
      hi2c->XferSize--;
 800ac02:	8d23      	ldrh	r3, [r4, #40]	; 0x28
 800ac04:	3b01      	subs	r3, #1
 800ac06:	8523      	strh	r3, [r4, #40]	; 0x28
      hi2c->XferCount--;
 800ac08:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
 800ac0a:	3b01      	subs	r3, #1
 800ac0c:	b29b      	uxth	r3, r3
 800ac0e:	8563      	strh	r3, [r4, #42]	; 0x2a
    if ((hi2c->XferCount == 0U) && \
 800ac10:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
 800ac12:	2b00      	cmp	r3, #0
 800ac14:	d1c2      	bne.n	800ab9c <I2C_Slave_ISR_IT+0x5c>
 800ac16:	4b14      	ldr	r3, [pc, #80]	; (800ac68 <I2C_Slave_ISR_IT+0x128>)
 800ac18:	429f      	cmp	r7, r3
 800ac1a:	d0bf      	beq.n	800ab9c <I2C_Slave_ISR_IT+0x5c>
 800ac1c:	e7ce      	b.n	800abbc <I2C_Slave_ISR_IT+0x7c>
  else if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_ADDR) != RESET) && \
 800ac1e:	2301      	movs	r3, #1
 800ac20:	0732      	lsls	r2, r6, #28
 800ac22:	d506      	bpl.n	800ac32 <I2C_Slave_ISR_IT+0xf2>
           (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_ADDRI) != RESET))
 800ac24:	08ea      	lsrs	r2, r5, #3
  else if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_ADDR) != RESET) && \
 800ac26:	421a      	tst	r2, r3
 800ac28:	d003      	beq.n	800ac32 <I2C_Slave_ISR_IT+0xf2>
    I2C_ITAddrCplt(hi2c, tmpITFlags);
 800ac2a:	0020      	movs	r0, r4
 800ac2c:	f7ff fdd5 	bl	800a7da <I2C_ITAddrCplt.isra.0>
 800ac30:	e7b4      	b.n	800ab9c <I2C_Slave_ISR_IT+0x5c>
  else if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_TXIS) != RESET) && (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_TXI) != RESET))
 800ac32:	2301      	movs	r3, #1
 800ac34:	07b2      	lsls	r2, r6, #30
 800ac36:	d5b1      	bpl.n	800ab9c <I2C_Slave_ISR_IT+0x5c>
 800ac38:	40dd      	lsrs	r5, r3
 800ac3a:	421d      	tst	r5, r3
 800ac3c:	d0ae      	beq.n	800ab9c <I2C_Slave_ISR_IT+0x5c>
    if (hi2c->XferCount > 0U)
 800ac3e:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
 800ac40:	2b00      	cmp	r3, #0
 800ac42:	d00d      	beq.n	800ac60 <I2C_Slave_ISR_IT+0x120>
      hi2c->Instance->TXDR = *hi2c->pBuffPtr;
 800ac44:	6a63      	ldr	r3, [r4, #36]	; 0x24
 800ac46:	6822      	ldr	r2, [r4, #0]
 800ac48:	7819      	ldrb	r1, [r3, #0]
      hi2c->pBuffPtr++;
 800ac4a:	3301      	adds	r3, #1
      hi2c->Instance->TXDR = *hi2c->pBuffPtr;
 800ac4c:	6291      	str	r1, [r2, #40]	; 0x28
      hi2c->pBuffPtr++;
 800ac4e:	6263      	str	r3, [r4, #36]	; 0x24
      hi2c->XferCount--;
 800ac50:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
 800ac52:	3b01      	subs	r3, #1
 800ac54:	b29b      	uxth	r3, r3
 800ac56:	8563      	strh	r3, [r4, #42]	; 0x2a
      hi2c->XferSize--;
 800ac58:	8d23      	ldrh	r3, [r4, #40]	; 0x28
 800ac5a:	3b01      	subs	r3, #1
 800ac5c:	8523      	strh	r3, [r4, #40]	; 0x28
 800ac5e:	e79d      	b.n	800ab9c <I2C_Slave_ISR_IT+0x5c>
      if ((tmpoptions == I2C_NEXT_FRAME) || (tmpoptions == I2C_FIRST_FRAME))
 800ac60:	4b02      	ldr	r3, [pc, #8]	; (800ac6c <I2C_Slave_ISR_IT+0x12c>)
 800ac62:	421f      	tst	r7, r3
 800ac64:	d0aa      	beq.n	800abbc <I2C_Slave_ISR_IT+0x7c>
 800ac66:	e799      	b.n	800ab9c <I2C_Slave_ISR_IT+0x5c>
 800ac68:	ffff0000 	.word	0xffff0000
 800ac6c:	feffffff 	.word	0xfeffffff

0800ac70 <HAL_I2C_ER_IRQHandler>:
  uint32_t itflags   = READ_REG(hi2c->Instance->ISR);
 800ac70:	6803      	ldr	r3, [r0, #0]
{
 800ac72:	b570      	push	{r4, r5, r6, lr}
  uint32_t itflags   = READ_REG(hi2c->Instance->ISR);
 800ac74:	699c      	ldr	r4, [r3, #24]
  if ((I2C_CHECK_FLAG(itflags, I2C_FLAG_BERR) != RESET) && (I2C_CHECK_IT_SOURCE(itsources, I2C_IT_ERRI) != RESET))
 800ac76:	2101      	movs	r1, #1
  uint32_t itsources = READ_REG(hi2c->Instance->CR1);
 800ac78:	681a      	ldr	r2, [r3, #0]
  if ((I2C_CHECK_FLAG(itflags, I2C_FLAG_BERR) != RESET) && (I2C_CHECK_IT_SOURCE(itsources, I2C_IT_ERRI) != RESET))
 800ac7a:	05e5      	lsls	r5, r4, #23
 800ac7c:	d508      	bpl.n	800ac90 <HAL_I2C_ER_IRQHandler+0x20>
 800ac7e:	09d5      	lsrs	r5, r2, #7
 800ac80:	420d      	tst	r5, r1
 800ac82:	d005      	beq.n	800ac90 <HAL_I2C_ER_IRQHandler+0x20>
    hi2c->ErrorCode |= HAL_I2C_ERROR_BERR;
 800ac84:	6c45      	ldr	r5, [r0, #68]	; 0x44
 800ac86:	4329      	orrs	r1, r5
 800ac88:	6441      	str	r1, [r0, #68]	; 0x44
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_BERR);
 800ac8a:	2180      	movs	r1, #128	; 0x80
 800ac8c:	0049      	lsls	r1, r1, #1
 800ac8e:	61d9      	str	r1, [r3, #28]
  if ((I2C_CHECK_FLAG(itflags, I2C_FLAG_OVR) != RESET) && (I2C_CHECK_IT_SOURCE(itsources, I2C_IT_ERRI) != RESET))
 800ac90:	2101      	movs	r1, #1
 800ac92:	0565      	lsls	r5, r4, #21
 800ac94:	d509      	bpl.n	800acaa <HAL_I2C_ER_IRQHandler+0x3a>
 800ac96:	09d5      	lsrs	r5, r2, #7
 800ac98:	420d      	tst	r5, r1
 800ac9a:	d006      	beq.n	800acaa <HAL_I2C_ER_IRQHandler+0x3a>
    hi2c->ErrorCode |= HAL_I2C_ERROR_OVR;
 800ac9c:	6c45      	ldr	r5, [r0, #68]	; 0x44
 800ac9e:	3107      	adds	r1, #7
 800aca0:	4329      	orrs	r1, r5
 800aca2:	6441      	str	r1, [r0, #68]	; 0x44
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_OVR);
 800aca4:	2180      	movs	r1, #128	; 0x80
 800aca6:	00c9      	lsls	r1, r1, #3
 800aca8:	61d9      	str	r1, [r3, #28]
  if ((I2C_CHECK_FLAG(itflags, I2C_FLAG_ARLO) != RESET) && (I2C_CHECK_IT_SOURCE(itsources, I2C_IT_ERRI) != RESET))
 800acaa:	2101      	movs	r1, #1
 800acac:	05a4      	lsls	r4, r4, #22
 800acae:	d509      	bpl.n	800acc4 <HAL_I2C_ER_IRQHandler+0x54>
 800acb0:	09d2      	lsrs	r2, r2, #7
 800acb2:	420a      	tst	r2, r1
 800acb4:	d006      	beq.n	800acc4 <HAL_I2C_ER_IRQHandler+0x54>
    hi2c->ErrorCode |= HAL_I2C_ERROR_ARLO;
 800acb6:	2202      	movs	r2, #2
 800acb8:	6c41      	ldr	r1, [r0, #68]	; 0x44
 800acba:	430a      	orrs	r2, r1
 800acbc:	6442      	str	r2, [r0, #68]	; 0x44
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_ARLO);
 800acbe:	2280      	movs	r2, #128	; 0x80
 800acc0:	0092      	lsls	r2, r2, #2
 800acc2:	61da      	str	r2, [r3, #28]
  if ((tmperror & (HAL_I2C_ERROR_BERR | HAL_I2C_ERROR_OVR | HAL_I2C_ERROR_ARLO)) !=  HAL_I2C_ERROR_NONE)
 800acc4:	230b      	movs	r3, #11
  tmperror = hi2c->ErrorCode;
 800acc6:	6c41      	ldr	r1, [r0, #68]	; 0x44
  if ((tmperror & (HAL_I2C_ERROR_BERR | HAL_I2C_ERROR_OVR | HAL_I2C_ERROR_ARLO)) !=  HAL_I2C_ERROR_NONE)
 800acc8:	4219      	tst	r1, r3
 800acca:	d001      	beq.n	800acd0 <HAL_I2C_ER_IRQHandler+0x60>
    I2C_ITError(hi2c, tmperror);
 800accc:	f7ff fe22 	bl	800a914 <I2C_ITError>
}
 800acd0:	bd70      	pop	{r4, r5, r6, pc}

0800acd2 <I2C_DMAAbort>:
  I2C_HandleTypeDef *hi2c = (I2C_HandleTypeDef *)(((DMA_HandleTypeDef *)hdma)->Parent); /* Derogation MISRAC2012-Rule-11.5 */
 800acd2:	6a40      	ldr	r0, [r0, #36]	; 0x24
{
 800acd4:	b510      	push	{r4, lr}
  if (hi2c->hdmatx != NULL)
 800acd6:	6b83      	ldr	r3, [r0, #56]	; 0x38
 800acd8:	2b00      	cmp	r3, #0
 800acda:	d001      	beq.n	800ace0 <I2C_DMAAbort+0xe>
    hi2c->hdmatx->XferAbortCallback = NULL;
 800acdc:	2200      	movs	r2, #0
 800acde:	635a      	str	r2, [r3, #52]	; 0x34
  if (hi2c->hdmarx != NULL)
 800ace0:	6bc3      	ldr	r3, [r0, #60]	; 0x3c
 800ace2:	2b00      	cmp	r3, #0
 800ace4:	d001      	beq.n	800acea <I2C_DMAAbort+0x18>
    hi2c->hdmarx->XferAbortCallback = NULL;
 800ace6:	2200      	movs	r2, #0
 800ace8:	635a      	str	r2, [r3, #52]	; 0x34
  I2C_TreatErrorCallback(hi2c);
 800acea:	f7ff fdfd 	bl	800a8e8 <I2C_TreatErrorCallback>
}
 800acee:	bd10      	pop	{r4, pc}

0800acf0 <HAL_I2CEx_ConfigAnalogFilter>:
  *                the configuration information for the specified I2Cx peripheral.
  * @param  AnalogFilter New state of the Analog filter.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2CEx_ConfigAnalogFilter(I2C_HandleTypeDef *hi2c, uint32_t AnalogFilter)
{
 800acf0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  /* Check the parameters */
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
 800acf2:	4a1b      	ldr	r2, [pc, #108]	; (800ad60 <HAL_I2CEx_ConfigAnalogFilter+0x70>)
 800acf4:	6803      	ldr	r3, [r0, #0]
{
 800acf6:	0006      	movs	r6, r0
 800acf8:	000c      	movs	r4, r1
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
 800acfa:	4293      	cmp	r3, r2
 800acfc:	d006      	beq.n	800ad0c <HAL_I2CEx_ConfigAnalogFilter+0x1c>
 800acfe:	4a19      	ldr	r2, [pc, #100]	; (800ad64 <HAL_I2CEx_ConfigAnalogFilter+0x74>)
 800ad00:	4293      	cmp	r3, r2
 800ad02:	d003      	beq.n	800ad0c <HAL_I2CEx_ConfigAnalogFilter+0x1c>
 800ad04:	2164      	movs	r1, #100	; 0x64
 800ad06:	4818      	ldr	r0, [pc, #96]	; (800ad68 <HAL_I2CEx_ConfigAnalogFilter+0x78>)
 800ad08:	f7fd fe12 	bl	8008930 <assert_failed>
  assert_param(IS_I2C_ANALOG_FILTER(AnalogFilter));
 800ad0c:	4d17      	ldr	r5, [pc, #92]	; (800ad6c <HAL_I2CEx_ConfigAnalogFilter+0x7c>)
 800ad0e:	422c      	tst	r4, r5
 800ad10:	d003      	beq.n	800ad1a <HAL_I2CEx_ConfigAnalogFilter+0x2a>
 800ad12:	2165      	movs	r1, #101	; 0x65
 800ad14:	4814      	ldr	r0, [pc, #80]	; (800ad68 <HAL_I2CEx_ConfigAnalogFilter+0x78>)
 800ad16:	f7fd fe0b 	bl	8008930 <assert_failed>

  if (hi2c->State == HAL_I2C_STATE_READY)
 800ad1a:	0037      	movs	r7, r6
 800ad1c:	3741      	adds	r7, #65	; 0x41
 800ad1e:	783b      	ldrb	r3, [r7, #0]

    return HAL_OK;
  }
  else
  {
    return HAL_BUSY;
 800ad20:	2002      	movs	r0, #2
  if (hi2c->State == HAL_I2C_STATE_READY)
 800ad22:	b2da      	uxtb	r2, r3
 800ad24:	4694      	mov	ip, r2
 800ad26:	2b20      	cmp	r3, #32
 800ad28:	d118      	bne.n	800ad5c <HAL_I2CEx_ConfigAnalogFilter+0x6c>
    __HAL_LOCK(hi2c);
 800ad2a:	0031      	movs	r1, r6
 800ad2c:	3140      	adds	r1, #64	; 0x40
 800ad2e:	780b      	ldrb	r3, [r1, #0]
 800ad30:	2b01      	cmp	r3, #1
 800ad32:	d013      	beq.n	800ad5c <HAL_I2CEx_ConfigAnalogFilter+0x6c>
    hi2c->State = HAL_I2C_STATE_BUSY;
 800ad34:	2324      	movs	r3, #36	; 0x24
    __HAL_I2C_DISABLE(hi2c);
 800ad36:	2201      	movs	r2, #1
    hi2c->State = HAL_I2C_STATE_BUSY;
 800ad38:	703b      	strb	r3, [r7, #0]
    __HAL_I2C_DISABLE(hi2c);
 800ad3a:	6833      	ldr	r3, [r6, #0]
 800ad3c:	6818      	ldr	r0, [r3, #0]
 800ad3e:	4390      	bics	r0, r2
 800ad40:	6018      	str	r0, [r3, #0]
    hi2c->Instance->CR1 &= ~(I2C_CR1_ANFOFF);
 800ad42:	6818      	ldr	r0, [r3, #0]
 800ad44:	4005      	ands	r5, r0
 800ad46:	601d      	str	r5, [r3, #0]
    hi2c->Instance->CR1 |= AnalogFilter;
 800ad48:	6818      	ldr	r0, [r3, #0]
 800ad4a:	4304      	orrs	r4, r0
 800ad4c:	601c      	str	r4, [r3, #0]
    __HAL_I2C_ENABLE(hi2c);
 800ad4e:	6818      	ldr	r0, [r3, #0]
 800ad50:	4302      	orrs	r2, r0
 800ad52:	601a      	str	r2, [r3, #0]
    __HAL_UNLOCK(hi2c);
 800ad54:	2000      	movs	r0, #0
    hi2c->State = HAL_I2C_STATE_READY;
 800ad56:	4663      	mov	r3, ip
 800ad58:	703b      	strb	r3, [r7, #0]
    __HAL_UNLOCK(hi2c);
 800ad5a:	7008      	strb	r0, [r1, #0]
  }
}
 800ad5c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 800ad5e:	46c0      	nop			; (mov r8, r8)
 800ad60:	40005400 	.word	0x40005400
 800ad64:	40005800 	.word	0x40005800
 800ad68:	08010838 	.word	0x08010838
 800ad6c:	ffffefff 	.word	0xffffefff

0800ad70 <HAL_I2CEx_ConfigDigitalFilter>:
  *                the configuration information for the specified I2Cx peripheral.
  * @param  DigitalFilter Coefficient of digital noise filter between Min_Data=0x00 and Max_Data=0x0F.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2CEx_ConfigDigitalFilter(I2C_HandleTypeDef *hi2c, uint32_t DigitalFilter)
{
 800ad70:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  uint32_t tmpreg;

  /* Check the parameters */
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
 800ad72:	4a19      	ldr	r2, [pc, #100]	; (800add8 <HAL_I2CEx_ConfigDigitalFilter+0x68>)
 800ad74:	6803      	ldr	r3, [r0, #0]
{
 800ad76:	0005      	movs	r5, r0
 800ad78:	000c      	movs	r4, r1
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
 800ad7a:	4293      	cmp	r3, r2
 800ad7c:	d006      	beq.n	800ad8c <HAL_I2CEx_ConfigDigitalFilter+0x1c>
 800ad7e:	4a17      	ldr	r2, [pc, #92]	; (800addc <HAL_I2CEx_ConfigDigitalFilter+0x6c>)
 800ad80:	4293      	cmp	r3, r2
 800ad82:	d003      	beq.n	800ad8c <HAL_I2CEx_ConfigDigitalFilter+0x1c>
 800ad84:	2192      	movs	r1, #146	; 0x92
 800ad86:	4816      	ldr	r0, [pc, #88]	; (800ade0 <HAL_I2CEx_ConfigDigitalFilter+0x70>)
 800ad88:	f7fd fdd2 	bl	8008930 <assert_failed>
  assert_param(IS_I2C_DIGITAL_FILTER(DigitalFilter));
 800ad8c:	2c0f      	cmp	r4, #15
 800ad8e:	d903      	bls.n	800ad98 <HAL_I2CEx_ConfigDigitalFilter+0x28>
 800ad90:	2193      	movs	r1, #147	; 0x93
 800ad92:	4813      	ldr	r0, [pc, #76]	; (800ade0 <HAL_I2CEx_ConfigDigitalFilter+0x70>)
 800ad94:	f7fd fdcc 	bl	8008930 <assert_failed>

  if (hi2c->State == HAL_I2C_STATE_READY)
 800ad98:	002a      	movs	r2, r5
 800ad9a:	3241      	adds	r2, #65	; 0x41
 800ad9c:	7813      	ldrb	r3, [r2, #0]

    return HAL_OK;
  }
  else
  {
    return HAL_BUSY;
 800ad9e:	2002      	movs	r0, #2
  if (hi2c->State == HAL_I2C_STATE_READY)
 800ada0:	b2df      	uxtb	r7, r3
 800ada2:	2b20      	cmp	r3, #32
 800ada4:	d117      	bne.n	800add6 <HAL_I2CEx_ConfigDigitalFilter+0x66>
    __HAL_LOCK(hi2c);
 800ada6:	002e      	movs	r6, r5
 800ada8:	3640      	adds	r6, #64	; 0x40
 800adaa:	7833      	ldrb	r3, [r6, #0]
 800adac:	2b01      	cmp	r3, #1
 800adae:	d012      	beq.n	800add6 <HAL_I2CEx_ConfigDigitalFilter+0x66>
    hi2c->State = HAL_I2C_STATE_BUSY;
 800adb0:	2324      	movs	r3, #36	; 0x24
 800adb2:	7013      	strb	r3, [r2, #0]
    __HAL_I2C_DISABLE(hi2c);
 800adb4:	682b      	ldr	r3, [r5, #0]
 800adb6:	3801      	subs	r0, #1
 800adb8:	6819      	ldr	r1, [r3, #0]
    tmpreg &= ~(I2C_CR1_DNF);
 800adba:	4d0a      	ldr	r5, [pc, #40]	; (800ade4 <HAL_I2CEx_ConfigDigitalFilter+0x74>)
    __HAL_I2C_DISABLE(hi2c);
 800adbc:	4381      	bics	r1, r0
 800adbe:	6019      	str	r1, [r3, #0]
    tmpreg = hi2c->Instance->CR1;
 800adc0:	6819      	ldr	r1, [r3, #0]
    tmpreg |= DigitalFilter << 8U;
 800adc2:	0224      	lsls	r4, r4, #8
    tmpreg &= ~(I2C_CR1_DNF);
 800adc4:	4029      	ands	r1, r5
    tmpreg |= DigitalFilter << 8U;
 800adc6:	430c      	orrs	r4, r1
    hi2c->Instance->CR1 = tmpreg;
 800adc8:	601c      	str	r4, [r3, #0]
    __HAL_I2C_ENABLE(hi2c);
 800adca:	6819      	ldr	r1, [r3, #0]
 800adcc:	4308      	orrs	r0, r1
 800adce:	6018      	str	r0, [r3, #0]
    __HAL_UNLOCK(hi2c);
 800add0:	2000      	movs	r0, #0
    hi2c->State = HAL_I2C_STATE_READY;
 800add2:	7017      	strb	r7, [r2, #0]
    __HAL_UNLOCK(hi2c);
 800add4:	7030      	strb	r0, [r6, #0]
  }
}
 800add6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 800add8:	40005400 	.word	0x40005400
 800addc:	40005800 	.word	0x40005800
 800ade0:	08010838 	.word	0x08010838
 800ade4:	fffff0ff 	.word	0xfffff0ff

0800ade8 <HAL_PCD_Init>:
  *         parameters in the PCD_InitTypeDef and initialize the associated handle.
  * @param  hpcd PCD handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCD_Init(PCD_HandleTypeDef *hpcd)
{
 800ade8:	b5f0      	push	{r4, r5, r6, r7, lr}
 800adea:	0004      	movs	r4, r0
  uint8_t i;

  /* Check the PCD handle allocation */
  if (hpcd == NULL)
  {
    return HAL_ERROR;
 800adec:	2501      	movs	r5, #1
{
 800adee:	b087      	sub	sp, #28
  if (hpcd == NULL)
 800adf0:	2800      	cmp	r0, #0
 800adf2:	d03b      	beq.n	800ae6c <HAL_PCD_Init+0x84>
  }

  /* Check the parameters */
  assert_param(IS_PCD_ALL_INSTANCE(hpcd->Instance));
 800adf4:	4b35      	ldr	r3, [pc, #212]	; (800aecc <HAL_PCD_Init+0xe4>)
 800adf6:	6802      	ldr	r2, [r0, #0]
 800adf8:	429a      	cmp	r2, r3
 800adfa:	d003      	beq.n	800ae04 <HAL_PCD_Init+0x1c>
 800adfc:	2185      	movs	r1, #133	; 0x85
 800adfe:	4834      	ldr	r0, [pc, #208]	; (800aed0 <HAL_PCD_Init+0xe8>)
 800ae00:	f7fd fd96 	bl	8008930 <assert_failed>

  if (hpcd->State == HAL_PCD_STATE_RESET)
 800ae04:	4d33      	ldr	r5, [pc, #204]	; (800aed4 <HAL_PCD_Init+0xec>)
 800ae06:	5d63      	ldrb	r3, [r4, r5]
 800ae08:	b2da      	uxtb	r2, r3
 800ae0a:	2b00      	cmp	r3, #0
 800ae0c:	d105      	bne.n	800ae1a <HAL_PCD_Init+0x32>
  {
    /* Allocate lock resource and initialize it */
    hpcd->Lock = HAL_UNLOCKED;
 800ae0e:	23aa      	movs	r3, #170	; 0xaa
 800ae10:	009b      	lsls	r3, r3, #2

    /* Init the low level hardware */
    hpcd->MspInitCallback(hpcd);
#else
    /* Init the low level hardware : GPIO, CLOCK, NVIC... */
    HAL_PCD_MspInit(hpcd);
 800ae12:	0020      	movs	r0, r4
    hpcd->Lock = HAL_UNLOCKED;
 800ae14:	54e2      	strb	r2, [r4, r3]
    HAL_PCD_MspInit(hpcd);
 800ae16:	f004 fca9 	bl	800f76c <HAL_PCD_MspInit>
#endif /* (USE_HAL_PCD_REGISTER_CALLBACKS) */
  }

  hpcd->State = HAL_PCD_STATE_BUSY;
 800ae1a:	2303      	movs	r3, #3
 800ae1c:	5563      	strb	r3, [r4, r5]

  /* Disable the Interrupts */
  __HAL_PCD_DISABLE(hpcd);
 800ae1e:	6820      	ldr	r0, [r4, #0]
 800ae20:	f002 fba6 	bl	800d570 <USB_DisableGlobalInt>

  /* Init endpoints structures */
  for (i = 0U; i < hpcd->Init.dev_endpoints; i++)
 800ae24:	2300      	movs	r3, #0
  {
    /* Init ep structure */
    hpcd->IN_ep[i].is_in = 1U;
 800ae26:	2701      	movs	r7, #1
    hpcd->IN_ep[i].num = i;
    hpcd->IN_ep[i].tx_fifo_num = i;
    /* Control until ep is activated */
    hpcd->IN_ep[i].type = EP_TYPE_CTRL;
 800ae28:	0019      	movs	r1, r3
  for (i = 0U; i < hpcd->Init.dev_endpoints; i++)
 800ae2a:	6860      	ldr	r0, [r4, #4]
 800ae2c:	4283      	cmp	r3, r0
 800ae2e:	d320      	bcc.n	800ae72 <HAL_PCD_Init+0x8a>
    hpcd->IN_ep[i].maxpacket = 0U;
    hpcd->IN_ep[i].xfer_buff = 0U;
    hpcd->IN_ep[i].xfer_len = 0U;
  }

  for (i = 0U; i < hpcd->Init.dev_endpoints; i++)
 800ae30:	2200      	movs	r2, #0
  {
    hpcd->OUT_ep[i].is_in = 0U;
 800ae32:	2628      	movs	r6, #40	; 0x28
 800ae34:	0011      	movs	r1, r2
  for (i = 0U; i < hpcd->Init.dev_endpoints; i++)
 800ae36:	4290      	cmp	r0, r2
 800ae38:	d834      	bhi.n	800aea4 <HAL_PCD_Init+0xbc>
    hpcd->OUT_ep[i].xfer_buff = 0U;
    hpcd->OUT_ep[i].xfer_len = 0U;
  }

  /* Init Device */
  (void)USB_DevInit(hpcd->Instance, hpcd->Init);
 800ae3a:	0023      	movs	r3, r4
 800ae3c:	466a      	mov	r2, sp
 800ae3e:	3310      	adds	r3, #16
 800ae40:	cb43      	ldmia	r3!, {r0, r1, r6}
 800ae42:	c243      	stmia	r2!, {r0, r1, r6}
 800ae44:	cb03      	ldmia	r3!, {r0, r1}
 800ae46:	c203      	stmia	r2!, {r0, r1}
 800ae48:	68a2      	ldr	r2, [r4, #8]
 800ae4a:	68e3      	ldr	r3, [r4, #12]
 800ae4c:	6861      	ldr	r1, [r4, #4]
 800ae4e:	6820      	ldr	r0, [r4, #0]
 800ae50:	f002 fb98 	bl	800d584 <USB_DevInit>

  hpcd->USB_Address = 0U;
 800ae54:	2300      	movs	r3, #0
 800ae56:	1d62      	adds	r2, r4, #5
 800ae58:	77d3      	strb	r3, [r2, #31]
  hpcd->State = HAL_PCD_STATE_READY;
 800ae5a:	2201      	movs	r2, #1
 800ae5c:	5562      	strb	r2, [r4, r5]
  if (hpcd->Init.lpm_enable == 1U)
  {
    (void)HAL_PCDEx_ActivateLPM(hpcd);
  }

  return HAL_OK;
 800ae5e:	001d      	movs	r5, r3
  if (hpcd->Init.lpm_enable == 1U)
 800ae60:	69e3      	ldr	r3, [r4, #28]
 800ae62:	4293      	cmp	r3, r2
 800ae64:	d102      	bne.n	800ae6c <HAL_PCD_Init+0x84>
    (void)HAL_PCDEx_ActivateLPM(hpcd);
 800ae66:	0020      	movs	r0, r4
 800ae68:	f000 fd97 	bl	800b99a <HAL_PCDEx_ActivateLPM>
}
 800ae6c:	0028      	movs	r0, r5
 800ae6e:	b007      	add	sp, #28
 800ae70:	bdf0      	pop	{r4, r5, r6, r7, pc}
    hpcd->IN_ep[i].is_in = 1U;
 800ae72:	2629      	movs	r6, #41	; 0x29
 800ae74:	2228      	movs	r2, #40	; 0x28
 800ae76:	46b4      	mov	ip, r6
 800ae78:	435a      	muls	r2, r3
 800ae7a:	18a2      	adds	r2, r4, r2
 800ae7c:	4494      	add	ip, r2
 800ae7e:	4666      	mov	r6, ip
 800ae80:	7037      	strb	r7, [r6, #0]
    hpcd->IN_ep[i].num = i;
 800ae82:	2628      	movs	r6, #40	; 0x28
 800ae84:	46b4      	mov	ip, r6
 800ae86:	4494      	add	ip, r2
 800ae88:	4666      	mov	r6, ip
 800ae8a:	7033      	strb	r3, [r6, #0]
    hpcd->IN_ep[i].type = EP_TYPE_CTRL;
 800ae8c:	262b      	movs	r6, #43	; 0x2b
 800ae8e:	46b4      	mov	ip, r6
 800ae90:	4494      	add	ip, r2
 800ae92:	4666      	mov	r6, ip
    hpcd->IN_ep[i].tx_fifo_num = i;
 800ae94:	86d3      	strh	r3, [r2, #54]	; 0x36
  for (i = 0U; i < hpcd->Init.dev_endpoints; i++)
 800ae96:	3301      	adds	r3, #1
    hpcd->IN_ep[i].type = EP_TYPE_CTRL;
 800ae98:	7031      	strb	r1, [r6, #0]
  for (i = 0U; i < hpcd->Init.dev_endpoints; i++)
 800ae9a:	b2db      	uxtb	r3, r3
    hpcd->IN_ep[i].maxpacket = 0U;
 800ae9c:	6391      	str	r1, [r2, #56]	; 0x38
    hpcd->IN_ep[i].xfer_buff = 0U;
 800ae9e:	63d1      	str	r1, [r2, #60]	; 0x3c
    hpcd->IN_ep[i].xfer_len = 0U;
 800aea0:	6411      	str	r1, [r2, #64]	; 0x40
  for (i = 0U; i < hpcd->Init.dev_endpoints; i++)
 800aea2:	e7c3      	b.n	800ae2c <HAL_PCD_Init+0x44>
    hpcd->OUT_ep[i].is_in = 0U;
 800aea4:	0033      	movs	r3, r6
 800aea6:	4353      	muls	r3, r2
 800aea8:	18e3      	adds	r3, r4, r3
 800aeaa:	001f      	movs	r7, r3
 800aeac:	376a      	adds	r7, #106	; 0x6a
 800aeae:	37ff      	adds	r7, #255	; 0xff
 800aeb0:	7039      	strb	r1, [r7, #0]
    hpcd->OUT_ep[i].num = i;
 800aeb2:	3f01      	subs	r7, #1
 800aeb4:	703a      	strb	r2, [r7, #0]
    hpcd->OUT_ep[i].type = EP_TYPE_CTRL;
 800aeb6:	70f9      	strb	r1, [r7, #3]
    hpcd->OUT_ep[i].xfer_len = 0U;
 800aeb8:	3381      	adds	r3, #129	; 0x81
    hpcd->OUT_ep[i].maxpacket = 0U;
 800aeba:	3f6c      	subs	r7, #108	; 0x6c
 800aebc:	67f9      	str	r1, [r7, #124]	; 0x7c
    hpcd->OUT_ep[i].xfer_len = 0U;
 800aebe:	33ff      	adds	r3, #255	; 0xff
    hpcd->OUT_ep[i].xfer_buff = 0U;
 800aec0:	3780      	adds	r7, #128	; 0x80
  for (i = 0U; i < hpcd->Init.dev_endpoints; i++)
 800aec2:	3201      	adds	r2, #1
    hpcd->OUT_ep[i].xfer_buff = 0U;
 800aec4:	6039      	str	r1, [r7, #0]
  for (i = 0U; i < hpcd->Init.dev_endpoints; i++)
 800aec6:	b2d2      	uxtb	r2, r2
    hpcd->OUT_ep[i].xfer_len = 0U;
 800aec8:	6019      	str	r1, [r3, #0]
  for (i = 0U; i < hpcd->Init.dev_endpoints; i++)
 800aeca:	e7b4      	b.n	800ae36 <HAL_PCD_Init+0x4e>
 800aecc:	40005c00 	.word	0x40005c00
 800aed0:	08010873 	.word	0x08010873
 800aed4:	000002a9 	.word	0x000002a9

0800aed8 <HAL_PCD_Start>:
  * @brief  Start the USB device
  * @param  hpcd PCD handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCD_Start(PCD_HandleTypeDef *hpcd)
{
 800aed8:	b570      	push	{r4, r5, r6, lr}
  __HAL_LOCK(hpcd);
 800aeda:	25aa      	movs	r5, #170	; 0xaa
 800aedc:	00ad      	lsls	r5, r5, #2
 800aede:	5d43      	ldrb	r3, [r0, r5]
{
 800aee0:	0004      	movs	r4, r0
  __HAL_LOCK(hpcd);
 800aee2:	2002      	movs	r0, #2
 800aee4:	2b01      	cmp	r3, #1
 800aee6:	d009      	beq.n	800aefc <HAL_PCD_Start+0x24>
 800aee8:	2301      	movs	r3, #1
 800aeea:	5563      	strb	r3, [r4, r5]
  __HAL_PCD_ENABLE(hpcd);
 800aeec:	6820      	ldr	r0, [r4, #0]
 800aeee:	f002 fb35 	bl	800d55c <USB_EnableGlobalInt>
  (void)USB_DevConnect(hpcd->Instance);
 800aef2:	6820      	ldr	r0, [r4, #0]
 800aef4:	f002 fd8b 	bl	800da0e <USB_DevConnect>
  __HAL_UNLOCK(hpcd);
 800aef8:	2000      	movs	r0, #0
 800aefa:	5560      	strb	r0, [r4, r5]

  return HAL_OK;
}
 800aefc:	bd70      	pop	{r4, r5, r6, pc}

0800aefe <HAL_PCD_SetAddress>:
  * @param  hpcd PCD handle
  * @param  address new device address
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCD_SetAddress(PCD_HandleTypeDef *hpcd, uint8_t address)
{
 800aefe:	b570      	push	{r4, r5, r6, lr}
  __HAL_LOCK(hpcd);
 800af00:	25aa      	movs	r5, #170	; 0xaa
 800af02:	00ad      	lsls	r5, r5, #2
 800af04:	5d43      	ldrb	r3, [r0, r5]
{
 800af06:	0004      	movs	r4, r0
  __HAL_LOCK(hpcd);
 800af08:	2002      	movs	r0, #2
 800af0a:	2b01      	cmp	r3, #1
 800af0c:	d008      	beq.n	800af20 <HAL_PCD_SetAddress+0x22>
 800af0e:	2301      	movs	r3, #1
 800af10:	5563      	strb	r3, [r4, r5]
  hpcd->USB_Address = address;
 800af12:	1d63      	adds	r3, r4, #5
 800af14:	77d9      	strb	r1, [r3, #31]
  (void)USB_SetDevAddress(hpcd->Instance, address);
 800af16:	6820      	ldr	r0, [r4, #0]
 800af18:	f002 fd72 	bl	800da00 <USB_SetDevAddress>
  __HAL_UNLOCK(hpcd);
 800af1c:	2000      	movs	r0, #0
 800af1e:	5560      	strb	r0, [r4, r5]

  return HAL_OK;
}
 800af20:	bd70      	pop	{r4, r5, r6, pc}
	...

0800af24 <HAL_PCD_IRQHandler>:
{
 800af24:	b5f0      	push	{r4, r5, r6, r7, lr}
 800af26:	0004      	movs	r4, r0
 800af28:	b085      	sub	sp, #20
  if (__HAL_PCD_GET_FLAG(hpcd, USB_ISTR_CTR))
 800af2a:	6800      	ldr	r0, [r0, #0]
 800af2c:	f002 fd77 	bl	800da1e <USB_ReadInterrupts>
 800af30:	0403      	lsls	r3, r0, #16
 800af32:	d500      	bpl.n	800af36 <HAL_PCD_IRQHandler+0x12>
 800af34:	e0da      	b.n	800b0ec <HAL_PCD_IRQHandler+0x1c8>
  if (__HAL_PCD_GET_FLAG(hpcd, USB_ISTR_RESET))
 800af36:	6820      	ldr	r0, [r4, #0]
 800af38:	f002 fd71 	bl	800da1e <USB_ReadInterrupts>
 800af3c:	0543      	lsls	r3, r0, #21
 800af3e:	d50c      	bpl.n	800af5a <HAL_PCD_IRQHandler+0x36>
    __HAL_PCD_CLEAR_FLAG(hpcd, USB_ISTR_RESET);
 800af40:	6823      	ldr	r3, [r4, #0]
 800af42:	49b1      	ldr	r1, [pc, #708]	; (800b208 <HAL_PCD_IRQHandler+0x2e4>)
 800af44:	3306      	adds	r3, #6
 800af46:	8fda      	ldrh	r2, [r3, #62]	; 0x3e
    HAL_PCD_ResetCallback(hpcd);
 800af48:	0020      	movs	r0, r4
    __HAL_PCD_CLEAR_FLAG(hpcd, USB_ISTR_RESET);
 800af4a:	400a      	ands	r2, r1
 800af4c:	87da      	strh	r2, [r3, #62]	; 0x3e
    HAL_PCD_ResetCallback(hpcd);
 800af4e:	f004 fc51 	bl	800f7f4 <HAL_PCD_ResetCallback>
    (void)HAL_PCD_SetAddress(hpcd, 0U);
 800af52:	2100      	movs	r1, #0
 800af54:	0020      	movs	r0, r4
 800af56:	f7ff ffd2 	bl	800aefe <HAL_PCD_SetAddress>
  if (__HAL_PCD_GET_FLAG(hpcd, USB_ISTR_PMAOVR))
 800af5a:	6820      	ldr	r0, [r4, #0]
 800af5c:	f002 fd5f 	bl	800da1e <USB_ReadInterrupts>
 800af60:	0443      	lsls	r3, r0, #17
 800af62:	d505      	bpl.n	800af70 <HAL_PCD_IRQHandler+0x4c>
    __HAL_PCD_CLEAR_FLAG(hpcd, USB_ISTR_PMAOVR);
 800af64:	6823      	ldr	r3, [r4, #0]
 800af66:	49a9      	ldr	r1, [pc, #676]	; (800b20c <HAL_PCD_IRQHandler+0x2e8>)
 800af68:	3306      	adds	r3, #6
 800af6a:	8fda      	ldrh	r2, [r3, #62]	; 0x3e
 800af6c:	400a      	ands	r2, r1
 800af6e:	87da      	strh	r2, [r3, #62]	; 0x3e
  if (__HAL_PCD_GET_FLAG(hpcd, USB_ISTR_ERR))
 800af70:	6820      	ldr	r0, [r4, #0]
 800af72:	f002 fd54 	bl	800da1e <USB_ReadInterrupts>
 800af76:	0483      	lsls	r3, r0, #18
 800af78:	d505      	bpl.n	800af86 <HAL_PCD_IRQHandler+0x62>
    __HAL_PCD_CLEAR_FLAG(hpcd, USB_ISTR_ERR);
 800af7a:	6823      	ldr	r3, [r4, #0]
 800af7c:	49a4      	ldr	r1, [pc, #656]	; (800b210 <HAL_PCD_IRQHandler+0x2ec>)
 800af7e:	3306      	adds	r3, #6
 800af80:	8fda      	ldrh	r2, [r3, #62]	; 0x3e
 800af82:	400a      	ands	r2, r1
 800af84:	87da      	strh	r2, [r3, #62]	; 0x3e
  if (__HAL_PCD_GET_FLAG(hpcd, USB_ISTR_WKUP))
 800af86:	6820      	ldr	r0, [r4, #0]
 800af88:	f002 fd49 	bl	800da1e <USB_ReadInterrupts>
 800af8c:	04c3      	lsls	r3, r0, #19
 800af8e:	d51c      	bpl.n	800afca <HAL_PCD_IRQHandler+0xa6>
    hpcd->Instance->CNTR &= (uint16_t) ~(USB_CNTR_LPMODE);
 800af90:	2104      	movs	r1, #4
 800af92:	6823      	ldr	r3, [r4, #0]
 800af94:	3302      	adds	r3, #2
 800af96:	8fda      	ldrh	r2, [r3, #62]	; 0x3e
 800af98:	438a      	bics	r2, r1
 800af9a:	87da      	strh	r2, [r3, #62]	; 0x3e
    hpcd->Instance->CNTR &= (uint16_t) ~(USB_CNTR_FSUSP);
 800af9c:	8fda      	ldrh	r2, [r3, #62]	; 0x3e
 800af9e:	1849      	adds	r1, r1, r1
 800afa0:	438a      	bics	r2, r1
 800afa2:	87da      	strh	r2, [r3, #62]	; 0x3e
    if (hpcd->LPM_State == LPM_L1)
 800afa4:	23b8      	movs	r3, #184	; 0xb8
 800afa6:	009b      	lsls	r3, r3, #2
 800afa8:	5ce2      	ldrb	r2, [r4, r3]
 800afaa:	2a01      	cmp	r2, #1
 800afac:	d104      	bne.n	800afb8 <HAL_PCD_IRQHandler+0x94>
      hpcd->LPM_State = LPM_L0;
 800afae:	2100      	movs	r1, #0
      HAL_PCDEx_LPM_Callback(hpcd, PCD_LPM_L0_ACTIVE);
 800afb0:	0020      	movs	r0, r4
      hpcd->LPM_State = LPM_L0;
 800afb2:	54e1      	strb	r1, [r4, r3]
      HAL_PCDEx_LPM_Callback(hpcd, PCD_LPM_L0_ACTIVE);
 800afb4:	f000 fd05 	bl	800b9c2 <HAL_PCDEx_LPM_Callback>
    HAL_PCD_ResumeCallback(hpcd);
 800afb8:	0020      	movs	r0, r4
 800afba:	f004 fc3f 	bl	800f83c <HAL_PCD_ResumeCallback>
    __HAL_PCD_CLEAR_FLAG(hpcd, USB_ISTR_WKUP);
 800afbe:	6823      	ldr	r3, [r4, #0]
 800afc0:	4994      	ldr	r1, [pc, #592]	; (800b214 <HAL_PCD_IRQHandler+0x2f0>)
 800afc2:	3306      	adds	r3, #6
 800afc4:	8fda      	ldrh	r2, [r3, #62]	; 0x3e
 800afc6:	400a      	ands	r2, r1
 800afc8:	87da      	strh	r2, [r3, #62]	; 0x3e
  if (__HAL_PCD_GET_FLAG(hpcd, USB_ISTR_SUSP))
 800afca:	6820      	ldr	r0, [r4, #0]
 800afcc:	f002 fd27 	bl	800da1e <USB_ReadInterrupts>
 800afd0:	0503      	lsls	r3, r0, #20
 800afd2:	d511      	bpl.n	800aff8 <HAL_PCD_IRQHandler+0xd4>
    hpcd->Instance->CNTR |= (uint16_t)USB_CNTR_FSUSP;
 800afd4:	2108      	movs	r1, #8
 800afd6:	6823      	ldr	r3, [r4, #0]
 800afd8:	1c9a      	adds	r2, r3, #2
 800afda:	8fd0      	ldrh	r0, [r2, #62]	; 0x3e
    __HAL_PCD_CLEAR_FLAG(hpcd, USB_ISTR_SUSP);
 800afdc:	3306      	adds	r3, #6
    hpcd->Instance->CNTR |= (uint16_t)USB_CNTR_FSUSP;
 800afde:	4301      	orrs	r1, r0
 800afe0:	87d1      	strh	r1, [r2, #62]	; 0x3e
    __HAL_PCD_CLEAR_FLAG(hpcd, USB_ISTR_SUSP);
 800afe2:	8fd9      	ldrh	r1, [r3, #62]	; 0x3e
 800afe4:	488c      	ldr	r0, [pc, #560]	; (800b218 <HAL_PCD_IRQHandler+0x2f4>)
 800afe6:	4001      	ands	r1, r0
 800afe8:	87d9      	strh	r1, [r3, #62]	; 0x3e
    hpcd->Instance->CNTR |= (uint16_t)USB_CNTR_LPMODE;
 800afea:	2304      	movs	r3, #4
 800afec:	8fd1      	ldrh	r1, [r2, #62]	; 0x3e
    HAL_PCD_SuspendCallback(hpcd);
 800afee:	0020      	movs	r0, r4
    hpcd->Instance->CNTR |= (uint16_t)USB_CNTR_LPMODE;
 800aff0:	430b      	orrs	r3, r1
 800aff2:	87d3      	strh	r3, [r2, #62]	; 0x3e
    HAL_PCD_SuspendCallback(hpcd);
 800aff4:	f004 fc10 	bl	800f818 <HAL_PCD_SuspendCallback>
  if (__HAL_PCD_GET_FLAG(hpcd, USB_ISTR_L1REQ))
 800aff8:	6820      	ldr	r0, [r4, #0]
 800affa:	f002 fd10 	bl	800da1e <USB_ReadInterrupts>
 800affe:	2580      	movs	r5, #128	; 0x80
 800b000:	4228      	tst	r0, r5
 800b002:	d020      	beq.n	800b046 <HAL_PCD_IRQHandler+0x122>
    if (hpcd->LPM_State == LPM_L0)
 800b004:	20b8      	movs	r0, #184	; 0xb8
    __HAL_PCD_CLEAR_FLAG(hpcd, USB_ISTR_L1REQ);
 800b006:	6823      	ldr	r3, [r4, #0]
    if (hpcd->LPM_State == LPM_L0)
 800b008:	0080      	lsls	r0, r0, #2
    __HAL_PCD_CLEAR_FLAG(hpcd, USB_ISTR_L1REQ);
 800b00a:	1d99      	adds	r1, r3, #6
 800b00c:	8fca      	ldrh	r2, [r1, #62]	; 0x3e
 800b00e:	43aa      	bics	r2, r5
 800b010:	87ca      	strh	r2, [r1, #62]	; 0x3e
    if (hpcd->LPM_State == LPM_L0)
 800b012:	5c22      	ldrb	r2, [r4, r0]
 800b014:	2a00      	cmp	r2, #0
 800b016:	d000      	beq.n	800b01a <HAL_PCD_IRQHandler+0xf6>
 800b018:	e39d      	b.n	800b756 <HAL_PCD_IRQHandler+0x832>
      hpcd->Instance->CNTR |= (uint16_t)USB_CNTR_LPMODE;
 800b01a:	1c99      	adds	r1, r3, #2
 800b01c:	8fcd      	ldrh	r5, [r1, #62]	; 0x3e
 800b01e:	3204      	adds	r2, #4
 800b020:	432a      	orrs	r2, r5
 800b022:	87ca      	strh	r2, [r1, #62]	; 0x3e
      hpcd->Instance->CNTR |= (uint16_t)USB_CNTR_FSUSP;
 800b024:	2208      	movs	r2, #8
 800b026:	8fcd      	ldrh	r5, [r1, #62]	; 0x3e
      hpcd->BESL = ((uint32_t)hpcd->Instance->LPMCSR & USB_LPMCSR_BESL) >> 2;
 800b028:	3354      	adds	r3, #84	; 0x54
      hpcd->Instance->CNTR |= (uint16_t)USB_CNTR_FSUSP;
 800b02a:	432a      	orrs	r2, r5
 800b02c:	87ca      	strh	r2, [r1, #62]	; 0x3e
      hpcd->LPM_State = LPM_L1;
 800b02e:	2101      	movs	r1, #1
      hpcd->BESL = ((uint32_t)hpcd->Instance->LPMCSR & USB_LPMCSR_BESL) >> 2;
 800b030:	223c      	movs	r2, #60	; 0x3c
      hpcd->LPM_State = LPM_L1;
 800b032:	5421      	strb	r1, [r4, r0]
      hpcd->BESL = ((uint32_t)hpcd->Instance->LPMCSR & USB_LPMCSR_BESL) >> 2;
 800b034:	881b      	ldrh	r3, [r3, #0]
      HAL_PCDEx_LPM_Callback(hpcd, PCD_LPM_L1_ACTIVE);
 800b036:	0020      	movs	r0, r4
      hpcd->BESL = ((uint32_t)hpcd->Instance->LPMCSR & USB_LPMCSR_BESL) >> 2;
 800b038:	089b      	lsrs	r3, r3, #2
 800b03a:	4013      	ands	r3, r2
 800b03c:	22b9      	movs	r2, #185	; 0xb9
 800b03e:	0092      	lsls	r2, r2, #2
 800b040:	50a3      	str	r3, [r4, r2]
      HAL_PCDEx_LPM_Callback(hpcd, PCD_LPM_L1_ACTIVE);
 800b042:	f000 fcbe 	bl	800b9c2 <HAL_PCDEx_LPM_Callback>
  if (__HAL_PCD_GET_FLAG(hpcd, USB_ISTR_SOF))
 800b046:	6820      	ldr	r0, [r4, #0]
 800b048:	f002 fce9 	bl	800da1e <USB_ReadInterrupts>
 800b04c:	0583      	lsls	r3, r0, #22
 800b04e:	d508      	bpl.n	800b062 <HAL_PCD_IRQHandler+0x13e>
    __HAL_PCD_CLEAR_FLAG(hpcd, USB_ISTR_SOF);
 800b050:	6823      	ldr	r3, [r4, #0]
 800b052:	4972      	ldr	r1, [pc, #456]	; (800b21c <HAL_PCD_IRQHandler+0x2f8>)
 800b054:	3306      	adds	r3, #6
 800b056:	8fda      	ldrh	r2, [r3, #62]	; 0x3e
    HAL_PCD_SOFCallback(hpcd);
 800b058:	0020      	movs	r0, r4
    __HAL_PCD_CLEAR_FLAG(hpcd, USB_ISTR_SOF);
 800b05a:	400a      	ands	r2, r1
 800b05c:	87da      	strh	r2, [r3, #62]	; 0x3e
    HAL_PCD_SOFCallback(hpcd);
 800b05e:	f004 fbc2 	bl	800f7e6 <HAL_PCD_SOFCallback>
  if (__HAL_PCD_GET_FLAG(hpcd, USB_ISTR_ESOF))
 800b062:	6820      	ldr	r0, [r4, #0]
 800b064:	f002 fcdb 	bl	800da1e <USB_ReadInterrupts>
 800b068:	05c3      	lsls	r3, r0, #23
 800b06a:	d505      	bpl.n	800b078 <HAL_PCD_IRQHandler+0x154>
    __HAL_PCD_CLEAR_FLAG(hpcd, USB_ISTR_ESOF);
 800b06c:	6823      	ldr	r3, [r4, #0]
 800b06e:	496c      	ldr	r1, [pc, #432]	; (800b220 <HAL_PCD_IRQHandler+0x2fc>)
 800b070:	3306      	adds	r3, #6
 800b072:	8fda      	ldrh	r2, [r3, #62]	; 0x3e
 800b074:	400a      	ands	r2, r1
 800b076:	87da      	strh	r2, [r3, #62]	; 0x3e
}
 800b078:	b005      	add	sp, #20
 800b07a:	bdf0      	pop	{r4, r5, r6, r7, pc}
  while ((hpcd->Instance->ISTR & USB_ISTR_CTR) != 0U)
  {
    wIstr = hpcd->Instance->ISTR;

    /* extract highest priority endpoint number */
    epindex = (uint8_t)(wIstr & USB_ISTR_EP_ID);
 800b07c:	210f      	movs	r1, #15
    wIstr = hpcd->Instance->ISTR;
 800b07e:	8fd3      	ldrh	r3, [r2, #62]	; 0x3e
    epindex = (uint8_t)(wIstr & USB_ISTR_EP_ID);
 800b080:	4019      	ands	r1, r3
 800b082:	9100      	str	r1, [sp, #0]

    if (epindex == 0U)
 800b084:	210f      	movs	r1, #15
    wIstr = hpcd->Instance->ISTR;
 800b086:	b29a      	uxth	r2, r3
    if (epindex == 0U)
 800b088:	420b      	tst	r3, r1
 800b08a:	d000      	beq.n	800b08e <HAL_PCD_IRQHandler+0x16a>
 800b08c:	e0da      	b.n	800b244 <HAL_PCD_IRQHandler+0x320>
    {
      /* Decode and service control endpoint interrupt */

      /* DIR bit = origin of the interrupt */
      if ((wIstr & USB_ISTR_DIR) == 0U)
 800b08e:	2310      	movs	r3, #16
 800b090:	0011      	movs	r1, r2
 800b092:	4019      	ands	r1, r3
 800b094:	421a      	tst	r2, r3
 800b096:	d130      	bne.n	800b0fa <HAL_PCD_IRQHandler+0x1d6>
      {
        /* DIR = 0 */

        /* DIR = 0 => IN  int */
        /* DIR = 0 implies that (EP_CTR_TX = 1) always */
        PCD_CLEAR_TX_EP_CTR(hpcd->Instance, PCD_ENDP0);
 800b098:	8803      	ldrh	r3, [r0, #0]
 800b09a:	4a62      	ldr	r2, [pc, #392]	; (800b224 <HAL_PCD_IRQHandler+0x300>)
 800b09c:	4013      	ands	r3, r2
 800b09e:	2280      	movs	r2, #128	; 0x80
 800b0a0:	0212      	lsls	r2, r2, #8
 800b0a2:	4313      	orrs	r3, r2
 800b0a4:	8003      	strh	r3, [r0, #0]
        ep = &hpcd->IN_ep[0];

        ep->xfer_count = PCD_GET_EP_TX_CNT(hpcd->Instance, ep->num);
 800b0a6:	0003      	movs	r3, r0
 800b0a8:	3350      	adds	r3, #80	; 0x50
 800b0aa:	881a      	ldrh	r2, [r3, #0]
 800b0ac:	0023      	movs	r3, r4
 800b0ae:	3328      	adds	r3, #40	; 0x28
 800b0b0:	781b      	ldrb	r3, [r3, #0]
 800b0b2:	00db      	lsls	r3, r3, #3
 800b0b4:	18c3      	adds	r3, r0, r3
 800b0b6:	189b      	adds	r3, r3, r2
 800b0b8:	4a5b      	ldr	r2, [pc, #364]	; (800b228 <HAL_PCD_IRQHandler+0x304>)

        /* TX COMPLETE */
#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
        hpcd->DataInStageCallback(hpcd, 0U);
#else
        HAL_PCD_DataInStageCallback(hpcd, 0U);
 800b0ba:	0020      	movs	r0, r4
        ep->xfer_count = PCD_GET_EP_TX_CNT(hpcd->Instance, ep->num);
 800b0bc:	189b      	adds	r3, r3, r2
 800b0be:	881b      	ldrh	r3, [r3, #0]
        ep->xfer_buff += ep->xfer_count;
 800b0c0:	6be2      	ldr	r2, [r4, #60]	; 0x3c
        ep->xfer_count = PCD_GET_EP_TX_CNT(hpcd->Instance, ep->num);
 800b0c2:	059b      	lsls	r3, r3, #22
 800b0c4:	0d9b      	lsrs	r3, r3, #22
 800b0c6:	6463      	str	r3, [r4, #68]	; 0x44
        ep->xfer_buff += ep->xfer_count;
 800b0c8:	18d3      	adds	r3, r2, r3
 800b0ca:	63e3      	str	r3, [r4, #60]	; 0x3c
        HAL_PCD_DataInStageCallback(hpcd, 0U);
 800b0cc:	f004 fb80 	bl	800f7d0 <HAL_PCD_DataInStageCallback>
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */

        if ((hpcd->USB_Address > 0U) && (ep->xfer_len == 0U))
 800b0d0:	1d63      	adds	r3, r4, #5
 800b0d2:	7fda      	ldrb	r2, [r3, #31]
 800b0d4:	2a00      	cmp	r2, #0
 800b0d6:	d009      	beq.n	800b0ec <HAL_PCD_IRQHandler+0x1c8>
 800b0d8:	6c20      	ldr	r0, [r4, #64]	; 0x40
 800b0da:	2800      	cmp	r0, #0
 800b0dc:	d106      	bne.n	800b0ec <HAL_PCD_IRQHandler+0x1c8>
        {
          hpcd->Instance->DADDR = ((uint16_t)hpcd->USB_Address | USB_DADDR_EF);
 800b0de:	2280      	movs	r2, #128	; 0x80
 800b0e0:	7fd9      	ldrb	r1, [r3, #31]
 800b0e2:	4311      	orrs	r1, r2
 800b0e4:	6822      	ldr	r2, [r4, #0]
 800b0e6:	324c      	adds	r2, #76	; 0x4c
 800b0e8:	8011      	strh	r1, [r2, #0]
          hpcd->USB_Address = 0U;
 800b0ea:	77d8      	strb	r0, [r3, #31]
  while ((hpcd->Instance->ISTR & USB_ISTR_CTR) != 0U)
 800b0ec:	6820      	ldr	r0, [r4, #0]
 800b0ee:	1d82      	adds	r2, r0, #6
 800b0f0:	8fd3      	ldrh	r3, [r2, #62]	; 0x3e
 800b0f2:	b21b      	sxth	r3, r3
 800b0f4:	2b00      	cmp	r3, #0
 800b0f6:	dbc1      	blt.n	800b07c <HAL_PCD_IRQHandler+0x158>
 800b0f8:	e71d      	b.n	800af36 <HAL_PCD_IRQHandler+0x12>
        /* DIR = 1 */

        /* DIR = 1 & CTR_RX => SETUP or OUT int */
        /* DIR = 1 & (CTR_TX | CTR_RX) => 2 int pending */
        ep = &hpcd->OUT_ep[0];
        wEPVal = PCD_GET_ENDPOINT(hpcd->Instance, PCD_ENDP0);
 800b0fa:	8802      	ldrh	r2, [r0, #0]

        if ((wEPVal & USB_EP_SETUP) != 0U)
 800b0fc:	2180      	movs	r1, #128	; 0x80
 800b0fe:	0016      	movs	r6, r2
 800b100:	0109      	lsls	r1, r1, #4
        wEPVal = PCD_GET_ENDPOINT(hpcd->Instance, PCD_ENDP0);
 800b102:	b293      	uxth	r3, r2
        if ((wEPVal & USB_EP_SETUP) != 0U)
 800b104:	400e      	ands	r6, r1
 800b106:	420a      	tst	r2, r1
 800b108:	d022      	beq.n	800b150 <HAL_PCD_IRQHandler+0x22c>
        {
          /* Get SETUP Packet */
          ep->xfer_count = PCD_GET_EP_RX_CNT(hpcd->Instance, ep->num);
 800b10a:	0003      	movs	r3, r0
 800b10c:	3350      	adds	r3, #80	; 0x50
 800b10e:	881a      	ldrh	r2, [r3, #0]
 800b110:	23b4      	movs	r3, #180	; 0xb4
 800b112:	005b      	lsls	r3, r3, #1
 800b114:	5ce3      	ldrb	r3, [r4, r3]

          USB_ReadPMA(hpcd->Instance, (uint8_t *)hpcd->Setup,
 800b116:	21ac      	movs	r1, #172	; 0xac
          ep->xfer_count = PCD_GET_EP_RX_CNT(hpcd->Instance, ep->num);
 800b118:	00db      	lsls	r3, r3, #3
 800b11a:	18c3      	adds	r3, r0, r3
 800b11c:	189b      	adds	r3, r3, r2
 800b11e:	4a43      	ldr	r2, [pc, #268]	; (800b22c <HAL_PCD_IRQHandler+0x308>)
          USB_ReadPMA(hpcd->Instance, (uint8_t *)hpcd->Setup,
 800b120:	0089      	lsls	r1, r1, #2
          ep->xfer_count = PCD_GET_EP_RX_CNT(hpcd->Instance, ep->num);
 800b122:	189b      	adds	r3, r3, r2
 800b124:	0022      	movs	r2, r4
 800b126:	881b      	ldrh	r3, [r3, #0]
 800b128:	3269      	adds	r2, #105	; 0x69
 800b12a:	059b      	lsls	r3, r3, #22
 800b12c:	0d9b      	lsrs	r3, r3, #22
 800b12e:	32ff      	adds	r2, #255	; 0xff
 800b130:	61d3      	str	r3, [r2, #28]
          USB_ReadPMA(hpcd->Instance, (uint8_t *)hpcd->Setup,
 800b132:	1861      	adds	r1, r4, r1
 800b134:	88d2      	ldrh	r2, [r2, #6]
 800b136:	f002 ff4f 	bl	800dfd8 <USB_ReadPMA>
                      ep->pmaadress, (uint16_t)ep->xfer_count);

          /* SETUP bit kept frozen while CTR_RX = 1 */
          PCD_CLEAR_RX_EP_CTR(hpcd->Instance, PCD_ENDP0);
 800b13a:	6822      	ldr	r2, [r4, #0]
 800b13c:	493c      	ldr	r1, [pc, #240]	; (800b230 <HAL_PCD_IRQHandler+0x30c>)
 800b13e:	8813      	ldrh	r3, [r2, #0]

          /* Process SETUP Packet*/
#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
          hpcd->SetupStageCallback(hpcd);
#else
          HAL_PCD_SetupStageCallback(hpcd);
 800b140:	0020      	movs	r0, r4
          PCD_CLEAR_RX_EP_CTR(hpcd->Instance, PCD_ENDP0);
 800b142:	400b      	ands	r3, r1
 800b144:	2180      	movs	r1, #128	; 0x80
 800b146:	430b      	orrs	r3, r1
 800b148:	8013      	strh	r3, [r2, #0]
          HAL_PCD_SetupStageCallback(hpcd);
 800b14a:	f004 fb2b 	bl	800f7a4 <HAL_PCD_SetupStageCallback>
 800b14e:	e7cd      	b.n	800b0ec <HAL_PCD_IRQHandler+0x1c8>
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
        }
        else if ((wEPVal & USB_EP_CTR_RX) != 0U)
 800b150:	b21b      	sxth	r3, r3
 800b152:	2b00      	cmp	r3, #0
 800b154:	daca      	bge.n	800b0ec <HAL_PCD_IRQHandler+0x1c8>
        {
          PCD_CLEAR_RX_EP_CTR(hpcd->Instance, PCD_ENDP0);
 800b156:	8803      	ldrh	r3, [r0, #0]
 800b158:	4a35      	ldr	r2, [pc, #212]	; (800b230 <HAL_PCD_IRQHandler+0x30c>)

          /* Get Control Data OUT Packet */
          ep->xfer_count = PCD_GET_EP_RX_CNT(hpcd->Instance, ep->num);
 800b15a:	0025      	movs	r5, r4
          PCD_CLEAR_RX_EP_CTR(hpcd->Instance, PCD_ENDP0);
 800b15c:	4013      	ands	r3, r2
 800b15e:	2280      	movs	r2, #128	; 0x80
 800b160:	4313      	orrs	r3, r2
 800b162:	8003      	strh	r3, [r0, #0]
          ep->xfer_count = PCD_GET_EP_RX_CNT(hpcd->Instance, ep->num);
 800b164:	0003      	movs	r3, r0
 800b166:	3350      	adds	r3, #80	; 0x50
 800b168:	881a      	ldrh	r2, [r3, #0]
 800b16a:	23b4      	movs	r3, #180	; 0xb4
 800b16c:	005b      	lsls	r3, r3, #1
 800b16e:	5ce3      	ldrb	r3, [r4, r3]
 800b170:	3569      	adds	r5, #105	; 0x69
 800b172:	00db      	lsls	r3, r3, #3
 800b174:	18c3      	adds	r3, r0, r3
 800b176:	189b      	adds	r3, r3, r2
 800b178:	4a2c      	ldr	r2, [pc, #176]	; (800b22c <HAL_PCD_IRQHandler+0x308>)
 800b17a:	35ff      	adds	r5, #255	; 0xff
 800b17c:	189b      	adds	r3, r3, r2
 800b17e:	881b      	ldrh	r3, [r3, #0]
 800b180:	059b      	lsls	r3, r3, #22
 800b182:	0d9b      	lsrs	r3, r3, #22
 800b184:	61eb      	str	r3, [r5, #28]

          if ((ep->xfer_count != 0U) && (ep->xfer_buff != 0U))
 800b186:	d00d      	beq.n	800b1a4 <HAL_PCD_IRQHandler+0x280>
 800b188:	6969      	ldr	r1, [r5, #20]
 800b18a:	2900      	cmp	r1, #0
 800b18c:	d00a      	beq.n	800b1a4 <HAL_PCD_IRQHandler+0x280>
          {
            USB_ReadPMA(hpcd->Instance, ep->xfer_buff,
 800b18e:	88ea      	ldrh	r2, [r5, #6]
 800b190:	f002 ff22 	bl	800dfd8 <USB_ReadPMA>
                        ep->pmaadress, (uint16_t)ep->xfer_count);

            ep->xfer_buff += ep->xfer_count;
 800b194:	696b      	ldr	r3, [r5, #20]
 800b196:	69ea      	ldr	r2, [r5, #28]

            /* Process Control Data OUT Packet */
#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
            hpcd->DataOutStageCallback(hpcd, 0U);
#else
            HAL_PCD_DataOutStageCallback(hpcd, 0U);
 800b198:	0031      	movs	r1, r6
            ep->xfer_buff += ep->xfer_count;
 800b19a:	189b      	adds	r3, r3, r2
            HAL_PCD_DataOutStageCallback(hpcd, 0U);
 800b19c:	0020      	movs	r0, r4
            ep->xfer_buff += ep->xfer_count;
 800b19e:	616b      	str	r3, [r5, #20]
            HAL_PCD_DataOutStageCallback(hpcd, 0U);
 800b1a0:	f004 fb09 	bl	800f7b6 <HAL_PCD_DataOutStageCallback>
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
          }

          PCD_SET_EP_RX_CNT(hpcd->Instance, PCD_ENDP0, ep->maxpacket);
 800b1a4:	6821      	ldr	r1, [r4, #0]
 800b1a6:	4a21      	ldr	r2, [pc, #132]	; (800b22c <HAL_PCD_IRQHandler+0x308>)
 800b1a8:	000b      	movs	r3, r1
 800b1aa:	3350      	adds	r3, #80	; 0x50
 800b1ac:	881b      	ldrh	r3, [r3, #0]
 800b1ae:	188a      	adds	r2, r1, r2
 800b1b0:	18d2      	adds	r2, r2, r3
 800b1b2:	692b      	ldr	r3, [r5, #16]
 800b1b4:	2b00      	cmp	r3, #0
 800b1b6:	d109      	bne.n	800b1cc <HAL_PCD_IRQHandler+0x2a8>
 800b1b8:	8813      	ldrh	r3, [r2, #0]
 800b1ba:	481e      	ldr	r0, [pc, #120]	; (800b234 <HAL_PCD_IRQHandler+0x310>)
 800b1bc:	4003      	ands	r3, r0
 800b1be:	2080      	movs	r0, #128	; 0x80
 800b1c0:	8013      	strh	r3, [r2, #0]
 800b1c2:	8813      	ldrh	r3, [r2, #0]
 800b1c4:	0200      	lsls	r0, r0, #8
 800b1c6:	4303      	orrs	r3, r0
 800b1c8:	8013      	strh	r3, [r2, #0]
 800b1ca:	e008      	b.n	800b1de <HAL_PCD_IRQHandler+0x2ba>
 800b1cc:	2b3e      	cmp	r3, #62	; 0x3e
 800b1ce:	d810      	bhi.n	800b1f2 <HAL_PCD_IRQHandler+0x2ce>
 800b1d0:	2501      	movs	r5, #1
 800b1d2:	0858      	lsrs	r0, r3, #1
 800b1d4:	402b      	ands	r3, r5
 800b1d6:	18c0      	adds	r0, r0, r3
 800b1d8:	0280      	lsls	r0, r0, #10
 800b1da:	b280      	uxth	r0, r0
 800b1dc:	8010      	strh	r0, [r2, #0]
          PCD_SET_EP_RX_STATUS(hpcd->Instance, PCD_ENDP0, USB_EP_RX_VALID);
 800b1de:	880b      	ldrh	r3, [r1, #0]
 800b1e0:	4a15      	ldr	r2, [pc, #84]	; (800b238 <HAL_PCD_IRQHandler+0x314>)
 800b1e2:	401a      	ands	r2, r3
 800b1e4:	23c0      	movs	r3, #192	; 0xc0
 800b1e6:	019b      	lsls	r3, r3, #6
      }
    }
  }

  /*enable endpoint IN*/
  PCD_SET_EP_TX_STATUS(hpcd->Instance, ep->num, USB_EP_TX_VALID);
 800b1e8:	4053      	eors	r3, r2
 800b1ea:	4a14      	ldr	r2, [pc, #80]	; (800b23c <HAL_PCD_IRQHandler+0x318>)
 800b1ec:	4313      	orrs	r3, r2
 800b1ee:	800b      	strh	r3, [r1, #0]

  return HAL_OK;
 800b1f0:	e77c      	b.n	800b0ec <HAL_PCD_IRQHandler+0x1c8>
          PCD_SET_EP_RX_CNT(hpcd->Instance, PCD_ENDP0, ep->maxpacket);
 800b1f2:	251f      	movs	r5, #31
 800b1f4:	0958      	lsrs	r0, r3, #5
 800b1f6:	402b      	ands	r3, r5
 800b1f8:	425d      	negs	r5, r3
 800b1fa:	416b      	adcs	r3, r5
 800b1fc:	1ac0      	subs	r0, r0, r3
 800b1fe:	4b10      	ldr	r3, [pc, #64]	; (800b240 <HAL_PCD_IRQHandler+0x31c>)
 800b200:	0280      	lsls	r0, r0, #10
 800b202:	4303      	orrs	r3, r0
 800b204:	b29b      	uxth	r3, r3
 800b206:	e7df      	b.n	800b1c8 <HAL_PCD_IRQHandler+0x2a4>
 800b208:	fffffbff 	.word	0xfffffbff
 800b20c:	ffffbfff 	.word	0xffffbfff
 800b210:	ffffdfff 	.word	0xffffdfff
 800b214:	ffffefff 	.word	0xffffefff
 800b218:	fffff7ff 	.word	0xfffff7ff
 800b21c:	fffffdff 	.word	0xfffffdff
 800b220:	fffffeff 	.word	0xfffffeff
 800b224:	ffff8f0f 	.word	0xffff8f0f
 800b228:	00000402 	.word	0x00000402
 800b22c:	00000406 	.word	0x00000406
 800b230:	00000f8f 	.word	0x00000f8f
 800b234:	ffff83ff 	.word	0xffff83ff
 800b238:	ffffbf8f 	.word	0xffffbf8f
 800b23c:	00008080 	.word	0x00008080
 800b240:	ffff8000 	.word	0xffff8000
      wEPVal = PCD_GET_ENDPOINT(hpcd->Instance, epindex);
 800b244:	9b00      	ldr	r3, [sp, #0]
 800b246:	009b      	lsls	r3, r3, #2
 800b248:	18c2      	adds	r2, r0, r3
 800b24a:	9301      	str	r3, [sp, #4]
 800b24c:	8813      	ldrh	r3, [r2, #0]
 800b24e:	b29f      	uxth	r7, r3
      if ((wEPVal & USB_EP_CTR_RX) != 0U)
 800b250:	b21b      	sxth	r3, r3
 800b252:	2b00      	cmp	r3, #0
 800b254:	db00      	blt.n	800b258 <HAL_PCD_IRQHandler+0x334>
 800b256:	e0e9      	b.n	800b42c <HAL_PCD_IRQHandler+0x508>
        PCD_CLEAR_RX_EP_CTR(hpcd->Instance, epindex);
 800b258:	8813      	ldrh	r3, [r2, #0]
 800b25a:	49bb      	ldr	r1, [pc, #748]	; (800b548 <HAL_PCD_IRQHandler+0x624>)
 800b25c:	400b      	ands	r3, r1
 800b25e:	2180      	movs	r1, #128	; 0x80
 800b260:	430b      	orrs	r3, r1
 800b262:	8013      	strh	r3, [r2, #0]
        if (ep->doublebuffer == 0U)
 800b264:	2328      	movs	r3, #40	; 0x28
 800b266:	9a00      	ldr	r2, [sp, #0]
 800b268:	4353      	muls	r3, r2
 800b26a:	18e3      	adds	r3, r4, r3
 800b26c:	001a      	movs	r2, r3
 800b26e:	001d      	movs	r5, r3
 800b270:	3275      	adds	r2, #117	; 0x75
 800b272:	32ff      	adds	r2, #255	; 0xff
 800b274:	7812      	ldrb	r2, [r2, #0]
 800b276:	3569      	adds	r5, #105	; 0x69
 800b278:	35ff      	adds	r5, #255	; 0xff
 800b27a:	2a00      	cmp	r2, #0
 800b27c:	d11a      	bne.n	800b2b4 <HAL_PCD_IRQHandler+0x390>
          count = (uint16_t)PCD_GET_EP_RX_CNT(hpcd->Instance, ep->num);
 800b27e:	0002      	movs	r2, r0
 800b280:	3250      	adds	r2, #80	; 0x50
 800b282:	8811      	ldrh	r1, [r2, #0]
 800b284:	782a      	ldrb	r2, [r5, #0]
 800b286:	00d2      	lsls	r2, r2, #3
 800b288:	1852      	adds	r2, r2, r1
 800b28a:	49b0      	ldr	r1, [pc, #704]	; (800b54c <HAL_PCD_IRQHandler+0x628>)
 800b28c:	1812      	adds	r2, r2, r0
 800b28e:	1852      	adds	r2, r2, r1
 800b290:	8812      	ldrh	r2, [r2, #0]
 800b292:	0592      	lsls	r2, r2, #22
 800b294:	0d95      	lsrs	r5, r2, #22
          if (count != 0U)
 800b296:	2a00      	cmp	r2, #0
 800b298:	d100      	bne.n	800b29c <HAL_PCD_IRQHandler+0x378>
 800b29a:	e0a6      	b.n	800b3ea <HAL_PCD_IRQHandler+0x4c6>
            USB_ReadPMA(hpcd->Instance, ep->xfer_buff, ep->pmaadress, count);
 800b29c:	001a      	movs	r2, r3
 800b29e:	326f      	adds	r2, #111	; 0x6f
                USB_ReadPMA(hpcd->Instance, ep->xfer_buff, ep->pmaaddr1, count);
 800b2a0:	337d      	adds	r3, #125	; 0x7d
 800b2a2:	33ff      	adds	r3, #255	; 0xff
 800b2a4:	0019      	movs	r1, r3
 800b2a6:	32ff      	adds	r2, #255	; 0xff
 800b2a8:	002b      	movs	r3, r5
 800b2aa:	8812      	ldrh	r2, [r2, #0]
 800b2ac:	6809      	ldr	r1, [r1, #0]
 800b2ae:	f002 fe93 	bl	800dfd8 <USB_ReadPMA>
 800b2b2:	e09a      	b.n	800b3ea <HAL_PCD_IRQHandler+0x4c6>
          if (ep->type == EP_TYPE_BULK)
 800b2b4:	0019      	movs	r1, r3
 800b2b6:	316c      	adds	r1, #108	; 0x6c
 800b2b8:	31ff      	adds	r1, #255	; 0xff
 800b2ba:	7809      	ldrb	r1, [r1, #0]
 800b2bc:	782a      	ldrb	r2, [r5, #0]
 800b2be:	2902      	cmp	r1, #2
 800b2c0:	d000      	beq.n	800b2c4 <HAL_PCD_IRQHandler+0x3a0>
 800b2c2:	e077      	b.n	800b3b4 <HAL_PCD_IRQHandler+0x490>
  if ((wEPVal & USB_EP_DTOG_RX) != 0U)
 800b2c4:	2680      	movs	r6, #128	; 0x80
 800b2c6:	01f6      	lsls	r6, r6, #7
 800b2c8:	46b4      	mov	ip, r6
 800b2ca:	403e      	ands	r6, r7
 800b2cc:	9602      	str	r6, [sp, #8]
 800b2ce:	0006      	movs	r6, r0
 800b2d0:	4665      	mov	r5, ip
 800b2d2:	3381      	adds	r3, #129	; 0x81
 800b2d4:	33ff      	adds	r3, #255	; 0xff
 800b2d6:	3650      	adds	r6, #80	; 0x50
 800b2d8:	6819      	ldr	r1, [r3, #0]
    count = (uint16_t)PCD_GET_EP_DBUF0_CNT(hpcd->Instance, ep->num);
 800b2da:	8836      	ldrh	r6, [r6, #0]
  if ((wEPVal & USB_EP_DTOG_RX) != 0U)
 800b2dc:	422f      	tst	r7, r5
 800b2de:	d034      	beq.n	800b34a <HAL_PCD_IRQHandler+0x426>
    count = (uint16_t)PCD_GET_EP_DBUF0_CNT(hpcd->Instance, ep->num);
 800b2e0:	00d5      	lsls	r5, r2, #3
 800b2e2:	1976      	adds	r6, r6, r5
 800b2e4:	4d9a      	ldr	r5, [pc, #616]	; (800b550 <HAL_PCD_IRQHandler+0x62c>)
 800b2e6:	1836      	adds	r6, r6, r0
 800b2e8:	1976      	adds	r6, r6, r5
 800b2ea:	8835      	ldrh	r5, [r6, #0]
 800b2ec:	05ad      	lsls	r5, r5, #22
 800b2ee:	0dad      	lsrs	r5, r5, #22
    if (ep->xfer_len >= count)
 800b2f0:	428d      	cmp	r5, r1
 800b2f2:	d90d      	bls.n	800b310 <HAL_PCD_IRQHandler+0x3ec>
 800b2f4:	2100      	movs	r1, #0
 800b2f6:	6019      	str	r1, [r3, #0]
      PCD_SET_EP_RX_STATUS(hpcd->Instance, ep->num, USB_EP_RX_NAK);
 800b2f8:	0092      	lsls	r2, r2, #2
 800b2fa:	1882      	adds	r2, r0, r2
 800b2fc:	8813      	ldrh	r3, [r2, #0]
 800b2fe:	4995      	ldr	r1, [pc, #596]	; (800b554 <HAL_PCD_IRQHandler+0x630>)
 800b300:	4019      	ands	r1, r3
 800b302:	2380      	movs	r3, #128	; 0x80
 800b304:	019b      	lsls	r3, r3, #6
 800b306:	404b      	eors	r3, r1
 800b308:	4993      	ldr	r1, [pc, #588]	; (800b558 <HAL_PCD_IRQHandler+0x634>)
 800b30a:	430b      	orrs	r3, r1
 800b30c:	8013      	strh	r3, [r2, #0]
 800b30e:	e002      	b.n	800b316 <HAL_PCD_IRQHandler+0x3f2>
      ep->xfer_len -= count;
 800b310:	1b49      	subs	r1, r1, r5
 800b312:	6019      	str	r1, [r3, #0]
    if (ep->xfer_len == 0U)
 800b314:	d0f0      	beq.n	800b2f8 <HAL_PCD_IRQHandler+0x3d4>
    if ((wEPVal & USB_EP_DTOG_TX) != 0U)
 800b316:	067b      	lsls	r3, r7, #25
 800b318:	d50e      	bpl.n	800b338 <HAL_PCD_IRQHandler+0x414>
      PCD_FreeUserBuffer(hpcd->Instance, ep->num, 0U);
 800b31a:	2328      	movs	r3, #40	; 0x28
 800b31c:	9a00      	ldr	r2, [sp, #0]
 800b31e:	498f      	ldr	r1, [pc, #572]	; (800b55c <HAL_PCD_IRQHandler+0x638>)
 800b320:	4353      	muls	r3, r2
 800b322:	18e3      	adds	r3, r4, r3
 800b324:	3369      	adds	r3, #105	; 0x69
 800b326:	33ff      	adds	r3, #255	; 0xff
 800b328:	781b      	ldrb	r3, [r3, #0]
 800b32a:	009b      	lsls	r3, r3, #2
 800b32c:	18c3      	adds	r3, r0, r3
 800b32e:	881a      	ldrh	r2, [r3, #0]
 800b330:	400a      	ands	r2, r1
 800b332:	498b      	ldr	r1, [pc, #556]	; (800b560 <HAL_PCD_IRQHandler+0x63c>)
 800b334:	430a      	orrs	r2, r1
 800b336:	801a      	strh	r2, [r3, #0]
    if (count != 0U)
 800b338:	2d00      	cmp	r5, #0
 800b33a:	d056      	beq.n	800b3ea <HAL_PCD_IRQHandler+0x4c6>
      USB_ReadPMA(hpcd->Instance, ep->xfer_buff, ep->pmaaddr0, count);
 800b33c:	2328      	movs	r3, #40	; 0x28
 800b33e:	9a00      	ldr	r2, [sp, #0]
 800b340:	4353      	muls	r3, r2
 800b342:	18e3      	adds	r3, r4, r3
                USB_ReadPMA(hpcd->Instance, ep->xfer_buff, ep->pmaaddr0, count);
 800b344:	001a      	movs	r2, r3
 800b346:	3271      	adds	r2, #113	; 0x71
 800b348:	e7aa      	b.n	800b2a0 <HAL_PCD_IRQHandler+0x37c>
    count = (uint16_t)PCD_GET_EP_DBUF1_CNT(hpcd->Instance, ep->num);
 800b34a:	00d5      	lsls	r5, r2, #3
 800b34c:	1976      	adds	r6, r6, r5
 800b34e:	4d7f      	ldr	r5, [pc, #508]	; (800b54c <HAL_PCD_IRQHandler+0x628>)
 800b350:	1836      	adds	r6, r6, r0
 800b352:	1976      	adds	r6, r6, r5
 800b354:	8835      	ldrh	r5, [r6, #0]
 800b356:	05ad      	lsls	r5, r5, #22
 800b358:	0dad      	lsrs	r5, r5, #22
    if (ep->xfer_len >= count)
 800b35a:	428d      	cmp	r5, r1
 800b35c:	d90d      	bls.n	800b37a <HAL_PCD_IRQHandler+0x456>
 800b35e:	9902      	ldr	r1, [sp, #8]
 800b360:	6019      	str	r1, [r3, #0]
      PCD_SET_EP_RX_STATUS(hpcd->Instance, ep->num, USB_EP_RX_NAK);
 800b362:	0092      	lsls	r2, r2, #2
 800b364:	1882      	adds	r2, r0, r2
 800b366:	8813      	ldrh	r3, [r2, #0]
 800b368:	497a      	ldr	r1, [pc, #488]	; (800b554 <HAL_PCD_IRQHandler+0x630>)
 800b36a:	4019      	ands	r1, r3
 800b36c:	2380      	movs	r3, #128	; 0x80
 800b36e:	019b      	lsls	r3, r3, #6
 800b370:	404b      	eors	r3, r1
 800b372:	4979      	ldr	r1, [pc, #484]	; (800b558 <HAL_PCD_IRQHandler+0x634>)
 800b374:	430b      	orrs	r3, r1
 800b376:	8013      	strh	r3, [r2, #0]
 800b378:	e002      	b.n	800b380 <HAL_PCD_IRQHandler+0x45c>
      ep->xfer_len -= count;
 800b37a:	1b49      	subs	r1, r1, r5
 800b37c:	6019      	str	r1, [r3, #0]
    if (ep->xfer_len == 0U)
 800b37e:	d0f0      	beq.n	800b362 <HAL_PCD_IRQHandler+0x43e>
    if ((wEPVal & USB_EP_DTOG_TX) == 0U)
 800b380:	067b      	lsls	r3, r7, #25
 800b382:	d40e      	bmi.n	800b3a2 <HAL_PCD_IRQHandler+0x47e>
      PCD_FreeUserBuffer(hpcd->Instance, ep->num, 0U);
 800b384:	2328      	movs	r3, #40	; 0x28
 800b386:	9a00      	ldr	r2, [sp, #0]
 800b388:	4974      	ldr	r1, [pc, #464]	; (800b55c <HAL_PCD_IRQHandler+0x638>)
 800b38a:	4353      	muls	r3, r2
 800b38c:	18e3      	adds	r3, r4, r3
 800b38e:	3369      	adds	r3, #105	; 0x69
 800b390:	33ff      	adds	r3, #255	; 0xff
 800b392:	781b      	ldrb	r3, [r3, #0]
 800b394:	009b      	lsls	r3, r3, #2
 800b396:	18c3      	adds	r3, r0, r3
 800b398:	881a      	ldrh	r2, [r3, #0]
 800b39a:	400a      	ands	r2, r1
 800b39c:	4970      	ldr	r1, [pc, #448]	; (800b560 <HAL_PCD_IRQHandler+0x63c>)
 800b39e:	430a      	orrs	r2, r1
 800b3a0:	801a      	strh	r2, [r3, #0]
    if (count != 0U)
 800b3a2:	2d00      	cmp	r5, #0
 800b3a4:	d021      	beq.n	800b3ea <HAL_PCD_IRQHandler+0x4c6>
      USB_ReadPMA(hpcd->Instance, ep->xfer_buff, ep->pmaaddr1, count);
 800b3a6:	2328      	movs	r3, #40	; 0x28
 800b3a8:	9a00      	ldr	r2, [sp, #0]
 800b3aa:	4353      	muls	r3, r2
 800b3ac:	18e3      	adds	r3, r4, r3
                USB_ReadPMA(hpcd->Instance, ep->xfer_buff, ep->pmaaddr1, count);
 800b3ae:	001a      	movs	r2, r3
 800b3b0:	3273      	adds	r2, #115	; 0x73
 800b3b2:	e775      	b.n	800b2a0 <HAL_PCD_IRQHandler+0x37c>
            PCD_FreeUserBuffer(hpcd->Instance, ep->num, 0U);
 800b3b4:	0092      	lsls	r2, r2, #2
 800b3b6:	1882      	adds	r2, r0, r2
 800b3b8:	8816      	ldrh	r6, [r2, #0]
 800b3ba:	4968      	ldr	r1, [pc, #416]	; (800b55c <HAL_PCD_IRQHandler+0x638>)
 800b3bc:	4031      	ands	r1, r6
 800b3be:	4e68      	ldr	r6, [pc, #416]	; (800b560 <HAL_PCD_IRQHandler+0x63c>)
 800b3c0:	4331      	orrs	r1, r6
 800b3c2:	8011      	strh	r1, [r2, #0]
            if ((PCD_GET_ENDPOINT(hpcd->Instance, ep->num) & USB_EP_DTOG_RX) != 0U)
 800b3c4:	782a      	ldrb	r2, [r5, #0]
 800b3c6:	0091      	lsls	r1, r2, #2
 800b3c8:	1841      	adds	r1, r0, r1
 800b3ca:	880d      	ldrh	r5, [r1, #0]
 800b3cc:	0001      	movs	r1, r0
 800b3ce:	3150      	adds	r1, #80	; 0x50
              count = (uint16_t)PCD_GET_EP_DBUF0_CNT(hpcd->Instance, ep->num);
 800b3d0:	8809      	ldrh	r1, [r1, #0]
 800b3d2:	00d2      	lsls	r2, r2, #3
 800b3d4:	1852      	adds	r2, r2, r1
 800b3d6:	1812      	adds	r2, r2, r0
            if ((PCD_GET_ENDPOINT(hpcd->Instance, ep->num) & USB_EP_DTOG_RX) != 0U)
 800b3d8:	046d      	lsls	r5, r5, #17
 800b3da:	d55d      	bpl.n	800b498 <HAL_PCD_IRQHandler+0x574>
              count = (uint16_t)PCD_GET_EP_DBUF0_CNT(hpcd->Instance, ep->num);
 800b3dc:	495c      	ldr	r1, [pc, #368]	; (800b550 <HAL_PCD_IRQHandler+0x62c>)
 800b3de:	1852      	adds	r2, r2, r1
 800b3e0:	8812      	ldrh	r2, [r2, #0]
 800b3e2:	0592      	lsls	r2, r2, #22
 800b3e4:	0d95      	lsrs	r5, r2, #22
              if (count != 0U)
 800b3e6:	2a00      	cmp	r2, #0
 800b3e8:	d1ac      	bne.n	800b344 <HAL_PCD_IRQHandler+0x420>
        ep->xfer_count += count;
 800b3ea:	2328      	movs	r3, #40	; 0x28
 800b3ec:	9900      	ldr	r1, [sp, #0]
 800b3ee:	4359      	muls	r1, r3
 800b3f0:	1862      	adds	r2, r4, r1
 800b3f2:	0016      	movs	r6, r2
 800b3f4:	3685      	adds	r6, #133	; 0x85
 800b3f6:	36ff      	adds	r6, #255	; 0xff
 800b3f8:	6830      	ldr	r0, [r6, #0]
        ep->xfer_buff += count;
 800b3fa:	3e08      	subs	r6, #8
        ep->xfer_count += count;
 800b3fc:	1940      	adds	r0, r0, r5
 800b3fe:	60b0      	str	r0, [r6, #8]
        ep->xfer_buff += count;
 800b400:	6830      	ldr	r0, [r6, #0]
 800b402:	1940      	adds	r0, r0, r5
 800b404:	6030      	str	r0, [r6, #0]
        if ((ep->xfer_len == 0U) || (count < ep->maxpacket))
 800b406:	0010      	movs	r0, r2
 800b408:	3081      	adds	r0, #129	; 0x81
 800b40a:	30ff      	adds	r0, #255	; 0xff
 800b40c:	6800      	ldr	r0, [r0, #0]
 800b40e:	2800      	cmp	r0, #0
 800b410:	d003      	beq.n	800b41a <HAL_PCD_IRQHandler+0x4f6>
 800b412:	32fc      	adds	r2, #252	; 0xfc
 800b414:	6fd2      	ldr	r2, [r2, #124]	; 0x7c
 800b416:	4295      	cmp	r5, r2
 800b418:	d246      	bcs.n	800b4a8 <HAL_PCD_IRQHandler+0x584>
          HAL_PCD_DataOutStageCallback(hpcd, ep->num);
 800b41a:	9a00      	ldr	r2, [sp, #0]
 800b41c:	0020      	movs	r0, r4
 800b41e:	4353      	muls	r3, r2
 800b420:	18e3      	adds	r3, r4, r3
 800b422:	3369      	adds	r3, #105	; 0x69
 800b424:	33ff      	adds	r3, #255	; 0xff
 800b426:	7819      	ldrb	r1, [r3, #0]
 800b428:	f004 f9c5 	bl	800f7b6 <HAL_PCD_DataOutStageCallback>
      if ((wEPVal & USB_EP_CTR_TX) != 0U)
 800b42c:	2380      	movs	r3, #128	; 0x80
 800b42e:	421f      	tst	r7, r3
 800b430:	d100      	bne.n	800b434 <HAL_PCD_IRQHandler+0x510>
 800b432:	e65b      	b.n	800b0ec <HAL_PCD_IRQHandler+0x1c8>
        PCD_CLEAR_TX_EP_CTR(hpcd->Instance, epindex);
 800b434:	9b01      	ldr	r3, [sp, #4]
 800b436:	6820      	ldr	r0, [r4, #0]
 800b438:	494a      	ldr	r1, [pc, #296]	; (800b564 <HAL_PCD_IRQHandler+0x640>)
 800b43a:	18c2      	adds	r2, r0, r3
 800b43c:	8813      	ldrh	r3, [r2, #0]
 800b43e:	4e4a      	ldr	r6, [pc, #296]	; (800b568 <HAL_PCD_IRQHandler+0x644>)
 800b440:	400b      	ands	r3, r1
 800b442:	4333      	orrs	r3, r6
 800b444:	b29b      	uxth	r3, r3
 800b446:	8013      	strh	r3, [r2, #0]
        if ((ep->type != EP_TYPE_BULK) ||
 800b448:	2328      	movs	r3, #40	; 0x28
 800b44a:	9a00      	ldr	r2, [sp, #0]
 800b44c:	9602      	str	r6, [sp, #8]
 800b44e:	4353      	muls	r3, r2
 800b450:	18e3      	adds	r3, r4, r3
 800b452:	9301      	str	r3, [sp, #4]
 800b454:	332b      	adds	r3, #43	; 0x2b
 800b456:	781b      	ldrb	r3, [r3, #0]
 800b458:	2b02      	cmp	r3, #2
 800b45a:	d101      	bne.n	800b460 <HAL_PCD_IRQHandler+0x53c>
 800b45c:	05fb      	lsls	r3, r7, #23
 800b45e:	d43a      	bmi.n	800b4d6 <HAL_PCD_IRQHandler+0x5b2>
          if (ep->xfer_len > TxByteNbre)
 800b460:	2128      	movs	r1, #40	; 0x28
          TxByteNbre = (uint16_t)PCD_GET_EP_TX_CNT(hpcd->Instance, ep->num);
 800b462:	0003      	movs	r3, r0
 800b464:	9f01      	ldr	r7, [sp, #4]
 800b466:	3350      	adds	r3, #80	; 0x50
 800b468:	187f      	adds	r7, r7, r1
 800b46a:	881e      	ldrh	r6, [r3, #0]
 800b46c:	783a      	ldrb	r2, [r7, #0]
          if (ep->xfer_len > TxByteNbre)
 800b46e:	9b00      	ldr	r3, [sp, #0]
          TxByteNbre = (uint16_t)PCD_GET_EP_TX_CNT(hpcd->Instance, ep->num);
 800b470:	00d2      	lsls	r2, r2, #3
          if (ep->xfer_len > TxByteNbre)
 800b472:	434b      	muls	r3, r1
          TxByteNbre = (uint16_t)PCD_GET_EP_TX_CNT(hpcd->Instance, ep->num);
 800b474:	1992      	adds	r2, r2, r6
 800b476:	4e36      	ldr	r6, [pc, #216]	; (800b550 <HAL_PCD_IRQHandler+0x62c>)
 800b478:	1882      	adds	r2, r0, r2
 800b47a:	1992      	adds	r2, r2, r6
 800b47c:	8812      	ldrh	r2, [r2, #0]
          if (ep->xfer_len > TxByteNbre)
 800b47e:	18e3      	adds	r3, r4, r3
 800b480:	6c1d      	ldr	r5, [r3, #64]	; 0x40
          TxByteNbre = (uint16_t)PCD_GET_EP_TX_CNT(hpcd->Instance, ep->num);
 800b482:	0592      	lsls	r2, r2, #22
          if (ep->xfer_len > TxByteNbre)
 800b484:	0d92      	lsrs	r2, r2, #22
 800b486:	4295      	cmp	r5, r2
 800b488:	d815      	bhi.n	800b4b6 <HAL_PCD_IRQHandler+0x592>
 800b48a:	2200      	movs	r2, #0
 800b48c:	641a      	str	r2, [r3, #64]	; 0x40
            HAL_PCD_DataInStageCallback(hpcd, ep->num);
 800b48e:	0020      	movs	r0, r4
 800b490:	7839      	ldrb	r1, [r7, #0]
 800b492:	f004 f99d 	bl	800f7d0 <HAL_PCD_DataInStageCallback>
 800b496:	e629      	b.n	800b0ec <HAL_PCD_IRQHandler+0x1c8>
              count = (uint16_t)PCD_GET_EP_DBUF1_CNT(hpcd->Instance, ep->num);
 800b498:	492c      	ldr	r1, [pc, #176]	; (800b54c <HAL_PCD_IRQHandler+0x628>)
 800b49a:	1852      	adds	r2, r2, r1
 800b49c:	8812      	ldrh	r2, [r2, #0]
 800b49e:	0592      	lsls	r2, r2, #22
 800b4a0:	0d95      	lsrs	r5, r2, #22
              if (count != 0U)
 800b4a2:	2a00      	cmp	r2, #0
 800b4a4:	d0a1      	beq.n	800b3ea <HAL_PCD_IRQHandler+0x4c6>
 800b4a6:	e782      	b.n	800b3ae <HAL_PCD_IRQHandler+0x48a>
        ep = &hpcd->OUT_ep[epindex];
 800b4a8:	3169      	adds	r1, #105	; 0x69
 800b4aa:	31ff      	adds	r1, #255	; 0xff
          (void) USB_EPStartXfer(hpcd->Instance, ep);
 800b4ac:	6820      	ldr	r0, [r4, #0]
        ep = &hpcd->OUT_ep[epindex];
 800b4ae:	1861      	adds	r1, r4, r1
          (void) USB_EPStartXfer(hpcd->Instance, ep);
 800b4b0:	f002 face 	bl	800da50 <USB_EPStartXfer>
 800b4b4:	e7ba      	b.n	800b42c <HAL_PCD_IRQHandler+0x508>
            ep->xfer_len -= TxByteNbre;
 800b4b6:	1aad      	subs	r5, r5, r2
 800b4b8:	641d      	str	r5, [r3, #64]	; 0x40
          if (ep->xfer_len == 0U)
 800b4ba:	d0e8      	beq.n	800b48e <HAL_PCD_IRQHandler+0x56a>
            ep->xfer_buff += TxByteNbre;
 800b4bc:	6bdd      	ldr	r5, [r3, #60]	; 0x3c
 800b4be:	18ad      	adds	r5, r5, r2
 800b4c0:	63dd      	str	r5, [r3, #60]	; 0x3c
            ep->xfer_count += TxByteNbre;
 800b4c2:	6c5d      	ldr	r5, [r3, #68]	; 0x44
 800b4c4:	18aa      	adds	r2, r5, r2
 800b4c6:	645a      	str	r2, [r3, #68]	; 0x44
        ep = &hpcd->IN_ep[epindex];
 800b4c8:	9b00      	ldr	r3, [sp, #0]
 800b4ca:	3301      	adds	r3, #1
 800b4cc:	4359      	muls	r1, r3
 800b4ce:	1861      	adds	r1, r4, r1
            (void)USB_EPStartXfer(hpcd->Instance, ep);
 800b4d0:	f002 fabe 	bl	800da50 <USB_EPStartXfer>
 800b4d4:	e60a      	b.n	800b0ec <HAL_PCD_IRQHandler+0x1c8>
 800b4d6:	9b01      	ldr	r3, [sp, #4]
 800b4d8:	0006      	movs	r6, r0
 800b4da:	3328      	adds	r3, #40	; 0x28
 800b4dc:	7819      	ldrb	r1, [r3, #0]
 800b4de:	9b01      	ldr	r3, [sp, #4]
 800b4e0:	00cd      	lsls	r5, r1, #3
 800b4e2:	6c1a      	ldr	r2, [r3, #64]	; 0x40
  if ((wEPVal & USB_EP_DTOG_TX) != 0U)
 800b4e4:	2340      	movs	r3, #64	; 0x40
 800b4e6:	469c      	mov	ip, r3
 800b4e8:	403b      	ands	r3, r7
 800b4ea:	9303      	str	r3, [sp, #12]
 800b4ec:	4663      	mov	r3, ip
 800b4ee:	3650      	adds	r6, #80	; 0x50
 800b4f0:	421f      	tst	r7, r3
 800b4f2:	d100      	bne.n	800b4f6 <HAL_PCD_IRQHandler+0x5d2>
 800b4f4:	e0a3      	b.n	800b63e <HAL_PCD_IRQHandler+0x71a>
    TxByteNbre = (uint16_t)PCD_GET_EP_DBUF0_CNT(hpcd->Instance, ep->num);
 800b4f6:	8833      	ldrh	r3, [r6, #0]
 800b4f8:	4e15      	ldr	r6, [pc, #84]	; (800b550 <HAL_PCD_IRQHandler+0x62c>)
 800b4fa:	46b4      	mov	ip, r6
 800b4fc:	4484      	add	ip, r0
 800b4fe:	4463      	add	r3, ip
 800b500:	5b5b      	ldrh	r3, [r3, r5]
      ep->xfer_len = 0U;
 800b502:	2600      	movs	r6, #0
    TxByteNbre = (uint16_t)PCD_GET_EP_DBUF0_CNT(hpcd->Instance, ep->num);
 800b504:	059b      	lsls	r3, r3, #22
    if (ep->xfer_len > TxByteNbre)
 800b506:	0d9b      	lsrs	r3, r3, #22
 800b508:	4293      	cmp	r3, r2
 800b50a:	d200      	bcs.n	800b50e <HAL_PCD_IRQHandler+0x5ea>
      ep->xfer_len -= TxByteNbre;
 800b50c:	1ad6      	subs	r6, r2, r3
 800b50e:	2228      	movs	r2, #40	; 0x28
 800b510:	9d00      	ldr	r5, [sp, #0]
 800b512:	436a      	muls	r2, r5
 800b514:	2580      	movs	r5, #128	; 0x80
 800b516:	18a2      	adds	r2, r4, r2
 800b518:	01ed      	lsls	r5, r5, #7
 800b51a:	6416      	str	r6, [r2, #64]	; 0x40
    if (ep->xfer_len == 0U)
 800b51c:	403d      	ands	r5, r7
 800b51e:	2e00      	cmp	r6, #0
 800b520:	d126      	bne.n	800b570 <HAL_PCD_IRQHandler+0x64c>
      HAL_PCD_DataInStageCallback(hpcd, ep->num);
 800b522:	0020      	movs	r0, r4
 800b524:	f004 f954 	bl	800f7d0 <HAL_PCD_DataInStageCallback>
      if ((wEPVal & USB_EP_DTOG_RX) != 0U)
 800b528:	2d00      	cmp	r5, #0
 800b52a:	d100      	bne.n	800b52e <HAL_PCD_IRQHandler+0x60a>
 800b52c:	e0a3      	b.n	800b676 <HAL_PCD_IRQHandler+0x752>
        PCD_FreeUserBuffer(hpcd->Instance, ep->num, 1U);
 800b52e:	9b01      	ldr	r3, [sp, #4]
 800b530:	6822      	ldr	r2, [r4, #0]
 800b532:	3328      	adds	r3, #40	; 0x28
 800b534:	781b      	ldrb	r3, [r3, #0]
 800b536:	4909      	ldr	r1, [pc, #36]	; (800b55c <HAL_PCD_IRQHandler+0x638>)
 800b538:	009b      	lsls	r3, r3, #2
 800b53a:	18d2      	adds	r2, r2, r3
 800b53c:	8813      	ldrh	r3, [r2, #0]
 800b53e:	400b      	ands	r3, r1
 800b540:	490a      	ldr	r1, [pc, #40]	; (800b56c <HAL_PCD_IRQHandler+0x648>)
 800b542:	430b      	orrs	r3, r1
 800b544:	8013      	strh	r3, [r2, #0]
 800b546:	e096      	b.n	800b676 <HAL_PCD_IRQHandler+0x752>
 800b548:	00000f8f 	.word	0x00000f8f
 800b54c:	00000406 	.word	0x00000406
 800b550:	00000402 	.word	0x00000402
 800b554:	ffffbf8f 	.word	0xffffbf8f
 800b558:	00008080 	.word	0x00008080
 800b55c:	ffff8f8f 	.word	0xffff8f8f
 800b560:	000080c0 	.word	0x000080c0
 800b564:	ffff8f0f 	.word	0xffff8f0f
 800b568:	ffff8000 	.word	0xffff8000
 800b56c:	0000c080 	.word	0x0000c080
      if ((wEPVal & USB_EP_DTOG_RX) != 0U)
 800b570:	2d00      	cmp	r5, #0
 800b572:	d007      	beq.n	800b584 <HAL_PCD_IRQHandler+0x660>
        PCD_FreeUserBuffer(hpcd->Instance, ep->num, 1U);
 800b574:	0089      	lsls	r1, r1, #2
 800b576:	1841      	adds	r1, r0, r1
 800b578:	880d      	ldrh	r5, [r1, #0]
 800b57a:	4a79      	ldr	r2, [pc, #484]	; (800b760 <HAL_PCD_IRQHandler+0x83c>)
 800b57c:	402a      	ands	r2, r5
 800b57e:	4d79      	ldr	r5, [pc, #484]	; (800b764 <HAL_PCD_IRQHandler+0x840>)
 800b580:	432a      	orrs	r2, r5
 800b582:	800a      	strh	r2, [r1, #0]
      if (ep->xfer_fill_db == 1U)
 800b584:	2528      	movs	r5, #40	; 0x28
 800b586:	9a00      	ldr	r2, [sp, #0]
 800b588:	4355      	muls	r5, r2
 800b58a:	1965      	adds	r5, r4, r5
 800b58c:	002f      	movs	r7, r5
 800b58e:	374c      	adds	r7, #76	; 0x4c
 800b590:	783a      	ldrb	r2, [r7, #0]
 800b592:	2a01      	cmp	r2, #1
 800b594:	d16f      	bne.n	800b676 <HAL_PCD_IRQHandler+0x752>
        ep->xfer_buff += TxByteNbre;
 800b596:	6bea      	ldr	r2, [r5, #60]	; 0x3c
        if (ep->xfer_len_db >= ep->maxpacket)
 800b598:	6cae      	ldr	r6, [r5, #72]	; 0x48
        ep->xfer_buff += TxByteNbre;
 800b59a:	18d1      	adds	r1, r2, r3
        ep->xfer_count += TxByteNbre;
 800b59c:	6c6a      	ldr	r2, [r5, #68]	; 0x44
        ep->xfer_buff += TxByteNbre;
 800b59e:	63e9      	str	r1, [r5, #60]	; 0x3c
        ep->xfer_count += TxByteNbre;
 800b5a0:	18d2      	adds	r2, r2, r3
 800b5a2:	646a      	str	r2, [r5, #68]	; 0x44
        if (ep->xfer_len_db >= ep->maxpacket)
 800b5a4:	6baa      	ldr	r2, [r5, #56]	; 0x38
 800b5a6:	4296      	cmp	r6, r2
 800b5a8:	d31b      	bcc.n	800b5e2 <HAL_PCD_IRQHandler+0x6be>
          ep->xfer_len_db -= len;
 800b5aa:	1ab6      	subs	r6, r6, r2
 800b5ac:	64ae      	str	r6, [r5, #72]	; 0x48
        PCD_SET_EP_DBUF0_CNT(hpcd->Instance, ep->num, ep->is_in, len);
 800b5ae:	9b01      	ldr	r3, [sp, #4]
 800b5b0:	9d01      	ldr	r5, [sp, #4]
 800b5b2:	3329      	adds	r3, #41	; 0x29
 800b5b4:	781e      	ldrb	r6, [r3, #0]
 800b5b6:	3528      	adds	r5, #40	; 0x28
 800b5b8:	b293      	uxth	r3, r2
 800b5ba:	2e00      	cmp	r6, #0
 800b5bc:	d134      	bne.n	800b628 <HAL_PCD_IRQHandler+0x704>
 800b5be:	0006      	movs	r6, r0
 800b5c0:	3650      	adds	r6, #80	; 0x50
 800b5c2:	8836      	ldrh	r6, [r6, #0]
 800b5c4:	782d      	ldrb	r5, [r5, #0]
 800b5c6:	4466      	add	r6, ip
 800b5c8:	00ed      	lsls	r5, r5, #3
 800b5ca:	19ad      	adds	r5, r5, r6
 800b5cc:	2a00      	cmp	r2, #0
 800b5ce:	d112      	bne.n	800b5f6 <HAL_PCD_IRQHandler+0x6d2>
 800b5d0:	882a      	ldrh	r2, [r5, #0]
 800b5d2:	4e65      	ldr	r6, [pc, #404]	; (800b768 <HAL_PCD_IRQHandler+0x844>)
 800b5d4:	4032      	ands	r2, r6
 800b5d6:	802a      	strh	r2, [r5, #0]
 800b5d8:	882e      	ldrh	r6, [r5, #0]
 800b5da:	9a02      	ldr	r2, [sp, #8]
 800b5dc:	4332      	orrs	r2, r6
 800b5de:	0016      	movs	r6, r2
 800b5e0:	e010      	b.n	800b604 <HAL_PCD_IRQHandler+0x6e0>
        else if (ep->xfer_len_db == 0U)
 800b5e2:	2e00      	cmp	r6, #0
 800b5e4:	d102      	bne.n	800b5ec <HAL_PCD_IRQHandler+0x6c8>
    if (ep->xfer_len > TxByteNbre)
 800b5e6:	001a      	movs	r2, r3
          ep->xfer_fill_db = 0U;
 800b5e8:	703e      	strb	r6, [r7, #0]
 800b5ea:	e7e0      	b.n	800b5ae <HAL_PCD_IRQHandler+0x68a>
          ep->xfer_fill_db = 0U;
 800b5ec:	2300      	movs	r3, #0
          ep->xfer_len_db = 0U;
 800b5ee:	0032      	movs	r2, r6
          ep->xfer_fill_db = 0U;
 800b5f0:	703b      	strb	r3, [r7, #0]
          ep->xfer_len_db = 0U;
 800b5f2:	64ab      	str	r3, [r5, #72]	; 0x48
 800b5f4:	e7db      	b.n	800b5ae <HAL_PCD_IRQHandler+0x68a>
        PCD_SET_EP_DBUF0_CNT(hpcd->Instance, ep->num, ep->is_in, len);
 800b5f6:	2a3e      	cmp	r2, #62	; 0x3e
 800b5f8:	d80e      	bhi.n	800b618 <HAL_PCD_IRQHandler+0x6f4>
 800b5fa:	2701      	movs	r7, #1
 800b5fc:	0856      	lsrs	r6, r2, #1
 800b5fe:	403a      	ands	r2, r7
 800b600:	18b6      	adds	r6, r6, r2
 800b602:	02b6      	lsls	r6, r6, #10
 800b604:	b2b6      	uxth	r6, r6
 800b606:	802e      	strh	r6, [r5, #0]
        USB_WritePMA(hpcd->Instance, ep->xfer_buff,  ep->pmaaddr0, (uint16_t)len);
 800b608:	2228      	movs	r2, #40	; 0x28
 800b60a:	9d00      	ldr	r5, [sp, #0]
 800b60c:	436a      	muls	r2, r5
 800b60e:	18a2      	adds	r2, r4, r2
 800b610:	8e12      	ldrh	r2, [r2, #48]	; 0x30
        USB_WritePMA(hpcd->Instance, ep->xfer_buff,  ep->pmaaddr1, (uint16_t)len);
 800b612:	f002 fa08 	bl	800da26 <USB_WritePMA>
 800b616:	e02e      	b.n	800b676 <HAL_PCD_IRQHandler+0x752>
        PCD_SET_EP_DBUF0_CNT(hpcd->Instance, ep->num, ep->is_in, len);
 800b618:	271f      	movs	r7, #31
 800b61a:	0956      	lsrs	r6, r2, #5
 800b61c:	403a      	ands	r2, r7
 800b61e:	4257      	negs	r7, r2
 800b620:	4157      	adcs	r7, r2
 800b622:	1bf6      	subs	r6, r6, r7
 800b624:	02b6      	lsls	r6, r6, #10
 800b626:	e7d8      	b.n	800b5da <HAL_PCD_IRQHandler+0x6b6>
 800b628:	2e01      	cmp	r6, #1
 800b62a:	d1ed      	bne.n	800b608 <HAL_PCD_IRQHandler+0x6e4>
 800b62c:	0002      	movs	r2, r0
 800b62e:	3250      	adds	r2, #80	; 0x50
 800b630:	8812      	ldrh	r2, [r2, #0]
 800b632:	782d      	ldrb	r5, [r5, #0]
 800b634:	4462      	add	r2, ip
 800b636:	00ed      	lsls	r5, r5, #3
 800b638:	18aa      	adds	r2, r5, r2
 800b63a:	8013      	strh	r3, [r2, #0]
 800b63c:	e7e4      	b.n	800b608 <HAL_PCD_IRQHandler+0x6e4>
    TxByteNbre = (uint16_t)PCD_GET_EP_DBUF1_CNT(hpcd->Instance, ep->num);
 800b63e:	4b4b      	ldr	r3, [pc, #300]	; (800b76c <HAL_PCD_IRQHandler+0x848>)
 800b640:	8836      	ldrh	r6, [r6, #0]
 800b642:	469c      	mov	ip, r3
 800b644:	4484      	add	ip, r0
 800b646:	4466      	add	r6, ip
 800b648:	5b76      	ldrh	r6, [r6, r5]
      ep->xfer_len = 0U;
 800b64a:	9b03      	ldr	r3, [sp, #12]
    TxByteNbre = (uint16_t)PCD_GET_EP_DBUF1_CNT(hpcd->Instance, ep->num);
 800b64c:	05b6      	lsls	r6, r6, #22
    if (ep->xfer_len >= TxByteNbre)
 800b64e:	0db6      	lsrs	r6, r6, #22
 800b650:	4296      	cmp	r6, r2
 800b652:	d800      	bhi.n	800b656 <HAL_PCD_IRQHandler+0x732>
      ep->xfer_len -= TxByteNbre;
 800b654:	1b93      	subs	r3, r2, r6
 800b656:	2228      	movs	r2, #40	; 0x28
 800b658:	9d00      	ldr	r5, [sp, #0]
 800b65a:	436a      	muls	r2, r5
 800b65c:	2580      	movs	r5, #128	; 0x80
 800b65e:	18a2      	adds	r2, r4, r2
 800b660:	01ed      	lsls	r5, r5, #7
 800b662:	6413      	str	r3, [r2, #64]	; 0x40
    if (ep->xfer_len == 0U)
 800b664:	403d      	ands	r5, r7
 800b666:	2b00      	cmp	r3, #0
 800b668:	d110      	bne.n	800b68c <HAL_PCD_IRQHandler+0x768>
      HAL_PCD_DataInStageCallback(hpcd, ep->num);
 800b66a:	0020      	movs	r0, r4
 800b66c:	f004 f8b0 	bl	800f7d0 <HAL_PCD_DataInStageCallback>
      if ((wEPVal & USB_EP_DTOG_RX) == 0U)
 800b670:	2d00      	cmp	r5, #0
 800b672:	d100      	bne.n	800b676 <HAL_PCD_IRQHandler+0x752>
 800b674:	e75b      	b.n	800b52e <HAL_PCD_IRQHandler+0x60a>
  PCD_SET_EP_TX_STATUS(hpcd->Instance, ep->num, USB_EP_TX_VALID);
 800b676:	9b01      	ldr	r3, [sp, #4]
 800b678:	6822      	ldr	r2, [r4, #0]
 800b67a:	3328      	adds	r3, #40	; 0x28
 800b67c:	781b      	ldrb	r3, [r3, #0]
 800b67e:	009b      	lsls	r3, r3, #2
 800b680:	18d1      	adds	r1, r2, r3
 800b682:	880b      	ldrh	r3, [r1, #0]
 800b684:	4a3a      	ldr	r2, [pc, #232]	; (800b770 <HAL_PCD_IRQHandler+0x84c>)
 800b686:	401a      	ands	r2, r3
 800b688:	2330      	movs	r3, #48	; 0x30
 800b68a:	e5ad      	b.n	800b1e8 <HAL_PCD_IRQHandler+0x2c4>
      if ((wEPVal & USB_EP_DTOG_RX) == 0U)
 800b68c:	2d00      	cmp	r5, #0
 800b68e:	d107      	bne.n	800b6a0 <HAL_PCD_IRQHandler+0x77c>
        PCD_FreeUserBuffer(hpcd->Instance, ep->num, 1U);
 800b690:	0089      	lsls	r1, r1, #2
 800b692:	1841      	adds	r1, r0, r1
 800b694:	880a      	ldrh	r2, [r1, #0]
 800b696:	4b32      	ldr	r3, [pc, #200]	; (800b760 <HAL_PCD_IRQHandler+0x83c>)
 800b698:	4013      	ands	r3, r2
 800b69a:	4a32      	ldr	r2, [pc, #200]	; (800b764 <HAL_PCD_IRQHandler+0x840>)
 800b69c:	4313      	orrs	r3, r2
 800b69e:	800b      	strh	r3, [r1, #0]
      if (ep->xfer_fill_db == 1U)
 800b6a0:	2328      	movs	r3, #40	; 0x28
 800b6a2:	9a00      	ldr	r2, [sp, #0]
 800b6a4:	4353      	muls	r3, r2
 800b6a6:	18e3      	adds	r3, r4, r3
 800b6a8:	001f      	movs	r7, r3
 800b6aa:	374c      	adds	r7, #76	; 0x4c
 800b6ac:	783a      	ldrb	r2, [r7, #0]
 800b6ae:	2a01      	cmp	r2, #1
 800b6b0:	d1e1      	bne.n	800b676 <HAL_PCD_IRQHandler+0x752>
        ep->xfer_buff += TxByteNbre;
 800b6b2:	6bda      	ldr	r2, [r3, #60]	; 0x3c
        if (ep->xfer_len_db >= ep->maxpacket)
 800b6b4:	6c9d      	ldr	r5, [r3, #72]	; 0x48
        ep->xfer_buff += TxByteNbre;
 800b6b6:	1991      	adds	r1, r2, r6
        ep->xfer_count += TxByteNbre;
 800b6b8:	6c5a      	ldr	r2, [r3, #68]	; 0x44
        ep->xfer_buff += TxByteNbre;
 800b6ba:	63d9      	str	r1, [r3, #60]	; 0x3c
        ep->xfer_count += TxByteNbre;
 800b6bc:	1992      	adds	r2, r2, r6
 800b6be:	645a      	str	r2, [r3, #68]	; 0x44
        if (ep->xfer_len_db >= ep->maxpacket)
 800b6c0:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 800b6c2:	4295      	cmp	r5, r2
 800b6c4:	d31b      	bcc.n	800b6fe <HAL_PCD_IRQHandler+0x7da>
          ep->xfer_len_db -= len;
 800b6c6:	1aad      	subs	r5, r5, r2
 800b6c8:	649d      	str	r5, [r3, #72]	; 0x48
        PCD_SET_EP_DBUF1_CNT(hpcd->Instance, ep->num, ep->is_in, len);
 800b6ca:	9b01      	ldr	r3, [sp, #4]
 800b6cc:	9d01      	ldr	r5, [sp, #4]
 800b6ce:	3329      	adds	r3, #41	; 0x29
 800b6d0:	781e      	ldrb	r6, [r3, #0]
 800b6d2:	3528      	adds	r5, #40	; 0x28
 800b6d4:	b293      	uxth	r3, r2
 800b6d6:	2e00      	cmp	r6, #0
 800b6d8:	d132      	bne.n	800b740 <HAL_PCD_IRQHandler+0x81c>
 800b6da:	0006      	movs	r6, r0
 800b6dc:	3650      	adds	r6, #80	; 0x50
 800b6de:	8836      	ldrh	r6, [r6, #0]
 800b6e0:	782d      	ldrb	r5, [r5, #0]
 800b6e2:	4466      	add	r6, ip
 800b6e4:	00ed      	lsls	r5, r5, #3
 800b6e6:	19ad      	adds	r5, r5, r6
 800b6e8:	2a00      	cmp	r2, #0
 800b6ea:	d112      	bne.n	800b712 <HAL_PCD_IRQHandler+0x7ee>
 800b6ec:	882a      	ldrh	r2, [r5, #0]
 800b6ee:	4e1e      	ldr	r6, [pc, #120]	; (800b768 <HAL_PCD_IRQHandler+0x844>)
 800b6f0:	4032      	ands	r2, r6
 800b6f2:	802a      	strh	r2, [r5, #0]
 800b6f4:	882e      	ldrh	r6, [r5, #0]
 800b6f6:	9a02      	ldr	r2, [sp, #8]
 800b6f8:	4332      	orrs	r2, r6
 800b6fa:	0016      	movs	r6, r2
 800b6fc:	e010      	b.n	800b720 <HAL_PCD_IRQHandler+0x7fc>
        else if (ep->xfer_len_db == 0U)
 800b6fe:	2d00      	cmp	r5, #0
 800b700:	d102      	bne.n	800b708 <HAL_PCD_IRQHandler+0x7e4>
    if (ep->xfer_len >= TxByteNbre)
 800b702:	0032      	movs	r2, r6
          ep->xfer_fill_db = 0U;
 800b704:	703d      	strb	r5, [r7, #0]
 800b706:	e7e0      	b.n	800b6ca <HAL_PCD_IRQHandler+0x7a6>
          ep->xfer_len_db = 0U;
 800b708:	2200      	movs	r2, #0
 800b70a:	649a      	str	r2, [r3, #72]	; 0x48
          ep->xfer_fill_db = 0;
 800b70c:	703a      	strb	r2, [r7, #0]
 800b70e:	002a      	movs	r2, r5
 800b710:	e7db      	b.n	800b6ca <HAL_PCD_IRQHandler+0x7a6>
        PCD_SET_EP_DBUF1_CNT(hpcd->Instance, ep->num, ep->is_in, len);
 800b712:	2a3e      	cmp	r2, #62	; 0x3e
 800b714:	d80c      	bhi.n	800b730 <HAL_PCD_IRQHandler+0x80c>
 800b716:	2701      	movs	r7, #1
 800b718:	0856      	lsrs	r6, r2, #1
 800b71a:	403a      	ands	r2, r7
 800b71c:	18b6      	adds	r6, r6, r2
 800b71e:	02b6      	lsls	r6, r6, #10
 800b720:	b2b6      	uxth	r6, r6
 800b722:	802e      	strh	r6, [r5, #0]
        USB_WritePMA(hpcd->Instance, ep->xfer_buff,  ep->pmaaddr1, (uint16_t)len);
 800b724:	2228      	movs	r2, #40	; 0x28
 800b726:	9d00      	ldr	r5, [sp, #0]
 800b728:	436a      	muls	r2, r5
 800b72a:	18a2      	adds	r2, r4, r2
 800b72c:	8e52      	ldrh	r2, [r2, #50]	; 0x32
 800b72e:	e770      	b.n	800b612 <HAL_PCD_IRQHandler+0x6ee>
        PCD_SET_EP_DBUF1_CNT(hpcd->Instance, ep->num, ep->is_in, len);
 800b730:	271f      	movs	r7, #31
 800b732:	0956      	lsrs	r6, r2, #5
 800b734:	403a      	ands	r2, r7
 800b736:	4257      	negs	r7, r2
 800b738:	4157      	adcs	r7, r2
 800b73a:	1bf6      	subs	r6, r6, r7
 800b73c:	02b6      	lsls	r6, r6, #10
 800b73e:	e7da      	b.n	800b6f6 <HAL_PCD_IRQHandler+0x7d2>
 800b740:	2e01      	cmp	r6, #1
 800b742:	d1ef      	bne.n	800b724 <HAL_PCD_IRQHandler+0x800>
 800b744:	0002      	movs	r2, r0
 800b746:	3250      	adds	r2, #80	; 0x50
 800b748:	8812      	ldrh	r2, [r2, #0]
 800b74a:	782d      	ldrb	r5, [r5, #0]
 800b74c:	4462      	add	r2, ip
 800b74e:	00ed      	lsls	r5, r5, #3
 800b750:	18aa      	adds	r2, r5, r2
 800b752:	8013      	strh	r3, [r2, #0]
 800b754:	e7e6      	b.n	800b724 <HAL_PCD_IRQHandler+0x800>
      HAL_PCD_SuspendCallback(hpcd);
 800b756:	0020      	movs	r0, r4
 800b758:	f004 f85e 	bl	800f818 <HAL_PCD_SuspendCallback>
 800b75c:	e473      	b.n	800b046 <HAL_PCD_IRQHandler+0x122>
 800b75e:	46c0      	nop			; (mov r8, r8)
 800b760:	ffff8f8f 	.word	0xffff8f8f
 800b764:	0000c080 	.word	0x0000c080
 800b768:	ffff83ff 	.word	0xffff83ff
 800b76c:	00000406 	.word	0x00000406
 800b770:	ffff8fbf 	.word	0xffff8fbf

0800b774 <HAL_PCD_EP_Open>:
{
 800b774:	b570      	push	{r4, r5, r6, lr}
 800b776:	0005      	movs	r5, r0
 800b778:	2007      	movs	r0, #7
 800b77a:	4008      	ands	r0, r1
  if ((ep_addr & 0x80U) == 0x80U)
 800b77c:	b249      	sxtb	r1, r1
 800b77e:	2428      	movs	r4, #40	; 0x28
 800b780:	2900      	cmp	r1, #0
 800b782:	da1d      	bge.n	800b7c0 <HAL_PCD_EP_Open+0x4c>
    ep = &hpcd->IN_ep[ep_addr & EP_ADDR_MSK];
 800b784:	1c41      	adds	r1, r0, #1
 800b786:	4361      	muls	r1, r4
    ep->is_in = 1U;
 800b788:	3c27      	subs	r4, #39	; 0x27
    ep = &hpcd->IN_ep[ep_addr & EP_ADDR_MSK];
 800b78a:	1869      	adds	r1, r5, r1
    ep->is_in = 1U;
 800b78c:	704c      	strb	r4, [r1, #1]
  ep->maxpacket = ep_mps;
 800b78e:	610a      	str	r2, [r1, #16]
  if (ep->is_in != 0U)
 800b790:	784a      	ldrb	r2, [r1, #1]
  ep->num = ep_addr & EP_ADDR_MSK;
 800b792:	7008      	strb	r0, [r1, #0]
  ep->type = ep_type;
 800b794:	70cb      	strb	r3, [r1, #3]
  if (ep->is_in != 0U)
 800b796:	2a00      	cmp	r2, #0
 800b798:	d000      	beq.n	800b79c <HAL_PCD_EP_Open+0x28>
    ep->tx_fifo_num = ep->num;
 800b79a:	81c8      	strh	r0, [r1, #14]
  if (ep_type == EP_TYPE_BULK)
 800b79c:	2b02      	cmp	r3, #2
 800b79e:	d101      	bne.n	800b7a4 <HAL_PCD_EP_Open+0x30>
    ep->data_pid_start = 0U;
 800b7a0:	2300      	movs	r3, #0
 800b7a2:	710b      	strb	r3, [r1, #4]
  __HAL_LOCK(hpcd);
 800b7a4:	24aa      	movs	r4, #170	; 0xaa
 800b7a6:	00a4      	lsls	r4, r4, #2
 800b7a8:	5d2b      	ldrb	r3, [r5, r4]
 800b7aa:	2002      	movs	r0, #2
 800b7ac:	2b01      	cmp	r3, #1
 800b7ae:	d006      	beq.n	800b7be <HAL_PCD_EP_Open+0x4a>
 800b7b0:	2301      	movs	r3, #1
 800b7b2:	552b      	strb	r3, [r5, r4]
  (void)USB_ActivateEndpoint(hpcd->Instance, ep);
 800b7b4:	6828      	ldr	r0, [r5, #0]
 800b7b6:	f001 fef9 	bl	800d5ac <USB_ActivateEndpoint>
  __HAL_UNLOCK(hpcd);
 800b7ba:	2000      	movs	r0, #0
 800b7bc:	5528      	strb	r0, [r5, r4]
}
 800b7be:	bd70      	pop	{r4, r5, r6, pc}
    ep = &hpcd->OUT_ep[ep_addr & EP_ADDR_MSK];
 800b7c0:	4344      	muls	r4, r0
 800b7c2:	0021      	movs	r1, r4
    ep->is_in = 0U;
 800b7c4:	2600      	movs	r6, #0
 800b7c6:	192c      	adds	r4, r5, r4
    ep = &hpcd->OUT_ep[ep_addr & EP_ADDR_MSK];
 800b7c8:	3169      	adds	r1, #105	; 0x69
    ep->is_in = 0U;
 800b7ca:	346a      	adds	r4, #106	; 0x6a
    ep = &hpcd->OUT_ep[ep_addr & EP_ADDR_MSK];
 800b7cc:	31ff      	adds	r1, #255	; 0xff
    ep->is_in = 0U;
 800b7ce:	34ff      	adds	r4, #255	; 0xff
    ep = &hpcd->OUT_ep[ep_addr & EP_ADDR_MSK];
 800b7d0:	1869      	adds	r1, r5, r1
    ep->is_in = 0U;
 800b7d2:	7026      	strb	r6, [r4, #0]
 800b7d4:	e7db      	b.n	800b78e <HAL_PCD_EP_Open+0x1a>

0800b7d6 <HAL_PCD_EP_Close>:
{
 800b7d6:	b570      	push	{r4, r5, r6, lr}
 800b7d8:	0004      	movs	r4, r0
 800b7da:	2007      	movs	r0, #7
 800b7dc:	4008      	ands	r0, r1
  if ((ep_addr & 0x80U) == 0x80U)
 800b7de:	b249      	sxtb	r1, r1
 800b7e0:	2328      	movs	r3, #40	; 0x28
 800b7e2:	2900      	cmp	r1, #0
 800b7e4:	da13      	bge.n	800b80e <HAL_PCD_EP_Close+0x38>
    ep = &hpcd->IN_ep[ep_addr & EP_ADDR_MSK];
 800b7e6:	1c41      	adds	r1, r0, #1
 800b7e8:	4359      	muls	r1, r3
    ep->is_in = 1U;
 800b7ea:	3b27      	subs	r3, #39	; 0x27
    ep = &hpcd->IN_ep[ep_addr & EP_ADDR_MSK];
 800b7ec:	1861      	adds	r1, r4, r1
    ep->is_in = 1U;
 800b7ee:	704b      	strb	r3, [r1, #1]
  __HAL_LOCK(hpcd);
 800b7f0:	25aa      	movs	r5, #170	; 0xaa
  ep->num   = ep_addr & EP_ADDR_MSK;
 800b7f2:	7008      	strb	r0, [r1, #0]
  __HAL_LOCK(hpcd);
 800b7f4:	00ad      	lsls	r5, r5, #2
 800b7f6:	5d63      	ldrb	r3, [r4, r5]
 800b7f8:	2002      	movs	r0, #2
 800b7fa:	2b01      	cmp	r3, #1
 800b7fc:	d006      	beq.n	800b80c <HAL_PCD_EP_Close+0x36>
 800b7fe:	2301      	movs	r3, #1
 800b800:	5563      	strb	r3, [r4, r5]
  (void)USB_DeactivateEndpoint(hpcd->Instance, ep);
 800b802:	6820      	ldr	r0, [r4, #0]
 800b804:	f002 f806 	bl	800d814 <USB_DeactivateEndpoint>
  __HAL_UNLOCK(hpcd);
 800b808:	2000      	movs	r0, #0
 800b80a:	5560      	strb	r0, [r4, r5]
}
 800b80c:	bd70      	pop	{r4, r5, r6, pc}
    ep = &hpcd->OUT_ep[ep_addr & EP_ADDR_MSK];
 800b80e:	4343      	muls	r3, r0
 800b810:	0019      	movs	r1, r3
    ep->is_in = 0U;
 800b812:	18e2      	adds	r2, r4, r3
 800b814:	2300      	movs	r3, #0
    ep = &hpcd->OUT_ep[ep_addr & EP_ADDR_MSK];
 800b816:	3169      	adds	r1, #105	; 0x69
    ep->is_in = 0U;
 800b818:	326a      	adds	r2, #106	; 0x6a
    ep = &hpcd->OUT_ep[ep_addr & EP_ADDR_MSK];
 800b81a:	31ff      	adds	r1, #255	; 0xff
    ep->is_in = 0U;
 800b81c:	32ff      	adds	r2, #255	; 0xff
    ep = &hpcd->OUT_ep[ep_addr & EP_ADDR_MSK];
 800b81e:	1861      	adds	r1, r4, r1
    ep->is_in = 0U;
 800b820:	7013      	strb	r3, [r2, #0]
 800b822:	e7e5      	b.n	800b7f0 <HAL_PCD_EP_Close+0x1a>

0800b824 <HAL_PCD_EP_Receive>:
{
 800b824:	b570      	push	{r4, r5, r6, lr}
 800b826:	2407      	movs	r4, #7
 800b828:	4021      	ands	r1, r4
  ep->xfer_buff = pBuf;
 800b82a:	3421      	adds	r4, #33	; 0x21
 800b82c:	434c      	muls	r4, r1
 800b82e:	1905      	adds	r5, r0, r4
 800b830:	002e      	movs	r6, r5
 800b832:	367d      	adds	r6, #125	; 0x7d
 800b834:	36ff      	adds	r6, #255	; 0xff
 800b836:	6032      	str	r2, [r6, #0]
  ep->xfer_len = len;
 800b838:	002a      	movs	r2, r5
 800b83a:	3281      	adds	r2, #129	; 0x81
 800b83c:	32ff      	adds	r2, #255	; 0xff
 800b83e:	6013      	str	r3, [r2, #0]
  ep->xfer_count = 0U;
 800b840:	002b      	movs	r3, r5
 800b842:	2600      	movs	r6, #0
 800b844:	3385      	adds	r3, #133	; 0x85
 800b846:	33ff      	adds	r3, #255	; 0xff
  ep->num = ep_addr & EP_ADDR_MSK;
 800b848:	3569      	adds	r5, #105	; 0x69
  ep->xfer_count = 0U;
 800b84a:	601e      	str	r6, [r3, #0]
  ep->num = ep_addr & EP_ADDR_MSK;
 800b84c:	35ff      	adds	r5, #255	; 0xff
  ep->is_in = 0U;
 800b84e:	3b1b      	subs	r3, #27
 800b850:	701e      	strb	r6, [r3, #0]
  ep->num = ep_addr & EP_ADDR_MSK;
 800b852:	7029      	strb	r1, [r5, #0]
  ep = &hpcd->OUT_ep[ep_addr & EP_ADDR_MSK];
 800b854:	0021      	movs	r1, r4
 800b856:	3169      	adds	r1, #105	; 0x69
 800b858:	31ff      	adds	r1, #255	; 0xff
 800b85a:	1841      	adds	r1, r0, r1
    (void)USB_EPStartXfer(hpcd->Instance, ep);
 800b85c:	6800      	ldr	r0, [r0, #0]
 800b85e:	f002 f8f7 	bl	800da50 <USB_EPStartXfer>
}
 800b862:	0030      	movs	r0, r6
 800b864:	bd70      	pop	{r4, r5, r6, pc}

0800b866 <HAL_PCD_EP_GetRxCount>:
  return hpcd->OUT_ep[ep_addr & EP_ADDR_MSK].xfer_count;
 800b866:	2307      	movs	r3, #7
 800b868:	400b      	ands	r3, r1
 800b86a:	2128      	movs	r1, #40	; 0x28
 800b86c:	4359      	muls	r1, r3
 800b86e:	1840      	adds	r0, r0, r1
 800b870:	3085      	adds	r0, #133	; 0x85
 800b872:	30ff      	adds	r0, #255	; 0xff
 800b874:	6800      	ldr	r0, [r0, #0]
}
 800b876:	4770      	bx	lr

0800b878 <HAL_PCD_EP_Transmit>:
{
 800b878:	b570      	push	{r4, r5, r6, lr}
  ep->xfer_buff = pBuf;
 800b87a:	2628      	movs	r6, #40	; 0x28
 800b87c:	2407      	movs	r4, #7
 800b87e:	4021      	ands	r1, r4
 800b880:	0034      	movs	r4, r6
 800b882:	434c      	muls	r4, r1
 800b884:	1904      	adds	r4, r0, r4
  ep->xfer_fill_db = 1U;
 800b886:	0025      	movs	r5, r4
  ep->xfer_buff = pBuf;
 800b888:	63e2      	str	r2, [r4, #60]	; 0x3c
  ep->xfer_fill_db = 1U;
 800b88a:	2201      	movs	r2, #1
 800b88c:	354c      	adds	r5, #76	; 0x4c
  ep->xfer_len = len;
 800b88e:	6423      	str	r3, [r4, #64]	; 0x40
  ep->xfer_fill_db = 1U;
 800b890:	702a      	strb	r2, [r5, #0]
  ep->xfer_count = 0U;
 800b892:	2500      	movs	r5, #0
  ep->xfer_len_db = len;
 800b894:	64a3      	str	r3, [r4, #72]	; 0x48
  ep->is_in = 1U;
 800b896:	0023      	movs	r3, r4
  ep->xfer_count = 0U;
 800b898:	6465      	str	r5, [r4, #68]	; 0x44
  ep->is_in = 1U;
 800b89a:	3329      	adds	r3, #41	; 0x29
  ep->num = ep_addr & EP_ADDR_MSK;
 800b89c:	19a4      	adds	r4, r4, r6
  ep->is_in = 1U;
 800b89e:	701a      	strb	r2, [r3, #0]
  ep->num = ep_addr & EP_ADDR_MSK;
 800b8a0:	7021      	strb	r1, [r4, #0]
  ep = &hpcd->IN_ep[ep_addr & EP_ADDR_MSK];
 800b8a2:	1889      	adds	r1, r1, r2
 800b8a4:	4371      	muls	r1, r6
 800b8a6:	1841      	adds	r1, r0, r1
    (void)USB_EPStartXfer(hpcd->Instance, ep);
 800b8a8:	6800      	ldr	r0, [r0, #0]
 800b8aa:	f002 f8d1 	bl	800da50 <USB_EPStartXfer>
}
 800b8ae:	0028      	movs	r0, r5
 800b8b0:	bd70      	pop	{r4, r5, r6, pc}

0800b8b2 <HAL_PCD_EP_SetStall>:
{
 800b8b2:	b570      	push	{r4, r5, r6, lr}
 800b8b4:	0004      	movs	r4, r0
 800b8b6:	2507      	movs	r5, #7
  if (((uint32_t)ep_addr & EP_ADDR_MSK) > hpcd->Init.dev_endpoints)
 800b8b8:	6863      	ldr	r3, [r4, #4]
    return HAL_ERROR;
 800b8ba:	2001      	movs	r0, #1
 800b8bc:	400d      	ands	r5, r1
  if (((uint32_t)ep_addr & EP_ADDR_MSK) > hpcd->Init.dev_endpoints)
 800b8be:	429d      	cmp	r5, r3
 800b8c0:	d816      	bhi.n	800b8f0 <HAL_PCD_EP_SetStall+0x3e>
  if ((0x80U & ep_addr) == 0x80U)
 800b8c2:	b24a      	sxtb	r2, r1
 800b8c4:	2328      	movs	r3, #40	; 0x28
 800b8c6:	2a00      	cmp	r2, #0
 800b8c8:	da13      	bge.n	800b8f2 <HAL_PCD_EP_SetStall+0x40>
    ep = &hpcd->IN_ep[ep_addr & EP_ADDR_MSK];
 800b8ca:	1829      	adds	r1, r5, r0
 800b8cc:	4359      	muls	r1, r3
 800b8ce:	1861      	adds	r1, r4, r1
    ep->is_in = 1U;
 800b8d0:	7048      	strb	r0, [r1, #1]
  ep->num = ep_addr & EP_ADDR_MSK;
 800b8d2:	700d      	strb	r5, [r1, #0]
  ep->is_stall = 1U;
 800b8d4:	2301      	movs	r3, #1
  __HAL_LOCK(hpcd);
 800b8d6:	25aa      	movs	r5, #170	; 0xaa
  ep->is_stall = 1U;
 800b8d8:	708b      	strb	r3, [r1, #2]
  __HAL_LOCK(hpcd);
 800b8da:	00ad      	lsls	r5, r5, #2
 800b8dc:	5d62      	ldrb	r2, [r4, r5]
 800b8de:	2002      	movs	r0, #2
 800b8e0:	429a      	cmp	r2, r3
 800b8e2:	d005      	beq.n	800b8f0 <HAL_PCD_EP_SetStall+0x3e>
 800b8e4:	5563      	strb	r3, [r4, r5]
  (void)USB_EPSetStall(hpcd->Instance, ep);
 800b8e6:	6820      	ldr	r0, [r4, #0]
 800b8e8:	f002 f82a 	bl	800d940 <USB_EPSetStall>
  __HAL_UNLOCK(hpcd);
 800b8ec:	2000      	movs	r0, #0
 800b8ee:	5560      	strb	r0, [r4, r5]
}
 800b8f0:	bd70      	pop	{r4, r5, r6, pc}
    ep = &hpcd->OUT_ep[ep_addr];
 800b8f2:	434b      	muls	r3, r1
 800b8f4:	0019      	movs	r1, r3
    ep->is_in = 0U;
 800b8f6:	18e2      	adds	r2, r4, r3
 800b8f8:	2300      	movs	r3, #0
    ep = &hpcd->OUT_ep[ep_addr];
 800b8fa:	3169      	adds	r1, #105	; 0x69
    ep->is_in = 0U;
 800b8fc:	326a      	adds	r2, #106	; 0x6a
    ep = &hpcd->OUT_ep[ep_addr];
 800b8fe:	31ff      	adds	r1, #255	; 0xff
    ep->is_in = 0U;
 800b900:	32ff      	adds	r2, #255	; 0xff
    ep = &hpcd->OUT_ep[ep_addr];
 800b902:	1861      	adds	r1, r4, r1
    ep->is_in = 0U;
 800b904:	7013      	strb	r3, [r2, #0]
 800b906:	e7e4      	b.n	800b8d2 <HAL_PCD_EP_SetStall+0x20>

0800b908 <HAL_PCD_EP_ClrStall>:
{
 800b908:	b570      	push	{r4, r5, r6, lr}
 800b90a:	0004      	movs	r4, r0
  if (((uint32_t)ep_addr & 0x0FU) > hpcd->Init.dev_endpoints)
 800b90c:	230f      	movs	r3, #15
 800b90e:	6862      	ldr	r2, [r4, #4]
    return HAL_ERROR;
 800b910:	2001      	movs	r0, #1
  if (((uint32_t)ep_addr & 0x0FU) > hpcd->Init.dev_endpoints)
 800b912:	400b      	ands	r3, r1
 800b914:	4293      	cmp	r3, r2
 800b916:	d81a      	bhi.n	800b94e <HAL_PCD_EP_ClrStall+0x46>
  if ((0x80U & ep_addr) == 0x80U)
 800b918:	3006      	adds	r0, #6
 800b91a:	4008      	ands	r0, r1
 800b91c:	b249      	sxtb	r1, r1
 800b91e:	2328      	movs	r3, #40	; 0x28
 800b920:	2900      	cmp	r1, #0
 800b922:	da15      	bge.n	800b950 <HAL_PCD_EP_ClrStall+0x48>
    ep = &hpcd->IN_ep[ep_addr & EP_ADDR_MSK];
 800b924:	1c41      	adds	r1, r0, #1
 800b926:	4359      	muls	r1, r3
    ep->is_in = 1U;
 800b928:	3b27      	subs	r3, #39	; 0x27
    ep = &hpcd->IN_ep[ep_addr & EP_ADDR_MSK];
 800b92a:	1861      	adds	r1, r4, r1
    ep->is_in = 1U;
 800b92c:	704b      	strb	r3, [r1, #1]
  ep->is_stall = 0U;
 800b92e:	2500      	movs	r5, #0
  __HAL_LOCK(hpcd);
 800b930:	26aa      	movs	r6, #170	; 0xaa
  ep->num = ep_addr & EP_ADDR_MSK;
 800b932:	7008      	strb	r0, [r1, #0]
  ep->is_stall = 0U;
 800b934:	708d      	strb	r5, [r1, #2]
  __HAL_LOCK(hpcd);
 800b936:	00b6      	lsls	r6, r6, #2
 800b938:	5da3      	ldrb	r3, [r4, r6]
 800b93a:	2002      	movs	r0, #2
 800b93c:	2b01      	cmp	r3, #1
 800b93e:	d006      	beq.n	800b94e <HAL_PCD_EP_ClrStall+0x46>
 800b940:	2301      	movs	r3, #1
 800b942:	55a3      	strb	r3, [r4, r6]
  (void)USB_EPClearStall(hpcd->Instance, ep);
 800b944:	6820      	ldr	r0, [r4, #0]
 800b946:	f002 f819 	bl	800d97c <USB_EPClearStall>
  return HAL_OK;
 800b94a:	0028      	movs	r0, r5
  __HAL_UNLOCK(hpcd);
 800b94c:	55a5      	strb	r5, [r4, r6]
}
 800b94e:	bd70      	pop	{r4, r5, r6, pc}
    ep = &hpcd->OUT_ep[ep_addr & EP_ADDR_MSK];
 800b950:	4343      	muls	r3, r0
 800b952:	0019      	movs	r1, r3
    ep->is_in = 0U;
 800b954:	18e2      	adds	r2, r4, r3
 800b956:	2300      	movs	r3, #0
    ep = &hpcd->OUT_ep[ep_addr & EP_ADDR_MSK];
 800b958:	3169      	adds	r1, #105	; 0x69
    ep->is_in = 0U;
 800b95a:	326a      	adds	r2, #106	; 0x6a
    ep = &hpcd->OUT_ep[ep_addr & EP_ADDR_MSK];
 800b95c:	31ff      	adds	r1, #255	; 0xff
    ep->is_in = 0U;
 800b95e:	32ff      	adds	r2, #255	; 0xff
    ep = &hpcd->OUT_ep[ep_addr & EP_ADDR_MSK];
 800b960:	1861      	adds	r1, r4, r1
    ep->is_in = 0U;
 800b962:	7013      	strb	r3, [r2, #0]
 800b964:	e7e3      	b.n	800b92e <HAL_PCD_EP_ClrStall+0x26>

0800b966 <HAL_PCDEx_PMAConfig>:
  * @retval HAL status
  */

HAL_StatusTypeDef  HAL_PCDEx_PMAConfig(PCD_HandleTypeDef *hpcd, uint16_t ep_addr,
                                       uint16_t ep_kind, uint32_t pmaadress)
{
 800b966:	b510      	push	{r4, lr}
 800b968:	000c      	movs	r4, r1
  PCD_EPTypeDef *ep;

  /* initialize ep structure*/
  if ((0x80U & ep_addr) == 0x80U)
 800b96a:	0621      	lsls	r1, r4, #24
 800b96c:	d50c      	bpl.n	800b988 <HAL_PCDEx_PMAConfig+0x22>
  {
    ep = &hpcd->IN_ep[ep_addr & EP_ADDR_MSK];
 800b96e:	2107      	movs	r1, #7
 800b970:	4021      	ands	r1, r4
 800b972:	2428      	movs	r4, #40	; 0x28
 800b974:	3101      	adds	r1, #1
 800b976:	4361      	muls	r1, r4
  }
  else
  {
    ep = &hpcd->OUT_ep[ep_addr];
 800b978:	1840      	adds	r0, r0, r1
  }

  /* Here we check if the endpoint is single or double Buffer*/
  if (ep_kind == PCD_SNG_BUF)
 800b97a:	b299      	uxth	r1, r3
 800b97c:	2a00      	cmp	r2, #0
 800b97e:	d108      	bne.n	800b992 <HAL_PCDEx_PMAConfig+0x2c>
  {
    /* Single Buffer */
    ep->doublebuffer = 0U;
 800b980:	7302      	strb	r2, [r0, #12]
    /* Configure the PMA */
    ep->pmaadress = (uint16_t)pmaadress;
 800b982:	80c1      	strh	r1, [r0, #6]
    ep->pmaaddr0 = (uint16_t)(pmaadress & 0xFFFFU);
    ep->pmaaddr1 = (uint16_t)((pmaadress & 0xFFFF0000U) >> 16);
  }

  return HAL_OK;
}
 800b984:	2000      	movs	r0, #0
 800b986:	bd10      	pop	{r4, pc}
    ep = &hpcd->OUT_ep[ep_addr];
 800b988:	2128      	movs	r1, #40	; 0x28
 800b98a:	4361      	muls	r1, r4
 800b98c:	3169      	adds	r1, #105	; 0x69
 800b98e:	31ff      	adds	r1, #255	; 0xff
 800b990:	e7f2      	b.n	800b978 <HAL_PCDEx_PMAConfig+0x12>
    ep->doublebuffer = 1U;
 800b992:	2201      	movs	r2, #1
    ep->pmaaddr0 = (uint16_t)(pmaadress & 0xFFFFU);
 800b994:	6083      	str	r3, [r0, #8]
    ep->doublebuffer = 1U;
 800b996:	7302      	strb	r2, [r0, #12]
    ep->pmaaddr1 = (uint16_t)((pmaadress & 0xFFFF0000U) >> 16);
 800b998:	e7f4      	b.n	800b984 <HAL_PCDEx_PMAConfig+0x1e>

0800b99a <HAL_PCDEx_ActivateLPM>:
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCDEx_ActivateLPM(PCD_HandleTypeDef *hpcd)
{

  USB_TypeDef *USBx = hpcd->Instance;
 800b99a:	6803      	ldr	r3, [r0, #0]
{
 800b99c:	0002      	movs	r2, r0
  hpcd->lpm_active = 1U;
 800b99e:	20ba      	movs	r0, #186	; 0xba
 800b9a0:	2101      	movs	r1, #1
{
 800b9a2:	b510      	push	{r4, lr}
  hpcd->lpm_active = 1U;
 800b9a4:	0080      	lsls	r0, r0, #2
  hpcd->LPM_State = LPM_L0;
 800b9a6:	24b8      	movs	r4, #184	; 0xb8
  hpcd->lpm_active = 1U;
 800b9a8:	5011      	str	r1, [r2, r0]
  hpcd->LPM_State = LPM_L0;
 800b9aa:	2000      	movs	r0, #0
 800b9ac:	00a4      	lsls	r4, r4, #2
 800b9ae:	5510      	strb	r0, [r2, r4]

  USBx->LPMCSR |= USB_LPMCSR_LMPEN;
 800b9b0:	3354      	adds	r3, #84	; 0x54
 800b9b2:	881a      	ldrh	r2, [r3, #0]
 800b9b4:	4311      	orrs	r1, r2
  USBx->LPMCSR |= USB_LPMCSR_LPMACK;
 800b9b6:	2202      	movs	r2, #2
  USBx->LPMCSR |= USB_LPMCSR_LMPEN;
 800b9b8:	8019      	strh	r1, [r3, #0]
  USBx->LPMCSR |= USB_LPMCSR_LPMACK;
 800b9ba:	8819      	ldrh	r1, [r3, #0]
 800b9bc:	430a      	orrs	r2, r1
 800b9be:	801a      	strh	r2, [r3, #0]

  return HAL_OK;
}
 800b9c0:	bd10      	pop	{r4, pc}

0800b9c2 <HAL_PCDEx_LPM_Callback>:
  UNUSED(msg);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_PCDEx_LPM_Callback could be implemented in the user file
   */
}
 800b9c2:	4770      	bx	lr

0800b9c4 <HAL_RCC_OscConfig>:
  *         supported by this macro. User should request a transition to HSE Off
  *         first and then HSE On or HSE Bypass.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RCC_OscConfig(RCC_OscInitTypeDef  *RCC_OscInitStruct)
{
 800b9c4:	b5f0      	push	{r4, r5, r6, r7, lr}
 800b9c6:	0004      	movs	r4, r0
 800b9c8:	b085      	sub	sp, #20
  uint32_t tickstart;
  uint32_t pll_config;
  uint32_t pll_config2;

  /* Check Null pointer */
  if(RCC_OscInitStruct == NULL)
 800b9ca:	2800      	cmp	r0, #0
 800b9cc:	d102      	bne.n	800b9d4 <HAL_RCC_OscConfig+0x10>
  {
    return HAL_ERROR;
 800b9ce:	2001      	movs	r0, #1
      }
    }
  }

  return HAL_OK;
}
 800b9d0:	b005      	add	sp, #20
 800b9d2:	bdf0      	pop	{r4, r5, r6, r7, pc}
  assert_param(IS_RCC_OSCILLATORTYPE(RCC_OscInitStruct->OscillatorType));
 800b9d4:	6803      	ldr	r3, [r0, #0]
 800b9d6:	2b00      	cmp	r3, #0
 800b9d8:	d142      	bne.n	800ba60 <HAL_RCC_OscConfig+0x9c>
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSI) == RCC_OSCILLATORTYPE_LSI)
 800b9da:	6823      	ldr	r3, [r4, #0]
 800b9dc:	071b      	lsls	r3, r3, #28
 800b9de:	d500      	bpl.n	800b9e2 <HAL_RCC_OscConfig+0x1e>
 800b9e0:	e102      	b.n	800bbe8 <HAL_RCC_OscConfig+0x224>
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSE) == RCC_OSCILLATORTYPE_LSE)
 800b9e2:	6823      	ldr	r3, [r4, #0]
 800b9e4:	075b      	lsls	r3, r3, #29
 800b9e6:	d500      	bpl.n	800b9ea <HAL_RCC_OscConfig+0x26>
 800b9e8:	e12d      	b.n	800bc46 <HAL_RCC_OscConfig+0x282>
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSI14) == RCC_OSCILLATORTYPE_HSI14)
 800b9ea:	6823      	ldr	r3, [r4, #0]
 800b9ec:	06db      	lsls	r3, r3, #27
 800b9ee:	d52a      	bpl.n	800ba46 <HAL_RCC_OscConfig+0x82>
    assert_param(IS_RCC_HSI14(RCC_OscInitStruct->HSI14State));
 800b9f0:	6963      	ldr	r3, [r4, #20]
 800b9f2:	2b01      	cmp	r3, #1
 800b9f4:	d905      	bls.n	800ba02 <HAL_RCC_OscConfig+0x3e>
 800b9f6:	3305      	adds	r3, #5
 800b9f8:	d003      	beq.n	800ba02 <HAL_RCC_OscConfig+0x3e>
 800b9fa:	49bb      	ldr	r1, [pc, #748]	; (800bce8 <HAL_RCC_OscConfig+0x324>)
 800b9fc:	48bb      	ldr	r0, [pc, #748]	; (800bcec <HAL_RCC_OscConfig+0x328>)
 800b9fe:	f7fc ff97 	bl	8008930 <assert_failed>
    assert_param(IS_RCC_CALIBRATION_VALUE(RCC_OscInitStruct->HSI14CalibrationValue));
 800ba02:	69a3      	ldr	r3, [r4, #24]
 800ba04:	2b1f      	cmp	r3, #31
 800ba06:	d903      	bls.n	800ba10 <HAL_RCC_OscConfig+0x4c>
 800ba08:	49b9      	ldr	r1, [pc, #740]	; (800bcf0 <HAL_RCC_OscConfig+0x32c>)
 800ba0a:	48b8      	ldr	r0, [pc, #736]	; (800bcec <HAL_RCC_OscConfig+0x328>)
 800ba0c:	f7fc ff90 	bl	8008930 <assert_failed>
    if(RCC_OscInitStruct->HSI14State == RCC_HSI14_ON)
 800ba10:	6962      	ldr	r2, [r4, #20]
 800ba12:	2304      	movs	r3, #4
 800ba14:	4db7      	ldr	r5, [pc, #732]	; (800bcf4 <HAL_RCC_OscConfig+0x330>)
 800ba16:	2a01      	cmp	r2, #1
 800ba18:	d000      	beq.n	800ba1c <HAL_RCC_OscConfig+0x58>
 800ba1a:	e1a5      	b.n	800bd68 <HAL_RCC_OscConfig+0x3a4>
      __HAL_RCC_HSI14ADC_DISABLE();
 800ba1c:	6b69      	ldr	r1, [r5, #52]	; 0x34
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSI14RDY) == RESET)
 800ba1e:	2702      	movs	r7, #2
      __HAL_RCC_HSI14ADC_DISABLE();
 800ba20:	430b      	orrs	r3, r1
 800ba22:	636b      	str	r3, [r5, #52]	; 0x34
      __HAL_RCC_HSI14_ENABLE();
 800ba24:	6b6b      	ldr	r3, [r5, #52]	; 0x34
 800ba26:	431a      	orrs	r2, r3
 800ba28:	636a      	str	r2, [r5, #52]	; 0x34
      tickstart = HAL_GetTick();
 800ba2a:	f7fd ffc5 	bl	80099b8 <HAL_GetTick>
 800ba2e:	0006      	movs	r6, r0
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSI14RDY) == RESET)
 800ba30:	6b6b      	ldr	r3, [r5, #52]	; 0x34
 800ba32:	423b      	tst	r3, r7
 800ba34:	d100      	bne.n	800ba38 <HAL_RCC_OscConfig+0x74>
 800ba36:	e190      	b.n	800bd5a <HAL_RCC_OscConfig+0x396>
      __HAL_RCC_HSI14_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSI14CalibrationValue);
 800ba38:	21f8      	movs	r1, #248	; 0xf8
 800ba3a:	6b6a      	ldr	r2, [r5, #52]	; 0x34
 800ba3c:	69a3      	ldr	r3, [r4, #24]
 800ba3e:	438a      	bics	r2, r1
 800ba40:	00db      	lsls	r3, r3, #3
 800ba42:	4313      	orrs	r3, r2
 800ba44:	636b      	str	r3, [r5, #52]	; 0x34
  assert_param(IS_RCC_PLL(RCC_OscInitStruct->PLL.PLLState));
 800ba46:	6a23      	ldr	r3, [r4, #32]
 800ba48:	2b02      	cmp	r3, #2
 800ba4a:	d903      	bls.n	800ba54 <HAL_RCC_OscConfig+0x90>
 800ba4c:	49aa      	ldr	r1, [pc, #680]	; (800bcf8 <HAL_RCC_OscConfig+0x334>)
 800ba4e:	48a7      	ldr	r0, [pc, #668]	; (800bcec <HAL_RCC_OscConfig+0x328>)
 800ba50:	f7fc ff6e 	bl	8008930 <assert_failed>
  if ((RCC_OscInitStruct->PLL.PLLState) != RCC_PLL_NONE)
 800ba54:	6a23      	ldr	r3, [r4, #32]
 800ba56:	2b00      	cmp	r3, #0
 800ba58:	d000      	beq.n	800ba5c <HAL_RCC_OscConfig+0x98>
 800ba5a:	e1a0      	b.n	800bd9e <HAL_RCC_OscConfig+0x3da>
  return HAL_OK;
 800ba5c:	2000      	movs	r0, #0
 800ba5e:	e7b7      	b.n	800b9d0 <HAL_RCC_OscConfig+0xc>
  assert_param(IS_RCC_OSCILLATORTYPE(RCC_OscInitStruct->OscillatorType));
 800ba60:	06db      	lsls	r3, r3, #27
 800ba62:	d104      	bne.n	800ba6e <HAL_RCC_OscConfig+0xaa>
 800ba64:	213a      	movs	r1, #58	; 0x3a
 800ba66:	48a1      	ldr	r0, [pc, #644]	; (800bcec <HAL_RCC_OscConfig+0x328>)
 800ba68:	31ff      	adds	r1, #255	; 0xff
 800ba6a:	f7fc ff61 	bl	8008930 <assert_failed>
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
 800ba6e:	6823      	ldr	r3, [r4, #0]
 800ba70:	07db      	lsls	r3, r3, #31
 800ba72:	d522      	bpl.n	800baba <HAL_RCC_OscConfig+0xf6>
    assert_param(IS_RCC_HSE(RCC_OscInitStruct->HSEState));
 800ba74:	6863      	ldr	r3, [r4, #4]
 800ba76:	2b01      	cmp	r3, #1
 800ba78:	d906      	bls.n	800ba88 <HAL_RCC_OscConfig+0xc4>
 800ba7a:	2b05      	cmp	r3, #5
 800ba7c:	d004      	beq.n	800ba88 <HAL_RCC_OscConfig+0xc4>
 800ba7e:	2140      	movs	r1, #64	; 0x40
 800ba80:	489a      	ldr	r0, [pc, #616]	; (800bcec <HAL_RCC_OscConfig+0x328>)
 800ba82:	31ff      	adds	r1, #255	; 0xff
 800ba84:	f7fc ff54 	bl	8008930 <assert_failed>
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_HSE) 
 800ba88:	210c      	movs	r1, #12
 800ba8a:	4d9a      	ldr	r5, [pc, #616]	; (800bcf4 <HAL_RCC_OscConfig+0x330>)
 800ba8c:	686a      	ldr	r2, [r5, #4]
 800ba8e:	400a      	ands	r2, r1
 800ba90:	2a04      	cmp	r2, #4
 800ba92:	d00b      	beq.n	800baac <HAL_RCC_OscConfig+0xe8>
       || ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_PLLCLK) && (__HAL_RCC_GET_PLL_OSCSOURCE() == RCC_PLLSOURCE_HSE)))
 800ba94:	686b      	ldr	r3, [r5, #4]
 800ba96:	400b      	ands	r3, r1
 800ba98:	2b08      	cmp	r3, #8
 800ba9a:	d141      	bne.n	800bb20 <HAL_RCC_OscConfig+0x15c>
 800ba9c:	22c0      	movs	r2, #192	; 0xc0
 800ba9e:	686b      	ldr	r3, [r5, #4]
 800baa0:	0252      	lsls	r2, r2, #9
 800baa2:	4013      	ands	r3, r2
 800baa4:	2280      	movs	r2, #128	; 0x80
 800baa6:	0252      	lsls	r2, r2, #9
 800baa8:	4293      	cmp	r3, r2
 800baaa:	d139      	bne.n	800bb20 <HAL_RCC_OscConfig+0x15c>
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET) && (RCC_OscInitStruct->HSEState == RCC_HSE_OFF))
 800baac:	682b      	ldr	r3, [r5, #0]
 800baae:	039b      	lsls	r3, r3, #14
 800bab0:	d503      	bpl.n	800baba <HAL_RCC_OscConfig+0xf6>
 800bab2:	6863      	ldr	r3, [r4, #4]
 800bab4:	2b00      	cmp	r3, #0
 800bab6:	d100      	bne.n	800baba <HAL_RCC_OscConfig+0xf6>
 800bab8:	e789      	b.n	800b9ce <HAL_RCC_OscConfig+0xa>
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSI) == RCC_OSCILLATORTYPE_HSI)
 800baba:	6823      	ldr	r3, [r4, #0]
 800babc:	079b      	lsls	r3, r3, #30
 800babe:	d58c      	bpl.n	800b9da <HAL_RCC_OscConfig+0x16>
    assert_param(IS_RCC_HSI(RCC_OscInitStruct->HSIState));
 800bac0:	68e3      	ldr	r3, [r4, #12]
 800bac2:	2b01      	cmp	r3, #1
 800bac4:	d904      	bls.n	800bad0 <HAL_RCC_OscConfig+0x10c>
 800bac6:	2174      	movs	r1, #116	; 0x74
 800bac8:	4888      	ldr	r0, [pc, #544]	; (800bcec <HAL_RCC_OscConfig+0x328>)
 800baca:	31ff      	adds	r1, #255	; 0xff
 800bacc:	f7fc ff30 	bl	8008930 <assert_failed>
    assert_param(IS_RCC_CALIBRATION_VALUE(RCC_OscInitStruct->HSICalibrationValue));
 800bad0:	6923      	ldr	r3, [r4, #16]
 800bad2:	2b1f      	cmp	r3, #31
 800bad4:	d904      	bls.n	800bae0 <HAL_RCC_OscConfig+0x11c>
 800bad6:	21ba      	movs	r1, #186	; 0xba
 800bad8:	4884      	ldr	r0, [pc, #528]	; (800bcec <HAL_RCC_OscConfig+0x328>)
 800bada:	0049      	lsls	r1, r1, #1
 800badc:	f7fc ff28 	bl	8008930 <assert_failed>
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_HSI) 
 800bae0:	220c      	movs	r2, #12
 800bae2:	4d84      	ldr	r5, [pc, #528]	; (800bcf4 <HAL_RCC_OscConfig+0x330>)
 800bae4:	686b      	ldr	r3, [r5, #4]
 800bae6:	4213      	tst	r3, r2
 800bae8:	d00b      	beq.n	800bb02 <HAL_RCC_OscConfig+0x13e>
       || ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_PLLCLK) && (__HAL_RCC_GET_PLL_OSCSOURCE() == RCC_PLLSOURCE_HSI)))
 800baea:	686b      	ldr	r3, [r5, #4]
 800baec:	4013      	ands	r3, r2
 800baee:	2b08      	cmp	r3, #8
 800baf0:	d155      	bne.n	800bb9e <HAL_RCC_OscConfig+0x1da>
 800baf2:	22c0      	movs	r2, #192	; 0xc0
 800baf4:	686b      	ldr	r3, [r5, #4]
 800baf6:	0252      	lsls	r2, r2, #9
 800baf8:	4013      	ands	r3, r2
 800bafa:	2280      	movs	r2, #128	; 0x80
 800bafc:	0212      	lsls	r2, r2, #8
 800bafe:	4293      	cmp	r3, r2
 800bb00:	d14d      	bne.n	800bb9e <HAL_RCC_OscConfig+0x1da>
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET) && (RCC_OscInitStruct->HSIState != RCC_HSI_ON))
 800bb02:	682b      	ldr	r3, [r5, #0]
 800bb04:	079b      	lsls	r3, r3, #30
 800bb06:	d503      	bpl.n	800bb10 <HAL_RCC_OscConfig+0x14c>
 800bb08:	68e3      	ldr	r3, [r4, #12]
 800bb0a:	2b01      	cmp	r3, #1
 800bb0c:	d000      	beq.n	800bb10 <HAL_RCC_OscConfig+0x14c>
 800bb0e:	e75e      	b.n	800b9ce <HAL_RCC_OscConfig+0xa>
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
 800bb10:	21f8      	movs	r1, #248	; 0xf8
 800bb12:	682a      	ldr	r2, [r5, #0]
 800bb14:	6923      	ldr	r3, [r4, #16]
 800bb16:	438a      	bics	r2, r1
 800bb18:	00db      	lsls	r3, r3, #3
 800bb1a:	4313      	orrs	r3, r2
 800bb1c:	602b      	str	r3, [r5, #0]
 800bb1e:	e75c      	b.n	800b9da <HAL_RCC_OscConfig+0x16>
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
 800bb20:	6863      	ldr	r3, [r4, #4]
 800bb22:	2b01      	cmp	r3, #1
 800bb24:	d113      	bne.n	800bb4e <HAL_RCC_OscConfig+0x18a>
 800bb26:	2380      	movs	r3, #128	; 0x80
 800bb28:	682a      	ldr	r2, [r5, #0]
 800bb2a:	025b      	lsls	r3, r3, #9
 800bb2c:	4313      	orrs	r3, r2
 800bb2e:	602b      	str	r3, [r5, #0]
        tickstart = HAL_GetTick();
 800bb30:	f7fd ff42 	bl	80099b8 <HAL_GetTick>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 800bb34:	2780      	movs	r7, #128	; 0x80
        tickstart = HAL_GetTick();
 800bb36:	0006      	movs	r6, r0
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 800bb38:	02bf      	lsls	r7, r7, #10
 800bb3a:	682b      	ldr	r3, [r5, #0]
 800bb3c:	423b      	tst	r3, r7
 800bb3e:	d1bc      	bne.n	800baba <HAL_RCC_OscConfig+0xf6>
          if((HAL_GetTick() - tickstart ) > HSE_TIMEOUT_VALUE)
 800bb40:	f7fd ff3a 	bl	80099b8 <HAL_GetTick>
 800bb44:	1b80      	subs	r0, r0, r6
 800bb46:	2864      	cmp	r0, #100	; 0x64
 800bb48:	d9f7      	bls.n	800bb3a <HAL_RCC_OscConfig+0x176>
            return HAL_TIMEOUT;
 800bb4a:	2003      	movs	r0, #3
 800bb4c:	e740      	b.n	800b9d0 <HAL_RCC_OscConfig+0xc>
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
 800bb4e:	2b00      	cmp	r3, #0
 800bb50:	d115      	bne.n	800bb7e <HAL_RCC_OscConfig+0x1ba>
 800bb52:	682b      	ldr	r3, [r5, #0]
 800bb54:	4a69      	ldr	r2, [pc, #420]	; (800bcfc <HAL_RCC_OscConfig+0x338>)
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET)
 800bb56:	2780      	movs	r7, #128	; 0x80
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
 800bb58:	4013      	ands	r3, r2
 800bb5a:	602b      	str	r3, [r5, #0]
 800bb5c:	682b      	ldr	r3, [r5, #0]
 800bb5e:	4a68      	ldr	r2, [pc, #416]	; (800bd00 <HAL_RCC_OscConfig+0x33c>)
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET)
 800bb60:	02bf      	lsls	r7, r7, #10
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
 800bb62:	4013      	ands	r3, r2
 800bb64:	602b      	str	r3, [r5, #0]
        tickstart = HAL_GetTick();
 800bb66:	f7fd ff27 	bl	80099b8 <HAL_GetTick>
 800bb6a:	0006      	movs	r6, r0
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET)
 800bb6c:	682b      	ldr	r3, [r5, #0]
 800bb6e:	423b      	tst	r3, r7
 800bb70:	d0a3      	beq.n	800baba <HAL_RCC_OscConfig+0xf6>
           if((HAL_GetTick() - tickstart ) > HSE_TIMEOUT_VALUE)
 800bb72:	f7fd ff21 	bl	80099b8 <HAL_GetTick>
 800bb76:	1b80      	subs	r0, r0, r6
 800bb78:	2864      	cmp	r0, #100	; 0x64
 800bb7a:	d9f7      	bls.n	800bb6c <HAL_RCC_OscConfig+0x1a8>
 800bb7c:	e7e5      	b.n	800bb4a <HAL_RCC_OscConfig+0x186>
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
 800bb7e:	2b05      	cmp	r3, #5
 800bb80:	d105      	bne.n	800bb8e <HAL_RCC_OscConfig+0x1ca>
 800bb82:	2380      	movs	r3, #128	; 0x80
 800bb84:	682a      	ldr	r2, [r5, #0]
 800bb86:	02db      	lsls	r3, r3, #11
 800bb88:	4313      	orrs	r3, r2
 800bb8a:	602b      	str	r3, [r5, #0]
 800bb8c:	e7cb      	b.n	800bb26 <HAL_RCC_OscConfig+0x162>
 800bb8e:	682b      	ldr	r3, [r5, #0]
 800bb90:	4a5a      	ldr	r2, [pc, #360]	; (800bcfc <HAL_RCC_OscConfig+0x338>)
 800bb92:	4013      	ands	r3, r2
 800bb94:	602b      	str	r3, [r5, #0]
 800bb96:	682b      	ldr	r3, [r5, #0]
 800bb98:	4a59      	ldr	r2, [pc, #356]	; (800bd00 <HAL_RCC_OscConfig+0x33c>)
 800bb9a:	4013      	ands	r3, r2
 800bb9c:	e7c7      	b.n	800bb2e <HAL_RCC_OscConfig+0x16a>
      if(RCC_OscInitStruct->HSIState != RCC_HSI_OFF)
 800bb9e:	68e2      	ldr	r2, [r4, #12]
 800bba0:	2301      	movs	r3, #1
 800bba2:	2a00      	cmp	r2, #0
 800bba4:	d00f      	beq.n	800bbc6 <HAL_RCC_OscConfig+0x202>
        __HAL_RCC_HSI_ENABLE();
 800bba6:	682a      	ldr	r2, [r5, #0]
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
 800bba8:	2702      	movs	r7, #2
        __HAL_RCC_HSI_ENABLE();
 800bbaa:	4313      	orrs	r3, r2
 800bbac:	602b      	str	r3, [r5, #0]
        tickstart = HAL_GetTick();
 800bbae:	f7fd ff03 	bl	80099b8 <HAL_GetTick>
 800bbb2:	0006      	movs	r6, r0
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
 800bbb4:	682b      	ldr	r3, [r5, #0]
 800bbb6:	423b      	tst	r3, r7
 800bbb8:	d1aa      	bne.n	800bb10 <HAL_RCC_OscConfig+0x14c>
          if((HAL_GetTick() - tickstart ) > HSI_TIMEOUT_VALUE)
 800bbba:	f7fd fefd 	bl	80099b8 <HAL_GetTick>
 800bbbe:	1b80      	subs	r0, r0, r6
 800bbc0:	2802      	cmp	r0, #2
 800bbc2:	d9f7      	bls.n	800bbb4 <HAL_RCC_OscConfig+0x1f0>
 800bbc4:	e7c1      	b.n	800bb4a <HAL_RCC_OscConfig+0x186>
        __HAL_RCC_HSI_DISABLE();
 800bbc6:	682a      	ldr	r2, [r5, #0]
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET)
 800bbc8:	2702      	movs	r7, #2
        __HAL_RCC_HSI_DISABLE();
 800bbca:	439a      	bics	r2, r3
 800bbcc:	602a      	str	r2, [r5, #0]
        tickstart = HAL_GetTick();
 800bbce:	f7fd fef3 	bl	80099b8 <HAL_GetTick>
 800bbd2:	0006      	movs	r6, r0
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET)
 800bbd4:	682b      	ldr	r3, [r5, #0]
 800bbd6:	423b      	tst	r3, r7
 800bbd8:	d100      	bne.n	800bbdc <HAL_RCC_OscConfig+0x218>
 800bbda:	e6fe      	b.n	800b9da <HAL_RCC_OscConfig+0x16>
          if((HAL_GetTick() - tickstart ) > HSI_TIMEOUT_VALUE)
 800bbdc:	f7fd feec 	bl	80099b8 <HAL_GetTick>
 800bbe0:	1b80      	subs	r0, r0, r6
 800bbe2:	2802      	cmp	r0, #2
 800bbe4:	d9f6      	bls.n	800bbd4 <HAL_RCC_OscConfig+0x210>
 800bbe6:	e7b0      	b.n	800bb4a <HAL_RCC_OscConfig+0x186>
    assert_param(IS_RCC_LSI(RCC_OscInitStruct->LSIState));
 800bbe8:	69e3      	ldr	r3, [r4, #28]
 800bbea:	2b01      	cmp	r3, #1
 800bbec:	d904      	bls.n	800bbf8 <HAL_RCC_OscConfig+0x234>
 800bbee:	21da      	movs	r1, #218	; 0xda
 800bbf0:	483e      	ldr	r0, [pc, #248]	; (800bcec <HAL_RCC_OscConfig+0x328>)
 800bbf2:	0049      	lsls	r1, r1, #1
 800bbf4:	f7fc fe9c 	bl	8008930 <assert_failed>
    if(RCC_OscInitStruct->LSIState != RCC_LSI_OFF)
 800bbf8:	69e2      	ldr	r2, [r4, #28]
 800bbfa:	2301      	movs	r3, #1
 800bbfc:	4d3d      	ldr	r5, [pc, #244]	; (800bcf4 <HAL_RCC_OscConfig+0x330>)
 800bbfe:	2a00      	cmp	r2, #0
 800bc00:	d010      	beq.n	800bc24 <HAL_RCC_OscConfig+0x260>
      __HAL_RCC_LSI_ENABLE();
 800bc02:	6a6a      	ldr	r2, [r5, #36]	; 0x24
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) == RESET)
 800bc04:	2702      	movs	r7, #2
      __HAL_RCC_LSI_ENABLE();
 800bc06:	4313      	orrs	r3, r2
 800bc08:	626b      	str	r3, [r5, #36]	; 0x24
      tickstart = HAL_GetTick();
 800bc0a:	f7fd fed5 	bl	80099b8 <HAL_GetTick>
 800bc0e:	0006      	movs	r6, r0
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) == RESET)
 800bc10:	6a6b      	ldr	r3, [r5, #36]	; 0x24
 800bc12:	423b      	tst	r3, r7
 800bc14:	d000      	beq.n	800bc18 <HAL_RCC_OscConfig+0x254>
 800bc16:	e6e4      	b.n	800b9e2 <HAL_RCC_OscConfig+0x1e>
        if((HAL_GetTick() - tickstart ) > LSI_TIMEOUT_VALUE)
 800bc18:	f7fd fece 	bl	80099b8 <HAL_GetTick>
 800bc1c:	1b80      	subs	r0, r0, r6
 800bc1e:	2802      	cmp	r0, #2
 800bc20:	d9f6      	bls.n	800bc10 <HAL_RCC_OscConfig+0x24c>
 800bc22:	e792      	b.n	800bb4a <HAL_RCC_OscConfig+0x186>
      __HAL_RCC_LSI_DISABLE();
 800bc24:	6a6a      	ldr	r2, [r5, #36]	; 0x24
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) != RESET)
 800bc26:	2702      	movs	r7, #2
      __HAL_RCC_LSI_DISABLE();
 800bc28:	439a      	bics	r2, r3
 800bc2a:	626a      	str	r2, [r5, #36]	; 0x24
      tickstart = HAL_GetTick();
 800bc2c:	f7fd fec4 	bl	80099b8 <HAL_GetTick>
 800bc30:	0006      	movs	r6, r0
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) != RESET)
 800bc32:	6a6b      	ldr	r3, [r5, #36]	; 0x24
 800bc34:	423b      	tst	r3, r7
 800bc36:	d100      	bne.n	800bc3a <HAL_RCC_OscConfig+0x276>
 800bc38:	e6d3      	b.n	800b9e2 <HAL_RCC_OscConfig+0x1e>
        if((HAL_GetTick() - tickstart ) > LSI_TIMEOUT_VALUE)
 800bc3a:	f7fd febd 	bl	80099b8 <HAL_GetTick>
 800bc3e:	1b80      	subs	r0, r0, r6
 800bc40:	2802      	cmp	r0, #2
 800bc42:	d9f6      	bls.n	800bc32 <HAL_RCC_OscConfig+0x26e>
 800bc44:	e781      	b.n	800bb4a <HAL_RCC_OscConfig+0x186>
    assert_param(IS_RCC_LSE(RCC_OscInitStruct->LSEState));
 800bc46:	68a3      	ldr	r3, [r4, #8]
 800bc48:	2b01      	cmp	r3, #1
 800bc4a:	d906      	bls.n	800bc5a <HAL_RCC_OscConfig+0x296>
 800bc4c:	2b05      	cmp	r3, #5
 800bc4e:	d004      	beq.n	800bc5a <HAL_RCC_OscConfig+0x296>
 800bc50:	21f0      	movs	r1, #240	; 0xf0
 800bc52:	4826      	ldr	r0, [pc, #152]	; (800bcec <HAL_RCC_OscConfig+0x328>)
 800bc54:	0049      	lsls	r1, r1, #1
 800bc56:	f7fc fe6b 	bl	8008930 <assert_failed>
    if(__HAL_RCC_PWR_IS_CLK_DISABLED())
 800bc5a:	2280      	movs	r2, #128	; 0x80
    FlagStatus       pwrclkchanged = RESET;
 800bc5c:	2100      	movs	r1, #0
    if(__HAL_RCC_PWR_IS_CLK_DISABLED())
 800bc5e:	4d25      	ldr	r5, [pc, #148]	; (800bcf4 <HAL_RCC_OscConfig+0x330>)
 800bc60:	0552      	lsls	r2, r2, #21
 800bc62:	69eb      	ldr	r3, [r5, #28]
    FlagStatus       pwrclkchanged = RESET;
 800bc64:	9100      	str	r1, [sp, #0]
    if(__HAL_RCC_PWR_IS_CLK_DISABLED())
 800bc66:	4213      	tst	r3, r2
 800bc68:	d108      	bne.n	800bc7c <HAL_RCC_OscConfig+0x2b8>
      __HAL_RCC_PWR_CLK_ENABLE();
 800bc6a:	69eb      	ldr	r3, [r5, #28]
 800bc6c:	4313      	orrs	r3, r2
 800bc6e:	61eb      	str	r3, [r5, #28]
 800bc70:	69eb      	ldr	r3, [r5, #28]
 800bc72:	4013      	ands	r3, r2
 800bc74:	9303      	str	r3, [sp, #12]
 800bc76:	9b03      	ldr	r3, [sp, #12]
      pwrclkchanged = SET;
 800bc78:	2301      	movs	r3, #1
 800bc7a:	9300      	str	r3, [sp, #0]
    if(HAL_IS_BIT_CLR(PWR->CR, PWR_CR_DBP))
 800bc7c:	2780      	movs	r7, #128	; 0x80
 800bc7e:	4e21      	ldr	r6, [pc, #132]	; (800bd04 <HAL_RCC_OscConfig+0x340>)
 800bc80:	007f      	lsls	r7, r7, #1
 800bc82:	6833      	ldr	r3, [r6, #0]
 800bc84:	423b      	tst	r3, r7
 800bc86:	d006      	beq.n	800bc96 <HAL_RCC_OscConfig+0x2d2>
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 800bc88:	68a3      	ldr	r3, [r4, #8]
 800bc8a:	2b01      	cmp	r3, #1
 800bc8c:	d113      	bne.n	800bcb6 <HAL_RCC_OscConfig+0x2f2>
 800bc8e:	6a2a      	ldr	r2, [r5, #32]
 800bc90:	4313      	orrs	r3, r2
 800bc92:	622b      	str	r3, [r5, #32]
 800bc94:	e043      	b.n	800bd1e <HAL_RCC_OscConfig+0x35a>
      SET_BIT(PWR->CR, PWR_CR_DBP);
 800bc96:	6833      	ldr	r3, [r6, #0]
 800bc98:	433b      	orrs	r3, r7
 800bc9a:	6033      	str	r3, [r6, #0]
      tickstart = HAL_GetTick();
 800bc9c:	f7fd fe8c 	bl	80099b8 <HAL_GetTick>
 800bca0:	9001      	str	r0, [sp, #4]
      while(HAL_IS_BIT_CLR(PWR->CR, PWR_CR_DBP))
 800bca2:	6833      	ldr	r3, [r6, #0]
 800bca4:	423b      	tst	r3, r7
 800bca6:	d1ef      	bne.n	800bc88 <HAL_RCC_OscConfig+0x2c4>
        if((HAL_GetTick() - tickstart) > RCC_DBP_TIMEOUT_VALUE)
 800bca8:	f7fd fe86 	bl	80099b8 <HAL_GetTick>
 800bcac:	9b01      	ldr	r3, [sp, #4]
 800bcae:	1ac0      	subs	r0, r0, r3
 800bcb0:	2864      	cmp	r0, #100	; 0x64
 800bcb2:	d9f6      	bls.n	800bca2 <HAL_RCC_OscConfig+0x2de>
 800bcb4:	e749      	b.n	800bb4a <HAL_RCC_OscConfig+0x186>
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 800bcb6:	2201      	movs	r2, #1
 800bcb8:	2b00      	cmp	r3, #0
 800bcba:	d127      	bne.n	800bd0c <HAL_RCC_OscConfig+0x348>
 800bcbc:	6a2b      	ldr	r3, [r5, #32]
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != RESET)
 800bcbe:	2702      	movs	r7, #2
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 800bcc0:	4393      	bics	r3, r2
 800bcc2:	622b      	str	r3, [r5, #32]
 800bcc4:	6a2b      	ldr	r3, [r5, #32]
 800bcc6:	3203      	adds	r2, #3
 800bcc8:	4393      	bics	r3, r2
 800bcca:	622b      	str	r3, [r5, #32]
      tickstart = HAL_GetTick();
 800bccc:	f7fd fe74 	bl	80099b8 <HAL_GetTick>
 800bcd0:	0006      	movs	r6, r0
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != RESET)
 800bcd2:	6a2b      	ldr	r3, [r5, #32]
 800bcd4:	423b      	tst	r3, r7
 800bcd6:	d029      	beq.n	800bd2c <HAL_RCC_OscConfig+0x368>
        if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
 800bcd8:	f7fd fe6e 	bl	80099b8 <HAL_GetTick>
 800bcdc:	4b0a      	ldr	r3, [pc, #40]	; (800bd08 <HAL_RCC_OscConfig+0x344>)
 800bcde:	1b80      	subs	r0, r0, r6
 800bce0:	4298      	cmp	r0, r3
 800bce2:	d9f6      	bls.n	800bcd2 <HAL_RCC_OscConfig+0x30e>
 800bce4:	e731      	b.n	800bb4a <HAL_RCC_OscConfig+0x186>
 800bce6:	46c0      	nop			; (mov r8, r8)
 800bce8:	00000226 	.word	0x00000226
 800bcec:	080108ab 	.word	0x080108ab
 800bcf0:	00000227 	.word	0x00000227
 800bcf4:	40021000 	.word	0x40021000
 800bcf8:	0000029a 	.word	0x0000029a
 800bcfc:	fffeffff 	.word	0xfffeffff
 800bd00:	fffbffff 	.word	0xfffbffff
 800bd04:	40007000 	.word	0x40007000
 800bd08:	00001388 	.word	0x00001388
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 800bd0c:	2b05      	cmp	r3, #5
 800bd0e:	d116      	bne.n	800bd3e <HAL_RCC_OscConfig+0x37a>
 800bd10:	6a29      	ldr	r1, [r5, #32]
 800bd12:	3b01      	subs	r3, #1
 800bd14:	430b      	orrs	r3, r1
 800bd16:	622b      	str	r3, [r5, #32]
 800bd18:	6a2b      	ldr	r3, [r5, #32]
 800bd1a:	431a      	orrs	r2, r3
 800bd1c:	622a      	str	r2, [r5, #32]
      tickstart = HAL_GetTick();
 800bd1e:	f7fd fe4b 	bl	80099b8 <HAL_GetTick>
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
 800bd22:	2702      	movs	r7, #2
      tickstart = HAL_GetTick();
 800bd24:	0006      	movs	r6, r0
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
 800bd26:	6a2b      	ldr	r3, [r5, #32]
 800bd28:	423b      	tst	r3, r7
 800bd2a:	d00f      	beq.n	800bd4c <HAL_RCC_OscConfig+0x388>
    if(pwrclkchanged == SET)
 800bd2c:	9b00      	ldr	r3, [sp, #0]
 800bd2e:	2b01      	cmp	r3, #1
 800bd30:	d000      	beq.n	800bd34 <HAL_RCC_OscConfig+0x370>
 800bd32:	e65a      	b.n	800b9ea <HAL_RCC_OscConfig+0x26>
      __HAL_RCC_PWR_CLK_DISABLE();
 800bd34:	69eb      	ldr	r3, [r5, #28]
 800bd36:	4a67      	ldr	r2, [pc, #412]	; (800bed4 <HAL_RCC_OscConfig+0x510>)
 800bd38:	4013      	ands	r3, r2
 800bd3a:	61eb      	str	r3, [r5, #28]
 800bd3c:	e655      	b.n	800b9ea <HAL_RCC_OscConfig+0x26>
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 800bd3e:	6a2b      	ldr	r3, [r5, #32]
 800bd40:	4393      	bics	r3, r2
 800bd42:	2204      	movs	r2, #4
 800bd44:	622b      	str	r3, [r5, #32]
 800bd46:	6a2b      	ldr	r3, [r5, #32]
 800bd48:	4393      	bics	r3, r2
 800bd4a:	e7a2      	b.n	800bc92 <HAL_RCC_OscConfig+0x2ce>
        if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
 800bd4c:	f7fd fe34 	bl	80099b8 <HAL_GetTick>
 800bd50:	4b61      	ldr	r3, [pc, #388]	; (800bed8 <HAL_RCC_OscConfig+0x514>)
 800bd52:	1b80      	subs	r0, r0, r6
 800bd54:	4298      	cmp	r0, r3
 800bd56:	d9e6      	bls.n	800bd26 <HAL_RCC_OscConfig+0x362>
 800bd58:	e6f7      	b.n	800bb4a <HAL_RCC_OscConfig+0x186>
        if((HAL_GetTick() - tickstart) > HSI14_TIMEOUT_VALUE)
 800bd5a:	f7fd fe2d 	bl	80099b8 <HAL_GetTick>
 800bd5e:	1b80      	subs	r0, r0, r6
 800bd60:	2802      	cmp	r0, #2
 800bd62:	d800      	bhi.n	800bd66 <HAL_RCC_OscConfig+0x3a2>
 800bd64:	e664      	b.n	800ba30 <HAL_RCC_OscConfig+0x6c>
 800bd66:	e6f0      	b.n	800bb4a <HAL_RCC_OscConfig+0x186>
    else if(RCC_OscInitStruct->HSI14State == RCC_HSI14_ADC_CONTROL)
 800bd68:	3205      	adds	r2, #5
 800bd6a:	d103      	bne.n	800bd74 <HAL_RCC_OscConfig+0x3b0>
      __HAL_RCC_HSI14ADC_ENABLE();
 800bd6c:	6b6a      	ldr	r2, [r5, #52]	; 0x34
 800bd6e:	439a      	bics	r2, r3
 800bd70:	636a      	str	r2, [r5, #52]	; 0x34
 800bd72:	e661      	b.n	800ba38 <HAL_RCC_OscConfig+0x74>
      __HAL_RCC_HSI14ADC_DISABLE();
 800bd74:	6b6a      	ldr	r2, [r5, #52]	; 0x34
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSI14RDY) != RESET)
 800bd76:	2702      	movs	r7, #2
      __HAL_RCC_HSI14ADC_DISABLE();
 800bd78:	4313      	orrs	r3, r2
      __HAL_RCC_HSI14_DISABLE();
 800bd7a:	2201      	movs	r2, #1
      __HAL_RCC_HSI14ADC_DISABLE();
 800bd7c:	636b      	str	r3, [r5, #52]	; 0x34
      __HAL_RCC_HSI14_DISABLE();
 800bd7e:	6b6b      	ldr	r3, [r5, #52]	; 0x34
 800bd80:	4393      	bics	r3, r2
 800bd82:	636b      	str	r3, [r5, #52]	; 0x34
      tickstart = HAL_GetTick();
 800bd84:	f7fd fe18 	bl	80099b8 <HAL_GetTick>
 800bd88:	0006      	movs	r6, r0
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSI14RDY) != RESET)
 800bd8a:	6b6b      	ldr	r3, [r5, #52]	; 0x34
 800bd8c:	423b      	tst	r3, r7
 800bd8e:	d100      	bne.n	800bd92 <HAL_RCC_OscConfig+0x3ce>
 800bd90:	e659      	b.n	800ba46 <HAL_RCC_OscConfig+0x82>
        if((HAL_GetTick() - tickstart) > HSI14_TIMEOUT_VALUE)
 800bd92:	f7fd fe11 	bl	80099b8 <HAL_GetTick>
 800bd96:	1b80      	subs	r0, r0, r6
 800bd98:	2802      	cmp	r0, #2
 800bd9a:	d9f6      	bls.n	800bd8a <HAL_RCC_OscConfig+0x3c6>
 800bd9c:	e6d5      	b.n	800bb4a <HAL_RCC_OscConfig+0x186>
    if(__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_PLLCLK)
 800bd9e:	200c      	movs	r0, #12
 800bda0:	4a4e      	ldr	r2, [pc, #312]	; (800bedc <HAL_RCC_OscConfig+0x518>)
 800bda2:	6851      	ldr	r1, [r2, #4]
 800bda4:	0015      	movs	r5, r2
 800bda6:	4001      	ands	r1, r0
 800bda8:	2908      	cmp	r1, #8
 800bdaa:	d075      	beq.n	800be98 <HAL_RCC_OscConfig+0x4d4>
      if((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_ON)
 800bdac:	4e4c      	ldr	r6, [pc, #304]	; (800bee0 <HAL_RCC_OscConfig+0x51c>)
 800bdae:	2b02      	cmp	r3, #2
 800bdb0:	d160      	bne.n	800be74 <HAL_RCC_OscConfig+0x4b0>
        assert_param(IS_RCC_PLLSOURCE(RCC_OscInitStruct->PLL.PLLSource));
 800bdb2:	4a4c      	ldr	r2, [pc, #304]	; (800bee4 <HAL_RCC_OscConfig+0x520>)
 800bdb4:	6a63      	ldr	r3, [r4, #36]	; 0x24
 800bdb6:	189b      	adds	r3, r3, r2
 800bdb8:	4a4b      	ldr	r2, [pc, #300]	; (800bee8 <HAL_RCC_OscConfig+0x524>)
 800bdba:	4213      	tst	r3, r2
 800bdbc:	d003      	beq.n	800bdc6 <HAL_RCC_OscConfig+0x402>
 800bdbe:	494b      	ldr	r1, [pc, #300]	; (800beec <HAL_RCC_OscConfig+0x528>)
 800bdc0:	484b      	ldr	r0, [pc, #300]	; (800bef0 <HAL_RCC_OscConfig+0x52c>)
 800bdc2:	f7fc fdb5 	bl	8008930 <assert_failed>
        assert_param(IS_RCC_PLL_MUL(RCC_OscInitStruct->PLL.PLLMUL));
 800bdc6:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 800bdc8:	4a4a      	ldr	r2, [pc, #296]	; (800bef4 <HAL_RCC_OscConfig+0x530>)
 800bdca:	0019      	movs	r1, r3
 800bdcc:	484a      	ldr	r0, [pc, #296]	; (800bef8 <HAL_RCC_OscConfig+0x534>)
 800bdce:	401a      	ands	r2, r3
 800bdd0:	4001      	ands	r1, r0
 800bdd2:	4203      	tst	r3, r0
 800bdd4:	d014      	beq.n	800be00 <HAL_RCC_OscConfig+0x43c>
 800bdd6:	2080      	movs	r0, #128	; 0x80
 800bdd8:	0340      	lsls	r0, r0, #13
 800bdda:	4281      	cmp	r1, r0
 800bddc:	d010      	beq.n	800be00 <HAL_RCC_OscConfig+0x43c>
 800bdde:	2080      	movs	r0, #128	; 0x80
 800bde0:	0380      	lsls	r0, r0, #14
 800bde2:	4281      	cmp	r1, r0
 800bde4:	d00c      	beq.n	800be00 <HAL_RCC_OscConfig+0x43c>
 800bde6:	21c0      	movs	r1, #192	; 0xc0
 800bde8:	0389      	lsls	r1, r1, #14
 800bdea:	428a      	cmp	r2, r1
 800bdec:	d008      	beq.n	800be00 <HAL_RCC_OscConfig+0x43c>
 800bdee:	22e0      	movs	r2, #224	; 0xe0
 800bdf0:	0392      	lsls	r2, r2, #14
 800bdf2:	4293      	cmp	r3, r2
 800bdf4:	d004      	beq.n	800be00 <HAL_RCC_OscConfig+0x43c>
 800bdf6:	21a9      	movs	r1, #169	; 0xa9
 800bdf8:	483d      	ldr	r0, [pc, #244]	; (800bef0 <HAL_RCC_OscConfig+0x52c>)
 800bdfa:	0089      	lsls	r1, r1, #2
 800bdfc:	f7fc fd98 	bl	8008930 <assert_failed>
        assert_param(IS_RCC_PREDIV(RCC_OscInitStruct->PLL.PREDIV));
 800be00:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 800be02:	2b0f      	cmp	r3, #15
 800be04:	d903      	bls.n	800be0e <HAL_RCC_OscConfig+0x44a>
 800be06:	493d      	ldr	r1, [pc, #244]	; (800befc <HAL_RCC_OscConfig+0x538>)
 800be08:	4839      	ldr	r0, [pc, #228]	; (800bef0 <HAL_RCC_OscConfig+0x52c>)
 800be0a:	f7fc fd91 	bl	8008930 <assert_failed>
        __HAL_RCC_PLL_DISABLE();
 800be0e:	682b      	ldr	r3, [r5, #0]
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY)  != RESET)
 800be10:	2780      	movs	r7, #128	; 0x80
        __HAL_RCC_PLL_DISABLE();
 800be12:	401e      	ands	r6, r3
 800be14:	602e      	str	r6, [r5, #0]
        tickstart = HAL_GetTick();
 800be16:	f7fd fdcf 	bl	80099b8 <HAL_GetTick>
 800be1a:	0006      	movs	r6, r0
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY)  != RESET)
 800be1c:	04bf      	lsls	r7, r7, #18
 800be1e:	682b      	ldr	r3, [r5, #0]
 800be20:	423b      	tst	r3, r7
 800be22:	d121      	bne.n	800be68 <HAL_RCC_OscConfig+0x4a4>
        __HAL_RCC_PLL_CONFIG(RCC_OscInitStruct->PLL.PLLSource,
 800be24:	220f      	movs	r2, #15
 800be26:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY)  == RESET)
 800be28:	2680      	movs	r6, #128	; 0x80
        __HAL_RCC_PLL_CONFIG(RCC_OscInitStruct->PLL.PLLSource,
 800be2a:	4393      	bics	r3, r2
 800be2c:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY)  == RESET)
 800be2e:	04b6      	lsls	r6, r6, #18
        __HAL_RCC_PLL_CONFIG(RCC_OscInitStruct->PLL.PLLSource,
 800be30:	4313      	orrs	r3, r2
 800be32:	62eb      	str	r3, [r5, #44]	; 0x2c
 800be34:	6a61      	ldr	r1, [r4, #36]	; 0x24
 800be36:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 800be38:	686a      	ldr	r2, [r5, #4]
 800be3a:	430b      	orrs	r3, r1
 800be3c:	4930      	ldr	r1, [pc, #192]	; (800bf00 <HAL_RCC_OscConfig+0x53c>)
 800be3e:	400a      	ands	r2, r1
 800be40:	4313      	orrs	r3, r2
 800be42:	606b      	str	r3, [r5, #4]
        __HAL_RCC_PLL_ENABLE();
 800be44:	2380      	movs	r3, #128	; 0x80
 800be46:	682a      	ldr	r2, [r5, #0]
 800be48:	045b      	lsls	r3, r3, #17
 800be4a:	4313      	orrs	r3, r2
 800be4c:	602b      	str	r3, [r5, #0]
        tickstart = HAL_GetTick();
 800be4e:	f7fd fdb3 	bl	80099b8 <HAL_GetTick>
 800be52:	0004      	movs	r4, r0
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY)  == RESET)
 800be54:	682b      	ldr	r3, [r5, #0]
 800be56:	4233      	tst	r3, r6
 800be58:	d000      	beq.n	800be5c <HAL_RCC_OscConfig+0x498>
 800be5a:	e5ff      	b.n	800ba5c <HAL_RCC_OscConfig+0x98>
          if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
 800be5c:	f7fd fdac 	bl	80099b8 <HAL_GetTick>
 800be60:	1b00      	subs	r0, r0, r4
 800be62:	2802      	cmp	r0, #2
 800be64:	d9f6      	bls.n	800be54 <HAL_RCC_OscConfig+0x490>
 800be66:	e670      	b.n	800bb4a <HAL_RCC_OscConfig+0x186>
          if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
 800be68:	f7fd fda6 	bl	80099b8 <HAL_GetTick>
 800be6c:	1b80      	subs	r0, r0, r6
 800be6e:	2802      	cmp	r0, #2
 800be70:	d9d5      	bls.n	800be1e <HAL_RCC_OscConfig+0x45a>
 800be72:	e66a      	b.n	800bb4a <HAL_RCC_OscConfig+0x186>
        __HAL_RCC_PLL_DISABLE();
 800be74:	6813      	ldr	r3, [r2, #0]
 800be76:	401e      	ands	r6, r3
 800be78:	6016      	str	r6, [r2, #0]
        tickstart = HAL_GetTick();
 800be7a:	f7fd fd9d 	bl	80099b8 <HAL_GetTick>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY)  != RESET)
 800be7e:	2680      	movs	r6, #128	; 0x80
        tickstart = HAL_GetTick();
 800be80:	0004      	movs	r4, r0
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY)  != RESET)
 800be82:	04b6      	lsls	r6, r6, #18
 800be84:	682b      	ldr	r3, [r5, #0]
 800be86:	4233      	tst	r3, r6
 800be88:	d100      	bne.n	800be8c <HAL_RCC_OscConfig+0x4c8>
 800be8a:	e5e7      	b.n	800ba5c <HAL_RCC_OscConfig+0x98>
          if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
 800be8c:	f7fd fd94 	bl	80099b8 <HAL_GetTick>
 800be90:	1b00      	subs	r0, r0, r4
 800be92:	2802      	cmp	r0, #2
 800be94:	d9f6      	bls.n	800be84 <HAL_RCC_OscConfig+0x4c0>
 800be96:	e658      	b.n	800bb4a <HAL_RCC_OscConfig+0x186>
        return HAL_ERROR;
 800be98:	0018      	movs	r0, r3
      if((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_OFF)
 800be9a:	2b01      	cmp	r3, #1
 800be9c:	d100      	bne.n	800bea0 <HAL_RCC_OscConfig+0x4dc>
 800be9e:	e597      	b.n	800b9d0 <HAL_RCC_OscConfig+0xc>
        if((READ_BIT(pll_config,  RCC_CFGR_PLLSRC)  != RCC_OscInitStruct->PLL.PLLSource) ||
 800bea0:	21c0      	movs	r1, #192	; 0xc0
        pll_config  = RCC->CFGR;
 800bea2:	6853      	ldr	r3, [r2, #4]
        if((READ_BIT(pll_config,  RCC_CFGR_PLLSRC)  != RCC_OscInitStruct->PLL.PLLSource) ||
 800bea4:	6a65      	ldr	r5, [r4, #36]	; 0x24
 800bea6:	0249      	lsls	r1, r1, #9
        return HAL_ERROR;
 800bea8:	2001      	movs	r0, #1
        pll_config2 = RCC->CFGR2;
 800beaa:	6ad2      	ldr	r2, [r2, #44]	; 0x2c
        if((READ_BIT(pll_config,  RCC_CFGR_PLLSRC)  != RCC_OscInitStruct->PLL.PLLSource) ||
 800beac:	4019      	ands	r1, r3
 800beae:	42a9      	cmp	r1, r5
 800beb0:	d000      	beq.n	800beb4 <HAL_RCC_OscConfig+0x4f0>
 800beb2:	e58d      	b.n	800b9d0 <HAL_RCC_OscConfig+0xc>
           (READ_BIT(pll_config2, RCC_CFGR2_PREDIV) != RCC_OscInitStruct->PLL.PREDIV)    ||
 800beb4:	210f      	movs	r1, #15
 800beb6:	400a      	ands	r2, r1
        if((READ_BIT(pll_config,  RCC_CFGR_PLLSRC)  != RCC_OscInitStruct->PLL.PLLSource) ||
 800beb8:	6ae1      	ldr	r1, [r4, #44]	; 0x2c
 800beba:	428a      	cmp	r2, r1
 800bebc:	d000      	beq.n	800bec0 <HAL_RCC_OscConfig+0x4fc>
 800bebe:	e587      	b.n	800b9d0 <HAL_RCC_OscConfig+0xc>
           (READ_BIT(pll_config,  RCC_CFGR_PLLMUL)  != RCC_OscInitStruct->PLL.PLLMUL))
 800bec0:	20f0      	movs	r0, #240	; 0xf0
 800bec2:	0380      	lsls	r0, r0, #14
 800bec4:	4003      	ands	r3, r0
           (READ_BIT(pll_config2, RCC_CFGR2_PREDIV) != RCC_OscInitStruct->PLL.PREDIV)    ||
 800bec6:	6aa0      	ldr	r0, [r4, #40]	; 0x28
 800bec8:	1a1b      	subs	r3, r3, r0
 800beca:	1e58      	subs	r0, r3, #1
 800becc:	4183      	sbcs	r3, r0
  return HAL_OK;
 800bece:	b2d8      	uxtb	r0, r3
 800bed0:	e57e      	b.n	800b9d0 <HAL_RCC_OscConfig+0xc>
 800bed2:	46c0      	nop			; (mov r8, r8)
 800bed4:	efffffff 	.word	0xefffffff
 800bed8:	00001388 	.word	0x00001388
 800bedc:	40021000 	.word	0x40021000
 800bee0:	feffffff 	.word	0xfeffffff
 800bee4:	ffff8000 	.word	0xffff8000
 800bee8:	ffff7fff 	.word	0xffff7fff
 800beec:	000002a3 	.word	0x000002a3
 800bef0:	080108ab 	.word	0x080108ab
 800bef4:	fffbffff 	.word	0xfffbffff
 800bef8:	fff3ffff 	.word	0xfff3ffff
 800befc:	000002a5 	.word	0x000002a5
 800bf00:	ffc27fff 	.word	0xffc27fff

0800bf04 <HAL_RCC_GetSysClockFreq>:
  *         right SYSCLK value. Otherwise, any configuration based on this function will be incorrect.
  *         
  * @retval SYSCLK frequency
  */
uint32_t HAL_RCC_GetSysClockFreq(void)
{
 800bf04:	b530      	push	{r4, r5, lr}
 800bf06:	b089      	sub	sp, #36	; 0x24
  const uint8_t aPLLMULFactorTable[16] = { 2U,  3U,  4U,  5U,  6U,  7U,  8U,  9U,
 800bf08:	2210      	movs	r2, #16
 800bf0a:	4910      	ldr	r1, [pc, #64]	; (800bf4c <HAL_RCC_GetSysClockFreq+0x48>)
 800bf0c:	4668      	mov	r0, sp
                                         10U, 11U, 12U, 13U, 14U, 15U, 16U, 16U};
  const uint8_t aPredivFactorTable[16] = { 1U, 2U,  3U,  4U,  5U,  6U,  7U,  8U,
 800bf0e:	ac04      	add	r4, sp, #16
  const uint8_t aPLLMULFactorTable[16] = { 2U,  3U,  4U,  5U,  6U,  7U,  8U,  9U,
 800bf10:	f003 fdec 	bl	800faec <memcpy>
  const uint8_t aPredivFactorTable[16] = { 1U, 2U,  3U,  4U,  5U,  6U,  7U,  8U,
 800bf14:	2210      	movs	r2, #16
 800bf16:	490e      	ldr	r1, [pc, #56]	; (800bf50 <HAL_RCC_GetSysClockFreq+0x4c>)
 800bf18:	0020      	movs	r0, r4
 800bf1a:	f003 fde7 	bl	800faec <memcpy>
  uint32_t sysclockfreq = 0U;
  
  tmpreg = RCC->CFGR;
  
  /* Get SYSCLK source -------------------------------------------------------*/
  switch (tmpreg & RCC_CFGR_SWS)
 800bf1e:	220c      	movs	r2, #12
  tmpreg = RCC->CFGR;
 800bf20:	490c      	ldr	r1, [pc, #48]	; (800bf54 <HAL_RCC_GetSysClockFreq+0x50>)
 800bf22:	684b      	ldr	r3, [r1, #4]
  switch (tmpreg & RCC_CFGR_SWS)
 800bf24:	401a      	ands	r2, r3
 800bf26:	2a08      	cmp	r2, #8
 800bf28:	d10d      	bne.n	800bf46 <HAL_RCC_GetSysClockFreq+0x42>
      break;
    }
    case RCC_SYSCLKSOURCE_STATUS_PLLCLK:  /* PLL used as system clock */
    {
      pllmul = aPLLMULFactorTable[(uint32_t)(tmpreg & RCC_CFGR_PLLMUL) >> RCC_CFGR_PLLMUL_BITNUMBER];
      prediv = aPredivFactorTable[(uint32_t)(RCC->CFGR2 & RCC_CFGR2_PREDIV) >> RCC_CFGR2_PREDIV_BITNUMBER];
 800bf2a:	6aca      	ldr	r2, [r1, #44]	; 0x2c
      pllmul = aPLLMULFactorTable[(uint32_t)(tmpreg & RCC_CFGR_PLLMUL) >> RCC_CFGR_PLLMUL_BITNUMBER];
 800bf2c:	210f      	movs	r1, #15
 800bf2e:	4668      	mov	r0, sp
 800bf30:	0c9b      	lsrs	r3, r3, #18
 800bf32:	400b      	ands	r3, r1
      prediv = aPredivFactorTable[(uint32_t)(RCC->CFGR2 & RCC_CFGR2_PREDIV) >> RCC_CFGR2_PREDIV_BITNUMBER];
 800bf34:	400a      	ands	r2, r1
      pllmul = aPLLMULFactorTable[(uint32_t)(tmpreg & RCC_CFGR_PLLMUL) >> RCC_CFGR_PLLMUL_BITNUMBER];
 800bf36:	5cc5      	ldrb	r5, [r0, r3]
      prediv = aPredivFactorTable[(uint32_t)(RCC->CFGR2 & RCC_CFGR2_PREDIV) >> RCC_CFGR2_PREDIV_BITNUMBER];
 800bf38:	5ca1      	ldrb	r1, [r4, r2]
 800bf3a:	4807      	ldr	r0, [pc, #28]	; (800bf58 <HAL_RCC_GetSysClockFreq+0x54>)
 800bf3c:	f7fc f914 	bl	8008168 <__udivsi3>
 800bf40:	4368      	muls	r0, r5
      sysclockfreq = HSI_VALUE;
      break;
    }
  }
  return sysclockfreq;
}
 800bf42:	b009      	add	sp, #36	; 0x24
 800bf44:	bd30      	pop	{r4, r5, pc}
      sysclockfreq = HSE_VALUE;
 800bf46:	4804      	ldr	r0, [pc, #16]	; (800bf58 <HAL_RCC_GetSysClockFreq+0x54>)
  return sysclockfreq;
 800bf48:	e7fb      	b.n	800bf42 <HAL_RCC_GetSysClockFreq+0x3e>
 800bf4a:	46c0      	nop			; (mov r8, r8)
 800bf4c:	080108e3 	.word	0x080108e3
 800bf50:	080108f4 	.word	0x080108f4
 800bf54:	40021000 	.word	0x40021000
 800bf58:	007a1200 	.word	0x007a1200

0800bf5c <HAL_RCC_ClockConfig>:
{
 800bf5c:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
 800bf5e:	0004      	movs	r4, r0
 800bf60:	000e      	movs	r6, r1
  if(RCC_ClkInitStruct == NULL)
 800bf62:	2800      	cmp	r0, #0
 800bf64:	d101      	bne.n	800bf6a <HAL_RCC_ClockConfig+0xe>
    return HAL_ERROR;
 800bf66:	2001      	movs	r0, #1
}
 800bf68:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
  assert_param(IS_RCC_CLOCKTYPE(RCC_ClkInitStruct->ClockType));
 800bf6a:	6803      	ldr	r3, [r0, #0]
 800bf6c:	075b      	lsls	r3, r3, #29
 800bf6e:	d103      	bne.n	800bf78 <HAL_RCC_ClockConfig+0x1c>
 800bf70:	4957      	ldr	r1, [pc, #348]	; (800c0d0 <HAL_RCC_ClockConfig+0x174>)
 800bf72:	4858      	ldr	r0, [pc, #352]	; (800c0d4 <HAL_RCC_ClockConfig+0x178>)
 800bf74:	f7fc fcdc 	bl	8008930 <assert_failed>
  assert_param(IS_FLASH_LATENCY(FLatency));
 800bf78:	2e01      	cmp	r6, #1
 800bf7a:	d903      	bls.n	800bf84 <HAL_RCC_ClockConfig+0x28>
 800bf7c:	4956      	ldr	r1, [pc, #344]	; (800c0d8 <HAL_RCC_ClockConfig+0x17c>)
 800bf7e:	4855      	ldr	r0, [pc, #340]	; (800c0d4 <HAL_RCC_ClockConfig+0x178>)
 800bf80:	f7fc fcd6 	bl	8008930 <assert_failed>
  if(FLatency > __HAL_FLASH_GET_LATENCY())
 800bf84:	2201      	movs	r2, #1
 800bf86:	4d55      	ldr	r5, [pc, #340]	; (800c0dc <HAL_RCC_ClockConfig+0x180>)
 800bf88:	682b      	ldr	r3, [r5, #0]
 800bf8a:	4013      	ands	r3, r2
 800bf8c:	42b3      	cmp	r3, r6
 800bf8e:	d31d      	bcc.n	800bfcc <HAL_RCC_ClockConfig+0x70>
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK) == RCC_CLOCKTYPE_HCLK)
 800bf90:	6823      	ldr	r3, [r4, #0]
 800bf92:	079a      	lsls	r2, r3, #30
 800bf94:	d423      	bmi.n	800bfde <HAL_RCC_ClockConfig+0x82>
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_SYSCLK) == RCC_CLOCKTYPE_SYSCLK)
 800bf96:	6823      	ldr	r3, [r4, #0]
 800bf98:	07db      	lsls	r3, r3, #31
 800bf9a:	d449      	bmi.n	800c030 <HAL_RCC_ClockConfig+0xd4>
  if(FLatency < __HAL_FLASH_GET_LATENCY())
 800bf9c:	2301      	movs	r3, #1
 800bf9e:	682a      	ldr	r2, [r5, #0]
 800bfa0:	401a      	ands	r2, r3
 800bfa2:	42b2      	cmp	r2, r6
 800bfa4:	d873      	bhi.n	800c08e <HAL_RCC_ClockConfig+0x132>
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)
 800bfa6:	6823      	ldr	r3, [r4, #0]
 800bfa8:	4d4d      	ldr	r5, [pc, #308]	; (800c0e0 <HAL_RCC_ClockConfig+0x184>)
 800bfaa:	075b      	lsls	r3, r3, #29
 800bfac:	d476      	bmi.n	800c09c <HAL_RCC_ClockConfig+0x140>
  SystemCoreClock = HAL_RCC_GetSysClockFreq() >> AHBPrescTable[(RCC->CFGR & RCC_CFGR_HPRE)>> RCC_CFGR_HPRE_BITNUMBER];
 800bfae:	f7ff ffa9 	bl	800bf04 <HAL_RCC_GetSysClockFreq>
 800bfb2:	686b      	ldr	r3, [r5, #4]
 800bfb4:	4a4b      	ldr	r2, [pc, #300]	; (800c0e4 <HAL_RCC_ClockConfig+0x188>)
 800bfb6:	061b      	lsls	r3, r3, #24
 800bfb8:	0f1b      	lsrs	r3, r3, #28
 800bfba:	5cd3      	ldrb	r3, [r2, r3]
 800bfbc:	40d8      	lsrs	r0, r3
 800bfbe:	4b4a      	ldr	r3, [pc, #296]	; (800c0e8 <HAL_RCC_ClockConfig+0x18c>)
 800bfc0:	6018      	str	r0, [r3, #0]
  HAL_InitTick (TICK_INT_PRIORITY);
 800bfc2:	2000      	movs	r0, #0
 800bfc4:	f7fc fce2 	bl	800898c <HAL_InitTick>
  return HAL_OK;
 800bfc8:	2000      	movs	r0, #0
 800bfca:	e7cd      	b.n	800bf68 <HAL_RCC_ClockConfig+0xc>
    __HAL_FLASH_SET_LATENCY(FLatency);
 800bfcc:	682b      	ldr	r3, [r5, #0]
 800bfce:	4393      	bics	r3, r2
 800bfd0:	4333      	orrs	r3, r6
 800bfd2:	602b      	str	r3, [r5, #0]
    if(__HAL_FLASH_GET_LATENCY() != FLatency)
 800bfd4:	682b      	ldr	r3, [r5, #0]
 800bfd6:	4013      	ands	r3, r2
 800bfd8:	42b3      	cmp	r3, r6
 800bfda:	d1c4      	bne.n	800bf66 <HAL_RCC_ClockConfig+0xa>
 800bfdc:	e7d8      	b.n	800bf90 <HAL_RCC_ClockConfig+0x34>
    if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)
 800bfde:	4f40      	ldr	r7, [pc, #256]	; (800c0e0 <HAL_RCC_ClockConfig+0x184>)
 800bfe0:	075b      	lsls	r3, r3, #29
 800bfe2:	d504      	bpl.n	800bfee <HAL_RCC_ClockConfig+0x92>
      MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE, RCC_HCLK_DIV16);
 800bfe4:	23e0      	movs	r3, #224	; 0xe0
 800bfe6:	687a      	ldr	r2, [r7, #4]
 800bfe8:	00db      	lsls	r3, r3, #3
 800bfea:	4313      	orrs	r3, r2
 800bfec:	607b      	str	r3, [r7, #4]
    assert_param(IS_RCC_HCLK(RCC_ClkInitStruct->AHBCLKDivider));
 800bfee:	68a3      	ldr	r3, [r4, #8]
 800bff0:	2280      	movs	r2, #128	; 0x80
 800bff2:	0019      	movs	r1, r3
 800bff4:	4391      	bics	r1, r2
 800bff6:	d014      	beq.n	800c022 <HAL_RCC_ClockConfig+0xc6>
 800bff8:	2220      	movs	r2, #32
 800bffa:	0019      	movs	r1, r3
 800bffc:	4391      	bics	r1, r2
 800bffe:	2990      	cmp	r1, #144	; 0x90
 800c000:	d00f      	beq.n	800c022 <HAL_RCC_ClockConfig+0xc6>
 800c002:	2240      	movs	r2, #64	; 0x40
 800c004:	0019      	movs	r1, r3
 800c006:	4391      	bics	r1, r2
 800c008:	29a0      	cmp	r1, #160	; 0xa0
 800c00a:	d00a      	beq.n	800c022 <HAL_RCC_ClockConfig+0xc6>
 800c00c:	2210      	movs	r2, #16
 800c00e:	0019      	movs	r1, r3
 800c010:	4391      	bics	r1, r2
 800c012:	29c0      	cmp	r1, #192	; 0xc0
 800c014:	d005      	beq.n	800c022 <HAL_RCC_ClockConfig+0xc6>
 800c016:	2bf0      	cmp	r3, #240	; 0xf0
 800c018:	d003      	beq.n	800c022 <HAL_RCC_ClockConfig+0xc6>
 800c01a:	4934      	ldr	r1, [pc, #208]	; (800c0ec <HAL_RCC_ClockConfig+0x190>)
 800c01c:	482d      	ldr	r0, [pc, #180]	; (800c0d4 <HAL_RCC_ClockConfig+0x178>)
 800c01e:	f7fc fc87 	bl	8008930 <assert_failed>
    MODIFY_REG(RCC->CFGR, RCC_CFGR_HPRE, RCC_ClkInitStruct->AHBCLKDivider);
 800c022:	22f0      	movs	r2, #240	; 0xf0
 800c024:	687b      	ldr	r3, [r7, #4]
 800c026:	4393      	bics	r3, r2
 800c028:	68a2      	ldr	r2, [r4, #8]
 800c02a:	4313      	orrs	r3, r2
 800c02c:	607b      	str	r3, [r7, #4]
 800c02e:	e7b2      	b.n	800bf96 <HAL_RCC_ClockConfig+0x3a>
    assert_param(IS_RCC_SYSCLKSOURCE(RCC_ClkInitStruct->SYSCLKSource));
 800c030:	6863      	ldr	r3, [r4, #4]
 800c032:	2b02      	cmp	r3, #2
 800c034:	d903      	bls.n	800c03e <HAL_RCC_ClockConfig+0xe2>
 800c036:	492e      	ldr	r1, [pc, #184]	; (800c0f0 <HAL_RCC_ClockConfig+0x194>)
 800c038:	4826      	ldr	r0, [pc, #152]	; (800c0d4 <HAL_RCC_ClockConfig+0x178>)
 800c03a:	f7fc fc79 	bl	8008930 <assert_failed>
    if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
 800c03e:	4f28      	ldr	r7, [pc, #160]	; (800c0e0 <HAL_RCC_ClockConfig+0x184>)
 800c040:	6862      	ldr	r2, [r4, #4]
      if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 800c042:	683b      	ldr	r3, [r7, #0]
    if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
 800c044:	2a01      	cmp	r2, #1
 800c046:	d11a      	bne.n	800c07e <HAL_RCC_ClockConfig+0x122>
      if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 800c048:	039b      	lsls	r3, r3, #14
 800c04a:	d400      	bmi.n	800c04e <HAL_RCC_ClockConfig+0xf2>
 800c04c:	e78b      	b.n	800bf66 <HAL_RCC_ClockConfig+0xa>
    __HAL_RCC_SYSCLK_CONFIG(RCC_ClkInitStruct->SYSCLKSource);
 800c04e:	2103      	movs	r1, #3
 800c050:	687b      	ldr	r3, [r7, #4]
 800c052:	438b      	bics	r3, r1
 800c054:	4313      	orrs	r3, r2
 800c056:	607b      	str	r3, [r7, #4]
    tickstart = HAL_GetTick();
 800c058:	f7fd fcae 	bl	80099b8 <HAL_GetTick>
 800c05c:	9001      	str	r0, [sp, #4]
    while (__HAL_RCC_GET_SYSCLK_SOURCE() != (RCC_ClkInitStruct->SYSCLKSource << RCC_CFGR_SWS_Pos))
 800c05e:	230c      	movs	r3, #12
 800c060:	687a      	ldr	r2, [r7, #4]
 800c062:	401a      	ands	r2, r3
 800c064:	6863      	ldr	r3, [r4, #4]
 800c066:	009b      	lsls	r3, r3, #2
 800c068:	429a      	cmp	r2, r3
 800c06a:	d097      	beq.n	800bf9c <HAL_RCC_ClockConfig+0x40>
      if((HAL_GetTick() - tickstart ) > CLOCKSWITCH_TIMEOUT_VALUE)
 800c06c:	f7fd fca4 	bl	80099b8 <HAL_GetTick>
 800c070:	9b01      	ldr	r3, [sp, #4]
 800c072:	1ac0      	subs	r0, r0, r3
 800c074:	4b1f      	ldr	r3, [pc, #124]	; (800c0f4 <HAL_RCC_ClockConfig+0x198>)
 800c076:	4298      	cmp	r0, r3
 800c078:	d9f1      	bls.n	800c05e <HAL_RCC_ClockConfig+0x102>
        return HAL_TIMEOUT;
 800c07a:	2003      	movs	r0, #3
 800c07c:	e774      	b.n	800bf68 <HAL_RCC_ClockConfig+0xc>
    else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)
 800c07e:	2a02      	cmp	r2, #2
 800c080:	d102      	bne.n	800c088 <HAL_RCC_ClockConfig+0x12c>
      if(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)
 800c082:	019b      	lsls	r3, r3, #6
 800c084:	d4e3      	bmi.n	800c04e <HAL_RCC_ClockConfig+0xf2>
 800c086:	e76e      	b.n	800bf66 <HAL_RCC_ClockConfig+0xa>
      if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
 800c088:	079b      	lsls	r3, r3, #30
 800c08a:	d4e0      	bmi.n	800c04e <HAL_RCC_ClockConfig+0xf2>
 800c08c:	e76b      	b.n	800bf66 <HAL_RCC_ClockConfig+0xa>
    __HAL_FLASH_SET_LATENCY(FLatency);
 800c08e:	682a      	ldr	r2, [r5, #0]
 800c090:	439a      	bics	r2, r3
 800c092:	602a      	str	r2, [r5, #0]
    if(__HAL_FLASH_GET_LATENCY() != FLatency)
 800c094:	682a      	ldr	r2, [r5, #0]
 800c096:	421a      	tst	r2, r3
 800c098:	d085      	beq.n	800bfa6 <HAL_RCC_ClockConfig+0x4a>
 800c09a:	e764      	b.n	800bf66 <HAL_RCC_ClockConfig+0xa>
    assert_param(IS_RCC_PCLK(RCC_ClkInitStruct->APB1CLKDivider));
 800c09c:	68e3      	ldr	r3, [r4, #12]
 800c09e:	4a16      	ldr	r2, [pc, #88]	; (800c0f8 <HAL_RCC_ClockConfig+0x19c>)
 800c0a0:	4213      	tst	r3, r2
 800c0a2:	d00e      	beq.n	800c0c2 <HAL_RCC_ClockConfig+0x166>
 800c0a4:	21a0      	movs	r1, #160	; 0xa0
 800c0a6:	4a15      	ldr	r2, [pc, #84]	; (800c0fc <HAL_RCC_ClockConfig+0x1a0>)
 800c0a8:	00c9      	lsls	r1, r1, #3
 800c0aa:	401a      	ands	r2, r3
 800c0ac:	428a      	cmp	r2, r1
 800c0ae:	d008      	beq.n	800c0c2 <HAL_RCC_ClockConfig+0x166>
 800c0b0:	22c0      	movs	r2, #192	; 0xc0
 800c0b2:	00d2      	lsls	r2, r2, #3
 800c0b4:	4293      	cmp	r3, r2
 800c0b6:	d004      	beq.n	800c0c2 <HAL_RCC_ClockConfig+0x166>
 800c0b8:	397d      	subs	r1, #125	; 0x7d
 800c0ba:	4806      	ldr	r0, [pc, #24]	; (800c0d4 <HAL_RCC_ClockConfig+0x178>)
 800c0bc:	39ff      	subs	r1, #255	; 0xff
 800c0be:	f7fc fc37 	bl	8008930 <assert_failed>
    MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE, RCC_ClkInitStruct->APB1CLKDivider);
 800c0c2:	686b      	ldr	r3, [r5, #4]
 800c0c4:	4a0e      	ldr	r2, [pc, #56]	; (800c100 <HAL_RCC_ClockConfig+0x1a4>)
 800c0c6:	4013      	ands	r3, r2
 800c0c8:	68e2      	ldr	r2, [r4, #12]
 800c0ca:	4313      	orrs	r3, r2
 800c0cc:	606b      	str	r3, [r5, #4]
 800c0ce:	e76e      	b.n	800bfae <HAL_RCC_ClockConfig+0x52>
 800c0d0:	00000316 	.word	0x00000316
 800c0d4:	080108ab 	.word	0x080108ab
 800c0d8:	00000317 	.word	0x00000317
 800c0dc:	40022000 	.word	0x40022000
 800c0e0:	40021000 	.word	0x40021000
 800c0e4:	08010561 	.word	0x08010561
 800c0e8:	2000045c 	.word	0x2000045c
 800c0ec:	00000336 	.word	0x00000336
 800c0f0:	0000033d 	.word	0x0000033d
 800c0f4:	00001388 	.word	0x00001388
 800c0f8:	fffffbff 	.word	0xfffffbff
 800c0fc:	fffffdff 	.word	0xfffffdff
 800c100:	fffff8ff 	.word	0xfffff8ff

0800c104 <HAL_RCC_GetPCLK1Freq>:
  * @retval PCLK1 frequency
  */
uint32_t HAL_RCC_GetPCLK1Freq(void)
{
  /* Get HCLK source and Compute PCLK1 frequency ---------------------------*/
  return (HAL_RCC_GetHCLKFreq() >> APBPrescTable[(RCC->CFGR & RCC_CFGR_PPRE) >> RCC_CFGR_PPRE_BITNUMBER]);
 800c104:	4b04      	ldr	r3, [pc, #16]	; (800c118 <HAL_RCC_GetPCLK1Freq+0x14>)
 800c106:	4a05      	ldr	r2, [pc, #20]	; (800c11c <HAL_RCC_GetPCLK1Freq+0x18>)
 800c108:	685b      	ldr	r3, [r3, #4]
 800c10a:	055b      	lsls	r3, r3, #21
 800c10c:	0f5b      	lsrs	r3, r3, #29
 800c10e:	5cd3      	ldrb	r3, [r2, r3]
 800c110:	4a03      	ldr	r2, [pc, #12]	; (800c120 <HAL_RCC_GetPCLK1Freq+0x1c>)
 800c112:	6810      	ldr	r0, [r2, #0]
 800c114:	40d8      	lsrs	r0, r3
}    
 800c116:	4770      	bx	lr
 800c118:	40021000 	.word	0x40021000
 800c11c:	08010571 	.word	0x08010571
 800c120:	2000045c 	.word	0x2000045c

0800c124 <HAL_RCC_GetClockConfig>:
  * contains the current clock configuration.
  * @param  pFLatency Pointer on the Flash Latency.
  * @retval None
  */
void HAL_RCC_GetClockConfig(RCC_ClkInitTypeDef  *RCC_ClkInitStruct, uint32_t *pFLatency)
{
 800c124:	b570      	push	{r4, r5, r6, lr}
 800c126:	0004      	movs	r4, r0
 800c128:	000d      	movs	r5, r1
  /* Check the parameters */
  assert_param(RCC_ClkInitStruct != NULL);
 800c12a:	2800      	cmp	r0, #0
 800c12c:	d103      	bne.n	800c136 <HAL_RCC_GetClockConfig+0x12>
 800c12e:	4910      	ldr	r1, [pc, #64]	; (800c170 <HAL_RCC_GetClockConfig+0x4c>)
 800c130:	4810      	ldr	r0, [pc, #64]	; (800c174 <HAL_RCC_GetClockConfig+0x50>)
 800c132:	f7fc fbfd 	bl	8008930 <assert_failed>
  assert_param(pFLatency != NULL);
 800c136:	2d00      	cmp	r5, #0
 800c138:	d103      	bne.n	800c142 <HAL_RCC_GetClockConfig+0x1e>
 800c13a:	490f      	ldr	r1, [pc, #60]	; (800c178 <HAL_RCC_GetClockConfig+0x54>)
 800c13c:	480d      	ldr	r0, [pc, #52]	; (800c174 <HAL_RCC_GetClockConfig+0x50>)
 800c13e:	f7fc fbf7 	bl	8008930 <assert_failed>

  /* Set all possible values for the Clock type parameter --------------------*/
  RCC_ClkInitStruct->ClockType = RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_PCLK1;
 800c142:	2307      	movs	r3, #7
  
  /* Get the SYSCLK configuration --------------------------------------------*/ 
  RCC_ClkInitStruct->SYSCLKSource = (uint32_t)(RCC->CFGR & RCC_CFGR_SW);
 800c144:	2103      	movs	r1, #3
  RCC_ClkInitStruct->ClockType = RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_PCLK1;
 800c146:	6023      	str	r3, [r4, #0]
  RCC_ClkInitStruct->SYSCLKSource = (uint32_t)(RCC->CFGR & RCC_CFGR_SW);
 800c148:	4b0c      	ldr	r3, [pc, #48]	; (800c17c <HAL_RCC_GetClockConfig+0x58>)
 800c14a:	685a      	ldr	r2, [r3, #4]
 800c14c:	400a      	ands	r2, r1
 800c14e:	6062      	str	r2, [r4, #4]
  
  /* Get the HCLK configuration ----------------------------------------------*/ 
  RCC_ClkInitStruct->AHBCLKDivider = (uint32_t)(RCC->CFGR & RCC_CFGR_HPRE); 
 800c150:	685a      	ldr	r2, [r3, #4]
 800c152:	31ed      	adds	r1, #237	; 0xed
 800c154:	400a      	ands	r2, r1
 800c156:	60a2      	str	r2, [r4, #8]
  
  /* Get the APB1 configuration ----------------------------------------------*/ 
  RCC_ClkInitStruct->APB1CLKDivider = (uint32_t)(RCC->CFGR & RCC_CFGR_PPRE);   
 800c158:	22e0      	movs	r2, #224	; 0xe0
 800c15a:	685b      	ldr	r3, [r3, #4]
 800c15c:	00d2      	lsls	r2, r2, #3
 800c15e:	4013      	ands	r3, r2
  /* Get the Flash Wait State (Latency) configuration ------------------------*/   
  *pFLatency = __HAL_FLASH_GET_LATENCY(); 
 800c160:	2201      	movs	r2, #1
  RCC_ClkInitStruct->APB1CLKDivider = (uint32_t)(RCC->CFGR & RCC_CFGR_PPRE);   
 800c162:	60e3      	str	r3, [r4, #12]
  *pFLatency = __HAL_FLASH_GET_LATENCY(); 
 800c164:	4b06      	ldr	r3, [pc, #24]	; (800c180 <HAL_RCC_GetClockConfig+0x5c>)
 800c166:	681b      	ldr	r3, [r3, #0]
 800c168:	4013      	ands	r3, r2
 800c16a:	602b      	str	r3, [r5, #0]
}
 800c16c:	bd70      	pop	{r4, r5, r6, pc}
 800c16e:	46c0      	nop			; (mov r8, r8)
 800c170:	00000515 	.word	0x00000515
 800c174:	080108ab 	.word	0x080108ab
 800c178:	00000516 	.word	0x00000516
 800c17c:	40021000 	.word	0x40021000
 800c180:	40022000 	.word	0x40022000

0800c184 <HAL_RCCEx_PeriphCLKConfig>:
  *         the backup registers) and RCC_BDCR register are set to their reset values.
  *
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RCCEx_PeriphCLKConfig(RCC_PeriphCLKInitTypeDef  *PeriphClkInit)
{
 800c184:	b5f0      	push	{r4, r5, r6, r7, lr}
  uint32_t tickstart = 0U;
  uint32_t temp_reg = 0U;

  /* Check the parameters */
  assert_param(IS_RCC_PERIPHCLOCK(PeriphClkInit->PeriphClockSelection));
 800c186:	4b57      	ldr	r3, [pc, #348]	; (800c2e4 <HAL_RCCEx_PeriphCLKConfig+0x160>)
 800c188:	6802      	ldr	r2, [r0, #0]
{
 800c18a:	0005      	movs	r5, r0
 800c18c:	b085      	sub	sp, #20
  assert_param(IS_RCC_PERIPHCLOCK(PeriphClkInit->PeriphClockSelection));
 800c18e:	429a      	cmp	r2, r3
 800c190:	d903      	bls.n	800c19a <HAL_RCCEx_PeriphCLKConfig+0x16>
 800c192:	216e      	movs	r1, #110	; 0x6e
 800c194:	4854      	ldr	r0, [pc, #336]	; (800c2e8 <HAL_RCCEx_PeriphCLKConfig+0x164>)
 800c196:	f7fc fbcb 	bl	8008930 <assert_failed>
  
  /*---------------------------- RTC configuration -------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_RTC) == (RCC_PERIPHCLK_RTC))
 800c19a:	682b      	ldr	r3, [r5, #0]
 800c19c:	03db      	lsls	r3, r3, #15
 800c19e:	d532      	bpl.n	800c206 <HAL_RCCEx_PeriphCLKConfig+0x82>
  {
    /* check for RTC Parameters used to output RTCCLK */
    assert_param(IS_RCC_RTCCLKSOURCE(PeriphClkInit->RTCClockSelection));
 800c1a0:	686b      	ldr	r3, [r5, #4]
 800c1a2:	4a52      	ldr	r2, [pc, #328]	; (800c2ec <HAL_RCCEx_PeriphCLKConfig+0x168>)
 800c1a4:	4213      	tst	r3, r2
 800c1a6:	d003      	beq.n	800c1b0 <HAL_RCCEx_PeriphCLKConfig+0x2c>
 800c1a8:	2174      	movs	r1, #116	; 0x74
 800c1aa:	484f      	ldr	r0, [pc, #316]	; (800c2e8 <HAL_RCCEx_PeriphCLKConfig+0x164>)
 800c1ac:	f7fc fbc0 	bl	8008930 <assert_failed>
    FlagStatus       pwrclkchanged = RESET;

    /* As soon as function is called to change RTC clock source, activation of the 
       power domain is done. */
    /* Requires to enable write access to Backup Domain of necessary */
    if(__HAL_RCC_PWR_IS_CLK_DISABLED())
 800c1b0:	2280      	movs	r2, #128	; 0x80
    FlagStatus       pwrclkchanged = RESET;
 800c1b2:	2100      	movs	r1, #0
    if(__HAL_RCC_PWR_IS_CLK_DISABLED())
 800c1b4:	4c4e      	ldr	r4, [pc, #312]	; (800c2f0 <HAL_RCCEx_PeriphCLKConfig+0x16c>)
 800c1b6:	0552      	lsls	r2, r2, #21
 800c1b8:	69e3      	ldr	r3, [r4, #28]
    FlagStatus       pwrclkchanged = RESET;
 800c1ba:	9100      	str	r1, [sp, #0]
    if(__HAL_RCC_PWR_IS_CLK_DISABLED())
 800c1bc:	4213      	tst	r3, r2
 800c1be:	d108      	bne.n	800c1d2 <HAL_RCCEx_PeriphCLKConfig+0x4e>
    {
    __HAL_RCC_PWR_CLK_ENABLE();
 800c1c0:	69e3      	ldr	r3, [r4, #28]
 800c1c2:	4313      	orrs	r3, r2
 800c1c4:	61e3      	str	r3, [r4, #28]
 800c1c6:	69e3      	ldr	r3, [r4, #28]
 800c1c8:	4013      	ands	r3, r2
 800c1ca:	9303      	str	r3, [sp, #12]
 800c1cc:	9b03      	ldr	r3, [sp, #12]
      pwrclkchanged = SET;
 800c1ce:	2301      	movs	r3, #1
 800c1d0:	9300      	str	r3, [sp, #0]
    }
    
    if(HAL_IS_BIT_CLR(PWR->CR, PWR_CR_DBP))
 800c1d2:	2780      	movs	r7, #128	; 0x80
 800c1d4:	4e47      	ldr	r6, [pc, #284]	; (800c2f4 <HAL_RCCEx_PeriphCLKConfig+0x170>)
 800c1d6:	007f      	lsls	r7, r7, #1
 800c1d8:	6833      	ldr	r3, [r6, #0]
 800c1da:	423b      	tst	r3, r7
 800c1dc:	d04c      	beq.n	800c278 <HAL_RCCEx_PeriphCLKConfig+0xf4>
        }
      }
    }
    
    /* Reset the Backup domain only if the RTC Clock source selection is modified from reset value */ 
    temp_reg = (RCC->BDCR & RCC_BDCR_RTCSEL);
 800c1de:	6a22      	ldr	r2, [r4, #32]
 800c1e0:	23c0      	movs	r3, #192	; 0xc0
 800c1e2:	0011      	movs	r1, r2
 800c1e4:	009b      	lsls	r3, r3, #2
 800c1e6:	4019      	ands	r1, r3
    if((temp_reg != 0x00000000U) && (temp_reg != (PeriphClkInit->RTCClockSelection & RCC_BDCR_RTCSEL)))
 800c1e8:	421a      	tst	r2, r3
 800c1ea:	d157      	bne.n	800c29c <HAL_RCCEx_PeriphCLKConfig+0x118>
            return HAL_TIMEOUT;
          }
        }
      }
    }
    __HAL_RCC_RTC_CONFIG(PeriphClkInit->RTCClockSelection);
 800c1ec:	6a23      	ldr	r3, [r4, #32]
 800c1ee:	4a3f      	ldr	r2, [pc, #252]	; (800c2ec <HAL_RCCEx_PeriphCLKConfig+0x168>)
 800c1f0:	4013      	ands	r3, r2
 800c1f2:	686a      	ldr	r2, [r5, #4]
 800c1f4:	4313      	orrs	r3, r2
 800c1f6:	6223      	str	r3, [r4, #32]

    /* Require to disable power clock if necessary */
    if(pwrclkchanged == SET)
 800c1f8:	9b00      	ldr	r3, [sp, #0]
 800c1fa:	2b01      	cmp	r3, #1
 800c1fc:	d103      	bne.n	800c206 <HAL_RCCEx_PeriphCLKConfig+0x82>
    {
      __HAL_RCC_PWR_CLK_DISABLE();
 800c1fe:	69e3      	ldr	r3, [r4, #28]
 800c200:	4a3d      	ldr	r2, [pc, #244]	; (800c2f8 <HAL_RCCEx_PeriphCLKConfig+0x174>)
 800c202:	4013      	ands	r3, r2
 800c204:	61e3      	str	r3, [r4, #28]
    }
  }

  /*------------------------------- USART1 Configuration ------------------------*/ 
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART1) == RCC_PERIPHCLK_USART1)
 800c206:	682b      	ldr	r3, [r5, #0]
 800c208:	07db      	lsls	r3, r3, #31
 800c20a:	d50d      	bpl.n	800c228 <HAL_RCCEx_PeriphCLKConfig+0xa4>
  {
    /* Check the parameters */
    assert_param(IS_RCC_USART1CLKSOURCE(PeriphClkInit->Usart1ClockSelection));
 800c20c:	68ab      	ldr	r3, [r5, #8]
 800c20e:	2b03      	cmp	r3, #3
 800c210:	d903      	bls.n	800c21a <HAL_RCCEx_PeriphCLKConfig+0x96>
 800c212:	21bb      	movs	r1, #187	; 0xbb
 800c214:	4834      	ldr	r0, [pc, #208]	; (800c2e8 <HAL_RCCEx_PeriphCLKConfig+0x164>)
 800c216:	f7fc fb8b 	bl	8008930 <assert_failed>
    
    /* Configure the USART1 clock source */
    __HAL_RCC_USART1_CONFIG(PeriphClkInit->Usart1ClockSelection);
 800c21a:	2103      	movs	r1, #3
 800c21c:	4a34      	ldr	r2, [pc, #208]	; (800c2f0 <HAL_RCCEx_PeriphCLKConfig+0x16c>)
 800c21e:	6b13      	ldr	r3, [r2, #48]	; 0x30
 800c220:	438b      	bics	r3, r1
 800c222:	68a9      	ldr	r1, [r5, #8]
 800c224:	430b      	orrs	r3, r1
 800c226:	6313      	str	r3, [r2, #48]	; 0x30
    __HAL_RCC_USART3_CONFIG(PeriphClkInit->Usart3ClockSelection);
  }
#endif /* STM32F091xC || STM32F098xx */  

  /*------------------------------ I2C1 Configuration ------------------------*/ 
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C1) == RCC_PERIPHCLK_I2C1)
 800c228:	682b      	ldr	r3, [r5, #0]
 800c22a:	069b      	lsls	r3, r3, #26
 800c22c:	d50e      	bpl.n	800c24c <HAL_RCCEx_PeriphCLKConfig+0xc8>
  {
    /* Check the parameters */
    assert_param(IS_RCC_I2C1CLKSOURCE(PeriphClkInit->I2c1ClockSelection));
 800c22e:	2310      	movs	r3, #16
 800c230:	68ea      	ldr	r2, [r5, #12]
 800c232:	439a      	bics	r2, r3
 800c234:	d003      	beq.n	800c23e <HAL_RCCEx_PeriphCLKConfig+0xba>
 800c236:	21df      	movs	r1, #223	; 0xdf
 800c238:	482b      	ldr	r0, [pc, #172]	; (800c2e8 <HAL_RCCEx_PeriphCLKConfig+0x164>)
 800c23a:	f7fc fb79 	bl	8008930 <assert_failed>
    
    /* Configure the I2C1 clock source */
    __HAL_RCC_I2C1_CONFIG(PeriphClkInit->I2c1ClockSelection);
 800c23e:	2110      	movs	r1, #16
 800c240:	4a2b      	ldr	r2, [pc, #172]	; (800c2f0 <HAL_RCCEx_PeriphCLKConfig+0x16c>)
 800c242:	6b13      	ldr	r3, [r2, #48]	; 0x30
 800c244:	438b      	bics	r3, r1
 800c246:	68e9      	ldr	r1, [r5, #12]
 800c248:	430b      	orrs	r3, r1
 800c24a:	6313      	str	r3, [r2, #48]	; 0x30
  }

#if defined(STM32F042x6) || defined(STM32F048xx) || defined(STM32F072xB) || defined(STM32F078xx) || defined(STM32F070xB) || defined(STM32F070x6)
  /*------------------------------ USB Configuration ------------------------*/ 
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USB) == RCC_PERIPHCLK_USB)
 800c24c:	682b      	ldr	r3, [r5, #0]
#endif /* STM32F042x6 || STM32F048xx ||                */
       /* STM32F051x8 || STM32F058xx ||                */
       /* STM32F071xB || STM32F072xB || STM32F078xx || */
       /* STM32F091xC || STM32F098xx */
  
  return HAL_OK;
 800c24e:	2000      	movs	r0, #0
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USB) == RCC_PERIPHCLK_USB)
 800c250:	039b      	lsls	r3, r3, #14
 800c252:	d521      	bpl.n	800c298 <HAL_RCCEx_PeriphCLKConfig+0x114>
    assert_param(IS_RCC_USBCLKSOURCE(PeriphClkInit->UsbClockSelection));
 800c254:	2380      	movs	r3, #128	; 0x80
 800c256:	692a      	ldr	r2, [r5, #16]
 800c258:	439a      	bics	r2, r3
 800c25a:	4282      	cmp	r2, r0
 800c25c:	d003      	beq.n	800c266 <HAL_RCCEx_PeriphCLKConfig+0xe2>
 800c25e:	21ea      	movs	r1, #234	; 0xea
 800c260:	4821      	ldr	r0, [pc, #132]	; (800c2e8 <HAL_RCCEx_PeriphCLKConfig+0x164>)
 800c262:	f7fc fb65 	bl	8008930 <assert_failed>
    __HAL_RCC_USB_CONFIG(PeriphClkInit->UsbClockSelection);
 800c266:	2180      	movs	r1, #128	; 0x80
 800c268:	4a21      	ldr	r2, [pc, #132]	; (800c2f0 <HAL_RCCEx_PeriphCLKConfig+0x16c>)
  return HAL_OK;
 800c26a:	2000      	movs	r0, #0
    __HAL_RCC_USB_CONFIG(PeriphClkInit->UsbClockSelection);
 800c26c:	6b13      	ldr	r3, [r2, #48]	; 0x30
 800c26e:	438b      	bics	r3, r1
 800c270:	6929      	ldr	r1, [r5, #16]
 800c272:	430b      	orrs	r3, r1
 800c274:	6313      	str	r3, [r2, #48]	; 0x30
 800c276:	e00f      	b.n	800c298 <HAL_RCCEx_PeriphCLKConfig+0x114>
      SET_BIT(PWR->CR, PWR_CR_DBP);
 800c278:	6833      	ldr	r3, [r6, #0]
 800c27a:	433b      	orrs	r3, r7
 800c27c:	6033      	str	r3, [r6, #0]
      tickstart = HAL_GetTick();
 800c27e:	f7fd fb9b 	bl	80099b8 <HAL_GetTick>
 800c282:	9001      	str	r0, [sp, #4]
      while(HAL_IS_BIT_CLR(PWR->CR, PWR_CR_DBP))
 800c284:	6833      	ldr	r3, [r6, #0]
 800c286:	423b      	tst	r3, r7
 800c288:	d1a9      	bne.n	800c1de <HAL_RCCEx_PeriphCLKConfig+0x5a>
        if((HAL_GetTick() - tickstart) > RCC_DBP_TIMEOUT_VALUE)
 800c28a:	f7fd fb95 	bl	80099b8 <HAL_GetTick>
 800c28e:	9b01      	ldr	r3, [sp, #4]
 800c290:	1ac0      	subs	r0, r0, r3
 800c292:	2864      	cmp	r0, #100	; 0x64
 800c294:	d9f6      	bls.n	800c284 <HAL_RCCEx_PeriphCLKConfig+0x100>
          return HAL_TIMEOUT;
 800c296:	2003      	movs	r0, #3
}
 800c298:	b005      	add	sp, #20
 800c29a:	bdf0      	pop	{r4, r5, r6, r7, pc}
    if((temp_reg != 0x00000000U) && (temp_reg != (PeriphClkInit->RTCClockSelection & RCC_BDCR_RTCSEL)))
 800c29c:	686a      	ldr	r2, [r5, #4]
 800c29e:	4013      	ands	r3, r2
 800c2a0:	428b      	cmp	r3, r1
 800c2a2:	d0a3      	beq.n	800c1ec <HAL_RCCEx_PeriphCLKConfig+0x68>
      __HAL_RCC_BACKUPRESET_FORCE();
 800c2a4:	2380      	movs	r3, #128	; 0x80
      temp_reg = (RCC->BDCR & ~(RCC_BDCR_RTCSEL));
 800c2a6:	6a22      	ldr	r2, [r4, #32]
      __HAL_RCC_BACKUPRESET_FORCE();
 800c2a8:	6a20      	ldr	r0, [r4, #32]
 800c2aa:	025b      	lsls	r3, r3, #9
 800c2ac:	4303      	orrs	r3, r0
 800c2ae:	6223      	str	r3, [r4, #32]
      __HAL_RCC_BACKUPRESET_RELEASE();
 800c2b0:	6a23      	ldr	r3, [r4, #32]
      temp_reg = (RCC->BDCR & ~(RCC_BDCR_RTCSEL));
 800c2b2:	490e      	ldr	r1, [pc, #56]	; (800c2ec <HAL_RCCEx_PeriphCLKConfig+0x168>)
      __HAL_RCC_BACKUPRESET_RELEASE();
 800c2b4:	4811      	ldr	r0, [pc, #68]	; (800c2fc <HAL_RCCEx_PeriphCLKConfig+0x178>)
      temp_reg = (RCC->BDCR & ~(RCC_BDCR_RTCSEL));
 800c2b6:	4011      	ands	r1, r2
      __HAL_RCC_BACKUPRESET_RELEASE();
 800c2b8:	4003      	ands	r3, r0
 800c2ba:	6223      	str	r3, [r4, #32]
      RCC->BDCR = temp_reg;
 800c2bc:	6221      	str	r1, [r4, #32]
      if (HAL_IS_BIT_SET(temp_reg, RCC_BDCR_LSEON))
 800c2be:	07d3      	lsls	r3, r2, #31
 800c2c0:	d400      	bmi.n	800c2c4 <HAL_RCCEx_PeriphCLKConfig+0x140>
 800c2c2:	e793      	b.n	800c1ec <HAL_RCCEx_PeriphCLKConfig+0x68>
        tickstart = HAL_GetTick();
 800c2c4:	f7fd fb78 	bl	80099b8 <HAL_GetTick>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
 800c2c8:	2702      	movs	r7, #2
        tickstart = HAL_GetTick();
 800c2ca:	0006      	movs	r6, r0
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
 800c2cc:	6a23      	ldr	r3, [r4, #32]
 800c2ce:	423b      	tst	r3, r7
 800c2d0:	d000      	beq.n	800c2d4 <HAL_RCCEx_PeriphCLKConfig+0x150>
 800c2d2:	e78b      	b.n	800c1ec <HAL_RCCEx_PeriphCLKConfig+0x68>
          if((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 800c2d4:	f7fd fb70 	bl	80099b8 <HAL_GetTick>
 800c2d8:	4b09      	ldr	r3, [pc, #36]	; (800c300 <HAL_RCCEx_PeriphCLKConfig+0x17c>)
 800c2da:	1b80      	subs	r0, r0, r6
 800c2dc:	4298      	cmp	r0, r3
 800c2de:	d9f5      	bls.n	800c2cc <HAL_RCCEx_PeriphCLKConfig+0x148>
 800c2e0:	e7d9      	b.n	800c296 <HAL_RCCEx_PeriphCLKConfig+0x112>
 800c2e2:	46c0      	nop			; (mov r8, r8)
 800c2e4:	00030021 	.word	0x00030021
 800c2e8:	08010905 	.word	0x08010905
 800c2ec:	fffffcff 	.word	0xfffffcff
 800c2f0:	40021000 	.word	0x40021000
 800c2f4:	40007000 	.word	0x40007000
 800c2f8:	efffffff 	.word	0xefffffff
 800c2fc:	fffeffff 	.word	0xfffeffff
 800c300:	00001388 	.word	0x00001388

0800c304 <HAL_SPI_ErrorCallback>:
 800c304:	4770      	bx	lr
	...

0800c308 <HAL_SPI_IRQHandler>:
  *               the configuration information for the specified SPI module.
  * @retval None
  */
void HAL_SPI_IRQHandler(SPI_HandleTypeDef *hspi)
{
  uint32_t itsource = hspi->Instance->CR2;
 800c308:	6803      	ldr	r3, [r0, #0]
{
 800c30a:	b5f0      	push	{r4, r5, r6, r7, lr}
 800c30c:	0004      	movs	r4, r0
  uint32_t itsource = hspi->Instance->CR2;
 800c30e:	6858      	ldr	r0, [r3, #4]
  uint32_t itflag   = hspi->Instance->SR;
 800c310:	689a      	ldr	r2, [r3, #8]

  /* SPI in mode Receiver ----------------------------------------------------*/
  if ((SPI_CHECK_FLAG(itflag, SPI_FLAG_OVR) == RESET) &&
 800c312:	2501      	movs	r5, #1
 800c314:	0991      	lsrs	r1, r2, #6
 800c316:	000f      	movs	r7, r1
{
 800c318:	b085      	sub	sp, #20
  if ((SPI_CHECK_FLAG(itflag, SPI_FLAG_OVR) == RESET) &&
 800c31a:	402f      	ands	r7, r5
 800c31c:	4229      	tst	r1, r5
 800c31e:	d109      	bne.n	800c334 <HAL_SPI_IRQHandler+0x2c>
 800c320:	422a      	tst	r2, r5
 800c322:	d007      	beq.n	800c334 <HAL_SPI_IRQHandler+0x2c>
      (SPI_CHECK_FLAG(itflag, SPI_FLAG_RXNE) != RESET) && (SPI_CHECK_IT_SOURCE(itsource, SPI_IT_RXNE) != RESET))
 800c324:	0986      	lsrs	r6, r0, #6
 800c326:	422e      	tst	r6, r5
 800c328:	d004      	beq.n	800c334 <HAL_SPI_IRQHandler+0x2c>
  {
    hspi->RxISR(hspi);
 800c32a:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
  }

  /* SPI in mode Transmitter -------------------------------------------------*/
  if ((SPI_CHECK_FLAG(itflag, SPI_FLAG_TXE) != RESET) && (SPI_CHECK_IT_SOURCE(itsource, SPI_IT_TXE) != RESET))
  {
    hspi->TxISR(hspi);
 800c32c:	0020      	movs	r0, r4
 800c32e:	4798      	blx	r3
#endif /* USE_HAL_SPI_REGISTER_CALLBACKS */
      }
    }
    return;
  }
}
 800c330:	b005      	add	sp, #20
 800c332:	bdf0      	pop	{r4, r5, r6, r7, pc}
  if ((SPI_CHECK_FLAG(itflag, SPI_FLAG_TXE) != RESET) && (SPI_CHECK_IT_SOURCE(itsource, SPI_IT_TXE) != RESET))
 800c334:	2501      	movs	r5, #1
 800c336:	0796      	lsls	r6, r2, #30
 800c338:	d504      	bpl.n	800c344 <HAL_SPI_IRQHandler+0x3c>
 800c33a:	09c6      	lsrs	r6, r0, #7
 800c33c:	422e      	tst	r6, r5
 800c33e:	d001      	beq.n	800c344 <HAL_SPI_IRQHandler+0x3c>
    hspi->TxISR(hspi);
 800c340:	6d23      	ldr	r3, [r4, #80]	; 0x50
 800c342:	e7f3      	b.n	800c32c <HAL_SPI_IRQHandler+0x24>
       || (SPI_CHECK_FLAG(itflag, SPI_FLAG_FRE) != RESET)) && (SPI_CHECK_IT_SOURCE(itsource, SPI_IT_ERR) != RESET))
 800c344:	2501      	movs	r5, #1
  if (((SPI_CHECK_FLAG(itflag, SPI_FLAG_MODF) != RESET) || (SPI_CHECK_FLAG(itflag, SPI_FLAG_OVR) != RESET)
 800c346:	0956      	lsrs	r6, r2, #5
       || (SPI_CHECK_FLAG(itflag, SPI_FLAG_FRE) != RESET)) && (SPI_CHECK_IT_SOURCE(itsource, SPI_IT_ERR) != RESET))
 800c348:	4331      	orrs	r1, r6
 800c34a:	0a12      	lsrs	r2, r2, #8
 800c34c:	402a      	ands	r2, r5
 800c34e:	4029      	ands	r1, r5
 800c350:	4311      	orrs	r1, r2
 800c352:	d0ed      	beq.n	800c330 <HAL_SPI_IRQHandler+0x28>
 800c354:	0941      	lsrs	r1, r0, #5
 800c356:	4229      	tst	r1, r5
 800c358:	d0ea      	beq.n	800c330 <HAL_SPI_IRQHandler+0x28>
    if (SPI_CHECK_FLAG(itflag, SPI_FLAG_OVR) != RESET)
 800c35a:	2f00      	cmp	r7, #0
 800c35c:	d00f      	beq.n	800c37e <HAL_SPI_IRQHandler+0x76>
      if (hspi->State != HAL_SPI_STATE_BUSY_TX)
 800c35e:	0021      	movs	r1, r4
 800c360:	315d      	adds	r1, #93	; 0x5d
 800c362:	7809      	ldrb	r1, [r1, #0]
 800c364:	2903      	cmp	r1, #3
 800c366:	d050      	beq.n	800c40a <HAL_SPI_IRQHandler+0x102>
        SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_OVR);
 800c368:	2104      	movs	r1, #4
 800c36a:	6e25      	ldr	r5, [r4, #96]	; 0x60
 800c36c:	4329      	orrs	r1, r5
 800c36e:	6621      	str	r1, [r4, #96]	; 0x60
        __HAL_SPI_CLEAR_OVRFLAG(hspi);
 800c370:	2100      	movs	r1, #0
 800c372:	9100      	str	r1, [sp, #0]
 800c374:	68d9      	ldr	r1, [r3, #12]
 800c376:	9100      	str	r1, [sp, #0]
 800c378:	6899      	ldr	r1, [r3, #8]
 800c37a:	9100      	str	r1, [sp, #0]
 800c37c:	9900      	ldr	r1, [sp, #0]
  if (((SPI_CHECK_FLAG(itflag, SPI_FLAG_MODF) != RESET) || (SPI_CHECK_FLAG(itflag, SPI_FLAG_OVR) != RESET)
 800c37e:	2101      	movs	r1, #1
    if (SPI_CHECK_FLAG(itflag, SPI_FLAG_MODF) != RESET)
 800c380:	420e      	tst	r6, r1
 800c382:	d00b      	beq.n	800c39c <HAL_SPI_IRQHandler+0x94>
      SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_MODF);
 800c384:	6e25      	ldr	r5, [r4, #96]	; 0x60
 800c386:	4329      	orrs	r1, r5
 800c388:	6621      	str	r1, [r4, #96]	; 0x60
      __HAL_SPI_CLEAR_MODFFLAG(hspi);
 800c38a:	2100      	movs	r1, #0
 800c38c:	2540      	movs	r5, #64	; 0x40
 800c38e:	9102      	str	r1, [sp, #8]
 800c390:	6899      	ldr	r1, [r3, #8]
 800c392:	9102      	str	r1, [sp, #8]
 800c394:	6819      	ldr	r1, [r3, #0]
 800c396:	43a9      	bics	r1, r5
 800c398:	6019      	str	r1, [r3, #0]
 800c39a:	9902      	ldr	r1, [sp, #8]
    if (SPI_CHECK_FLAG(itflag, SPI_FLAG_FRE) != RESET)
 800c39c:	2a00      	cmp	r2, #0
 800c39e:	d008      	beq.n	800c3b2 <HAL_SPI_IRQHandler+0xaa>
      SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_FRE);
 800c3a0:	2208      	movs	r2, #8
 800c3a2:	6e21      	ldr	r1, [r4, #96]	; 0x60
 800c3a4:	430a      	orrs	r2, r1
 800c3a6:	6622      	str	r2, [r4, #96]	; 0x60
      __HAL_SPI_CLEAR_FREFLAG(hspi);
 800c3a8:	2200      	movs	r2, #0
 800c3aa:	9203      	str	r2, [sp, #12]
 800c3ac:	689a      	ldr	r2, [r3, #8]
 800c3ae:	9203      	str	r2, [sp, #12]
 800c3b0:	9a03      	ldr	r2, [sp, #12]
    if (hspi->ErrorCode != HAL_SPI_ERROR_NONE)
 800c3b2:	6e22      	ldr	r2, [r4, #96]	; 0x60
 800c3b4:	2a00      	cmp	r2, #0
 800c3b6:	d0bb      	beq.n	800c330 <HAL_SPI_IRQHandler+0x28>
      __HAL_SPI_DISABLE_IT(hspi, SPI_IT_RXNE | SPI_IT_TXE | SPI_IT_ERR);
 800c3b8:	21e0      	movs	r1, #224	; 0xe0
 800c3ba:	685a      	ldr	r2, [r3, #4]
 800c3bc:	438a      	bics	r2, r1
 800c3be:	605a      	str	r2, [r3, #4]
      hspi->State = HAL_SPI_STATE_READY;
 800c3c0:	0022      	movs	r2, r4
 800c3c2:	39df      	subs	r1, #223	; 0xdf
 800c3c4:	325d      	adds	r2, #93	; 0x5d
 800c3c6:	7011      	strb	r1, [r2, #0]
      if ((HAL_IS_BIT_SET(itsource, SPI_CR2_TXDMAEN)) || (HAL_IS_BIT_SET(itsource, SPI_CR2_RXDMAEN)))
 800c3c8:	3102      	adds	r1, #2
 800c3ca:	4208      	tst	r0, r1
 800c3cc:	d025      	beq.n	800c41a <HAL_SPI_IRQHandler+0x112>
        CLEAR_BIT(hspi->Instance->CR2, (SPI_CR2_TXDMAEN | SPI_CR2_RXDMAEN));
 800c3ce:	685a      	ldr	r2, [r3, #4]
        if (hspi->hdmarx != NULL)
 800c3d0:	6da0      	ldr	r0, [r4, #88]	; 0x58
        CLEAR_BIT(hspi->Instance->CR2, (SPI_CR2_TXDMAEN | SPI_CR2_RXDMAEN));
 800c3d2:	438a      	bics	r2, r1
 800c3d4:	605a      	str	r2, [r3, #4]
        if (hspi->hdmarx != NULL)
 800c3d6:	2800      	cmp	r0, #0
 800c3d8:	d009      	beq.n	800c3ee <HAL_SPI_IRQHandler+0xe6>
          hspi->hdmarx->XferAbortCallback = SPI_DMAAbortOnError;
 800c3da:	4b12      	ldr	r3, [pc, #72]	; (800c424 <HAL_SPI_IRQHandler+0x11c>)
 800c3dc:	6343      	str	r3, [r0, #52]	; 0x34
          if (HAL_OK != HAL_DMA_Abort_IT(hspi->hdmarx))
 800c3de:	f7fd fe51 	bl	800a084 <HAL_DMA_Abort_IT>
 800c3e2:	2800      	cmp	r0, #0
 800c3e4:	d003      	beq.n	800c3ee <HAL_SPI_IRQHandler+0xe6>
            SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_ABORT);
 800c3e6:	2340      	movs	r3, #64	; 0x40
 800c3e8:	6e22      	ldr	r2, [r4, #96]	; 0x60
 800c3ea:	4313      	orrs	r3, r2
 800c3ec:	6623      	str	r3, [r4, #96]	; 0x60
        if (hspi->hdmatx != NULL)
 800c3ee:	6d60      	ldr	r0, [r4, #84]	; 0x54
 800c3f0:	2800      	cmp	r0, #0
 800c3f2:	d09d      	beq.n	800c330 <HAL_SPI_IRQHandler+0x28>
          hspi->hdmatx->XferAbortCallback = SPI_DMAAbortOnError;
 800c3f4:	4b0b      	ldr	r3, [pc, #44]	; (800c424 <HAL_SPI_IRQHandler+0x11c>)
 800c3f6:	6343      	str	r3, [r0, #52]	; 0x34
          if (HAL_OK != HAL_DMA_Abort_IT(hspi->hdmatx))
 800c3f8:	f7fd fe44 	bl	800a084 <HAL_DMA_Abort_IT>
 800c3fc:	2800      	cmp	r0, #0
 800c3fe:	d097      	beq.n	800c330 <HAL_SPI_IRQHandler+0x28>
            SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_ABORT);
 800c400:	2340      	movs	r3, #64	; 0x40
 800c402:	6e22      	ldr	r2, [r4, #96]	; 0x60
 800c404:	4313      	orrs	r3, r2
 800c406:	6623      	str	r3, [r4, #96]	; 0x60
 800c408:	e792      	b.n	800c330 <HAL_SPI_IRQHandler+0x28>
        __HAL_SPI_CLEAR_OVRFLAG(hspi);
 800c40a:	2200      	movs	r2, #0
 800c40c:	9201      	str	r2, [sp, #4]
 800c40e:	68da      	ldr	r2, [r3, #12]
 800c410:	9201      	str	r2, [sp, #4]
 800c412:	689b      	ldr	r3, [r3, #8]
 800c414:	9301      	str	r3, [sp, #4]
 800c416:	9b01      	ldr	r3, [sp, #4]
        return;
 800c418:	e78a      	b.n	800c330 <HAL_SPI_IRQHandler+0x28>
        HAL_SPI_ErrorCallback(hspi);
 800c41a:	0020      	movs	r0, r4
 800c41c:	f7ff ff72 	bl	800c304 <HAL_SPI_ErrorCallback>
 800c420:	e786      	b.n	800c330 <HAL_SPI_IRQHandler+0x28>
 800c422:	46c0      	nop			; (mov r8, r8)
 800c424:	0800c429 	.word	0x0800c429

0800c428 <SPI_DMAAbortOnError>:
  * @param  hdma DMA handle.
  * @retval None
  */
static void SPI_DMAAbortOnError(DMA_HandleTypeDef *hdma)
{
  SPI_HandleTypeDef *hspi = (SPI_HandleTypeDef *)(((DMA_HandleTypeDef *)hdma)->Parent); /* Derogation MISRAC2012-Rule-11.5 */
 800c428:	6a40      	ldr	r0, [r0, #36]	; 0x24
  hspi->RxXferCount = 0U;
 800c42a:	2300      	movs	r3, #0
 800c42c:	0002      	movs	r2, r0
{
 800c42e:	b510      	push	{r4, lr}
  hspi->RxXferCount = 0U;
 800c430:	3208      	adds	r2, #8
 800c432:	87d3      	strh	r3, [r2, #62]	; 0x3e
  hspi->TxXferCount = 0U;
 800c434:	87c3      	strh	r3, [r0, #62]	; 0x3e

  /* Call user error callback */
#if (USE_HAL_SPI_REGISTER_CALLBACKS == 1U)
  hspi->ErrorCallback(hspi);
#else
  HAL_SPI_ErrorCallback(hspi);
 800c436:	f7ff ff65 	bl	800c304 <HAL_SPI_ErrorCallback>
#endif /* USE_HAL_SPI_REGISTER_CALLBACKS */
}
 800c43a:	bd10      	pop	{r4, pc}

0800c43c <HAL_TIM_Base_Start_IT>:
  * @brief  Starts the TIM Base generation in interrupt mode.
  * @param  htim TIM Base handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_TIM_Base_Start_IT(TIM_HandleTypeDef *htim)
{
 800c43c:	b570      	push	{r4, r5, r6, lr}
  uint32_t tmpsmcr;

  /* Check the parameters */
  assert_param(IS_TIM_INSTANCE(htim->Instance));
 800c43e:	6803      	ldr	r3, [r0, #0]
 800c440:	4c20      	ldr	r4, [pc, #128]	; (800c4c4 <HAL_TIM_Base_Start_IT+0x88>)
{
 800c442:	0005      	movs	r5, r0
  assert_param(IS_TIM_INSTANCE(htim->Instance));
 800c444:	42a3      	cmp	r3, r4
 800c446:	d019      	beq.n	800c47c <HAL_TIM_Base_Start_IT+0x40>
 800c448:	4a1f      	ldr	r2, [pc, #124]	; (800c4c8 <HAL_TIM_Base_Start_IT+0x8c>)
 800c44a:	4293      	cmp	r3, r2
 800c44c:	d016      	beq.n	800c47c <HAL_TIM_Base_Start_IT+0x40>
 800c44e:	4a1f      	ldr	r2, [pc, #124]	; (800c4cc <HAL_TIM_Base_Start_IT+0x90>)
 800c450:	4293      	cmp	r3, r2
 800c452:	d013      	beq.n	800c47c <HAL_TIM_Base_Start_IT+0x40>
 800c454:	4a1e      	ldr	r2, [pc, #120]	; (800c4d0 <HAL_TIM_Base_Start_IT+0x94>)
 800c456:	4293      	cmp	r3, r2
 800c458:	d010      	beq.n	800c47c <HAL_TIM_Base_Start_IT+0x40>
 800c45a:	4a1e      	ldr	r2, [pc, #120]	; (800c4d4 <HAL_TIM_Base_Start_IT+0x98>)
 800c45c:	4293      	cmp	r3, r2
 800c45e:	d00d      	beq.n	800c47c <HAL_TIM_Base_Start_IT+0x40>
 800c460:	4a1d      	ldr	r2, [pc, #116]	; (800c4d8 <HAL_TIM_Base_Start_IT+0x9c>)
 800c462:	4293      	cmp	r3, r2
 800c464:	d00a      	beq.n	800c47c <HAL_TIM_Base_Start_IT+0x40>
 800c466:	4a1d      	ldr	r2, [pc, #116]	; (800c4dc <HAL_TIM_Base_Start_IT+0xa0>)
 800c468:	4293      	cmp	r3, r2
 800c46a:	d007      	beq.n	800c47c <HAL_TIM_Base_Start_IT+0x40>
 800c46c:	4a1c      	ldr	r2, [pc, #112]	; (800c4e0 <HAL_TIM_Base_Start_IT+0xa4>)
 800c46e:	4293      	cmp	r3, r2
 800c470:	d004      	beq.n	800c47c <HAL_TIM_Base_Start_IT+0x40>
 800c472:	21d0      	movs	r1, #208	; 0xd0
 800c474:	481b      	ldr	r0, [pc, #108]	; (800c4e4 <HAL_TIM_Base_Start_IT+0xa8>)
 800c476:	31ff      	adds	r1, #255	; 0xff
 800c478:	f7fc fa5a 	bl	8008930 <assert_failed>

  /* Check the TIM state */
  if (htim->State != HAL_TIM_STATE_READY)
 800c47c:	002b      	movs	r3, r5
  {
    return HAL_ERROR;
 800c47e:	2001      	movs	r0, #1
  if (htim->State != HAL_TIM_STATE_READY)
 800c480:	333d      	adds	r3, #61	; 0x3d
 800c482:	781a      	ldrb	r2, [r3, #0]
 800c484:	4282      	cmp	r2, r0
 800c486:	d117      	bne.n	800c4b8 <HAL_TIM_Base_Start_IT+0x7c>
  }

  /* Set the TIM state */
  htim->State = HAL_TIM_STATE_BUSY;
 800c488:	2202      	movs	r2, #2
 800c48a:	701a      	strb	r2, [r3, #0]

  /* Enable the TIM Update interrupt */
  __HAL_TIM_ENABLE_IT(htim, TIM_IT_UPDATE);
 800c48c:	682b      	ldr	r3, [r5, #0]
 800c48e:	68da      	ldr	r2, [r3, #12]
 800c490:	4302      	orrs	r2, r0
 800c492:	60da      	str	r2, [r3, #12]

  /* Enable the Peripheral, except in trigger mode where enable is automatically done with trigger */
  if (IS_TIM_SLAVE_INSTANCE(htim->Instance))
 800c494:	42a3      	cmp	r3, r4
 800c496:	d005      	beq.n	800c4a4 <HAL_TIM_Base_Start_IT+0x68>
 800c498:	4a0b      	ldr	r2, [pc, #44]	; (800c4c8 <HAL_TIM_Base_Start_IT+0x8c>)
 800c49a:	4293      	cmp	r3, r2
 800c49c:	d002      	beq.n	800c4a4 <HAL_TIM_Base_Start_IT+0x68>
 800c49e:	4a0e      	ldr	r2, [pc, #56]	; (800c4d8 <HAL_TIM_Base_Start_IT+0x9c>)
 800c4a0:	4293      	cmp	r3, r2
 800c4a2:	d10a      	bne.n	800c4ba <HAL_TIM_Base_Start_IT+0x7e>
  {
    tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;
 800c4a4:	2107      	movs	r1, #7
 800c4a6:	689a      	ldr	r2, [r3, #8]
  {
    __HAL_TIM_ENABLE(htim);
  }

  /* Return function status */
  return HAL_OK;
 800c4a8:	2000      	movs	r0, #0
    tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;
 800c4aa:	400a      	ands	r2, r1
    if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
 800c4ac:	2a06      	cmp	r2, #6
 800c4ae:	d003      	beq.n	800c4b8 <HAL_TIM_Base_Start_IT+0x7c>
      __HAL_TIM_ENABLE(htim);
 800c4b0:	2201      	movs	r2, #1
 800c4b2:	6819      	ldr	r1, [r3, #0]
 800c4b4:	430a      	orrs	r2, r1
 800c4b6:	601a      	str	r2, [r3, #0]
}
 800c4b8:	bd70      	pop	{r4, r5, r6, pc}
    __HAL_TIM_ENABLE(htim);
 800c4ba:	681a      	ldr	r2, [r3, #0]
 800c4bc:	4310      	orrs	r0, r2
 800c4be:	6018      	str	r0, [r3, #0]
  return HAL_OK;
 800c4c0:	2000      	movs	r0, #0
 800c4c2:	e7f9      	b.n	800c4b8 <HAL_TIM_Base_Start_IT+0x7c>
 800c4c4:	40012c00 	.word	0x40012c00
 800c4c8:	40000400 	.word	0x40000400
 800c4cc:	40001000 	.word	0x40001000
 800c4d0:	40001400 	.word	0x40001400
 800c4d4:	40002000 	.word	0x40002000
 800c4d8:	40014000 	.word	0x40014000
 800c4dc:	40014400 	.word	0x40014400
 800c4e0:	40014800 	.word	0x40014800
 800c4e4:	08010940 	.word	0x08010940

0800c4e8 <HAL_TIM_OC_DelayElapsedCallback>:
 800c4e8:	4770      	bx	lr

0800c4ea <HAL_TIM_IC_CaptureCallback>:
 800c4ea:	4770      	bx	lr

0800c4ec <HAL_TIM_PWM_PulseFinishedCallback>:
 800c4ec:	4770      	bx	lr

0800c4ee <HAL_TIM_TriggerCallback>:
 800c4ee:	4770      	bx	lr

0800c4f0 <HAL_TIM_IRQHandler>:
  * @retval None
  */
void HAL_TIM_IRQHandler(TIM_HandleTypeDef *htim)
{
  /* Capture compare 1 event */
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC1) != RESET)
 800c4f0:	2202      	movs	r2, #2
 800c4f2:	6803      	ldr	r3, [r0, #0]
{
 800c4f4:	b510      	push	{r4, lr}
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC1) != RESET)
 800c4f6:	6919      	ldr	r1, [r3, #16]
{
 800c4f8:	0004      	movs	r4, r0
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC1) != RESET)
 800c4fa:	4211      	tst	r1, r2
 800c4fc:	d00e      	beq.n	800c51c <HAL_TIM_IRQHandler+0x2c>
  {
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC1) != RESET)
 800c4fe:	68d9      	ldr	r1, [r3, #12]
 800c500:	4211      	tst	r1, r2
 800c502:	d00b      	beq.n	800c51c <HAL_TIM_IRQHandler+0x2c>
    {
      {
        __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC1);
 800c504:	3a05      	subs	r2, #5
 800c506:	611a      	str	r2, [r3, #16]
        htim->Channel = HAL_TIM_ACTIVE_CHANNEL_1;
 800c508:	3204      	adds	r2, #4
 800c50a:	7702      	strb	r2, [r0, #28]

        /* Input capture event */
        if ((htim->Instance->CCMR1 & TIM_CCMR1_CC1S) != 0x00U)
 800c50c:	699b      	ldr	r3, [r3, #24]
 800c50e:	079b      	lsls	r3, r3, #30
 800c510:	d100      	bne.n	800c514 <HAL_TIM_IRQHandler+0x24>
 800c512:	e079      	b.n	800c608 <HAL_TIM_IRQHandler+0x118>
        {
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
          htim->IC_CaptureCallback(htim);
#else
          HAL_TIM_IC_CaptureCallback(htim);
 800c514:	f7ff ffe9 	bl	800c4ea <HAL_TIM_IC_CaptureCallback>
#else
          HAL_TIM_OC_DelayElapsedCallback(htim);
          HAL_TIM_PWM_PulseFinishedCallback(htim);
#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
        }
        htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
 800c518:	2300      	movs	r3, #0
 800c51a:	7723      	strb	r3, [r4, #28]
      }
    }
  }
  /* Capture compare 2 event */
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC2) != RESET)
 800c51c:	2204      	movs	r2, #4
 800c51e:	6823      	ldr	r3, [r4, #0]
 800c520:	6919      	ldr	r1, [r3, #16]
 800c522:	4211      	tst	r1, r2
 800c524:	d010      	beq.n	800c548 <HAL_TIM_IRQHandler+0x58>
  {
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC2) != RESET)
 800c526:	68d9      	ldr	r1, [r3, #12]
 800c528:	4211      	tst	r1, r2
 800c52a:	d00d      	beq.n	800c548 <HAL_TIM_IRQHandler+0x58>
    {
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC2);
 800c52c:	3a09      	subs	r2, #9
 800c52e:	611a      	str	r2, [r3, #16]
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_2;
 800c530:	3207      	adds	r2, #7
 800c532:	7722      	strb	r2, [r4, #28]
      /* Input capture event */
      if ((htim->Instance->CCMR1 & TIM_CCMR1_CC2S) != 0x00U)
 800c534:	699a      	ldr	r2, [r3, #24]
 800c536:	23c0      	movs	r3, #192	; 0xc0
 800c538:	009b      	lsls	r3, r3, #2
      {
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
        htim->IC_CaptureCallback(htim);
#else
        HAL_TIM_IC_CaptureCallback(htim);
 800c53a:	0020      	movs	r0, r4
      if ((htim->Instance->CCMR1 & TIM_CCMR1_CC2S) != 0x00U)
 800c53c:	421a      	tst	r2, r3
 800c53e:	d069      	beq.n	800c614 <HAL_TIM_IRQHandler+0x124>
        HAL_TIM_IC_CaptureCallback(htim);
 800c540:	f7ff ffd3 	bl	800c4ea <HAL_TIM_IC_CaptureCallback>
#else
        HAL_TIM_OC_DelayElapsedCallback(htim);
        HAL_TIM_PWM_PulseFinishedCallback(htim);
#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
      }
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
 800c544:	2300      	movs	r3, #0
 800c546:	7723      	strb	r3, [r4, #28]
    }
  }
  /* Capture compare 3 event */
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC3) != RESET)
 800c548:	2208      	movs	r2, #8
 800c54a:	6823      	ldr	r3, [r4, #0]
 800c54c:	6919      	ldr	r1, [r3, #16]
 800c54e:	4211      	tst	r1, r2
 800c550:	d00e      	beq.n	800c570 <HAL_TIM_IRQHandler+0x80>
  {
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC3) != RESET)
 800c552:	68d9      	ldr	r1, [r3, #12]
 800c554:	4211      	tst	r1, r2
 800c556:	d00b      	beq.n	800c570 <HAL_TIM_IRQHandler+0x80>
    {
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC3);
 800c558:	3a11      	subs	r2, #17
 800c55a:	611a      	str	r2, [r3, #16]
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_3;
 800c55c:	320d      	adds	r2, #13
 800c55e:	7722      	strb	r2, [r4, #28]
      /* Input capture event */
      if ((htim->Instance->CCMR2 & TIM_CCMR2_CC3S) != 0x00U)
 800c560:	69db      	ldr	r3, [r3, #28]
      {
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
        htim->IC_CaptureCallback(htim);
#else
        HAL_TIM_IC_CaptureCallback(htim);
 800c562:	0020      	movs	r0, r4
      if ((htim->Instance->CCMR2 & TIM_CCMR2_CC3S) != 0x00U)
 800c564:	079b      	lsls	r3, r3, #30
 800c566:	d05b      	beq.n	800c620 <HAL_TIM_IRQHandler+0x130>
        HAL_TIM_IC_CaptureCallback(htim);
 800c568:	f7ff ffbf 	bl	800c4ea <HAL_TIM_IC_CaptureCallback>
#else
        HAL_TIM_OC_DelayElapsedCallback(htim);
        HAL_TIM_PWM_PulseFinishedCallback(htim);
#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
      }
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
 800c56c:	2300      	movs	r3, #0
 800c56e:	7723      	strb	r3, [r4, #28]
    }
  }
  /* Capture compare 4 event */
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC4) != RESET)
 800c570:	2210      	movs	r2, #16
 800c572:	6823      	ldr	r3, [r4, #0]
 800c574:	6919      	ldr	r1, [r3, #16]
 800c576:	4211      	tst	r1, r2
 800c578:	d010      	beq.n	800c59c <HAL_TIM_IRQHandler+0xac>
  {
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC4) != RESET)
 800c57a:	68d9      	ldr	r1, [r3, #12]
 800c57c:	4211      	tst	r1, r2
 800c57e:	d00d      	beq.n	800c59c <HAL_TIM_IRQHandler+0xac>
    {
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC4);
 800c580:	3a21      	subs	r2, #33	; 0x21
 800c582:	611a      	str	r2, [r3, #16]
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_4;
 800c584:	3219      	adds	r2, #25
 800c586:	7722      	strb	r2, [r4, #28]
      /* Input capture event */
      if ((htim->Instance->CCMR2 & TIM_CCMR2_CC4S) != 0x00U)
 800c588:	69da      	ldr	r2, [r3, #28]
 800c58a:	23c0      	movs	r3, #192	; 0xc0
 800c58c:	009b      	lsls	r3, r3, #2
      {
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
        htim->IC_CaptureCallback(htim);
#else
        HAL_TIM_IC_CaptureCallback(htim);
 800c58e:	0020      	movs	r0, r4
      if ((htim->Instance->CCMR2 & TIM_CCMR2_CC4S) != 0x00U)
 800c590:	421a      	tst	r2, r3
 800c592:	d04b      	beq.n	800c62c <HAL_TIM_IRQHandler+0x13c>
        HAL_TIM_IC_CaptureCallback(htim);
 800c594:	f7ff ffa9 	bl	800c4ea <HAL_TIM_IC_CaptureCallback>
#else
        HAL_TIM_OC_DelayElapsedCallback(htim);
        HAL_TIM_PWM_PulseFinishedCallback(htim);
#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
      }
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
 800c598:	2300      	movs	r3, #0
 800c59a:	7723      	strb	r3, [r4, #28]
    }
  }
  /* TIM Update event */
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_UPDATE) != RESET)
 800c59c:	2201      	movs	r2, #1
 800c59e:	6823      	ldr	r3, [r4, #0]
 800c5a0:	6919      	ldr	r1, [r3, #16]
 800c5a2:	4211      	tst	r1, r2
 800c5a4:	d007      	beq.n	800c5b6 <HAL_TIM_IRQHandler+0xc6>
  {
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_UPDATE) != RESET)
 800c5a6:	68d9      	ldr	r1, [r3, #12]
 800c5a8:	4211      	tst	r1, r2
 800c5aa:	d004      	beq.n	800c5b6 <HAL_TIM_IRQHandler+0xc6>
    {
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_UPDATE);
 800c5ac:	3a03      	subs	r2, #3
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
      htim->PeriodElapsedCallback(htim);
#else
      HAL_TIM_PeriodElapsedCallback(htim);
 800c5ae:	0020      	movs	r0, r4
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_UPDATE);
 800c5b0:	611a      	str	r2, [r3, #16]
      HAL_TIM_PeriodElapsedCallback(htim);
 800c5b2:	f7fc f9b1 	bl	8008918 <HAL_TIM_PeriodElapsedCallback>
#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
    }
  }
  /* TIM Break input event */
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_BREAK) != RESET)
 800c5b6:	2280      	movs	r2, #128	; 0x80
 800c5b8:	6823      	ldr	r3, [r4, #0]
 800c5ba:	6919      	ldr	r1, [r3, #16]
 800c5bc:	4211      	tst	r1, r2
 800c5be:	d008      	beq.n	800c5d2 <HAL_TIM_IRQHandler+0xe2>
  {
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_BREAK) != RESET)
 800c5c0:	68d9      	ldr	r1, [r3, #12]
 800c5c2:	4211      	tst	r1, r2
 800c5c4:	d005      	beq.n	800c5d2 <HAL_TIM_IRQHandler+0xe2>
    {
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_BREAK);
 800c5c6:	3a02      	subs	r2, #2
 800c5c8:	3aff      	subs	r2, #255	; 0xff
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
      htim->BreakCallback(htim);
#else
      HAL_TIMEx_BreakCallback(htim);
 800c5ca:	0020      	movs	r0, r4
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_BREAK);
 800c5cc:	611a      	str	r2, [r3, #16]
      HAL_TIMEx_BreakCallback(htim);
 800c5ce:	f000 fb52 	bl	800cc76 <HAL_TIMEx_BreakCallback>
#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
    }
  }
  /* TIM Trigger detection event */
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_TRIGGER) != RESET)
 800c5d2:	2240      	movs	r2, #64	; 0x40
 800c5d4:	6823      	ldr	r3, [r4, #0]
 800c5d6:	6919      	ldr	r1, [r3, #16]
 800c5d8:	4211      	tst	r1, r2
 800c5da:	d007      	beq.n	800c5ec <HAL_TIM_IRQHandler+0xfc>
  {
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_TRIGGER) != RESET)
 800c5dc:	68d9      	ldr	r1, [r3, #12]
 800c5de:	4211      	tst	r1, r2
 800c5e0:	d004      	beq.n	800c5ec <HAL_TIM_IRQHandler+0xfc>
    {
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_TRIGGER);
 800c5e2:	3a81      	subs	r2, #129	; 0x81
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
      htim->TriggerCallback(htim);
#else
      HAL_TIM_TriggerCallback(htim);
 800c5e4:	0020      	movs	r0, r4
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_TRIGGER);
 800c5e6:	611a      	str	r2, [r3, #16]
      HAL_TIM_TriggerCallback(htim);
 800c5e8:	f7ff ff81 	bl	800c4ee <HAL_TIM_TriggerCallback>
#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
    }
  }
  /* TIM commutation event */
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_COM) != RESET)
 800c5ec:	2220      	movs	r2, #32
 800c5ee:	6823      	ldr	r3, [r4, #0]
 800c5f0:	6919      	ldr	r1, [r3, #16]
 800c5f2:	4211      	tst	r1, r2
 800c5f4:	d007      	beq.n	800c606 <HAL_TIM_IRQHandler+0x116>
  {
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_COM) != RESET)
 800c5f6:	68d9      	ldr	r1, [r3, #12]
 800c5f8:	4211      	tst	r1, r2
 800c5fa:	d004      	beq.n	800c606 <HAL_TIM_IRQHandler+0x116>
    {
      __HAL_TIM_CLEAR_IT(htim, TIM_FLAG_COM);
 800c5fc:	3a41      	subs	r2, #65	; 0x41
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
      htim->CommutationCallback(htim);
#else
      HAL_TIMEx_CommutCallback(htim);
 800c5fe:	0020      	movs	r0, r4
      __HAL_TIM_CLEAR_IT(htim, TIM_FLAG_COM);
 800c600:	611a      	str	r2, [r3, #16]
      HAL_TIMEx_CommutCallback(htim);
 800c602:	f000 fb37 	bl	800cc74 <HAL_TIMEx_CommutCallback>
#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
    }
  }
}
 800c606:	bd10      	pop	{r4, pc}
          HAL_TIM_OC_DelayElapsedCallback(htim);
 800c608:	f7ff ff6e 	bl	800c4e8 <HAL_TIM_OC_DelayElapsedCallback>
          HAL_TIM_PWM_PulseFinishedCallback(htim);
 800c60c:	0020      	movs	r0, r4
 800c60e:	f7ff ff6d 	bl	800c4ec <HAL_TIM_PWM_PulseFinishedCallback>
 800c612:	e781      	b.n	800c518 <HAL_TIM_IRQHandler+0x28>
        HAL_TIM_OC_DelayElapsedCallback(htim);
 800c614:	f7ff ff68 	bl	800c4e8 <HAL_TIM_OC_DelayElapsedCallback>
        HAL_TIM_PWM_PulseFinishedCallback(htim);
 800c618:	0020      	movs	r0, r4
 800c61a:	f7ff ff67 	bl	800c4ec <HAL_TIM_PWM_PulseFinishedCallback>
 800c61e:	e791      	b.n	800c544 <HAL_TIM_IRQHandler+0x54>
        HAL_TIM_OC_DelayElapsedCallback(htim);
 800c620:	f7ff ff62 	bl	800c4e8 <HAL_TIM_OC_DelayElapsedCallback>
        HAL_TIM_PWM_PulseFinishedCallback(htim);
 800c624:	0020      	movs	r0, r4
 800c626:	f7ff ff61 	bl	800c4ec <HAL_TIM_PWM_PulseFinishedCallback>
 800c62a:	e79f      	b.n	800c56c <HAL_TIM_IRQHandler+0x7c>
        HAL_TIM_OC_DelayElapsedCallback(htim);
 800c62c:	f7ff ff5c 	bl	800c4e8 <HAL_TIM_OC_DelayElapsedCallback>
        HAL_TIM_PWM_PulseFinishedCallback(htim);
 800c630:	0020      	movs	r0, r4
 800c632:	f7ff ff5b 	bl	800c4ec <HAL_TIM_PWM_PulseFinishedCallback>
 800c636:	e7af      	b.n	800c598 <HAL_TIM_IRQHandler+0xa8>

0800c638 <TIM_Base_SetConfig>:
{
  uint32_t tmpcr1;
  tmpcr1 = TIMx->CR1;

  /* Set TIM Time Base Unit parameters ---------------------------------------*/
  if (IS_TIM_COUNTER_MODE_SELECT_INSTANCE(TIMx))
 800c638:	4a1c      	ldr	r2, [pc, #112]	; (800c6ac <TIM_Base_SetConfig+0x74>)
{
 800c63a:	b510      	push	{r4, lr}
  tmpcr1 = TIMx->CR1;
 800c63c:	6803      	ldr	r3, [r0, #0]
  if (IS_TIM_COUNTER_MODE_SELECT_INSTANCE(TIMx))
 800c63e:	4290      	cmp	r0, r2
 800c640:	d002      	beq.n	800c648 <TIM_Base_SetConfig+0x10>
 800c642:	4c1b      	ldr	r4, [pc, #108]	; (800c6b0 <TIM_Base_SetConfig+0x78>)
 800c644:	42a0      	cmp	r0, r4
 800c646:	d108      	bne.n	800c65a <TIM_Base_SetConfig+0x22>
  {
    /* Select the Counter Mode */
    tmpcr1 &= ~(TIM_CR1_DIR | TIM_CR1_CMS);
 800c648:	2470      	movs	r4, #112	; 0x70
 800c64a:	43a3      	bics	r3, r4
    tmpcr1 |= Structure->CounterMode;
 800c64c:	684c      	ldr	r4, [r1, #4]
 800c64e:	4323      	orrs	r3, r4
  }

  if (IS_TIM_CLOCK_DIVISION_INSTANCE(TIMx))
 800c650:	4290      	cmp	r0, r2
 800c652:	d00e      	beq.n	800c672 <TIM_Base_SetConfig+0x3a>
 800c654:	4c16      	ldr	r4, [pc, #88]	; (800c6b0 <TIM_Base_SetConfig+0x78>)
 800c656:	42a0      	cmp	r0, r4
 800c658:	d00b      	beq.n	800c672 <TIM_Base_SetConfig+0x3a>
 800c65a:	4c16      	ldr	r4, [pc, #88]	; (800c6b4 <TIM_Base_SetConfig+0x7c>)
 800c65c:	42a0      	cmp	r0, r4
 800c65e:	d008      	beq.n	800c672 <TIM_Base_SetConfig+0x3a>
 800c660:	4c15      	ldr	r4, [pc, #84]	; (800c6b8 <TIM_Base_SetConfig+0x80>)
 800c662:	42a0      	cmp	r0, r4
 800c664:	d005      	beq.n	800c672 <TIM_Base_SetConfig+0x3a>
 800c666:	4c15      	ldr	r4, [pc, #84]	; (800c6bc <TIM_Base_SetConfig+0x84>)
 800c668:	42a0      	cmp	r0, r4
 800c66a:	d002      	beq.n	800c672 <TIM_Base_SetConfig+0x3a>
 800c66c:	4c14      	ldr	r4, [pc, #80]	; (800c6c0 <TIM_Base_SetConfig+0x88>)
 800c66e:	42a0      	cmp	r0, r4
 800c670:	d103      	bne.n	800c67a <TIM_Base_SetConfig+0x42>
  {
    /* Set the clock division */
    tmpcr1 &= ~TIM_CR1_CKD;
 800c672:	4c14      	ldr	r4, [pc, #80]	; (800c6c4 <TIM_Base_SetConfig+0x8c>)
 800c674:	4023      	ands	r3, r4
    tmpcr1 |= (uint32_t)Structure->ClockDivision;
 800c676:	68cc      	ldr	r4, [r1, #12]
 800c678:	4323      	orrs	r3, r4
  }

  /* Set the auto-reload preload */
  MODIFY_REG(tmpcr1, TIM_CR1_ARPE, Structure->AutoReloadPreload);
 800c67a:	2480      	movs	r4, #128	; 0x80
 800c67c:	43a3      	bics	r3, r4
 800c67e:	694c      	ldr	r4, [r1, #20]
 800c680:	4323      	orrs	r3, r4

  TIMx->CR1 = tmpcr1;
 800c682:	6003      	str	r3, [r0, #0]

  /* Set the Autoreload value */
  TIMx->ARR = (uint32_t)Structure->Period ;
 800c684:	688b      	ldr	r3, [r1, #8]
 800c686:	62c3      	str	r3, [r0, #44]	; 0x2c

  /* Set the Prescaler value */
  TIMx->PSC = Structure->Prescaler;
 800c688:	680b      	ldr	r3, [r1, #0]
 800c68a:	6283      	str	r3, [r0, #40]	; 0x28

  if (IS_TIM_REPETITION_COUNTER_INSTANCE(TIMx))
 800c68c:	4290      	cmp	r0, r2
 800c68e:	d008      	beq.n	800c6a2 <TIM_Base_SetConfig+0x6a>
 800c690:	4b09      	ldr	r3, [pc, #36]	; (800c6b8 <TIM_Base_SetConfig+0x80>)
 800c692:	4298      	cmp	r0, r3
 800c694:	d005      	beq.n	800c6a2 <TIM_Base_SetConfig+0x6a>
 800c696:	4b09      	ldr	r3, [pc, #36]	; (800c6bc <TIM_Base_SetConfig+0x84>)
 800c698:	4298      	cmp	r0, r3
 800c69a:	d002      	beq.n	800c6a2 <TIM_Base_SetConfig+0x6a>
 800c69c:	4b08      	ldr	r3, [pc, #32]	; (800c6c0 <TIM_Base_SetConfig+0x88>)
 800c69e:	4298      	cmp	r0, r3
 800c6a0:	d101      	bne.n	800c6a6 <TIM_Base_SetConfig+0x6e>
  {
    /* Set the Repetition Counter value */
    TIMx->RCR = Structure->RepetitionCounter;
 800c6a2:	690b      	ldr	r3, [r1, #16]
 800c6a4:	6303      	str	r3, [r0, #48]	; 0x30
  }

  /* Generate an update event to reload the Prescaler
     and the repetition counter (only for advanced timer) value immediately */
  TIMx->EGR = TIM_EGR_UG;
 800c6a6:	2301      	movs	r3, #1
 800c6a8:	6143      	str	r3, [r0, #20]
}
 800c6aa:	bd10      	pop	{r4, pc}
 800c6ac:	40012c00 	.word	0x40012c00
 800c6b0:	40000400 	.word	0x40000400
 800c6b4:	40002000 	.word	0x40002000
 800c6b8:	40014000 	.word	0x40014000
 800c6bc:	40014400 	.word	0x40014400
 800c6c0:	40014800 	.word	0x40014800
 800c6c4:	fffffcff 	.word	0xfffffcff

0800c6c8 <HAL_TIM_Base_Init>:
{
 800c6c8:	b570      	push	{r4, r5, r6, lr}
 800c6ca:	0004      	movs	r4, r0
    return HAL_ERROR;
 800c6cc:	2001      	movs	r0, #1
  if (htim == NULL)
 800c6ce:	2c00      	cmp	r4, #0
 800c6d0:	d066      	beq.n	800c7a0 <HAL_TIM_Base_Init+0xd8>
  assert_param(IS_TIM_INSTANCE(htim->Instance));
 800c6d2:	6823      	ldr	r3, [r4, #0]
 800c6d4:	4a33      	ldr	r2, [pc, #204]	; (800c7a4 <HAL_TIM_Base_Init+0xdc>)
 800c6d6:	4293      	cmp	r3, r2
 800c6d8:	d019      	beq.n	800c70e <HAL_TIM_Base_Init+0x46>
 800c6da:	4a33      	ldr	r2, [pc, #204]	; (800c7a8 <HAL_TIM_Base_Init+0xe0>)
 800c6dc:	4293      	cmp	r3, r2
 800c6de:	d016      	beq.n	800c70e <HAL_TIM_Base_Init+0x46>
 800c6e0:	4a32      	ldr	r2, [pc, #200]	; (800c7ac <HAL_TIM_Base_Init+0xe4>)
 800c6e2:	4293      	cmp	r3, r2
 800c6e4:	d013      	beq.n	800c70e <HAL_TIM_Base_Init+0x46>
 800c6e6:	4a32      	ldr	r2, [pc, #200]	; (800c7b0 <HAL_TIM_Base_Init+0xe8>)
 800c6e8:	4293      	cmp	r3, r2
 800c6ea:	d010      	beq.n	800c70e <HAL_TIM_Base_Init+0x46>
 800c6ec:	4a31      	ldr	r2, [pc, #196]	; (800c7b4 <HAL_TIM_Base_Init+0xec>)
 800c6ee:	4293      	cmp	r3, r2
 800c6f0:	d00d      	beq.n	800c70e <HAL_TIM_Base_Init+0x46>
 800c6f2:	4a31      	ldr	r2, [pc, #196]	; (800c7b8 <HAL_TIM_Base_Init+0xf0>)
 800c6f4:	4293      	cmp	r3, r2
 800c6f6:	d00a      	beq.n	800c70e <HAL_TIM_Base_Init+0x46>
 800c6f8:	4a30      	ldr	r2, [pc, #192]	; (800c7bc <HAL_TIM_Base_Init+0xf4>)
 800c6fa:	4293      	cmp	r3, r2
 800c6fc:	d007      	beq.n	800c70e <HAL_TIM_Base_Init+0x46>
 800c6fe:	4a30      	ldr	r2, [pc, #192]	; (800c7c0 <HAL_TIM_Base_Init+0xf8>)
 800c700:	4293      	cmp	r3, r2
 800c702:	d004      	beq.n	800c70e <HAL_TIM_Base_Init+0x46>
 800c704:	2114      	movs	r1, #20
 800c706:	482f      	ldr	r0, [pc, #188]	; (800c7c4 <HAL_TIM_Base_Init+0xfc>)
 800c708:	31ff      	adds	r1, #255	; 0xff
 800c70a:	f7fc f911 	bl	8008930 <assert_failed>
  assert_param(IS_TIM_COUNTER_MODE(htim->Init.CounterMode));
 800c70e:	68a3      	ldr	r3, [r4, #8]
 800c710:	2210      	movs	r2, #16
 800c712:	0019      	movs	r1, r3
 800c714:	4391      	bics	r1, r2
 800c716:	d00b      	beq.n	800c730 <HAL_TIM_Base_Init+0x68>
 800c718:	2240      	movs	r2, #64	; 0x40
 800c71a:	0019      	movs	r1, r3
 800c71c:	4391      	bics	r1, r2
 800c71e:	2920      	cmp	r1, #32
 800c720:	d006      	beq.n	800c730 <HAL_TIM_Base_Init+0x68>
 800c722:	2b40      	cmp	r3, #64	; 0x40
 800c724:	d004      	beq.n	800c730 <HAL_TIM_Base_Init+0x68>
 800c726:	218a      	movs	r1, #138	; 0x8a
 800c728:	4826      	ldr	r0, [pc, #152]	; (800c7c4 <HAL_TIM_Base_Init+0xfc>)
 800c72a:	0049      	lsls	r1, r1, #1
 800c72c:	f7fc f900 	bl	8008930 <assert_failed>
  assert_param(IS_TIM_CLOCKDIVISION_DIV(htim->Init.ClockDivision));
 800c730:	6923      	ldr	r3, [r4, #16]
 800c732:	4a25      	ldr	r2, [pc, #148]	; (800c7c8 <HAL_TIM_Base_Init+0x100>)
 800c734:	4213      	tst	r3, r2
 800c736:	d008      	beq.n	800c74a <HAL_TIM_Base_Init+0x82>
 800c738:	2280      	movs	r2, #128	; 0x80
 800c73a:	0092      	lsls	r2, r2, #2
 800c73c:	4293      	cmp	r3, r2
 800c73e:	d004      	beq.n	800c74a <HAL_TIM_Base_Init+0x82>
 800c740:	2116      	movs	r1, #22
 800c742:	4820      	ldr	r0, [pc, #128]	; (800c7c4 <HAL_TIM_Base_Init+0xfc>)
 800c744:	31ff      	adds	r1, #255	; 0xff
 800c746:	f7fc f8f3 	bl	8008930 <assert_failed>
  assert_param(IS_TIM_AUTORELOAD_PRELOAD(htim->Init.AutoReloadPreload));
 800c74a:	2380      	movs	r3, #128	; 0x80
 800c74c:	69a2      	ldr	r2, [r4, #24]
 800c74e:	439a      	bics	r2, r3
 800c750:	d004      	beq.n	800c75c <HAL_TIM_Base_Init+0x94>
 800c752:	218b      	movs	r1, #139	; 0x8b
 800c754:	481b      	ldr	r0, [pc, #108]	; (800c7c4 <HAL_TIM_Base_Init+0xfc>)
 800c756:	0049      	lsls	r1, r1, #1
 800c758:	f7fc f8ea 	bl	8008930 <assert_failed>
  if (htim->State == HAL_TIM_STATE_RESET)
 800c75c:	0025      	movs	r5, r4
 800c75e:	353d      	adds	r5, #61	; 0x3d
 800c760:	782b      	ldrb	r3, [r5, #0]
 800c762:	b2da      	uxtb	r2, r3
 800c764:	2b00      	cmp	r3, #0
 800c766:	d105      	bne.n	800c774 <HAL_TIM_Base_Init+0xac>
    htim->Lock = HAL_UNLOCKED;
 800c768:	0023      	movs	r3, r4
 800c76a:	333c      	adds	r3, #60	; 0x3c
    HAL_TIM_Base_MspInit(htim);
 800c76c:	0020      	movs	r0, r4
    htim->Lock = HAL_UNLOCKED;
 800c76e:	701a      	strb	r2, [r3, #0]
    HAL_TIM_Base_MspInit(htim);
 800c770:	f7fc fa14 	bl	8008b9c <HAL_TIM_Base_MspInit>
  htim->State = HAL_TIM_STATE_BUSY;
 800c774:	2302      	movs	r3, #2
 800c776:	702b      	strb	r3, [r5, #0]
  TIM_Base_SetConfig(htim->Instance, &htim->Init);
 800c778:	6820      	ldr	r0, [r4, #0]
 800c77a:	1d21      	adds	r1, r4, #4
 800c77c:	f7ff ff5c 	bl	800c638 <TIM_Base_SetConfig>
  htim->DMABurstState = HAL_DMA_BURST_STATE_READY;
 800c780:	0022      	movs	r2, r4
 800c782:	2301      	movs	r3, #1
  return HAL_OK;
 800c784:	2000      	movs	r0, #0
  htim->DMABurstState = HAL_DMA_BURST_STATE_READY;
 800c786:	3246      	adds	r2, #70	; 0x46
 800c788:	7013      	strb	r3, [r2, #0]
  TIM_CHANNEL_N_STATE_SET_ALL(htim, HAL_TIM_CHANNEL_STATE_READY);
 800c78a:	3445      	adds	r4, #69	; 0x45
  TIM_CHANNEL_STATE_SET_ALL(htim, HAL_TIM_CHANNEL_STATE_READY);
 800c78c:	3a08      	subs	r2, #8
 800c78e:	7013      	strb	r3, [r2, #0]
 800c790:	7053      	strb	r3, [r2, #1]
 800c792:	7093      	strb	r3, [r2, #2]
 800c794:	70d3      	strb	r3, [r2, #3]
  TIM_CHANNEL_N_STATE_SET_ALL(htim, HAL_TIM_CHANNEL_STATE_READY);
 800c796:	7113      	strb	r3, [r2, #4]
 800c798:	7153      	strb	r3, [r2, #5]
 800c79a:	7193      	strb	r3, [r2, #6]
 800c79c:	7023      	strb	r3, [r4, #0]
  htim->State = HAL_TIM_STATE_READY;
 800c79e:	702b      	strb	r3, [r5, #0]
}
 800c7a0:	bd70      	pop	{r4, r5, r6, pc}
 800c7a2:	46c0      	nop			; (mov r8, r8)
 800c7a4:	40012c00 	.word	0x40012c00
 800c7a8:	40000400 	.word	0x40000400
 800c7ac:	40001000 	.word	0x40001000
 800c7b0:	40001400 	.word	0x40001400
 800c7b4:	40002000 	.word	0x40002000
 800c7b8:	40014000 	.word	0x40014000
 800c7bc:	40014400 	.word	0x40014400
 800c7c0:	40014800 	.word	0x40014800
 800c7c4:	08010940 	.word	0x08010940
 800c7c8:	fffffeff 	.word	0xfffffeff

0800c7cc <TIM_ETR_SetConfig>:
  *          This parameter must be a value between 0x00 and 0x0F
  * @retval None
  */
void TIM_ETR_SetConfig(TIM_TypeDef *TIMx, uint32_t TIM_ExtTRGPrescaler,
                       uint32_t TIM_ExtTRGPolarity, uint32_t ExtTRGFilter)
{
 800c7cc:	b530      	push	{r4, r5, lr}
  uint32_t tmpsmcr;

  tmpsmcr = TIMx->SMCR;
 800c7ce:	6884      	ldr	r4, [r0, #8]

  /* Reset the ETR Bits */
  tmpsmcr &= ~(TIM_SMCR_ETF | TIM_SMCR_ETPS | TIM_SMCR_ECE | TIM_SMCR_ETP);
 800c7d0:	4d03      	ldr	r5, [pc, #12]	; (800c7e0 <TIM_ETR_SetConfig+0x14>)

  /* Set the Prescaler, the Filter value and the Polarity */
  tmpsmcr |= (uint32_t)(TIM_ExtTRGPrescaler | (TIM_ExtTRGPolarity | (ExtTRGFilter << 8U)));
 800c7d2:	430a      	orrs	r2, r1
 800c7d4:	021b      	lsls	r3, r3, #8
  tmpsmcr &= ~(TIM_SMCR_ETF | TIM_SMCR_ETPS | TIM_SMCR_ECE | TIM_SMCR_ETP);
 800c7d6:	402c      	ands	r4, r5
  tmpsmcr |= (uint32_t)(TIM_ExtTRGPrescaler | (TIM_ExtTRGPolarity | (ExtTRGFilter << 8U)));
 800c7d8:	4313      	orrs	r3, r2
 800c7da:	4323      	orrs	r3, r4

  /* Write to TIMx SMCR */
  TIMx->SMCR = tmpsmcr;
 800c7dc:	6083      	str	r3, [r0, #8]
}
 800c7de:	bd30      	pop	{r4, r5, pc}
 800c7e0:	ffff00ff 	.word	0xffff00ff

0800c7e4 <HAL_TIM_ConfigClockSource>:
{
 800c7e4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  __HAL_LOCK(htim);
 800c7e6:	0006      	movs	r6, r0
 800c7e8:	2302      	movs	r3, #2
 800c7ea:	363c      	adds	r6, #60	; 0x3c
 800c7ec:	7832      	ldrb	r2, [r6, #0]
{
 800c7ee:	0005      	movs	r5, r0
 800c7f0:	000c      	movs	r4, r1
  __HAL_LOCK(htim);
 800c7f2:	0018      	movs	r0, r3
 800c7f4:	2a01      	cmp	r2, #1
 800c7f6:	d044      	beq.n	800c882 <HAL_TIM_ConfigClockSource+0x9e>
  htim->State = HAL_TIM_STATE_BUSY;
 800c7f8:	002f      	movs	r7, r5
  __HAL_LOCK(htim);
 800c7fa:	2201      	movs	r2, #1
  htim->State = HAL_TIM_STATE_BUSY;
 800c7fc:	373d      	adds	r7, #61	; 0x3d
  __HAL_LOCK(htim);
 800c7fe:	7032      	strb	r2, [r6, #0]
  htim->State = HAL_TIM_STATE_BUSY;
 800c800:	703b      	strb	r3, [r7, #0]
  assert_param(IS_TIM_CLOCKSOURCE(sClockSourceConfig->ClockSource));
 800c802:	4aa9      	ldr	r2, [pc, #676]	; (800caa8 <HAL_TIM_ConfigClockSource+0x2c4>)
 800c804:	680b      	ldr	r3, [r1, #0]
 800c806:	1899      	adds	r1, r3, r2
 800c808:	4aa8      	ldr	r2, [pc, #672]	; (800caac <HAL_TIM_ConfigClockSource+0x2c8>)
 800c80a:	4211      	tst	r1, r2
 800c80c:	d008      	beq.n	800c820 <HAL_TIM_ConfigClockSource+0x3c>
 800c80e:	2230      	movs	r2, #48	; 0x30
 800c810:	4393      	bics	r3, r2
 800c812:	d005      	beq.n	800c820 <HAL_TIM_ConfigClockSource+0x3c>
 800c814:	2b40      	cmp	r3, #64	; 0x40
 800c816:	d003      	beq.n	800c820 <HAL_TIM_ConfigClockSource+0x3c>
 800c818:	49a5      	ldr	r1, [pc, #660]	; (800cab0 <HAL_TIM_ConfigClockSource+0x2cc>)
 800c81a:	48a6      	ldr	r0, [pc, #664]	; (800cab4 <HAL_TIM_ConfigClockSource+0x2d0>)
 800c81c:	f7fc f888 	bl	8008930 <assert_failed>
  tmpsmcr = htim->Instance->SMCR;
 800c820:	682b      	ldr	r3, [r5, #0]
  tmpsmcr &= ~(TIM_SMCR_ETF | TIM_SMCR_ETPS | TIM_SMCR_ECE | TIM_SMCR_ETP);
 800c822:	49a5      	ldr	r1, [pc, #660]	; (800cab8 <HAL_TIM_ConfigClockSource+0x2d4>)
  tmpsmcr = htim->Instance->SMCR;
 800c824:	689a      	ldr	r2, [r3, #8]
  tmpsmcr &= ~(TIM_SMCR_ETF | TIM_SMCR_ETPS | TIM_SMCR_ECE | TIM_SMCR_ETP);
 800c826:	400a      	ands	r2, r1
  htim->Instance->SMCR = tmpsmcr;
 800c828:	609a      	str	r2, [r3, #8]
  switch (sClockSourceConfig->ClockSource)
 800c82a:	6822      	ldr	r2, [r4, #0]
 800c82c:	2a60      	cmp	r2, #96	; 0x60
 800c82e:	d100      	bne.n	800c832 <HAL_TIM_ConfigClockSource+0x4e>
 800c830:	e0fd      	b.n	800ca2e <HAL_TIM_ConfigClockSource+0x24a>
 800c832:	d866      	bhi.n	800c902 <HAL_TIM_ConfigClockSource+0x11e>
 800c834:	2a40      	cmp	r2, #64	; 0x40
 800c836:	d100      	bne.n	800c83a <HAL_TIM_ConfigClockSource+0x56>
 800c838:	e174      	b.n	800cb24 <HAL_TIM_ConfigClockSource+0x340>
 800c83a:	d823      	bhi.n	800c884 <HAL_TIM_ConfigClockSource+0xa0>
 800c83c:	2a20      	cmp	r2, #32
 800c83e:	d003      	beq.n	800c848 <HAL_TIM_ConfigClockSource+0x64>
 800c840:	d819      	bhi.n	800c876 <HAL_TIM_ConfigClockSource+0x92>
 800c842:	2110      	movs	r1, #16
 800c844:	438a      	bics	r2, r1
 800c846:	d118      	bne.n	800c87a <HAL_TIM_ConfigClockSource+0x96>
        assert_param(IS_TIM_CLOCKSOURCE_ITRX_INSTANCE(htim->Instance));
 800c848:	4a9c      	ldr	r2, [pc, #624]	; (800cabc <HAL_TIM_ConfigClockSource+0x2d8>)
 800c84a:	4293      	cmp	r3, r2
 800c84c:	d009      	beq.n	800c862 <HAL_TIM_ConfigClockSource+0x7e>
 800c84e:	4a9c      	ldr	r2, [pc, #624]	; (800cac0 <HAL_TIM_ConfigClockSource+0x2dc>)
 800c850:	4293      	cmp	r3, r2
 800c852:	d006      	beq.n	800c862 <HAL_TIM_ConfigClockSource+0x7e>
 800c854:	4a9b      	ldr	r2, [pc, #620]	; (800cac4 <HAL_TIM_ConfigClockSource+0x2e0>)
 800c856:	4293      	cmp	r3, r2
 800c858:	d003      	beq.n	800c862 <HAL_TIM_ConfigClockSource+0x7e>
 800c85a:	499b      	ldr	r1, [pc, #620]	; (800cac8 <HAL_TIM_ConfigClockSource+0x2e4>)
 800c85c:	4895      	ldr	r0, [pc, #596]	; (800cab4 <HAL_TIM_ConfigClockSource+0x2d0>)
 800c85e:	f7fc f867 	bl	8008930 <assert_failed>
  tmpsmcr &= ~TIM_SMCR_TS;
 800c862:	2270      	movs	r2, #112	; 0x70
        TIM_ITRx_SetConfig(htim->Instance, sClockSourceConfig->ClockSource);
 800c864:	6829      	ldr	r1, [r5, #0]
  tmpsmcr = TIMx->SMCR;
 800c866:	688b      	ldr	r3, [r1, #8]
  tmpsmcr &= ~TIM_SMCR_TS;
 800c868:	4393      	bics	r3, r2
  tmpsmcr |= (InputTriggerSource | TIM_SLAVEMODE_EXTERNAL1);
 800c86a:	6822      	ldr	r2, [r4, #0]
 800c86c:	4313      	orrs	r3, r2
 800c86e:	2207      	movs	r2, #7
 800c870:	4313      	orrs	r3, r2
  TIMx->SMCR = tmpsmcr;
 800c872:	608b      	str	r3, [r1, #8]
}
 800c874:	e001      	b.n	800c87a <HAL_TIM_ConfigClockSource+0x96>
  switch (sClockSourceConfig->ClockSource)
 800c876:	2a30      	cmp	r2, #48	; 0x30
 800c878:	d0e6      	beq.n	800c848 <HAL_TIM_ConfigClockSource+0x64>
  htim->State = HAL_TIM_STATE_READY;
 800c87a:	2301      	movs	r3, #1
  __HAL_UNLOCK(htim);
 800c87c:	2000      	movs	r0, #0
  htim->State = HAL_TIM_STATE_READY;
 800c87e:	703b      	strb	r3, [r7, #0]
  __HAL_UNLOCK(htim);
 800c880:	7030      	strb	r0, [r6, #0]
}
 800c882:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  switch (sClockSourceConfig->ClockSource)
 800c884:	2a50      	cmp	r2, #80	; 0x50
 800c886:	d1f8      	bne.n	800c87a <HAL_TIM_ConfigClockSource+0x96>
      assert_param(IS_TIM_CLOCKSOURCE_TIX_INSTANCE(htim->Instance));
 800c888:	4a8c      	ldr	r2, [pc, #560]	; (800cabc <HAL_TIM_ConfigClockSource+0x2d8>)
 800c88a:	4293      	cmp	r3, r2
 800c88c:	d009      	beq.n	800c8a2 <HAL_TIM_ConfigClockSource+0xbe>
 800c88e:	4a8c      	ldr	r2, [pc, #560]	; (800cac0 <HAL_TIM_ConfigClockSource+0x2dc>)
 800c890:	4293      	cmp	r3, r2
 800c892:	d006      	beq.n	800c8a2 <HAL_TIM_ConfigClockSource+0xbe>
 800c894:	4a8b      	ldr	r2, [pc, #556]	; (800cac4 <HAL_TIM_ConfigClockSource+0x2e0>)
 800c896:	4293      	cmp	r3, r2
 800c898:	d003      	beq.n	800c8a2 <HAL_TIM_ConfigClockSource+0xbe>
 800c89a:	498c      	ldr	r1, [pc, #560]	; (800cacc <HAL_TIM_ConfigClockSource+0x2e8>)
 800c89c:	4885      	ldr	r0, [pc, #532]	; (800cab4 <HAL_TIM_ConfigClockSource+0x2d0>)
 800c89e:	f7fc f847 	bl	8008930 <assert_failed>
      assert_param(IS_TIM_CLOCKPOLARITY(sClockSourceConfig->ClockPolarity));
 800c8a2:	2280      	movs	r2, #128	; 0x80
 800c8a4:	6863      	ldr	r3, [r4, #4]
 800c8a6:	0212      	lsls	r2, r2, #8
 800c8a8:	4293      	cmp	r3, r2
 800c8aa:	d009      	beq.n	800c8c0 <HAL_TIM_ConfigClockSource+0xdc>
 800c8ac:	2202      	movs	r2, #2
 800c8ae:	0019      	movs	r1, r3
 800c8b0:	4391      	bics	r1, r2
 800c8b2:	d005      	beq.n	800c8c0 <HAL_TIM_ConfigClockSource+0xdc>
 800c8b4:	2b0a      	cmp	r3, #10
 800c8b6:	d003      	beq.n	800c8c0 <HAL_TIM_ConfigClockSource+0xdc>
 800c8b8:	4985      	ldr	r1, [pc, #532]	; (800cad0 <HAL_TIM_ConfigClockSource+0x2ec>)
 800c8ba:	487e      	ldr	r0, [pc, #504]	; (800cab4 <HAL_TIM_ConfigClockSource+0x2d0>)
 800c8bc:	f7fc f838 	bl	8008930 <assert_failed>
      assert_param(IS_TIM_CLOCKFILTER(sClockSourceConfig->ClockFilter));
 800c8c0:	68e3      	ldr	r3, [r4, #12]
 800c8c2:	2b0f      	cmp	r3, #15
 800c8c4:	d903      	bls.n	800c8ce <HAL_TIM_ConfigClockSource+0xea>
 800c8c6:	4983      	ldr	r1, [pc, #524]	; (800cad4 <HAL_TIM_ConfigClockSource+0x2f0>)
 800c8c8:	487a      	ldr	r0, [pc, #488]	; (800cab4 <HAL_TIM_ConfigClockSource+0x2d0>)
 800c8ca:	f7fc f831 	bl	8008930 <assert_failed>
      TIM_TI1_ConfigInputStage(htim->Instance,
 800c8ce:	682b      	ldr	r3, [r5, #0]
  TIMx->CCER &= ~TIM_CCER_CC1E;
 800c8d0:	2501      	movs	r5, #1
  tmpccer = TIMx->CCER;
 800c8d2:	6a18      	ldr	r0, [r3, #32]
      TIM_TI1_ConfigInputStage(htim->Instance,
 800c8d4:	6861      	ldr	r1, [r4, #4]
 800c8d6:	68e2      	ldr	r2, [r4, #12]
  TIMx->CCER &= ~TIM_CCER_CC1E;
 800c8d8:	6a1c      	ldr	r4, [r3, #32]
  tmpccmr1 |= (TIM_ICFilter << 4U);
 800c8da:	0112      	lsls	r2, r2, #4
  TIMx->CCER &= ~TIM_CCER_CC1E;
 800c8dc:	43ac      	bics	r4, r5
 800c8de:	621c      	str	r4, [r3, #32]
  tmpccmr1 = TIMx->CCMR1;
 800c8e0:	699c      	ldr	r4, [r3, #24]
  tmpccmr1 &= ~TIM_CCMR1_IC1F;
 800c8e2:	35ef      	adds	r5, #239	; 0xef
 800c8e4:	43ac      	bics	r4, r5
  tmpccmr1 |= (TIM_ICFilter << 4U);
 800c8e6:	4322      	orrs	r2, r4
  tmpccer &= ~(TIM_CCER_CC1P | TIM_CCER_CC1NP);
 800c8e8:	240a      	movs	r4, #10
 800c8ea:	43a0      	bics	r0, r4
  tmpccer |= TIM_ICPolarity;
 800c8ec:	4301      	orrs	r1, r0
  TIMx->CCMR1 = tmpccmr1;
 800c8ee:	619a      	str	r2, [r3, #24]
  TIMx->CCER = tmpccer;
 800c8f0:	6219      	str	r1, [r3, #32]
  tmpsmcr &= ~TIM_SMCR_TS;
 800c8f2:	2170      	movs	r1, #112	; 0x70
  tmpsmcr = TIMx->SMCR;
 800c8f4:	689a      	ldr	r2, [r3, #8]
  tmpsmcr &= ~TIM_SMCR_TS;
 800c8f6:	438a      	bics	r2, r1
 800c8f8:	0011      	movs	r1, r2
  tmpsmcr |= (InputTriggerSource | TIM_SLAVEMODE_EXTERNAL1);
 800c8fa:	2257      	movs	r2, #87	; 0x57
 800c8fc:	430a      	orrs	r2, r1
  TIMx->SMCR = tmpsmcr;
 800c8fe:	609a      	str	r2, [r3, #8]
}
 800c900:	e7bb      	b.n	800c87a <HAL_TIM_ConfigClockSource+0x96>
  switch (sClockSourceConfig->ClockSource)
 800c902:	2180      	movs	r1, #128	; 0x80
 800c904:	0149      	lsls	r1, r1, #5
 800c906:	428a      	cmp	r2, r1
 800c908:	d039      	beq.n	800c97e <HAL_TIM_ConfigClockSource+0x19a>
 800c90a:	2180      	movs	r1, #128	; 0x80
 800c90c:	0189      	lsls	r1, r1, #6
 800c90e:	428a      	cmp	r2, r1
 800c910:	d05a      	beq.n	800c9c8 <HAL_TIM_ConfigClockSource+0x1e4>
 800c912:	2a70      	cmp	r2, #112	; 0x70
 800c914:	d1b1      	bne.n	800c87a <HAL_TIM_ConfigClockSource+0x96>
      assert_param(IS_TIM_CLOCKSOURCE_ETRMODE1_INSTANCE(htim->Instance));
 800c916:	4a69      	ldr	r2, [pc, #420]	; (800cabc <HAL_TIM_ConfigClockSource+0x2d8>)
 800c918:	4293      	cmp	r3, r2
 800c91a:	d006      	beq.n	800c92a <HAL_TIM_ConfigClockSource+0x146>
 800c91c:	4a68      	ldr	r2, [pc, #416]	; (800cac0 <HAL_TIM_ConfigClockSource+0x2dc>)
 800c91e:	4293      	cmp	r3, r2
 800c920:	d003      	beq.n	800c92a <HAL_TIM_ConfigClockSource+0x146>
 800c922:	496d      	ldr	r1, [pc, #436]	; (800cad8 <HAL_TIM_ConfigClockSource+0x2f4>)
 800c924:	4863      	ldr	r0, [pc, #396]	; (800cab4 <HAL_TIM_ConfigClockSource+0x2d0>)
 800c926:	f7fc f803 	bl	8008930 <assert_failed>
      assert_param(IS_TIM_CLOCKPRESCALER(sClockSourceConfig->ClockPrescaler));
 800c92a:	4b6c      	ldr	r3, [pc, #432]	; (800cadc <HAL_TIM_ConfigClockSource+0x2f8>)
 800c92c:	68a2      	ldr	r2, [r4, #8]
 800c92e:	421a      	tst	r2, r3
 800c930:	d003      	beq.n	800c93a <HAL_TIM_ConfigClockSource+0x156>
 800c932:	496b      	ldr	r1, [pc, #428]	; (800cae0 <HAL_TIM_ConfigClockSource+0x2fc>)
 800c934:	485f      	ldr	r0, [pc, #380]	; (800cab4 <HAL_TIM_ConfigClockSource+0x2d0>)
 800c936:	f7fb fffb 	bl	8008930 <assert_failed>
      assert_param(IS_TIM_CLOCKPOLARITY(sClockSourceConfig->ClockPolarity));
 800c93a:	2280      	movs	r2, #128	; 0x80
 800c93c:	6863      	ldr	r3, [r4, #4]
 800c93e:	0212      	lsls	r2, r2, #8
 800c940:	4293      	cmp	r3, r2
 800c942:	d009      	beq.n	800c958 <HAL_TIM_ConfigClockSource+0x174>
 800c944:	2202      	movs	r2, #2
 800c946:	0019      	movs	r1, r3
 800c948:	4391      	bics	r1, r2
 800c94a:	d005      	beq.n	800c958 <HAL_TIM_ConfigClockSource+0x174>
 800c94c:	2b0a      	cmp	r3, #10
 800c94e:	d003      	beq.n	800c958 <HAL_TIM_ConfigClockSource+0x174>
 800c950:	4964      	ldr	r1, [pc, #400]	; (800cae4 <HAL_TIM_ConfigClockSource+0x300>)
 800c952:	4858      	ldr	r0, [pc, #352]	; (800cab4 <HAL_TIM_ConfigClockSource+0x2d0>)
 800c954:	f7fb ffec 	bl	8008930 <assert_failed>
      assert_param(IS_TIM_CLOCKFILTER(sClockSourceConfig->ClockFilter));
 800c958:	68e3      	ldr	r3, [r4, #12]
 800c95a:	2b0f      	cmp	r3, #15
 800c95c:	d903      	bls.n	800c966 <HAL_TIM_ConfigClockSource+0x182>
 800c95e:	4962      	ldr	r1, [pc, #392]	; (800cae8 <HAL_TIM_ConfigClockSource+0x304>)
 800c960:	4854      	ldr	r0, [pc, #336]	; (800cab4 <HAL_TIM_ConfigClockSource+0x2d0>)
 800c962:	f7fb ffe5 	bl	8008930 <assert_failed>
      TIM_ETR_SetConfig(htim->Instance,
 800c966:	68e3      	ldr	r3, [r4, #12]
 800c968:	6862      	ldr	r2, [r4, #4]
 800c96a:	68a1      	ldr	r1, [r4, #8]
 800c96c:	6828      	ldr	r0, [r5, #0]
 800c96e:	f7ff ff2d 	bl	800c7cc <TIM_ETR_SetConfig>
      tmpsmcr |= (TIM_SLAVEMODE_EXTERNAL1 | TIM_CLOCKSOURCE_ETRMODE1);
 800c972:	2377      	movs	r3, #119	; 0x77
      tmpsmcr = htim->Instance->SMCR;
 800c974:	682a      	ldr	r2, [r5, #0]
 800c976:	6891      	ldr	r1, [r2, #8]
      htim->Instance->SMCR |= TIM_SMCR_ECE;
 800c978:	430b      	orrs	r3, r1
 800c97a:	6093      	str	r3, [r2, #8]
      break;
 800c97c:	e77d      	b.n	800c87a <HAL_TIM_ConfigClockSource+0x96>
      assert_param(IS_TIM_INSTANCE(htim->Instance));
 800c97e:	4a4f      	ldr	r2, [pc, #316]	; (800cabc <HAL_TIM_ConfigClockSource+0x2d8>)
 800c980:	4293      	cmp	r3, r2
 800c982:	d100      	bne.n	800c986 <HAL_TIM_ConfigClockSource+0x1a2>
 800c984:	e779      	b.n	800c87a <HAL_TIM_ConfigClockSource+0x96>
 800c986:	4a4e      	ldr	r2, [pc, #312]	; (800cac0 <HAL_TIM_ConfigClockSource+0x2dc>)
 800c988:	4293      	cmp	r3, r2
 800c98a:	d100      	bne.n	800c98e <HAL_TIM_ConfigClockSource+0x1aa>
 800c98c:	e775      	b.n	800c87a <HAL_TIM_ConfigClockSource+0x96>
 800c98e:	4a57      	ldr	r2, [pc, #348]	; (800caec <HAL_TIM_ConfigClockSource+0x308>)
 800c990:	4293      	cmp	r3, r2
 800c992:	d100      	bne.n	800c996 <HAL_TIM_ConfigClockSource+0x1b2>
 800c994:	e771      	b.n	800c87a <HAL_TIM_ConfigClockSource+0x96>
 800c996:	4a56      	ldr	r2, [pc, #344]	; (800caf0 <HAL_TIM_ConfigClockSource+0x30c>)
 800c998:	4293      	cmp	r3, r2
 800c99a:	d100      	bne.n	800c99e <HAL_TIM_ConfigClockSource+0x1ba>
 800c99c:	e76d      	b.n	800c87a <HAL_TIM_ConfigClockSource+0x96>
 800c99e:	4a55      	ldr	r2, [pc, #340]	; (800caf4 <HAL_TIM_ConfigClockSource+0x310>)
 800c9a0:	4293      	cmp	r3, r2
 800c9a2:	d100      	bne.n	800c9a6 <HAL_TIM_ConfigClockSource+0x1c2>
 800c9a4:	e769      	b.n	800c87a <HAL_TIM_ConfigClockSource+0x96>
 800c9a6:	4a47      	ldr	r2, [pc, #284]	; (800cac4 <HAL_TIM_ConfigClockSource+0x2e0>)
 800c9a8:	4293      	cmp	r3, r2
 800c9aa:	d100      	bne.n	800c9ae <HAL_TIM_ConfigClockSource+0x1ca>
 800c9ac:	e765      	b.n	800c87a <HAL_TIM_ConfigClockSource+0x96>
 800c9ae:	4a52      	ldr	r2, [pc, #328]	; (800caf8 <HAL_TIM_ConfigClockSource+0x314>)
 800c9b0:	4293      	cmp	r3, r2
 800c9b2:	d100      	bne.n	800c9b6 <HAL_TIM_ConfigClockSource+0x1d2>
 800c9b4:	e761      	b.n	800c87a <HAL_TIM_ConfigClockSource+0x96>
 800c9b6:	4a51      	ldr	r2, [pc, #324]	; (800cafc <HAL_TIM_ConfigClockSource+0x318>)
 800c9b8:	4293      	cmp	r3, r2
 800c9ba:	d100      	bne.n	800c9be <HAL_TIM_ConfigClockSource+0x1da>
 800c9bc:	e75d      	b.n	800c87a <HAL_TIM_ConfigClockSource+0x96>
 800c9be:	4950      	ldr	r1, [pc, #320]	; (800cb00 <HAL_TIM_ConfigClockSource+0x31c>)
 800c9c0:	483c      	ldr	r0, [pc, #240]	; (800cab4 <HAL_TIM_ConfigClockSource+0x2d0>)
 800c9c2:	f7fb ffb5 	bl	8008930 <assert_failed>
 800c9c6:	e758      	b.n	800c87a <HAL_TIM_ConfigClockSource+0x96>
      assert_param(IS_TIM_CLOCKSOURCE_ETRMODE2_INSTANCE(htim->Instance));
 800c9c8:	4a3c      	ldr	r2, [pc, #240]	; (800cabc <HAL_TIM_ConfigClockSource+0x2d8>)
 800c9ca:	4293      	cmp	r3, r2
 800c9cc:	d006      	beq.n	800c9dc <HAL_TIM_ConfigClockSource+0x1f8>
 800c9ce:	4a3c      	ldr	r2, [pc, #240]	; (800cac0 <HAL_TIM_ConfigClockSource+0x2dc>)
 800c9d0:	4293      	cmp	r3, r2
 800c9d2:	d003      	beq.n	800c9dc <HAL_TIM_ConfigClockSource+0x1f8>
 800c9d4:	494b      	ldr	r1, [pc, #300]	; (800cb04 <HAL_TIM_ConfigClockSource+0x320>)
 800c9d6:	4837      	ldr	r0, [pc, #220]	; (800cab4 <HAL_TIM_ConfigClockSource+0x2d0>)
 800c9d8:	f7fb ffaa 	bl	8008930 <assert_failed>
      assert_param(IS_TIM_CLOCKPRESCALER(sClockSourceConfig->ClockPrescaler));
 800c9dc:	4b3f      	ldr	r3, [pc, #252]	; (800cadc <HAL_TIM_ConfigClockSource+0x2f8>)
 800c9de:	68a2      	ldr	r2, [r4, #8]
 800c9e0:	421a      	tst	r2, r3
 800c9e2:	d003      	beq.n	800c9ec <HAL_TIM_ConfigClockSource+0x208>
 800c9e4:	4948      	ldr	r1, [pc, #288]	; (800cb08 <HAL_TIM_ConfigClockSource+0x324>)
 800c9e6:	4833      	ldr	r0, [pc, #204]	; (800cab4 <HAL_TIM_ConfigClockSource+0x2d0>)
 800c9e8:	f7fb ffa2 	bl	8008930 <assert_failed>
      assert_param(IS_TIM_CLOCKPOLARITY(sClockSourceConfig->ClockPolarity));
 800c9ec:	2280      	movs	r2, #128	; 0x80
 800c9ee:	6863      	ldr	r3, [r4, #4]
 800c9f0:	0212      	lsls	r2, r2, #8
 800c9f2:	4293      	cmp	r3, r2
 800c9f4:	d009      	beq.n	800ca0a <HAL_TIM_ConfigClockSource+0x226>
 800c9f6:	2202      	movs	r2, #2
 800c9f8:	0019      	movs	r1, r3
 800c9fa:	4391      	bics	r1, r2
 800c9fc:	d005      	beq.n	800ca0a <HAL_TIM_ConfigClockSource+0x226>
 800c9fe:	2b0a      	cmp	r3, #10
 800ca00:	d003      	beq.n	800ca0a <HAL_TIM_ConfigClockSource+0x226>
 800ca02:	4942      	ldr	r1, [pc, #264]	; (800cb0c <HAL_TIM_ConfigClockSource+0x328>)
 800ca04:	482b      	ldr	r0, [pc, #172]	; (800cab4 <HAL_TIM_ConfigClockSource+0x2d0>)
 800ca06:	f7fb ff93 	bl	8008930 <assert_failed>
      assert_param(IS_TIM_CLOCKFILTER(sClockSourceConfig->ClockFilter));
 800ca0a:	68e3      	ldr	r3, [r4, #12]
 800ca0c:	2b0f      	cmp	r3, #15
 800ca0e:	d903      	bls.n	800ca18 <HAL_TIM_ConfigClockSource+0x234>
 800ca10:	493f      	ldr	r1, [pc, #252]	; (800cb10 <HAL_TIM_ConfigClockSource+0x32c>)
 800ca12:	4828      	ldr	r0, [pc, #160]	; (800cab4 <HAL_TIM_ConfigClockSource+0x2d0>)
 800ca14:	f7fb ff8c 	bl	8008930 <assert_failed>
      TIM_ETR_SetConfig(htim->Instance,
 800ca18:	68e3      	ldr	r3, [r4, #12]
 800ca1a:	6862      	ldr	r2, [r4, #4]
 800ca1c:	68a1      	ldr	r1, [r4, #8]
 800ca1e:	6828      	ldr	r0, [r5, #0]
 800ca20:	f7ff fed4 	bl	800c7cc <TIM_ETR_SetConfig>
      htim->Instance->SMCR |= TIM_SMCR_ECE;
 800ca24:	2380      	movs	r3, #128	; 0x80
 800ca26:	682a      	ldr	r2, [r5, #0]
 800ca28:	01db      	lsls	r3, r3, #7
 800ca2a:	6891      	ldr	r1, [r2, #8]
 800ca2c:	e7a4      	b.n	800c978 <HAL_TIM_ConfigClockSource+0x194>
      assert_param(IS_TIM_CLOCKSOURCE_TIX_INSTANCE(htim->Instance));
 800ca2e:	4a23      	ldr	r2, [pc, #140]	; (800cabc <HAL_TIM_ConfigClockSource+0x2d8>)
 800ca30:	4293      	cmp	r3, r2
 800ca32:	d009      	beq.n	800ca48 <HAL_TIM_ConfigClockSource+0x264>
 800ca34:	4a22      	ldr	r2, [pc, #136]	; (800cac0 <HAL_TIM_ConfigClockSource+0x2dc>)
 800ca36:	4293      	cmp	r3, r2
 800ca38:	d006      	beq.n	800ca48 <HAL_TIM_ConfigClockSource+0x264>
 800ca3a:	4a22      	ldr	r2, [pc, #136]	; (800cac4 <HAL_TIM_ConfigClockSource+0x2e0>)
 800ca3c:	4293      	cmp	r3, r2
 800ca3e:	d003      	beq.n	800ca48 <HAL_TIM_ConfigClockSource+0x264>
 800ca40:	4934      	ldr	r1, [pc, #208]	; (800cb14 <HAL_TIM_ConfigClockSource+0x330>)
 800ca42:	481c      	ldr	r0, [pc, #112]	; (800cab4 <HAL_TIM_ConfigClockSource+0x2d0>)
 800ca44:	f7fb ff74 	bl	8008930 <assert_failed>
      assert_param(IS_TIM_CLOCKPOLARITY(sClockSourceConfig->ClockPolarity));
 800ca48:	2280      	movs	r2, #128	; 0x80
 800ca4a:	6863      	ldr	r3, [r4, #4]
 800ca4c:	0212      	lsls	r2, r2, #8
 800ca4e:	4293      	cmp	r3, r2
 800ca50:	d009      	beq.n	800ca66 <HAL_TIM_ConfigClockSource+0x282>
 800ca52:	2202      	movs	r2, #2
 800ca54:	0019      	movs	r1, r3
 800ca56:	4391      	bics	r1, r2
 800ca58:	d005      	beq.n	800ca66 <HAL_TIM_ConfigClockSource+0x282>
 800ca5a:	2b0a      	cmp	r3, #10
 800ca5c:	d003      	beq.n	800ca66 <HAL_TIM_ConfigClockSource+0x282>
 800ca5e:	492e      	ldr	r1, [pc, #184]	; (800cb18 <HAL_TIM_ConfigClockSource+0x334>)
 800ca60:	4814      	ldr	r0, [pc, #80]	; (800cab4 <HAL_TIM_ConfigClockSource+0x2d0>)
 800ca62:	f7fb ff65 	bl	8008930 <assert_failed>
      assert_param(IS_TIM_CLOCKFILTER(sClockSourceConfig->ClockFilter));
 800ca66:	68e3      	ldr	r3, [r4, #12]
 800ca68:	2b0f      	cmp	r3, #15
 800ca6a:	d903      	bls.n	800ca74 <HAL_TIM_ConfigClockSource+0x290>
 800ca6c:	492b      	ldr	r1, [pc, #172]	; (800cb1c <HAL_TIM_ConfigClockSource+0x338>)
 800ca6e:	4811      	ldr	r0, [pc, #68]	; (800cab4 <HAL_TIM_ConfigClockSource+0x2d0>)
 800ca70:	f7fb ff5e 	bl	8008930 <assert_failed>
      TIM_TI2_ConfigInputStage(htim->Instance,
 800ca74:	6862      	ldr	r2, [r4, #4]
 800ca76:	68e1      	ldr	r1, [r4, #12]
  TIMx->CCER &= ~TIM_CCER_CC2E;
 800ca78:	2410      	movs	r4, #16
      TIM_TI2_ConfigInputStage(htim->Instance,
 800ca7a:	682b      	ldr	r3, [r5, #0]
  tmpccmr1 &= ~TIM_CCMR1_IC2F;
 800ca7c:	4d28      	ldr	r5, [pc, #160]	; (800cb20 <HAL_TIM_ConfigClockSource+0x33c>)
  TIMx->CCER &= ~TIM_CCER_CC2E;
 800ca7e:	6a18      	ldr	r0, [r3, #32]
  tmpccmr1 |= (TIM_ICFilter << 12U);
 800ca80:	0309      	lsls	r1, r1, #12
  TIMx->CCER &= ~TIM_CCER_CC2E;
 800ca82:	43a0      	bics	r0, r4
 800ca84:	6218      	str	r0, [r3, #32]
  tmpccmr1 = TIMx->CCMR1;
 800ca86:	699c      	ldr	r4, [r3, #24]
  tmpccer = TIMx->CCER;
 800ca88:	6a18      	ldr	r0, [r3, #32]
  tmpccmr1 &= ~TIM_CCMR1_IC2F;
 800ca8a:	402c      	ands	r4, r5
  tmpccmr1 |= (TIM_ICFilter << 12U);
 800ca8c:	4321      	orrs	r1, r4
  tmpccer &= ~(TIM_CCER_CC2P | TIM_CCER_CC2NP);
 800ca8e:	24a0      	movs	r4, #160	; 0xa0
  TIMx->CCMR1 = tmpccmr1 ;
 800ca90:	6199      	str	r1, [r3, #24]
  tmpsmcr &= ~TIM_SMCR_TS;
 800ca92:	2170      	movs	r1, #112	; 0x70
  tmpccer &= ~(TIM_CCER_CC2P | TIM_CCER_CC2NP);
 800ca94:	43a0      	bics	r0, r4
  tmpccer |= (TIM_ICPolarity << 4U);
 800ca96:	0112      	lsls	r2, r2, #4
 800ca98:	4302      	orrs	r2, r0
  TIMx->CCER = tmpccer;
 800ca9a:	621a      	str	r2, [r3, #32]
  tmpsmcr = TIMx->SMCR;
 800ca9c:	689a      	ldr	r2, [r3, #8]
  tmpsmcr &= ~TIM_SMCR_TS;
 800ca9e:	438a      	bics	r2, r1
 800caa0:	0011      	movs	r1, r2
  tmpsmcr |= (InputTriggerSource | TIM_SLAVEMODE_EXTERNAL1);
 800caa2:	2267      	movs	r2, #103	; 0x67
 800caa4:	e72a      	b.n	800c8fc <HAL_TIM_ConfigClockSource+0x118>
 800caa6:	46c0      	nop			; (mov r8, r8)
 800caa8:	fffff000 	.word	0xfffff000
 800caac:	ffffefff 	.word	0xffffefff
 800cab0:	00001427 	.word	0x00001427
 800cab4:	08010940 	.word	0x08010940
 800cab8:	ffff0088 	.word	0xffff0088
 800cabc:	40012c00 	.word	0x40012c00
 800cac0:	40000400 	.word	0x40000400
 800cac4:	40014000 	.word	0x40014000
 800cac8:	00001499 	.word	0x00001499
 800cacc:	00001466 	.word	0x00001466
 800cad0:	00001469 	.word	0x00001469
 800cad4:	0000146a 	.word	0x0000146a
 800cad8:	0000143a 	.word	0x0000143a
 800cadc:	ffffcfff 	.word	0xffffcfff
 800cae0:	0000143d 	.word	0x0000143d
 800cae4:	0000143e 	.word	0x0000143e
 800cae8:	0000143f 	.word	0x0000143f
 800caec:	40001000 	.word	0x40001000
 800caf0:	40001400 	.word	0x40001400
 800caf4:	40002000 	.word	0x40002000
 800caf8:	40014400 	.word	0x40014400
 800cafc:	40014800 	.word	0x40014800
 800cb00:	00001433 	.word	0x00001433
 800cb04:	00001452 	.word	0x00001452
 800cb08:	00001455 	.word	0x00001455
 800cb0c:	00001456 	.word	0x00001456
 800cb10:	00001457 	.word	0x00001457
 800cb14:	00001476 	.word	0x00001476
 800cb18:	00001479 	.word	0x00001479
 800cb1c:	0000147a 	.word	0x0000147a
 800cb20:	ffff0fff 	.word	0xffff0fff
      assert_param(IS_TIM_CLOCKSOURCE_TIX_INSTANCE(htim->Instance));
 800cb24:	4a1d      	ldr	r2, [pc, #116]	; (800cb9c <HAL_TIM_ConfigClockSource+0x3b8>)
 800cb26:	4293      	cmp	r3, r2
 800cb28:	d009      	beq.n	800cb3e <HAL_TIM_ConfigClockSource+0x35a>
 800cb2a:	4a1d      	ldr	r2, [pc, #116]	; (800cba0 <HAL_TIM_ConfigClockSource+0x3bc>)
 800cb2c:	4293      	cmp	r3, r2
 800cb2e:	d006      	beq.n	800cb3e <HAL_TIM_ConfigClockSource+0x35a>
 800cb30:	4a1c      	ldr	r2, [pc, #112]	; (800cba4 <HAL_TIM_ConfigClockSource+0x3c0>)
 800cb32:	4293      	cmp	r3, r2
 800cb34:	d003      	beq.n	800cb3e <HAL_TIM_ConfigClockSource+0x35a>
 800cb36:	491c      	ldr	r1, [pc, #112]	; (800cba8 <HAL_TIM_ConfigClockSource+0x3c4>)
 800cb38:	481c      	ldr	r0, [pc, #112]	; (800cbac <HAL_TIM_ConfigClockSource+0x3c8>)
 800cb3a:	f7fb fef9 	bl	8008930 <assert_failed>
      assert_param(IS_TIM_CLOCKPOLARITY(sClockSourceConfig->ClockPolarity));
 800cb3e:	2280      	movs	r2, #128	; 0x80
 800cb40:	6863      	ldr	r3, [r4, #4]
 800cb42:	0212      	lsls	r2, r2, #8
 800cb44:	4293      	cmp	r3, r2
 800cb46:	d009      	beq.n	800cb5c <HAL_TIM_ConfigClockSource+0x378>
 800cb48:	2202      	movs	r2, #2
 800cb4a:	0019      	movs	r1, r3
 800cb4c:	4391      	bics	r1, r2
 800cb4e:	d005      	beq.n	800cb5c <HAL_TIM_ConfigClockSource+0x378>
 800cb50:	2b0a      	cmp	r3, #10
 800cb52:	d003      	beq.n	800cb5c <HAL_TIM_ConfigClockSource+0x378>
 800cb54:	4916      	ldr	r1, [pc, #88]	; (800cbb0 <HAL_TIM_ConfigClockSource+0x3cc>)
 800cb56:	4815      	ldr	r0, [pc, #84]	; (800cbac <HAL_TIM_ConfigClockSource+0x3c8>)
 800cb58:	f7fb feea 	bl	8008930 <assert_failed>
      assert_param(IS_TIM_CLOCKFILTER(sClockSourceConfig->ClockFilter));
 800cb5c:	68e3      	ldr	r3, [r4, #12]
 800cb5e:	2b0f      	cmp	r3, #15
 800cb60:	d903      	bls.n	800cb6a <HAL_TIM_ConfigClockSource+0x386>
 800cb62:	4914      	ldr	r1, [pc, #80]	; (800cbb4 <HAL_TIM_ConfigClockSource+0x3d0>)
 800cb64:	4811      	ldr	r0, [pc, #68]	; (800cbac <HAL_TIM_ConfigClockSource+0x3c8>)
 800cb66:	f7fb fee3 	bl	8008930 <assert_failed>
      TIM_TI1_ConfigInputStage(htim->Instance,
 800cb6a:	682b      	ldr	r3, [r5, #0]
  TIMx->CCER &= ~TIM_CCER_CC1E;
 800cb6c:	2501      	movs	r5, #1
  tmpccer = TIMx->CCER;
 800cb6e:	6a18      	ldr	r0, [r3, #32]
      TIM_TI1_ConfigInputStage(htim->Instance,
 800cb70:	6861      	ldr	r1, [r4, #4]
 800cb72:	68e2      	ldr	r2, [r4, #12]
  TIMx->CCER &= ~TIM_CCER_CC1E;
 800cb74:	6a1c      	ldr	r4, [r3, #32]
  tmpccmr1 |= (TIM_ICFilter << 4U);
 800cb76:	0112      	lsls	r2, r2, #4
  TIMx->CCER &= ~TIM_CCER_CC1E;
 800cb78:	43ac      	bics	r4, r5
 800cb7a:	621c      	str	r4, [r3, #32]
  tmpccmr1 = TIMx->CCMR1;
 800cb7c:	699c      	ldr	r4, [r3, #24]
  tmpccmr1 &= ~TIM_CCMR1_IC1F;
 800cb7e:	35ef      	adds	r5, #239	; 0xef
 800cb80:	43ac      	bics	r4, r5
  tmpccmr1 |= (TIM_ICFilter << 4U);
 800cb82:	4322      	orrs	r2, r4
  tmpccer &= ~(TIM_CCER_CC1P | TIM_CCER_CC1NP);
 800cb84:	240a      	movs	r4, #10
 800cb86:	43a0      	bics	r0, r4
  tmpccer |= TIM_ICPolarity;
 800cb88:	4301      	orrs	r1, r0
  TIMx->CCMR1 = tmpccmr1;
 800cb8a:	619a      	str	r2, [r3, #24]
  TIMx->CCER = tmpccer;
 800cb8c:	6219      	str	r1, [r3, #32]
  tmpsmcr &= ~TIM_SMCR_TS;
 800cb8e:	2170      	movs	r1, #112	; 0x70
  tmpsmcr = TIMx->SMCR;
 800cb90:	689a      	ldr	r2, [r3, #8]
  tmpsmcr &= ~TIM_SMCR_TS;
 800cb92:	438a      	bics	r2, r1
 800cb94:	0011      	movs	r1, r2
  tmpsmcr |= (InputTriggerSource | TIM_SLAVEMODE_EXTERNAL1);
 800cb96:	2247      	movs	r2, #71	; 0x47
 800cb98:	e6b0      	b.n	800c8fc <HAL_TIM_ConfigClockSource+0x118>
 800cb9a:	46c0      	nop			; (mov r8, r8)
 800cb9c:	40012c00 	.word	0x40012c00
 800cba0:	40000400 	.word	0x40000400
 800cba4:	40014000 	.word	0x40014000
 800cba8:	00001486 	.word	0x00001486
 800cbac:	08010940 	.word	0x08010940
 800cbb0:	00001489 	.word	0x00001489
 800cbb4:	0000148a 	.word	0x0000148a

0800cbb8 <HAL_TIMEx_MasterConfigSynchronization>:
  *         mode.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_TIMEx_MasterConfigSynchronization(TIM_HandleTypeDef *htim,
                                                        TIM_MasterConfigTypeDef *sMasterConfig)
{
 800cbb8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  uint32_t tmpcr2;
  uint32_t tmpsmcr;

  /* Check the parameters */
  assert_param(IS_TIM_MASTER_INSTANCE(htim->Instance));
 800cbba:	6803      	ldr	r3, [r0, #0]
 800cbbc:	4e25      	ldr	r6, [pc, #148]	; (800cc54 <HAL_TIMEx_MasterConfigSynchronization+0x9c>)
{
 800cbbe:	0005      	movs	r5, r0
 800cbc0:	000c      	movs	r4, r1
  assert_param(IS_TIM_MASTER_INSTANCE(htim->Instance));
 800cbc2:	42b3      	cmp	r3, r6
 800cbc4:	d010      	beq.n	800cbe8 <HAL_TIMEx_MasterConfigSynchronization+0x30>
 800cbc6:	4a24      	ldr	r2, [pc, #144]	; (800cc58 <HAL_TIMEx_MasterConfigSynchronization+0xa0>)
 800cbc8:	4293      	cmp	r3, r2
 800cbca:	d00d      	beq.n	800cbe8 <HAL_TIMEx_MasterConfigSynchronization+0x30>
 800cbcc:	4a23      	ldr	r2, [pc, #140]	; (800cc5c <HAL_TIMEx_MasterConfigSynchronization+0xa4>)
 800cbce:	4293      	cmp	r3, r2
 800cbd0:	d00a      	beq.n	800cbe8 <HAL_TIMEx_MasterConfigSynchronization+0x30>
 800cbd2:	4a23      	ldr	r2, [pc, #140]	; (800cc60 <HAL_TIMEx_MasterConfigSynchronization+0xa8>)
 800cbd4:	4293      	cmp	r3, r2
 800cbd6:	d007      	beq.n	800cbe8 <HAL_TIMEx_MasterConfigSynchronization+0x30>
 800cbd8:	4a22      	ldr	r2, [pc, #136]	; (800cc64 <HAL_TIMEx_MasterConfigSynchronization+0xac>)
 800cbda:	4293      	cmp	r3, r2
 800cbdc:	d004      	beq.n	800cbe8 <HAL_TIMEx_MasterConfigSynchronization+0x30>
 800cbde:	21ec      	movs	r1, #236	; 0xec
 800cbe0:	4821      	ldr	r0, [pc, #132]	; (800cc68 <HAL_TIMEx_MasterConfigSynchronization+0xb0>)
 800cbe2:	00c9      	lsls	r1, r1, #3
 800cbe4:	f7fb fea4 	bl	8008930 <assert_failed>
  assert_param(IS_TIM_TRGO_SOURCE(sMasterConfig->MasterOutputTrigger));
 800cbe8:	2330      	movs	r3, #48	; 0x30
 800cbea:	6822      	ldr	r2, [r4, #0]
 800cbec:	439a      	bics	r2, r3
 800cbee:	d005      	beq.n	800cbfc <HAL_TIMEx_MasterConfigSynchronization+0x44>
 800cbf0:	2a40      	cmp	r2, #64	; 0x40
 800cbf2:	d003      	beq.n	800cbfc <HAL_TIMEx_MasterConfigSynchronization+0x44>
 800cbf4:	491d      	ldr	r1, [pc, #116]	; (800cc6c <HAL_TIMEx_MasterConfigSynchronization+0xb4>)
 800cbf6:	481c      	ldr	r0, [pc, #112]	; (800cc68 <HAL_TIMEx_MasterConfigSynchronization+0xb0>)
 800cbf8:	f7fb fe9a 	bl	8008930 <assert_failed>
  assert_param(IS_TIM_MSM_STATE(sMasterConfig->MasterSlaveMode));
 800cbfc:	2380      	movs	r3, #128	; 0x80
 800cbfe:	6862      	ldr	r2, [r4, #4]
 800cc00:	439a      	bics	r2, r3
 800cc02:	d003      	beq.n	800cc0c <HAL_TIMEx_MasterConfigSynchronization+0x54>
 800cc04:	491a      	ldr	r1, [pc, #104]	; (800cc70 <HAL_TIMEx_MasterConfigSynchronization+0xb8>)
 800cc06:	4818      	ldr	r0, [pc, #96]	; (800cc68 <HAL_TIMEx_MasterConfigSynchronization+0xb0>)
 800cc08:	f7fb fe92 	bl	8008930 <assert_failed>

  /* Check input state */
  __HAL_LOCK(htim);
 800cc0c:	0029      	movs	r1, r5
 800cc0e:	2302      	movs	r3, #2
 800cc10:	313c      	adds	r1, #60	; 0x3c
 800cc12:	780a      	ldrb	r2, [r1, #0]
 800cc14:	0018      	movs	r0, r3
 800cc16:	2a01      	cmp	r2, #1
 800cc18:	d01b      	beq.n	800cc52 <HAL_TIMEx_MasterConfigSynchronization+0x9a>

  /* Change the handler state */
  htim->State = HAL_TIM_STATE_BUSY;
 800cc1a:	0028      	movs	r0, r5

  /* Get the TIMx SMCR register value */
  tmpsmcr = htim->Instance->SMCR;

  /* Reset the MMS Bits */
  tmpcr2 &= ~TIM_CR2_MMS;
 800cc1c:	2770      	movs	r7, #112	; 0x70
  htim->State = HAL_TIM_STATE_BUSY;
 800cc1e:	303d      	adds	r0, #61	; 0x3d
 800cc20:	7003      	strb	r3, [r0, #0]
  tmpcr2 = htim->Instance->CR2;
 800cc22:	682b      	ldr	r3, [r5, #0]
 800cc24:	685d      	ldr	r5, [r3, #4]
  tmpsmcr = htim->Instance->SMCR;
 800cc26:	689a      	ldr	r2, [r3, #8]
  tmpcr2 &= ~TIM_CR2_MMS;
 800cc28:	43bd      	bics	r5, r7
  /* Select the TRGO source */
  tmpcr2 |=  sMasterConfig->MasterOutputTrigger;
 800cc2a:	6827      	ldr	r7, [r4, #0]
 800cc2c:	433d      	orrs	r5, r7

  /* Update TIMx CR2 */
  htim->Instance->CR2 = tmpcr2;
 800cc2e:	605d      	str	r5, [r3, #4]

  if (IS_TIM_SLAVE_INSTANCE(htim->Instance))
 800cc30:	42b3      	cmp	r3, r6
 800cc32:	d005      	beq.n	800cc40 <HAL_TIMEx_MasterConfigSynchronization+0x88>
 800cc34:	4d08      	ldr	r5, [pc, #32]	; (800cc58 <HAL_TIMEx_MasterConfigSynchronization+0xa0>)
 800cc36:	42ab      	cmp	r3, r5
 800cc38:	d002      	beq.n	800cc40 <HAL_TIMEx_MasterConfigSynchronization+0x88>
 800cc3a:	4d0a      	ldr	r5, [pc, #40]	; (800cc64 <HAL_TIMEx_MasterConfigSynchronization+0xac>)
 800cc3c:	42ab      	cmp	r3, r5
 800cc3e:	d104      	bne.n	800cc4a <HAL_TIMEx_MasterConfigSynchronization+0x92>
  {
    /* Reset the MSM Bit */
    tmpsmcr &= ~TIM_SMCR_MSM;
 800cc40:	2580      	movs	r5, #128	; 0x80
    /* Set master mode */
    tmpsmcr |= sMasterConfig->MasterSlaveMode;
 800cc42:	6864      	ldr	r4, [r4, #4]
    tmpsmcr &= ~TIM_SMCR_MSM;
 800cc44:	43aa      	bics	r2, r5
    tmpsmcr |= sMasterConfig->MasterSlaveMode;
 800cc46:	4322      	orrs	r2, r4

    /* Update TIMx SMCR */
    htim->Instance->SMCR = tmpsmcr;
 800cc48:	609a      	str	r2, [r3, #8]
  }

  /* Change the htim state */
  htim->State = HAL_TIM_STATE_READY;
 800cc4a:	2301      	movs	r3, #1
 800cc4c:	7003      	strb	r3, [r0, #0]

  __HAL_UNLOCK(htim);
 800cc4e:	2000      	movs	r0, #0
 800cc50:	7008      	strb	r0, [r1, #0]

  return HAL_OK;
}
 800cc52:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 800cc54:	40012c00 	.word	0x40012c00
 800cc58:	40000400 	.word	0x40000400
 800cc5c:	40001000 	.word	0x40001000
 800cc60:	40001400 	.word	0x40001400
 800cc64:	40014000 	.word	0x40014000
 800cc68:	08010978 	.word	0x08010978
 800cc6c:	00000761 	.word	0x00000761
 800cc70:	00000762 	.word	0x00000762

0800cc74 <HAL_TIMEx_CommutCallback>:
 800cc74:	4770      	bx	lr

0800cc76 <HAL_TIMEx_BreakCallback>:
 800cc76:	4770      	bx	lr

0800cc78 <UART_TxISR_8BIT>:
  * @retval None
  */
static void UART_TxISR_8BIT(UART_HandleTypeDef *huart)
{
  /* Check that a Tx process is ongoing */
  if (huart->gState == HAL_UART_STATE_BUSY_TX)
 800cc78:	6f83      	ldr	r3, [r0, #120]	; 0x78
{
 800cc7a:	b510      	push	{r4, lr}
  if (huart->gState == HAL_UART_STATE_BUSY_TX)
 800cc7c:	2b21      	cmp	r3, #33	; 0x21
 800cc7e:	d10d      	bne.n	800cc9c <UART_TxISR_8BIT+0x24>
  {
    if (huart->TxXferCount == 0U)
 800cc80:	0001      	movs	r1, r0
 800cc82:	3152      	adds	r1, #82	; 0x52
 800cc84:	880a      	ldrh	r2, [r1, #0]
 800cc86:	6803      	ldr	r3, [r0, #0]
 800cc88:	2a00      	cmp	r2, #0
 800cc8a:	d108      	bne.n	800cc9e <UART_TxISR_8BIT+0x26>
    {
      /* Disable the UART Transmit Data Register Empty Interrupt */
      CLEAR_BIT(huart->Instance->CR1, USART_CR1_TXEIE);
 800cc8c:	2180      	movs	r1, #128	; 0x80
 800cc8e:	681a      	ldr	r2, [r3, #0]
 800cc90:	438a      	bics	r2, r1
 800cc92:	601a      	str	r2, [r3, #0]

      /* Enable the UART Transmit Complete Interrupt */
      SET_BIT(huart->Instance->CR1, USART_CR1_TCIE);
 800cc94:	2240      	movs	r2, #64	; 0x40
 800cc96:	6819      	ldr	r1, [r3, #0]
 800cc98:	430a      	orrs	r2, r1
 800cc9a:	601a      	str	r2, [r3, #0]
      huart->Instance->TDR = (uint8_t)(*huart->pTxBuffPtr & (uint8_t)0xFF);
      huart->pTxBuffPtr++;
      huart->TxXferCount--;
    }
  }
}
 800cc9c:	bd10      	pop	{r4, pc}
      huart->Instance->TDR = (uint8_t)(*huart->pTxBuffPtr & (uint8_t)0xFF);
 800cc9e:	6cc2      	ldr	r2, [r0, #76]	; 0x4c
 800cca0:	7814      	ldrb	r4, [r2, #0]
      huart->pTxBuffPtr++;
 800cca2:	3201      	adds	r2, #1
      huart->Instance->TDR = (uint8_t)(*huart->pTxBuffPtr & (uint8_t)0xFF);
 800cca4:	851c      	strh	r4, [r3, #40]	; 0x28
      huart->pTxBuffPtr++;
 800cca6:	64c2      	str	r2, [r0, #76]	; 0x4c
      huart->TxXferCount--;
 800cca8:	880b      	ldrh	r3, [r1, #0]
 800ccaa:	3b01      	subs	r3, #1
 800ccac:	b29b      	uxth	r3, r3
 800ccae:	800b      	strh	r3, [r1, #0]
}
 800ccb0:	e7f4      	b.n	800cc9c <UART_TxISR_8BIT+0x24>

0800ccb2 <UART_TxISR_16BIT>:
static void UART_TxISR_16BIT(UART_HandleTypeDef *huart)
{
  uint16_t *tmp;

  /* Check that a Tx process is ongoing */
  if (huart->gState == HAL_UART_STATE_BUSY_TX)
 800ccb2:	6f83      	ldr	r3, [r0, #120]	; 0x78
{
 800ccb4:	b510      	push	{r4, lr}
  if (huart->gState == HAL_UART_STATE_BUSY_TX)
 800ccb6:	2b21      	cmp	r3, #33	; 0x21
 800ccb8:	d10d      	bne.n	800ccd6 <UART_TxISR_16BIT+0x24>
  {
    if (huart->TxXferCount == 0U)
 800ccba:	0001      	movs	r1, r0
 800ccbc:	3152      	adds	r1, #82	; 0x52
 800ccbe:	880a      	ldrh	r2, [r1, #0]
 800ccc0:	6803      	ldr	r3, [r0, #0]
 800ccc2:	2a00      	cmp	r2, #0
 800ccc4:	d108      	bne.n	800ccd8 <UART_TxISR_16BIT+0x26>
    {
      /* Disable the UART Transmit Data Register Empty Interrupt */
      CLEAR_BIT(huart->Instance->CR1, USART_CR1_TXEIE);
 800ccc6:	2180      	movs	r1, #128	; 0x80
 800ccc8:	681a      	ldr	r2, [r3, #0]
 800ccca:	438a      	bics	r2, r1
 800cccc:	601a      	str	r2, [r3, #0]

      /* Enable the UART Transmit Complete Interrupt */
      SET_BIT(huart->Instance->CR1, USART_CR1_TCIE);
 800ccce:	2240      	movs	r2, #64	; 0x40
 800ccd0:	6819      	ldr	r1, [r3, #0]
 800ccd2:	430a      	orrs	r2, r1
 800ccd4:	601a      	str	r2, [r3, #0]
      huart->Instance->TDR = (((uint32_t)(*tmp)) & 0x01FFUL);
      huart->pTxBuffPtr += 2U;
      huart->TxXferCount--;
    }
  }
}
 800ccd6:	bd10      	pop	{r4, pc}
      tmp = (uint16_t *) huart->pTxBuffPtr;
 800ccd8:	6cc4      	ldr	r4, [r0, #76]	; 0x4c
      huart->Instance->TDR = (((uint32_t)(*tmp)) & 0x01FFUL);
 800ccda:	8822      	ldrh	r2, [r4, #0]
      huart->pTxBuffPtr += 2U;
 800ccdc:	3402      	adds	r4, #2
      huart->Instance->TDR = (((uint32_t)(*tmp)) & 0x01FFUL);
 800ccde:	05d2      	lsls	r2, r2, #23
 800cce0:	0dd2      	lsrs	r2, r2, #23
 800cce2:	851a      	strh	r2, [r3, #40]	; 0x28
      huart->pTxBuffPtr += 2U;
 800cce4:	64c4      	str	r4, [r0, #76]	; 0x4c
      huart->TxXferCount--;
 800cce6:	880b      	ldrh	r3, [r1, #0]
 800cce8:	3b01      	subs	r3, #1
 800ccea:	b29b      	uxth	r3, r3
 800ccec:	800b      	strh	r3, [r1, #0]
}
 800ccee:	e7f2      	b.n	800ccd6 <UART_TxISR_16BIT+0x24>

0800ccf0 <HAL_UART_Transmit_IT>:
{
 800ccf0:	b570      	push	{r4, r5, r6, lr}
  if (huart->gState == HAL_UART_STATE_READY)
 800ccf2:	6f84      	ldr	r4, [r0, #120]	; 0x78
{
 800ccf4:	0003      	movs	r3, r0
    return HAL_BUSY;
 800ccf6:	2002      	movs	r0, #2
  if (huart->gState == HAL_UART_STATE_READY)
 800ccf8:	2c20      	cmp	r4, #32
 800ccfa:	d131      	bne.n	800cd60 <HAL_UART_Transmit_IT+0x70>
      return HAL_ERROR;
 800ccfc:	3801      	subs	r0, #1
    if ((pData == NULL) || (Size == 0U))
 800ccfe:	2900      	cmp	r1, #0
 800cd00:	d02e      	beq.n	800cd60 <HAL_UART_Transmit_IT+0x70>
 800cd02:	2a00      	cmp	r2, #0
 800cd04:	d02c      	beq.n	800cd60 <HAL_UART_Transmit_IT+0x70>
    if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
 800cd06:	2080      	movs	r0, #128	; 0x80
 800cd08:	689d      	ldr	r5, [r3, #8]
 800cd0a:	0140      	lsls	r0, r0, #5
 800cd0c:	4285      	cmp	r5, r0
 800cd0e:	d106      	bne.n	800cd1e <HAL_UART_Transmit_IT+0x2e>
 800cd10:	6918      	ldr	r0, [r3, #16]
 800cd12:	2800      	cmp	r0, #0
 800cd14:	d103      	bne.n	800cd1e <HAL_UART_Transmit_IT+0x2e>
      if ((((uint32_t)pData) & 1U) != 0U)
 800cd16:	3c1f      	subs	r4, #31
      return HAL_ERROR;
 800cd18:	0020      	movs	r0, r4
      if ((((uint32_t)pData) & 1U) != 0U)
 800cd1a:	4221      	tst	r1, r4
 800cd1c:	d120      	bne.n	800cd60 <HAL_UART_Transmit_IT+0x70>
    __HAL_LOCK(huart);
 800cd1e:	001c      	movs	r4, r3
 800cd20:	3474      	adds	r4, #116	; 0x74
 800cd22:	7826      	ldrb	r6, [r4, #0]
    return HAL_BUSY;
 800cd24:	2002      	movs	r0, #2
    __HAL_LOCK(huart);
 800cd26:	2e01      	cmp	r6, #1
 800cd28:	d01a      	beq.n	800cd60 <HAL_UART_Transmit_IT+0x70>
    huart->pTxBuffPtr  = pData;
 800cd2a:	64d9      	str	r1, [r3, #76]	; 0x4c
    huart->TxXferSize  = Size;
 800cd2c:	0019      	movs	r1, r3
 800cd2e:	3150      	adds	r1, #80	; 0x50
 800cd30:	800a      	strh	r2, [r1, #0]
    huart->TxXferCount = Size;
 800cd32:	804a      	strh	r2, [r1, #2]
    huart->ErrorCode = HAL_UART_ERROR_NONE;
 800cd34:	2100      	movs	r1, #0
 800cd36:	1d1a      	adds	r2, r3, #4
 800cd38:	67d1      	str	r1, [r2, #124]	; 0x7c
    huart->gState = HAL_UART_STATE_BUSY_TX;
 800cd3a:	2221      	movs	r2, #33	; 0x21
    if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
 800cd3c:	2180      	movs	r1, #128	; 0x80
    huart->gState = HAL_UART_STATE_BUSY_TX;
 800cd3e:	679a      	str	r2, [r3, #120]	; 0x78
    if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
 800cd40:	0149      	lsls	r1, r1, #5
      huart->TxISR = UART_TxISR_8BIT;
 800cd42:	4a08      	ldr	r2, [pc, #32]	; (800cd64 <HAL_UART_Transmit_IT+0x74>)
    if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
 800cd44:	428d      	cmp	r5, r1
 800cd46:	d103      	bne.n	800cd50 <HAL_UART_Transmit_IT+0x60>
 800cd48:	6919      	ldr	r1, [r3, #16]
 800cd4a:	2900      	cmp	r1, #0
 800cd4c:	d100      	bne.n	800cd50 <HAL_UART_Transmit_IT+0x60>
      huart->TxISR = UART_TxISR_16BIT;
 800cd4e:	4a06      	ldr	r2, [pc, #24]	; (800cd68 <HAL_UART_Transmit_IT+0x78>)
    __HAL_UNLOCK(huart);
 800cd50:	2000      	movs	r0, #0
 800cd52:	669a      	str	r2, [r3, #104]	; 0x68
 800cd54:	7020      	strb	r0, [r4, #0]
    SET_BIT(huart->Instance->CR1, USART_CR1_TXEIE);
 800cd56:	681a      	ldr	r2, [r3, #0]
 800cd58:	2380      	movs	r3, #128	; 0x80
 800cd5a:	6811      	ldr	r1, [r2, #0]
 800cd5c:	430b      	orrs	r3, r1
 800cd5e:	6013      	str	r3, [r2, #0]
}
 800cd60:	bd70      	pop	{r4, r5, r6, pc}
 800cd62:	46c0      	nop			; (mov r8, r8)
 800cd64:	0800cc79 	.word	0x0800cc79
 800cd68:	0800ccb3 	.word	0x0800ccb3

0800cd6c <HAL_UART_RxCpltCallback>:
 800cd6c:	4770      	bx	lr

0800cd6e <HAL_UART_AbortTransmitCpltCallback>:
 800cd6e:	4770      	bx	lr

0800cd70 <HAL_UART_AbortTransmit_IT>:
  CLEAR_BIT(huart->Instance->CR1, (USART_CR1_TXEIE | USART_CR1_TCIE));
 800cd70:	21c0      	movs	r1, #192	; 0xc0
 800cd72:	6803      	ldr	r3, [r0, #0]
{
 800cd74:	b510      	push	{r4, lr}
  CLEAR_BIT(huart->Instance->CR1, (USART_CR1_TXEIE | USART_CR1_TCIE));
 800cd76:	681a      	ldr	r2, [r3, #0]
{
 800cd78:	0004      	movs	r4, r0
  CLEAR_BIT(huart->Instance->CR1, (USART_CR1_TXEIE | USART_CR1_TCIE));
 800cd7a:	438a      	bics	r2, r1
 800cd7c:	601a      	str	r2, [r3, #0]
  if (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAT))
 800cd7e:	6898      	ldr	r0, [r3, #8]
 800cd80:	3940      	subs	r1, #64	; 0x40
 800cd82:	0002      	movs	r2, r0
 800cd84:	400a      	ands	r2, r1
 800cd86:	4208      	tst	r0, r1
 800cd88:	d01a      	beq.n	800cdc0 <HAL_UART_AbortTransmit_IT+0x50>
    CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAT);
 800cd8a:	689a      	ldr	r2, [r3, #8]
    if (huart->hdmatx != NULL)
 800cd8c:	6ee0      	ldr	r0, [r4, #108]	; 0x6c
    CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAT);
 800cd8e:	438a      	bics	r2, r1
 800cd90:	609a      	str	r2, [r3, #8]
    if (huart->hdmatx != NULL)
 800cd92:	2800      	cmp	r0, #0
 800cd94:	d00a      	beq.n	800cdac <HAL_UART_AbortTransmit_IT+0x3c>
      huart->hdmatx->XferAbortCallback = UART_DMATxOnlyAbortCallback;
 800cd96:	4b0d      	ldr	r3, [pc, #52]	; (800cdcc <HAL_UART_AbortTransmit_IT+0x5c>)
 800cd98:	6343      	str	r3, [r0, #52]	; 0x34
      if (HAL_DMA_Abort_IT(huart->hdmatx) != HAL_OK)
 800cd9a:	f7fd f973 	bl	800a084 <HAL_DMA_Abort_IT>
 800cd9e:	2800      	cmp	r0, #0
 800cda0:	d002      	beq.n	800cda8 <HAL_UART_AbortTransmit_IT+0x38>
        huart->hdmatx->XferAbortCallback(huart->hdmatx);
 800cda2:	6ee0      	ldr	r0, [r4, #108]	; 0x6c
 800cda4:	6b43      	ldr	r3, [r0, #52]	; 0x34
 800cda6:	4798      	blx	r3
}
 800cda8:	2000      	movs	r0, #0
 800cdaa:	bd10      	pop	{r4, pc}
      huart->TxXferCount = 0U;
 800cdac:	0023      	movs	r3, r4
 800cdae:	3352      	adds	r3, #82	; 0x52
 800cdb0:	8018      	strh	r0, [r3, #0]
      huart->TxISR = NULL;
 800cdb2:	66a0      	str	r0, [r4, #104]	; 0x68
    huart->gState = HAL_UART_STATE_READY;
 800cdb4:	2320      	movs	r3, #32
    HAL_UART_AbortTransmitCpltCallback(huart);
 800cdb6:	0020      	movs	r0, r4
    huart->gState = HAL_UART_STATE_READY;
 800cdb8:	67a3      	str	r3, [r4, #120]	; 0x78
    HAL_UART_AbortTransmitCpltCallback(huart);
 800cdba:	f7ff ffd8 	bl	800cd6e <HAL_UART_AbortTransmitCpltCallback>
 800cdbe:	e7f3      	b.n	800cda8 <HAL_UART_AbortTransmit_IT+0x38>
    huart->TxXferCount = 0U;
 800cdc0:	0023      	movs	r3, r4
 800cdc2:	3352      	adds	r3, #82	; 0x52
 800cdc4:	801a      	strh	r2, [r3, #0]
    huart->TxISR = NULL;
 800cdc6:	66a2      	str	r2, [r4, #104]	; 0x68
 800cdc8:	e7f4      	b.n	800cdb4 <HAL_UART_AbortTransmit_IT+0x44>
 800cdca:	46c0      	nop			; (mov r8, r8)
 800cdcc:	0800cdd1 	.word	0x0800cdd1

0800cdd0 <UART_DMATxOnlyAbortCallback>:
  UART_HandleTypeDef *huart = (UART_HandleTypeDef *)(hdma->Parent);
 800cdd0:	6a40      	ldr	r0, [r0, #36]	; 0x24
  huart->TxXferCount = 0U;
 800cdd2:	2200      	movs	r2, #0
 800cdd4:	0003      	movs	r3, r0
 800cdd6:	3352      	adds	r3, #82	; 0x52
{
 800cdd8:	b510      	push	{r4, lr}
  huart->TxXferCount = 0U;
 800cdda:	801a      	strh	r2, [r3, #0]
  huart->gState = HAL_UART_STATE_READY;
 800cddc:	2320      	movs	r3, #32
 800cdde:	6783      	str	r3, [r0, #120]	; 0x78
  HAL_UART_AbortTransmitCpltCallback(huart);
 800cde0:	f7ff ffc5 	bl	800cd6e <HAL_UART_AbortTransmitCpltCallback>
}
 800cde4:	bd10      	pop	{r4, pc}

0800cde6 <HAL_UARTEx_RxEventCallback>:
}
 800cde6:	4770      	bx	lr

0800cde8 <UART_RxISR_8BIT>:
{
  uint16_t uhMask = huart->Mask;
  uint16_t  uhdata;

  /* Check that a Rx process is ongoing */
  if (huart->RxState == HAL_UART_STATE_BUSY_RX)
 800cde8:	6fc2      	ldr	r2, [r0, #124]	; 0x7c
{
 800cdea:	b510      	push	{r4, lr}
 800cdec:	6803      	ldr	r3, [r0, #0]
 800cdee:	0004      	movs	r4, r0
  if (huart->RxState == HAL_UART_STATE_BUSY_RX)
 800cdf0:	2a22      	cmp	r2, #34	; 0x22
 800cdf2:	d134      	bne.n	800ce5e <UART_RxISR_8BIT+0x76>
  uint16_t uhMask = huart->Mask;
 800cdf4:	0002      	movs	r2, r0
 800cdf6:	325c      	adds	r2, #92	; 0x5c
  {
    uhdata = (uint16_t) READ_REG(huart->Instance->RDR);
 800cdf8:	8c9b      	ldrh	r3, [r3, #36]	; 0x24
    *huart->pRxBuffPtr = (uint8_t)(uhdata & (uint8_t)uhMask);
 800cdfa:	8812      	ldrh	r2, [r2, #0]
 800cdfc:	4013      	ands	r3, r2
 800cdfe:	6d42      	ldr	r2, [r0, #84]	; 0x54
 800ce00:	7013      	strb	r3, [r2, #0]
    huart->pRxBuffPtr++;
    huart->RxXferCount--;
 800ce02:	0002      	movs	r2, r0
    huart->pRxBuffPtr++;
 800ce04:	6d43      	ldr	r3, [r0, #84]	; 0x54
    huart->RxXferCount--;
 800ce06:	325a      	adds	r2, #90	; 0x5a
    huart->pRxBuffPtr++;
 800ce08:	3301      	adds	r3, #1
 800ce0a:	6543      	str	r3, [r0, #84]	; 0x54
    huart->RxXferCount--;
 800ce0c:	8813      	ldrh	r3, [r2, #0]
 800ce0e:	3b01      	subs	r3, #1
 800ce10:	b29b      	uxth	r3, r3
 800ce12:	8013      	strh	r3, [r2, #0]

    if (huart->RxXferCount == 0U)
 800ce14:	8813      	ldrh	r3, [r2, #0]
 800ce16:	b299      	uxth	r1, r3
 800ce18:	2b00      	cmp	r3, #0
 800ce1a:	d11b      	bne.n	800ce54 <UART_RxISR_8BIT+0x6c>
    {
      /* Disable the UART Parity Error Interrupt and RXNE interrupts */
      CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE));
 800ce1c:	6803      	ldr	r3, [r0, #0]
 800ce1e:	4812      	ldr	r0, [pc, #72]	; (800ce68 <UART_RxISR_8BIT+0x80>)
 800ce20:	681a      	ldr	r2, [r3, #0]
 800ce22:	4002      	ands	r2, r0
 800ce24:	601a      	str	r2, [r3, #0]

      /* Disable the UART Error Interrupt: (Frame error, noise error, overrun error) */
      CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
 800ce26:	689a      	ldr	r2, [r3, #8]
 800ce28:	3023      	adds	r0, #35	; 0x23
 800ce2a:	30ff      	adds	r0, #255	; 0xff
 800ce2c:	4382      	bics	r2, r0
 800ce2e:	609a      	str	r2, [r3, #8]

      /* Rx process is completed, restore huart->RxState to Ready */
      huart->RxState = HAL_UART_STATE_READY;
 800ce30:	2220      	movs	r2, #32
 800ce32:	67e2      	str	r2, [r4, #124]	; 0x7c
      /* Clear RxISR function pointer */
      huart->RxISR = NULL;

      /* Check current reception Mode :
         If Reception till IDLE event has been selected : */
      if (huart->ReceptionType == HAL_UART_RECEPTION_TOIDLE)
 800ce34:	6e22      	ldr	r2, [r4, #96]	; 0x60
      huart->RxISR = NULL;
 800ce36:	6661      	str	r1, [r4, #100]	; 0x64
      if (huart->ReceptionType == HAL_UART_RECEPTION_TOIDLE)
 800ce38:	4282      	cmp	r2, r0
 800ce3a:	d10c      	bne.n	800ce56 <UART_RxISR_8BIT+0x6e>
      {
        /* Disable IDLE interrupt */
        CLEAR_BIT(huart->Instance->CR1, USART_CR1_IDLEIE);
 800ce3c:	2110      	movs	r1, #16
 800ce3e:	681a      	ldr	r2, [r3, #0]
#if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
        /*Call registered Rx Event callback*/
        huart->RxEventCallback(huart, huart->RxXferSize);
#else
        /*Call legacy weak Rx Event callback*/
        HAL_UARTEx_RxEventCallback(huart, huart->RxXferSize);
 800ce40:	0020      	movs	r0, r4
        CLEAR_BIT(huart->Instance->CR1, USART_CR1_IDLEIE);
 800ce42:	438a      	bics	r2, r1
 800ce44:	601a      	str	r2, [r3, #0]
        HAL_UARTEx_RxEventCallback(huart, huart->RxXferSize);
 800ce46:	0023      	movs	r3, r4
 800ce48:	3358      	adds	r3, #88	; 0x58
 800ce4a:	8819      	ldrh	r1, [r3, #0]
 800ce4c:	f7ff ffcb 	bl	800cde6 <HAL_UARTEx_RxEventCallback>
#else
        /*Call legacy weak Rx complete callback*/
        HAL_UART_RxCpltCallback(huart);
#endif /* USE_HAL_UART_REGISTER_CALLBACKS */
      }
      huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
 800ce50:	2300      	movs	r3, #0
 800ce52:	6623      	str	r3, [r4, #96]	; 0x60
  else
  {
    /* Clear RXNE interrupt flag */
    __HAL_UART_SEND_REQ(huart, UART_RXDATA_FLUSH_REQUEST);
  }
}
 800ce54:	bd10      	pop	{r4, pc}
        HAL_UART_RxCpltCallback(huart);
 800ce56:	0020      	movs	r0, r4
 800ce58:	f7ff ff88 	bl	800cd6c <HAL_UART_RxCpltCallback>
 800ce5c:	e7f8      	b.n	800ce50 <UART_RxISR_8BIT+0x68>
    __HAL_UART_SEND_REQ(huart, UART_RXDATA_FLUSH_REQUEST);
 800ce5e:	2208      	movs	r2, #8
 800ce60:	6999      	ldr	r1, [r3, #24]
 800ce62:	430a      	orrs	r2, r1
 800ce64:	619a      	str	r2, [r3, #24]
}
 800ce66:	e7f5      	b.n	800ce54 <UART_RxISR_8BIT+0x6c>
 800ce68:	fffffedf 	.word	0xfffffedf

0800ce6c <UART_RxISR_16BIT>:
  uint16_t *tmp;
  uint16_t uhMask = huart->Mask;
  uint16_t  uhdata;

  /* Check that a Rx process is ongoing */
  if (huart->RxState == HAL_UART_STATE_BUSY_RX)
 800ce6c:	6fc2      	ldr	r2, [r0, #124]	; 0x7c
{
 800ce6e:	b510      	push	{r4, lr}
 800ce70:	6803      	ldr	r3, [r0, #0]
 800ce72:	0004      	movs	r4, r0
  if (huart->RxState == HAL_UART_STATE_BUSY_RX)
 800ce74:	2a22      	cmp	r2, #34	; 0x22
 800ce76:	d132      	bne.n	800cede <UART_RxISR_16BIT+0x72>
  uint16_t uhMask = huart->Mask;
 800ce78:	0021      	movs	r1, r4
 800ce7a:	315c      	adds	r1, #92	; 0x5c
  {
    uhdata = (uint16_t) READ_REG(huart->Instance->RDR);
 800ce7c:	8c98      	ldrh	r0, [r3, #36]	; 0x24
    tmp = (uint16_t *) huart->pRxBuffPtr ;
    *tmp = (uint16_t)(uhdata & uhMask);
 800ce7e:	8809      	ldrh	r1, [r1, #0]
    tmp = (uint16_t *) huart->pRxBuffPtr ;
 800ce80:	6d62      	ldr	r2, [r4, #84]	; 0x54
    *tmp = (uint16_t)(uhdata & uhMask);
 800ce82:	4001      	ands	r1, r0
 800ce84:	8011      	strh	r1, [r2, #0]
    huart->pRxBuffPtr += 2U;
    huart->RxXferCount--;
 800ce86:	0021      	movs	r1, r4
    huart->pRxBuffPtr += 2U;
 800ce88:	3202      	adds	r2, #2
    huart->RxXferCount--;
 800ce8a:	315a      	adds	r1, #90	; 0x5a
    huart->pRxBuffPtr += 2U;
 800ce8c:	6562      	str	r2, [r4, #84]	; 0x54
    huart->RxXferCount--;
 800ce8e:	880a      	ldrh	r2, [r1, #0]
 800ce90:	3a01      	subs	r2, #1
 800ce92:	b292      	uxth	r2, r2
 800ce94:	800a      	strh	r2, [r1, #0]

    if (huart->RxXferCount == 0U)
 800ce96:	880a      	ldrh	r2, [r1, #0]
 800ce98:	b291      	uxth	r1, r2
 800ce9a:	2a00      	cmp	r2, #0
 800ce9c:	d11a      	bne.n	800ced4 <UART_RxISR_16BIT+0x68>
    {
      /* Disable the UART Parity Error Interrupt and RXNE interrupt*/
      CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE));
 800ce9e:	681a      	ldr	r2, [r3, #0]
 800cea0:	4811      	ldr	r0, [pc, #68]	; (800cee8 <UART_RxISR_16BIT+0x7c>)
 800cea2:	4002      	ands	r2, r0
 800cea4:	601a      	str	r2, [r3, #0]

      /* Disable the UART Error Interrupt: (Frame error, noise error, overrun error) */
      CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
 800cea6:	689a      	ldr	r2, [r3, #8]
 800cea8:	3023      	adds	r0, #35	; 0x23
 800ceaa:	30ff      	adds	r0, #255	; 0xff
 800ceac:	4382      	bics	r2, r0
 800ceae:	609a      	str	r2, [r3, #8]

      /* Rx process is completed, restore huart->RxState to Ready */
      huart->RxState = HAL_UART_STATE_READY;
 800ceb0:	2220      	movs	r2, #32
 800ceb2:	67e2      	str	r2, [r4, #124]	; 0x7c
      /* Clear RxISR function pointer */
      huart->RxISR = NULL;

      /* Check current reception Mode :
         If Reception till IDLE event has been selected : */
      if (huart->ReceptionType == HAL_UART_RECEPTION_TOIDLE)
 800ceb4:	6e22      	ldr	r2, [r4, #96]	; 0x60
      huart->RxISR = NULL;
 800ceb6:	6661      	str	r1, [r4, #100]	; 0x64
      if (huart->ReceptionType == HAL_UART_RECEPTION_TOIDLE)
 800ceb8:	4282      	cmp	r2, r0
 800ceba:	d10c      	bne.n	800ced6 <UART_RxISR_16BIT+0x6a>
      {
        /* Disable IDLE interrupt */
        CLEAR_BIT(huart->Instance->CR1, USART_CR1_IDLEIE);
 800cebc:	2110      	movs	r1, #16
 800cebe:	681a      	ldr	r2, [r3, #0]
#if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
        /*Call registered Rx Event callback*/
        huart->RxEventCallback(huart, huart->RxXferSize);
#else
        /*Call legacy weak Rx Event callback*/
        HAL_UARTEx_RxEventCallback(huart, huart->RxXferSize);
 800cec0:	0020      	movs	r0, r4
        CLEAR_BIT(huart->Instance->CR1, USART_CR1_IDLEIE);
 800cec2:	438a      	bics	r2, r1
 800cec4:	601a      	str	r2, [r3, #0]
        HAL_UARTEx_RxEventCallback(huart, huart->RxXferSize);
 800cec6:	0023      	movs	r3, r4
 800cec8:	3358      	adds	r3, #88	; 0x58
 800ceca:	8819      	ldrh	r1, [r3, #0]
 800cecc:	f7ff ff8b 	bl	800cde6 <HAL_UARTEx_RxEventCallback>
#else
        /*Call legacy weak Rx complete callback*/
        HAL_UART_RxCpltCallback(huart);
#endif /* USE_HAL_UART_REGISTER_CALLBACKS */
      }
      huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
 800ced0:	2300      	movs	r3, #0
 800ced2:	6623      	str	r3, [r4, #96]	; 0x60
  else
  {
    /* Clear RXNE interrupt flag */
    __HAL_UART_SEND_REQ(huart, UART_RXDATA_FLUSH_REQUEST);
  }
}
 800ced4:	bd10      	pop	{r4, pc}
        HAL_UART_RxCpltCallback(huart);
 800ced6:	0020      	movs	r0, r4
 800ced8:	f7ff ff48 	bl	800cd6c <HAL_UART_RxCpltCallback>
 800cedc:	e7f8      	b.n	800ced0 <UART_RxISR_16BIT+0x64>
    __HAL_UART_SEND_REQ(huart, UART_RXDATA_FLUSH_REQUEST);
 800cede:	2208      	movs	r2, #8
 800cee0:	6999      	ldr	r1, [r3, #24]
 800cee2:	430a      	orrs	r2, r1
 800cee4:	619a      	str	r2, [r3, #24]
}
 800cee6:	e7f5      	b.n	800ced4 <UART_RxISR_16BIT+0x68>
 800cee8:	fffffedf 	.word	0xfffffedf

0800ceec <UART_SetConfig>:
  assert_param(IS_UART_BAUDRATE(huart->Init.BaudRate));
 800ceec:	4b6a      	ldr	r3, [pc, #424]	; (800d098 <UART_SetConfig+0x1ac>)
 800ceee:	6842      	ldr	r2, [r0, #4]
{
 800cef0:	b570      	push	{r4, r5, r6, lr}
 800cef2:	0004      	movs	r4, r0
  assert_param(IS_UART_BAUDRATE(huart->Init.BaudRate));
 800cef4:	429a      	cmp	r2, r3
 800cef6:	d903      	bls.n	800cf00 <UART_SetConfig+0x14>
 800cef8:	4968      	ldr	r1, [pc, #416]	; (800d09c <UART_SetConfig+0x1b0>)
 800cefa:	4869      	ldr	r0, [pc, #420]	; (800d0a0 <UART_SetConfig+0x1b4>)
 800cefc:	f7fb fd18 	bl	8008930 <assert_failed>
  assert_param(IS_UART_WORD_LENGTH(huart->Init.WordLength));
 800cf00:	2280      	movs	r2, #128	; 0x80
 800cf02:	68a3      	ldr	r3, [r4, #8]
 800cf04:	0552      	lsls	r2, r2, #21
 800cf06:	4293      	cmp	r3, r2
 800cf08:	d006      	beq.n	800cf18 <UART_SetConfig+0x2c>
 800cf0a:	4a66      	ldr	r2, [pc, #408]	; (800d0a4 <UART_SetConfig+0x1b8>)
 800cf0c:	4213      	tst	r3, r2
 800cf0e:	d003      	beq.n	800cf18 <UART_SetConfig+0x2c>
 800cf10:	4965      	ldr	r1, [pc, #404]	; (800d0a8 <UART_SetConfig+0x1bc>)
 800cf12:	4863      	ldr	r0, [pc, #396]	; (800d0a0 <UART_SetConfig+0x1b4>)
 800cf14:	f7fb fd0c 	bl	8008930 <assert_failed>
  assert_param(IS_UART_STOPBITS(huart->Init.StopBits));
 800cf18:	4d64      	ldr	r5, [pc, #400]	; (800d0ac <UART_SetConfig+0x1c0>)
 800cf1a:	68e3      	ldr	r3, [r4, #12]
 800cf1c:	422b      	tst	r3, r5
 800cf1e:	d003      	beq.n	800cf28 <UART_SetConfig+0x3c>
 800cf20:	4963      	ldr	r1, [pc, #396]	; (800d0b0 <UART_SetConfig+0x1c4>)
 800cf22:	485f      	ldr	r0, [pc, #380]	; (800d0a0 <UART_SetConfig+0x1b4>)
 800cf24:	f7fb fd04 	bl	8008930 <assert_failed>
  assert_param(IS_UART_ONE_BIT_SAMPLE(huart->Init.OneBitSampling));
 800cf28:	4b62      	ldr	r3, [pc, #392]	; (800d0b4 <UART_SetConfig+0x1c8>)
 800cf2a:	6a22      	ldr	r2, [r4, #32]
 800cf2c:	421a      	tst	r2, r3
 800cf2e:	d003      	beq.n	800cf38 <UART_SetConfig+0x4c>
 800cf30:	4961      	ldr	r1, [pc, #388]	; (800d0b8 <UART_SetConfig+0x1cc>)
 800cf32:	485b      	ldr	r0, [pc, #364]	; (800d0a0 <UART_SetConfig+0x1b4>)
 800cf34:	f7fb fcfc 	bl	8008930 <assert_failed>
  assert_param(IS_UART_PARITY(huart->Init.Parity));
 800cf38:	6923      	ldr	r3, [r4, #16]
 800cf3a:	4a60      	ldr	r2, [pc, #384]	; (800d0bc <UART_SetConfig+0x1d0>)
 800cf3c:	4213      	tst	r3, r2
 800cf3e:	d007      	beq.n	800cf50 <UART_SetConfig+0x64>
 800cf40:	22c0      	movs	r2, #192	; 0xc0
 800cf42:	00d2      	lsls	r2, r2, #3
 800cf44:	4293      	cmp	r3, r2
 800cf46:	d003      	beq.n	800cf50 <UART_SetConfig+0x64>
 800cf48:	495d      	ldr	r1, [pc, #372]	; (800d0c0 <UART_SetConfig+0x1d4>)
 800cf4a:	4855      	ldr	r0, [pc, #340]	; (800d0a0 <UART_SetConfig+0x1b4>)
 800cf4c:	f7fb fcf0 	bl	8008930 <assert_failed>
  assert_param(IS_UART_MODE(huart->Init.Mode));
 800cf50:	6963      	ldr	r3, [r4, #20]
 800cf52:	220c      	movs	r2, #12
 800cf54:	0019      	movs	r1, r3
 800cf56:	4391      	bics	r1, r2
 800cf58:	d101      	bne.n	800cf5e <UART_SetConfig+0x72>
 800cf5a:	2b00      	cmp	r3, #0
 800cf5c:	d103      	bne.n	800cf66 <UART_SetConfig+0x7a>
 800cf5e:	4959      	ldr	r1, [pc, #356]	; (800d0c4 <UART_SetConfig+0x1d8>)
 800cf60:	484f      	ldr	r0, [pc, #316]	; (800d0a0 <UART_SetConfig+0x1b4>)
 800cf62:	f7fb fce5 	bl	8008930 <assert_failed>
  assert_param(IS_UART_HARDWARE_FLOW_CONTROL(huart->Init.HwFlowCtl));
 800cf66:	4b58      	ldr	r3, [pc, #352]	; (800d0c8 <UART_SetConfig+0x1dc>)
 800cf68:	69a2      	ldr	r2, [r4, #24]
 800cf6a:	421a      	tst	r2, r3
 800cf6c:	d003      	beq.n	800cf76 <UART_SetConfig+0x8a>
 800cf6e:	4957      	ldr	r1, [pc, #348]	; (800d0cc <UART_SetConfig+0x1e0>)
 800cf70:	484b      	ldr	r0, [pc, #300]	; (800d0a0 <UART_SetConfig+0x1b4>)
 800cf72:	f7fb fcdd 	bl	8008930 <assert_failed>
  assert_param(IS_UART_OVERSAMPLING(huart->Init.OverSampling));
 800cf76:	4b56      	ldr	r3, [pc, #344]	; (800d0d0 <UART_SetConfig+0x1e4>)
 800cf78:	69e2      	ldr	r2, [r4, #28]
 800cf7a:	421a      	tst	r2, r3
 800cf7c:	d003      	beq.n	800cf86 <UART_SetConfig+0x9a>
 800cf7e:	4955      	ldr	r1, [pc, #340]	; (800d0d4 <UART_SetConfig+0x1e8>)
 800cf80:	4847      	ldr	r0, [pc, #284]	; (800d0a0 <UART_SetConfig+0x1b4>)
 800cf82:	f7fb fcd5 	bl	8008930 <assert_failed>
  tmpreg = (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling ;
 800cf86:	6926      	ldr	r6, [r4, #16]
 800cf88:	68a1      	ldr	r1, [r4, #8]
  MODIFY_REG(huart->Instance->CR1, USART_CR1_FIELDS, tmpreg);
 800cf8a:	6822      	ldr	r2, [r4, #0]
  tmpreg = (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling ;
 800cf8c:	4331      	orrs	r1, r6
 800cf8e:	6966      	ldr	r6, [r4, #20]
  MODIFY_REG(huart->Instance->CR1, USART_CR1_FIELDS, tmpreg);
 800cf90:	6810      	ldr	r0, [r2, #0]
  tmpreg = (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling ;
 800cf92:	69e3      	ldr	r3, [r4, #28]
 800cf94:	4331      	orrs	r1, r6
  MODIFY_REG(huart->Instance->CR1, USART_CR1_FIELDS, tmpreg);
 800cf96:	4e50      	ldr	r6, [pc, #320]	; (800d0d8 <UART_SetConfig+0x1ec>)
  tmpreg = (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling ;
 800cf98:	4319      	orrs	r1, r3
  MODIFY_REG(huart->Instance->CR1, USART_CR1_FIELDS, tmpreg);
 800cf9a:	4030      	ands	r0, r6
 800cf9c:	4301      	orrs	r1, r0
 800cf9e:	6011      	str	r1, [r2, #0]
  MODIFY_REG(huart->Instance->CR2, USART_CR2_STOP, huart->Init.StopBits);
 800cfa0:	6851      	ldr	r1, [r2, #4]
 800cfa2:	400d      	ands	r5, r1
 800cfa4:	68e1      	ldr	r1, [r4, #12]
 800cfa6:	430d      	orrs	r5, r1
 800cfa8:	6055      	str	r5, [r2, #4]
  tmpreg |= huart->Init.OneBitSampling;
 800cfaa:	69a1      	ldr	r1, [r4, #24]
 800cfac:	6a25      	ldr	r5, [r4, #32]
  MODIFY_REG(huart->Instance->CR3, USART_CR3_FIELDS, tmpreg);
 800cfae:	6890      	ldr	r0, [r2, #8]
  tmpreg |= huart->Init.OneBitSampling;
 800cfb0:	4329      	orrs	r1, r5
  MODIFY_REG(huart->Instance->CR3, USART_CR3_FIELDS, tmpreg);
 800cfb2:	4d4a      	ldr	r5, [pc, #296]	; (800d0dc <UART_SetConfig+0x1f0>)
 800cfb4:	4028      	ands	r0, r5
 800cfb6:	4301      	orrs	r1, r0
 800cfb8:	6091      	str	r1, [r2, #8]
  UART_GETCLOCKSOURCE(huart, clocksource);
 800cfba:	4949      	ldr	r1, [pc, #292]	; (800d0e0 <UART_SetConfig+0x1f4>)
 800cfbc:	428a      	cmp	r2, r1
 800cfbe:	d115      	bne.n	800cfec <UART_SetConfig+0x100>
 800cfc0:	2103      	movs	r1, #3
 800cfc2:	4a48      	ldr	r2, [pc, #288]	; (800d0e4 <UART_SetConfig+0x1f8>)
 800cfc4:	6b12      	ldr	r2, [r2, #48]	; 0x30
 800cfc6:	400a      	ands	r2, r1
 800cfc8:	3a01      	subs	r2, #1
 800cfca:	2a02      	cmp	r2, #2
 800cfcc:	d857      	bhi.n	800d07e <UART_SetConfig+0x192>
 800cfce:	4946      	ldr	r1, [pc, #280]	; (800d0e8 <UART_SetConfig+0x1fc>)
 800cfd0:	5c88      	ldrb	r0, [r1, r2]
  if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
 800cfd2:	2280      	movs	r2, #128	; 0x80
 800cfd4:	0212      	lsls	r2, r2, #8
 800cfd6:	4293      	cmp	r3, r2
 800cfd8:	d12d      	bne.n	800d036 <UART_SetConfig+0x14a>
    switch (clocksource)
 800cfda:	2808      	cmp	r0, #8
 800cfdc:	d80f      	bhi.n	800cffe <UART_SetConfig+0x112>
 800cfde:	f7fb f8a5 	bl	800812c <__gnu_thumb1_case_uqi>
 800cfe2:	0e52      	.short	0x0e52
 800cfe4:	0e270e10 	.word	0x0e270e10
 800cfe8:	0e0e      	.short	0x0e0e
 800cfea:	11          	.byte	0x11
 800cfeb:	00          	.byte	0x00
  UART_GETCLOCKSOURCE(huart, clocksource);
 800cfec:	493f      	ldr	r1, [pc, #252]	; (800d0ec <UART_SetConfig+0x200>)
 800cfee:	428a      	cmp	r2, r1
 800cff0:	d045      	beq.n	800d07e <UART_SetConfig+0x192>
 800cff2:	493f      	ldr	r1, [pc, #252]	; (800d0f0 <UART_SetConfig+0x204>)
 800cff4:	428a      	cmp	r2, r1
 800cff6:	d042      	beq.n	800d07e <UART_SetConfig+0x192>
 800cff8:	493e      	ldr	r1, [pc, #248]	; (800d0f4 <UART_SetConfig+0x208>)
 800cffa:	428a      	cmp	r2, r1
 800cffc:	d03f      	beq.n	800d07e <UART_SetConfig+0x192>
  if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
 800cffe:	2001      	movs	r0, #1
 800d000:	e046      	b.n	800d090 <UART_SetConfig+0x1a4>
 800d002:	4b3d      	ldr	r3, [pc, #244]	; (800d0f8 <UART_SetConfig+0x20c>)
      usartdiv = (uint16_t)(UART_DIV_SAMPLING8(pclk, huart->Init.BaudRate));
 800d004:	0058      	lsls	r0, r3, #1
 800d006:	6863      	ldr	r3, [r4, #4]
 800d008:	6861      	ldr	r1, [r4, #4]
 800d00a:	085b      	lsrs	r3, r3, #1
 800d00c:	18c0      	adds	r0, r0, r3
 800d00e:	f7fb f8ab 	bl	8008168 <__udivsi3>
      if ((usartdiv >= UART_BRR_MIN) && (usartdiv <= UART_BRR_MAX))
 800d012:	493a      	ldr	r1, [pc, #232]	; (800d0fc <UART_SetConfig+0x210>)
 800d014:	b282      	uxth	r2, r0
 800d016:	3a10      	subs	r2, #16
 800d018:	0403      	lsls	r3, r0, #16
 800d01a:	428a      	cmp	r2, r1
 800d01c:	d8ef      	bhi.n	800cffe <UART_SetConfig+0x112>
        brrtemp = (uint16_t)(usartdiv & 0xFFF0U);
 800d01e:	220f      	movs	r2, #15
        brrtemp |= (uint16_t)((usartdiv & (uint16_t)0x000FU) >> 1U);
 800d020:	031b      	lsls	r3, r3, #12
        brrtemp = (uint16_t)(usartdiv & 0xFFF0U);
 800d022:	4390      	bics	r0, r2
 800d024:	b280      	uxth	r0, r0
        huart->Instance->BRR = brrtemp;
 800d026:	6822      	ldr	r2, [r4, #0]
        brrtemp |= (uint16_t)((usartdiv & (uint16_t)0x000FU) >> 1U);
 800d028:	0f5b      	lsrs	r3, r3, #29
        huart->Instance->BRR = brrtemp;
 800d02a:	4318      	orrs	r0, r3
 800d02c:	60d0      	str	r0, [r2, #12]
 800d02e:	e02e      	b.n	800d08e <UART_SetConfig+0x1a2>
        pclk = HAL_RCC_GetSysClockFreq();
 800d030:	f7fe ff68 	bl	800bf04 <HAL_RCC_GetSysClockFreq>
 800d034:	e029      	b.n	800d08a <UART_SetConfig+0x19e>
    switch (clocksource)
 800d036:	2808      	cmp	r0, #8
 800d038:	d8e1      	bhi.n	800cffe <UART_SetConfig+0x112>
 800d03a:	f7fb f86d 	bl	8008118 <__gnu_thumb1_case_sqi>
 800d03e:	e016      	.short	0xe016
 800d040:	e01be01e 	.word	0xe01be01e
 800d044:	e0e0      	.short	0xe0e0
 800d046:	05          	.byte	0x05
 800d047:	00          	.byte	0x00
  if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
 800d048:	2080      	movs	r0, #128	; 0x80
 800d04a:	0200      	lsls	r0, r0, #8
      usartdiv = (uint16_t)(UART_DIV_SAMPLING16(pclk, huart->Init.BaudRate));
 800d04c:	6863      	ldr	r3, [r4, #4]
 800d04e:	6861      	ldr	r1, [r4, #4]
 800d050:	085b      	lsrs	r3, r3, #1
 800d052:	1818      	adds	r0, r3, r0
 800d054:	f7fb f888 	bl	8008168 <__udivsi3>
 800d058:	b280      	uxth	r0, r0
      if ((usartdiv >= UART_BRR_MIN) && (usartdiv <= UART_BRR_MAX))
 800d05a:	0002      	movs	r2, r0
 800d05c:	4b27      	ldr	r3, [pc, #156]	; (800d0fc <UART_SetConfig+0x210>)
 800d05e:	3a10      	subs	r2, #16
 800d060:	429a      	cmp	r2, r3
 800d062:	d8cc      	bhi.n	800cffe <UART_SetConfig+0x112>
        huart->Instance->BRR = usartdiv;
 800d064:	6823      	ldr	r3, [r4, #0]
 800d066:	60d8      	str	r0, [r3, #12]
 800d068:	e011      	b.n	800d08e <UART_SetConfig+0x1a2>
        pclk = HAL_RCC_GetPCLK1Freq();
 800d06a:	f7ff f84b 	bl	800c104 <HAL_RCC_GetPCLK1Freq>
    if (pclk != 0U)
 800d06e:	2800      	cmp	r0, #0
 800d070:	d00d      	beq.n	800d08e <UART_SetConfig+0x1a2>
 800d072:	e7eb      	b.n	800d04c <UART_SetConfig+0x160>
        pclk = HAL_RCC_GetSysClockFreq();
 800d074:	f7fe ff46 	bl	800bf04 <HAL_RCC_GetSysClockFreq>
        break;
 800d078:	e7f9      	b.n	800d06e <UART_SetConfig+0x182>
        pclk = (uint32_t) HSI_VALUE;
 800d07a:	481f      	ldr	r0, [pc, #124]	; (800d0f8 <UART_SetConfig+0x20c>)
 800d07c:	e7e6      	b.n	800d04c <UART_SetConfig+0x160>
  if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
 800d07e:	2280      	movs	r2, #128	; 0x80
 800d080:	0212      	lsls	r2, r2, #8
 800d082:	4293      	cmp	r3, r2
 800d084:	d1f1      	bne.n	800d06a <UART_SetConfig+0x17e>
        pclk = HAL_RCC_GetPCLK1Freq();
 800d086:	f7ff f83d 	bl	800c104 <HAL_RCC_GetPCLK1Freq>
        pclk = HAL_RCC_GetSysClockFreq();
 800d08a:	1e03      	subs	r3, r0, #0
    if (pclk != 0U)
 800d08c:	d1ba      	bne.n	800d004 <UART_SetConfig+0x118>
 800d08e:	2000      	movs	r0, #0
  huart->RxISR = NULL;
 800d090:	2300      	movs	r3, #0
 800d092:	6663      	str	r3, [r4, #100]	; 0x64
  huart->TxISR = NULL;
 800d094:	66a3      	str	r3, [r4, #104]	; 0x68
}
 800d096:	bd70      	pop	{r4, r5, r6, pc}
 800d098:	005b8d80 	.word	0x005b8d80
 800d09c:	00000be1 	.word	0x00000be1
 800d0a0:	080109b3 	.word	0x080109b3
 800d0a4:	ffffefff 	.word	0xffffefff
 800d0a8:	00000be2 	.word	0x00000be2
 800d0ac:	ffffcfff 	.word	0xffffcfff
 800d0b0:	00000be3 	.word	0x00000be3
 800d0b4:	fffff7ff 	.word	0xfffff7ff
 800d0b8:	00000be4 	.word	0x00000be4
 800d0bc:	fffffbff 	.word	0xfffffbff
 800d0c0:	00000be6 	.word	0x00000be6
 800d0c4:	00000be7 	.word	0x00000be7
 800d0c8:	fffffcff 	.word	0xfffffcff
 800d0cc:	00000be8 	.word	0x00000be8
 800d0d0:	ffff7fff 	.word	0xffff7fff
 800d0d4:	00000be9 	.word	0x00000be9
 800d0d8:	efff69f3 	.word	0xefff69f3
 800d0dc:	fffff4ff 	.word	0xfffff4ff
 800d0e0:	40013800 	.word	0x40013800
 800d0e4:	40021000 	.word	0x40021000
 800d0e8:	080109ec 	.word	0x080109ec
 800d0ec:	40004400 	.word	0x40004400
 800d0f0:	40004800 	.word	0x40004800
 800d0f4:	40004c00 	.word	0x40004c00
 800d0f8:	007a1200 	.word	0x007a1200
 800d0fc:	0000ffef 	.word	0x0000ffef

0800d100 <UART_AdvFeatureConfig>:
  assert_param(IS_UART_ADVFEATURE_INIT(huart->AdvancedInit.AdvFeatureInit));
 800d100:	6a43      	ldr	r3, [r0, #36]	; 0x24
{
 800d102:	b570      	push	{r4, r5, r6, lr}
 800d104:	0004      	movs	r4, r0
  assert_param(IS_UART_ADVFEATURE_INIT(huart->AdvancedInit.AdvFeatureInit));
 800d106:	2bff      	cmp	r3, #255	; 0xff
 800d108:	d903      	bls.n	800d112 <UART_AdvFeatureConfig+0x12>
 800d10a:	4955      	ldr	r1, [pc, #340]	; (800d260 <UART_AdvFeatureConfig+0x160>)
 800d10c:	4855      	ldr	r0, [pc, #340]	; (800d264 <UART_AdvFeatureConfig+0x164>)
 800d10e:	f7fb fc0f 	bl	8008930 <assert_failed>
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_TXINVERT_INIT))
 800d112:	6a63      	ldr	r3, [r4, #36]	; 0x24
 800d114:	07db      	lsls	r3, r3, #31
 800d116:	d50d      	bpl.n	800d134 <UART_AdvFeatureConfig+0x34>
    assert_param(IS_UART_ADVFEATURE_TXINV(huart->AdvancedInit.TxPinLevelInvert));
 800d118:	4d53      	ldr	r5, [pc, #332]	; (800d268 <UART_AdvFeatureConfig+0x168>)
 800d11a:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 800d11c:	422b      	tst	r3, r5
 800d11e:	d003      	beq.n	800d128 <UART_AdvFeatureConfig+0x28>
 800d120:	4952      	ldr	r1, [pc, #328]	; (800d26c <UART_AdvFeatureConfig+0x16c>)
 800d122:	4850      	ldr	r0, [pc, #320]	; (800d264 <UART_AdvFeatureConfig+0x164>)
 800d124:	f7fb fc04 	bl	8008930 <assert_failed>
    MODIFY_REG(huart->Instance->CR2, USART_CR2_TXINV, huart->AdvancedInit.TxPinLevelInvert);
 800d128:	6822      	ldr	r2, [r4, #0]
 800d12a:	6aa1      	ldr	r1, [r4, #40]	; 0x28
 800d12c:	6853      	ldr	r3, [r2, #4]
 800d12e:	402b      	ands	r3, r5
 800d130:	430b      	orrs	r3, r1
 800d132:	6053      	str	r3, [r2, #4]
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_RXINVERT_INIT))
 800d134:	6a63      	ldr	r3, [r4, #36]	; 0x24
 800d136:	079b      	lsls	r3, r3, #30
 800d138:	d50e      	bpl.n	800d158 <UART_AdvFeatureConfig+0x58>
    assert_param(IS_UART_ADVFEATURE_RXINV(huart->AdvancedInit.RxPinLevelInvert));
 800d13a:	4d4d      	ldr	r5, [pc, #308]	; (800d270 <UART_AdvFeatureConfig+0x170>)
 800d13c:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 800d13e:	422b      	tst	r3, r5
 800d140:	d004      	beq.n	800d14c <UART_AdvFeatureConfig+0x4c>
 800d142:	21c7      	movs	r1, #199	; 0xc7
 800d144:	4847      	ldr	r0, [pc, #284]	; (800d264 <UART_AdvFeatureConfig+0x164>)
 800d146:	0109      	lsls	r1, r1, #4
 800d148:	f7fb fbf2 	bl	8008930 <assert_failed>
    MODIFY_REG(huart->Instance->CR2, USART_CR2_RXINV, huart->AdvancedInit.RxPinLevelInvert);
 800d14c:	6822      	ldr	r2, [r4, #0]
 800d14e:	6ae1      	ldr	r1, [r4, #44]	; 0x2c
 800d150:	6853      	ldr	r3, [r2, #4]
 800d152:	402b      	ands	r3, r5
 800d154:	430b      	orrs	r3, r1
 800d156:	6053      	str	r3, [r2, #4]
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_DATAINVERT_INIT))
 800d158:	6a63      	ldr	r3, [r4, #36]	; 0x24
 800d15a:	075b      	lsls	r3, r3, #29
 800d15c:	d50d      	bpl.n	800d17a <UART_AdvFeatureConfig+0x7a>
    assert_param(IS_UART_ADVFEATURE_DATAINV(huart->AdvancedInit.DataInvert));
 800d15e:	4d45      	ldr	r5, [pc, #276]	; (800d274 <UART_AdvFeatureConfig+0x174>)
 800d160:	6b23      	ldr	r3, [r4, #48]	; 0x30
 800d162:	422b      	tst	r3, r5
 800d164:	d003      	beq.n	800d16e <UART_AdvFeatureConfig+0x6e>
 800d166:	4944      	ldr	r1, [pc, #272]	; (800d278 <UART_AdvFeatureConfig+0x178>)
 800d168:	483e      	ldr	r0, [pc, #248]	; (800d264 <UART_AdvFeatureConfig+0x164>)
 800d16a:	f7fb fbe1 	bl	8008930 <assert_failed>
    MODIFY_REG(huart->Instance->CR2, USART_CR2_DATAINV, huart->AdvancedInit.DataInvert);
 800d16e:	6822      	ldr	r2, [r4, #0]
 800d170:	6b21      	ldr	r1, [r4, #48]	; 0x30
 800d172:	6853      	ldr	r3, [r2, #4]
 800d174:	402b      	ands	r3, r5
 800d176:	430b      	orrs	r3, r1
 800d178:	6053      	str	r3, [r2, #4]
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_SWAP_INIT))
 800d17a:	6a63      	ldr	r3, [r4, #36]	; 0x24
 800d17c:	071b      	lsls	r3, r3, #28
 800d17e:	d50d      	bpl.n	800d19c <UART_AdvFeatureConfig+0x9c>
    assert_param(IS_UART_ADVFEATURE_SWAP(huart->AdvancedInit.Swap));
 800d180:	4d3e      	ldr	r5, [pc, #248]	; (800d27c <UART_AdvFeatureConfig+0x17c>)
 800d182:	6b63      	ldr	r3, [r4, #52]	; 0x34
 800d184:	422b      	tst	r3, r5
 800d186:	d003      	beq.n	800d190 <UART_AdvFeatureConfig+0x90>
 800d188:	493d      	ldr	r1, [pc, #244]	; (800d280 <UART_AdvFeatureConfig+0x180>)
 800d18a:	4836      	ldr	r0, [pc, #216]	; (800d264 <UART_AdvFeatureConfig+0x164>)
 800d18c:	f7fb fbd0 	bl	8008930 <assert_failed>
    MODIFY_REG(huart->Instance->CR2, USART_CR2_SWAP, huart->AdvancedInit.Swap);
 800d190:	6822      	ldr	r2, [r4, #0]
 800d192:	6b61      	ldr	r1, [r4, #52]	; 0x34
 800d194:	6853      	ldr	r3, [r2, #4]
 800d196:	402b      	ands	r3, r5
 800d198:	430b      	orrs	r3, r1
 800d19a:	6053      	str	r3, [r2, #4]
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_RXOVERRUNDISABLE_INIT))
 800d19c:	6a63      	ldr	r3, [r4, #36]	; 0x24
 800d19e:	06db      	lsls	r3, r3, #27
 800d1a0:	d50d      	bpl.n	800d1be <UART_AdvFeatureConfig+0xbe>
    assert_param(IS_UART_OVERRUN(huart->AdvancedInit.OverrunDisable));
 800d1a2:	4d38      	ldr	r5, [pc, #224]	; (800d284 <UART_AdvFeatureConfig+0x184>)
 800d1a4:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 800d1a6:	422b      	tst	r3, r5
 800d1a8:	d003      	beq.n	800d1b2 <UART_AdvFeatureConfig+0xb2>
 800d1aa:	4937      	ldr	r1, [pc, #220]	; (800d288 <UART_AdvFeatureConfig+0x188>)
 800d1ac:	482d      	ldr	r0, [pc, #180]	; (800d264 <UART_AdvFeatureConfig+0x164>)
 800d1ae:	f7fb fbbf 	bl	8008930 <assert_failed>
    MODIFY_REG(huart->Instance->CR3, USART_CR3_OVRDIS, huart->AdvancedInit.OverrunDisable);
 800d1b2:	6822      	ldr	r2, [r4, #0]
 800d1b4:	6ba1      	ldr	r1, [r4, #56]	; 0x38
 800d1b6:	6893      	ldr	r3, [r2, #8]
 800d1b8:	402b      	ands	r3, r5
 800d1ba:	430b      	orrs	r3, r1
 800d1bc:	6093      	str	r3, [r2, #8]
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_DMADISABLEONERROR_INIT))
 800d1be:	6a63      	ldr	r3, [r4, #36]	; 0x24
 800d1c0:	069b      	lsls	r3, r3, #26
 800d1c2:	d50d      	bpl.n	800d1e0 <UART_AdvFeatureConfig+0xe0>
    assert_param(IS_UART_ADVFEATURE_DMAONRXERROR(huart->AdvancedInit.DMADisableonRxError));
 800d1c4:	4d31      	ldr	r5, [pc, #196]	; (800d28c <UART_AdvFeatureConfig+0x18c>)
 800d1c6:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 800d1c8:	422b      	tst	r3, r5
 800d1ca:	d003      	beq.n	800d1d4 <UART_AdvFeatureConfig+0xd4>
 800d1cc:	4930      	ldr	r1, [pc, #192]	; (800d290 <UART_AdvFeatureConfig+0x190>)
 800d1ce:	4825      	ldr	r0, [pc, #148]	; (800d264 <UART_AdvFeatureConfig+0x164>)
 800d1d0:	f7fb fbae 	bl	8008930 <assert_failed>
    MODIFY_REG(huart->Instance->CR3, USART_CR3_DDRE, huart->AdvancedInit.DMADisableonRxError);
 800d1d4:	6822      	ldr	r2, [r4, #0]
 800d1d6:	6be1      	ldr	r1, [r4, #60]	; 0x3c
 800d1d8:	6893      	ldr	r3, [r2, #8]
 800d1da:	402b      	ands	r3, r5
 800d1dc:	430b      	orrs	r3, r1
 800d1de:	6093      	str	r3, [r2, #8]
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_AUTOBAUDRATE_INIT))
 800d1e0:	6a63      	ldr	r3, [r4, #36]	; 0x24
 800d1e2:	065b      	lsls	r3, r3, #25
 800d1e4:	d52a      	bpl.n	800d23c <UART_AdvFeatureConfig+0x13c>
    assert_param(IS_USART_AUTOBAUDRATE_DETECTION_INSTANCE(huart->Instance));
 800d1e6:	6823      	ldr	r3, [r4, #0]
 800d1e8:	4a2a      	ldr	r2, [pc, #168]	; (800d294 <UART_AdvFeatureConfig+0x194>)
 800d1ea:	4293      	cmp	r3, r2
 800d1ec:	d006      	beq.n	800d1fc <UART_AdvFeatureConfig+0xfc>
 800d1ee:	4a2a      	ldr	r2, [pc, #168]	; (800d298 <UART_AdvFeatureConfig+0x198>)
 800d1f0:	4293      	cmp	r3, r2
 800d1f2:	d003      	beq.n	800d1fc <UART_AdvFeatureConfig+0xfc>
 800d1f4:	4929      	ldr	r1, [pc, #164]	; (800d29c <UART_AdvFeatureConfig+0x19c>)
 800d1f6:	481b      	ldr	r0, [pc, #108]	; (800d264 <UART_AdvFeatureConfig+0x164>)
 800d1f8:	f7fb fb9a 	bl	8008930 <assert_failed>
    assert_param(IS_UART_ADVFEATURE_AUTOBAUDRATE(huart->AdvancedInit.AutoBaudRateEnable));
 800d1fc:	4d28      	ldr	r5, [pc, #160]	; (800d2a0 <UART_AdvFeatureConfig+0x1a0>)
 800d1fe:	6c23      	ldr	r3, [r4, #64]	; 0x40
 800d200:	422b      	tst	r3, r5
 800d202:	d003      	beq.n	800d20c <UART_AdvFeatureConfig+0x10c>
 800d204:	4927      	ldr	r1, [pc, #156]	; (800d2a4 <UART_AdvFeatureConfig+0x1a4>)
 800d206:	4817      	ldr	r0, [pc, #92]	; (800d264 <UART_AdvFeatureConfig+0x164>)
 800d208:	f7fb fb92 	bl	8008930 <assert_failed>
    MODIFY_REG(huart->Instance->CR2, USART_CR2_ABREN, huart->AdvancedInit.AutoBaudRateEnable);
 800d20c:	6821      	ldr	r1, [r4, #0]
 800d20e:	6c22      	ldr	r2, [r4, #64]	; 0x40
 800d210:	684b      	ldr	r3, [r1, #4]
 800d212:	402b      	ands	r3, r5
 800d214:	4313      	orrs	r3, r2
 800d216:	604b      	str	r3, [r1, #4]
    if (huart->AdvancedInit.AutoBaudRateEnable == UART_ADVFEATURE_AUTOBAUDRATE_ENABLE)
 800d218:	2380      	movs	r3, #128	; 0x80
 800d21a:	035b      	lsls	r3, r3, #13
 800d21c:	429a      	cmp	r2, r3
 800d21e:	d10d      	bne.n	800d23c <UART_AdvFeatureConfig+0x13c>
      assert_param(IS_UART_ADVFEATURE_AUTOBAUDRATEMODE(huart->AdvancedInit.AutoBaudRateMode));
 800d220:	4d21      	ldr	r5, [pc, #132]	; (800d2a8 <UART_AdvFeatureConfig+0x1a8>)
 800d222:	6c63      	ldr	r3, [r4, #68]	; 0x44
 800d224:	422b      	tst	r3, r5
 800d226:	d003      	beq.n	800d230 <UART_AdvFeatureConfig+0x130>
 800d228:	4920      	ldr	r1, [pc, #128]	; (800d2ac <UART_AdvFeatureConfig+0x1ac>)
 800d22a:	480e      	ldr	r0, [pc, #56]	; (800d264 <UART_AdvFeatureConfig+0x164>)
 800d22c:	f7fb fb80 	bl	8008930 <assert_failed>
      MODIFY_REG(huart->Instance->CR2, USART_CR2_ABRMODE, huart->AdvancedInit.AutoBaudRateMode);
 800d230:	6822      	ldr	r2, [r4, #0]
 800d232:	6c61      	ldr	r1, [r4, #68]	; 0x44
 800d234:	6853      	ldr	r3, [r2, #4]
 800d236:	402b      	ands	r3, r5
 800d238:	430b      	orrs	r3, r1
 800d23a:	6053      	str	r3, [r2, #4]
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_MSBFIRST_INIT))
 800d23c:	6a63      	ldr	r3, [r4, #36]	; 0x24
 800d23e:	061b      	lsls	r3, r3, #24
 800d240:	d50d      	bpl.n	800d25e <UART_AdvFeatureConfig+0x15e>
    assert_param(IS_UART_ADVFEATURE_MSBFIRST(huart->AdvancedInit.MSBFirst));
 800d242:	4d1b      	ldr	r5, [pc, #108]	; (800d2b0 <UART_AdvFeatureConfig+0x1b0>)
 800d244:	6ca3      	ldr	r3, [r4, #72]	; 0x48
 800d246:	422b      	tst	r3, r5
 800d248:	d003      	beq.n	800d252 <UART_AdvFeatureConfig+0x152>
 800d24a:	491a      	ldr	r1, [pc, #104]	; (800d2b4 <UART_AdvFeatureConfig+0x1b4>)
 800d24c:	4805      	ldr	r0, [pc, #20]	; (800d264 <UART_AdvFeatureConfig+0x164>)
 800d24e:	f7fb fb6f 	bl	8008930 <assert_failed>
    MODIFY_REG(huart->Instance->CR2, USART_CR2_MSBFIRST, huart->AdvancedInit.MSBFirst);
 800d252:	6822      	ldr	r2, [r4, #0]
 800d254:	6ca1      	ldr	r1, [r4, #72]	; 0x48
 800d256:	6853      	ldr	r3, [r2, #4]
 800d258:	402b      	ands	r3, r5
 800d25a:	430b      	orrs	r3, r1
 800d25c:	6053      	str	r3, [r2, #4]
}
 800d25e:	bd70      	pop	{r4, r5, r6, pc}
 800d260:	00000c64 	.word	0x00000c64
 800d264:	080109b3 	.word	0x080109b3
 800d268:	fffdffff 	.word	0xfffdffff
 800d26c:	00000c69 	.word	0x00000c69
 800d270:	fffeffff 	.word	0xfffeffff
 800d274:	fffbffff 	.word	0xfffbffff
 800d278:	00000c77 	.word	0x00000c77
 800d27c:	ffff7fff 	.word	0xffff7fff
 800d280:	00000c7e 	.word	0x00000c7e
 800d284:	ffffefff 	.word	0xffffefff
 800d288:	00000c85 	.word	0x00000c85
 800d28c:	ffffdfff 	.word	0xffffdfff
 800d290:	00000c8c 	.word	0x00000c8c
 800d294:	40013800 	.word	0x40013800
 800d298:	40004400 	.word	0x40004400
 800d29c:	00000c93 	.word	0x00000c93
 800d2a0:	ffefffff 	.word	0xffefffff
 800d2a4:	00000c94 	.word	0x00000c94
 800d2a8:	ff9fffff 	.word	0xff9fffff
 800d2ac:	00000c99 	.word	0x00000c99
 800d2b0:	fff7ffff 	.word	0xfff7ffff
 800d2b4:	00000ca1 	.word	0x00000ca1

0800d2b8 <UART_WaitOnFlagUntilTimeout>:
{
 800d2b8:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
        if (__HAL_UART_GET_FLAG(huart, UART_FLAG_RTOF) == SET)
 800d2ba:	2780      	movs	r7, #128	; 0x80
{
 800d2bc:	0004      	movs	r4, r0
 800d2be:	000d      	movs	r5, r1
 800d2c0:	0016      	movs	r6, r2
 800d2c2:	9301      	str	r3, [sp, #4]
        if (__HAL_UART_GET_FLAG(huart, UART_FLAG_RTOF) == SET)
 800d2c4:	013f      	lsls	r7, r7, #4
  while ((__HAL_UART_GET_FLAG(huart, Flag) ? SET : RESET) == Status)
 800d2c6:	6822      	ldr	r2, [r4, #0]
 800d2c8:	69d3      	ldr	r3, [r2, #28]
 800d2ca:	402b      	ands	r3, r5
 800d2cc:	1b5b      	subs	r3, r3, r5
 800d2ce:	4259      	negs	r1, r3
 800d2d0:	414b      	adcs	r3, r1
 800d2d2:	42b3      	cmp	r3, r6
 800d2d4:	d001      	beq.n	800d2da <UART_WaitOnFlagUntilTimeout+0x22>
  return HAL_OK;
 800d2d6:	2000      	movs	r0, #0
 800d2d8:	e01c      	b.n	800d314 <UART_WaitOnFlagUntilTimeout+0x5c>
    if (Timeout != HAL_MAX_DELAY)
 800d2da:	9b08      	ldr	r3, [sp, #32]
 800d2dc:	3301      	adds	r3, #1
 800d2de:	d0f3      	beq.n	800d2c8 <UART_WaitOnFlagUntilTimeout+0x10>
      if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
 800d2e0:	f7fc fb6a 	bl	80099b8 <HAL_GetTick>
 800d2e4:	9b01      	ldr	r3, [sp, #4]
 800d2e6:	9a08      	ldr	r2, [sp, #32]
 800d2e8:	1ac0      	subs	r0, r0, r3
 800d2ea:	6823      	ldr	r3, [r4, #0]
 800d2ec:	4290      	cmp	r0, r2
 800d2ee:	d801      	bhi.n	800d2f4 <UART_WaitOnFlagUntilTimeout+0x3c>
 800d2f0:	2a00      	cmp	r2, #0
 800d2f2:	d110      	bne.n	800d316 <UART_WaitOnFlagUntilTimeout+0x5e>
        CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE | USART_CR1_TXEIE));
 800d2f4:	681a      	ldr	r2, [r3, #0]
 800d2f6:	4913      	ldr	r1, [pc, #76]	; (800d344 <UART_WaitOnFlagUntilTimeout+0x8c>)
 800d2f8:	400a      	ands	r2, r1
 800d2fa:	601a      	str	r2, [r3, #0]
        CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
 800d2fc:	689a      	ldr	r2, [r3, #8]
 800d2fe:	31a3      	adds	r1, #163	; 0xa3
 800d300:	31ff      	adds	r1, #255	; 0xff
 800d302:	438a      	bics	r2, r1
 800d304:	609a      	str	r2, [r3, #8]
        huart->gState = HAL_UART_STATE_READY;
 800d306:	2320      	movs	r3, #32
 800d308:	67a3      	str	r3, [r4, #120]	; 0x78
        huart->RxState = HAL_UART_STATE_READY;
 800d30a:	67e3      	str	r3, [r4, #124]	; 0x7c
          __HAL_UNLOCK(huart);
 800d30c:	2300      	movs	r3, #0
          return HAL_TIMEOUT;
 800d30e:	2003      	movs	r0, #3
          __HAL_UNLOCK(huart);
 800d310:	3474      	adds	r4, #116	; 0x74
 800d312:	7023      	strb	r3, [r4, #0]
}
 800d314:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
      if (READ_BIT(huart->Instance->CR1, USART_CR1_RE) != 0U)
 800d316:	2104      	movs	r1, #4
 800d318:	681a      	ldr	r2, [r3, #0]
 800d31a:	420a      	tst	r2, r1
 800d31c:	d0d3      	beq.n	800d2c6 <UART_WaitOnFlagUntilTimeout+0xe>
        if (__HAL_UART_GET_FLAG(huart, UART_FLAG_RTOF) == SET)
 800d31e:	69da      	ldr	r2, [r3, #28]
 800d320:	423a      	tst	r2, r7
 800d322:	d0d0      	beq.n	800d2c6 <UART_WaitOnFlagUntilTimeout+0xe>
          __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_RTOF);
 800d324:	621f      	str	r7, [r3, #32]
          CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE | USART_CR1_TXEIE));
 800d326:	681a      	ldr	r2, [r3, #0]
 800d328:	4906      	ldr	r1, [pc, #24]	; (800d344 <UART_WaitOnFlagUntilTimeout+0x8c>)
 800d32a:	400a      	ands	r2, r1
 800d32c:	601a      	str	r2, [r3, #0]
          CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
 800d32e:	689a      	ldr	r2, [r3, #8]
 800d330:	31a3      	adds	r1, #163	; 0xa3
 800d332:	31ff      	adds	r1, #255	; 0xff
 800d334:	438a      	bics	r2, r1
 800d336:	609a      	str	r2, [r3, #8]
          huart->gState = HAL_UART_STATE_READY;
 800d338:	2320      	movs	r3, #32
          huart->ErrorCode = HAL_UART_ERROR_RTO;
 800d33a:	1d22      	adds	r2, r4, #4
          huart->gState = HAL_UART_STATE_READY;
 800d33c:	67a3      	str	r3, [r4, #120]	; 0x78
          huart->RxState = HAL_UART_STATE_READY;
 800d33e:	67e3      	str	r3, [r4, #124]	; 0x7c
          huart->ErrorCode = HAL_UART_ERROR_RTO;
 800d340:	67d3      	str	r3, [r2, #124]	; 0x7c
 800d342:	e7e3      	b.n	800d30c <UART_WaitOnFlagUntilTimeout+0x54>
 800d344:	fffffe5f 	.word	0xfffffe5f

0800d348 <UART_CheckIdleState>:
{
 800d348:	b573      	push	{r0, r1, r4, r5, r6, lr}
  huart->ErrorCode = HAL_UART_ERROR_NONE;
 800d34a:	2600      	movs	r6, #0
{
 800d34c:	0004      	movs	r4, r0
  huart->ErrorCode = HAL_UART_ERROR_NONE;
 800d34e:	1d03      	adds	r3, r0, #4
 800d350:	67de      	str	r6, [r3, #124]	; 0x7c
  tickstart = HAL_GetTick();
 800d352:	f7fc fb31 	bl	80099b8 <HAL_GetTick>
  if ((huart->Instance->CR1 & USART_CR1_TE) == USART_CR1_TE)
 800d356:	6823      	ldr	r3, [r4, #0]
  tickstart = HAL_GetTick();
 800d358:	0005      	movs	r5, r0
  if ((huart->Instance->CR1 & USART_CR1_TE) == USART_CR1_TE)
 800d35a:	681b      	ldr	r3, [r3, #0]
 800d35c:	071b      	lsls	r3, r3, #28
 800d35e:	d416      	bmi.n	800d38e <UART_CheckIdleState+0x46>
  if ((huart->Instance->CR1 & USART_CR1_RE) == USART_CR1_RE)
 800d360:	6823      	ldr	r3, [r4, #0]
 800d362:	681b      	ldr	r3, [r3, #0]
 800d364:	075b      	lsls	r3, r3, #29
 800d366:	d50a      	bpl.n	800d37e <UART_CheckIdleState+0x36>
    if (UART_WaitOnFlagUntilTimeout(huart, USART_ISR_REACK, RESET, tickstart, HAL_UART_TIMEOUT_VALUE) != HAL_OK)
 800d368:	2180      	movs	r1, #128	; 0x80
 800d36a:	4b0f      	ldr	r3, [pc, #60]	; (800d3a8 <UART_CheckIdleState+0x60>)
 800d36c:	2200      	movs	r2, #0
 800d36e:	9300      	str	r3, [sp, #0]
 800d370:	0020      	movs	r0, r4
 800d372:	002b      	movs	r3, r5
 800d374:	03c9      	lsls	r1, r1, #15
 800d376:	f7ff ff9f 	bl	800d2b8 <UART_WaitOnFlagUntilTimeout>
 800d37a:	2800      	cmp	r0, #0
 800d37c:	d112      	bne.n	800d3a4 <UART_CheckIdleState+0x5c>
  huart->gState = HAL_UART_STATE_READY;
 800d37e:	2320      	movs	r3, #32
  huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
 800d380:	2000      	movs	r0, #0
  huart->gState = HAL_UART_STATE_READY;
 800d382:	67a3      	str	r3, [r4, #120]	; 0x78
  huart->RxState = HAL_UART_STATE_READY;
 800d384:	67e3      	str	r3, [r4, #124]	; 0x7c
  huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
 800d386:	6620      	str	r0, [r4, #96]	; 0x60
  __HAL_UNLOCK(huart);
 800d388:	3474      	adds	r4, #116	; 0x74
 800d38a:	7020      	strb	r0, [r4, #0]
  return HAL_OK;
 800d38c:	e00b      	b.n	800d3a6 <UART_CheckIdleState+0x5e>
    if (UART_WaitOnFlagUntilTimeout(huart, USART_ISR_TEACK, RESET, tickstart, HAL_UART_TIMEOUT_VALUE) != HAL_OK)
 800d38e:	2180      	movs	r1, #128	; 0x80
 800d390:	4b05      	ldr	r3, [pc, #20]	; (800d3a8 <UART_CheckIdleState+0x60>)
 800d392:	0032      	movs	r2, r6
 800d394:	9300      	str	r3, [sp, #0]
 800d396:	0389      	lsls	r1, r1, #14
 800d398:	0003      	movs	r3, r0
 800d39a:	0020      	movs	r0, r4
 800d39c:	f7ff ff8c 	bl	800d2b8 <UART_WaitOnFlagUntilTimeout>
 800d3a0:	2800      	cmp	r0, #0
 800d3a2:	d0dd      	beq.n	800d360 <UART_CheckIdleState+0x18>
      return HAL_TIMEOUT;
 800d3a4:	2003      	movs	r0, #3
}
 800d3a6:	bd76      	pop	{r1, r2, r4, r5, r6, pc}
 800d3a8:	01ffffff 	.word	0x01ffffff

0800d3ac <HAL_UART_Init>:
{
 800d3ac:	b510      	push	{r4, lr}
 800d3ae:	1e04      	subs	r4, r0, #0
  if (huart == NULL)
 800d3b0:	d101      	bne.n	800d3b6 <HAL_UART_Init+0xa>
    return HAL_ERROR;
 800d3b2:	2001      	movs	r0, #1
}
 800d3b4:	bd10      	pop	{r4, pc}
  if (huart->Init.HwFlowCtl != UART_HWCONTROL_NONE)
 800d3b6:	6981      	ldr	r1, [r0, #24]
 800d3b8:	6803      	ldr	r3, [r0, #0]
 800d3ba:	4a26      	ldr	r2, [pc, #152]	; (800d454 <HAL_UART_Init+0xa8>)
 800d3bc:	2900      	cmp	r1, #0
 800d3be:	d03b      	beq.n	800d438 <HAL_UART_Init+0x8c>
    assert_param(IS_UART_HWFLOW_INSTANCE(huart->Instance));
 800d3c0:	4293      	cmp	r3, r2
 800d3c2:	d00d      	beq.n	800d3e0 <HAL_UART_Init+0x34>
 800d3c4:	4a24      	ldr	r2, [pc, #144]	; (800d458 <HAL_UART_Init+0xac>)
 800d3c6:	4293      	cmp	r3, r2
 800d3c8:	d00a      	beq.n	800d3e0 <HAL_UART_Init+0x34>
 800d3ca:	4a24      	ldr	r2, [pc, #144]	; (800d45c <HAL_UART_Init+0xb0>)
 800d3cc:	4293      	cmp	r3, r2
 800d3ce:	d007      	beq.n	800d3e0 <HAL_UART_Init+0x34>
 800d3d0:	4a23      	ldr	r2, [pc, #140]	; (800d460 <HAL_UART_Init+0xb4>)
 800d3d2:	4293      	cmp	r3, r2
 800d3d4:	d004      	beq.n	800d3e0 <HAL_UART_Init+0x34>
 800d3d6:	212c      	movs	r1, #44	; 0x2c
 800d3d8:	31ff      	adds	r1, #255	; 0xff
    assert_param(IS_UART_INSTANCE(huart->Instance));
 800d3da:	4822      	ldr	r0, [pc, #136]	; (800d464 <HAL_UART_Init+0xb8>)
 800d3dc:	f7fb faa8 	bl	8008930 <assert_failed>
  if (huart->gState == HAL_UART_STATE_RESET)
 800d3e0:	6fa3      	ldr	r3, [r4, #120]	; 0x78
 800d3e2:	2b00      	cmp	r3, #0
 800d3e4:	d105      	bne.n	800d3f2 <HAL_UART_Init+0x46>
    huart->Lock = HAL_UNLOCKED;
 800d3e6:	0022      	movs	r2, r4
 800d3e8:	3274      	adds	r2, #116	; 0x74
    HAL_UART_MspInit(huart);
 800d3ea:	0020      	movs	r0, r4
    huart->Lock = HAL_UNLOCKED;
 800d3ec:	7013      	strb	r3, [r2, #0]
    HAL_UART_MspInit(huart);
 800d3ee:	f7fb fc5b 	bl	8008ca8 <HAL_UART_MspInit>
  huart->gState = HAL_UART_STATE_BUSY;
 800d3f2:	2324      	movs	r3, #36	; 0x24
  __HAL_UART_DISABLE(huart);
 800d3f4:	2101      	movs	r1, #1
 800d3f6:	6822      	ldr	r2, [r4, #0]
  huart->gState = HAL_UART_STATE_BUSY;
 800d3f8:	67a3      	str	r3, [r4, #120]	; 0x78
  __HAL_UART_DISABLE(huart);
 800d3fa:	6813      	ldr	r3, [r2, #0]
  if (UART_SetConfig(huart) == HAL_ERROR)
 800d3fc:	0020      	movs	r0, r4
  __HAL_UART_DISABLE(huart);
 800d3fe:	438b      	bics	r3, r1
 800d400:	6013      	str	r3, [r2, #0]
  if (UART_SetConfig(huart) == HAL_ERROR)
 800d402:	f7ff fd73 	bl	800ceec <UART_SetConfig>
 800d406:	2801      	cmp	r0, #1
 800d408:	d0d3      	beq.n	800d3b2 <HAL_UART_Init+0x6>
  if (huart->AdvancedInit.AdvFeatureInit != UART_ADVFEATURE_NO_INIT)
 800d40a:	6a63      	ldr	r3, [r4, #36]	; 0x24
 800d40c:	2b00      	cmp	r3, #0
 800d40e:	d002      	beq.n	800d416 <HAL_UART_Init+0x6a>
    UART_AdvFeatureConfig(huart);
 800d410:	0020      	movs	r0, r4
 800d412:	f7ff fe75 	bl	800d100 <UART_AdvFeatureConfig>
  CLEAR_BIT(huart->Instance->CR2, USART_CR2_CLKEN);
 800d416:	6823      	ldr	r3, [r4, #0]
 800d418:	4913      	ldr	r1, [pc, #76]	; (800d468 <HAL_UART_Init+0xbc>)
 800d41a:	685a      	ldr	r2, [r3, #4]
  return (UART_CheckIdleState(huart));
 800d41c:	0020      	movs	r0, r4
  CLEAR_BIT(huart->Instance->CR2, USART_CR2_CLKEN);
 800d41e:	400a      	ands	r2, r1
  CLEAR_BIT(huart->Instance->CR3, USART_CR3_HDSEL);
 800d420:	2108      	movs	r1, #8
  CLEAR_BIT(huart->Instance->CR2, USART_CR2_CLKEN);
 800d422:	605a      	str	r2, [r3, #4]
  CLEAR_BIT(huart->Instance->CR3, USART_CR3_HDSEL);
 800d424:	689a      	ldr	r2, [r3, #8]
 800d426:	438a      	bics	r2, r1
 800d428:	609a      	str	r2, [r3, #8]
  __HAL_UART_ENABLE(huart);
 800d42a:	2201      	movs	r2, #1
 800d42c:	6819      	ldr	r1, [r3, #0]
 800d42e:	430a      	orrs	r2, r1
 800d430:	601a      	str	r2, [r3, #0]
  return (UART_CheckIdleState(huart));
 800d432:	f7ff ff89 	bl	800d348 <UART_CheckIdleState>
 800d436:	e7bd      	b.n	800d3b4 <HAL_UART_Init+0x8>
    assert_param(IS_UART_INSTANCE(huart->Instance));
 800d438:	4293      	cmp	r3, r2
 800d43a:	d0d1      	beq.n	800d3e0 <HAL_UART_Init+0x34>
 800d43c:	4a06      	ldr	r2, [pc, #24]	; (800d458 <HAL_UART_Init+0xac>)
 800d43e:	4293      	cmp	r3, r2
 800d440:	d0ce      	beq.n	800d3e0 <HAL_UART_Init+0x34>
 800d442:	4a06      	ldr	r2, [pc, #24]	; (800d45c <HAL_UART_Init+0xb0>)
 800d444:	4293      	cmp	r3, r2
 800d446:	d0cb      	beq.n	800d3e0 <HAL_UART_Init+0x34>
 800d448:	4a05      	ldr	r2, [pc, #20]	; (800d460 <HAL_UART_Init+0xb4>)
 800d44a:	4293      	cmp	r3, r2
 800d44c:	d0c8      	beq.n	800d3e0 <HAL_UART_Init+0x34>
 800d44e:	2198      	movs	r1, #152	; 0x98
 800d450:	0049      	lsls	r1, r1, #1
 800d452:	e7c2      	b.n	800d3da <HAL_UART_Init+0x2e>
 800d454:	40013800 	.word	0x40013800
 800d458:	40004400 	.word	0x40004400
 800d45c:	40004800 	.word	0x40004800
 800d460:	40004c00 	.word	0x40004c00
 800d464:	080109b3 	.word	0x080109b3
 800d468:	fffff7ff 	.word	0xfffff7ff

0800d46c <UART_Start_Receive_IT>:
  huart->RxXferSize  = Size;
 800d46c:	0003      	movs	r3, r0
 800d46e:	3358      	adds	r3, #88	; 0x58
{
 800d470:	b510      	push	{r4, lr}
  huart->pRxBuffPtr  = pData;
 800d472:	6541      	str	r1, [r0, #84]	; 0x54
  UART_MASK_COMPUTATION(huart);
 800d474:	2480      	movs	r4, #128	; 0x80
  huart->RxXferSize  = Size;
 800d476:	801a      	strh	r2, [r3, #0]
  huart->RxXferCount = Size;
 800d478:	805a      	strh	r2, [r3, #2]
  huart->RxISR       = NULL;
 800d47a:	2200      	movs	r2, #0
  UART_MASK_COMPUTATION(huart);
 800d47c:	6881      	ldr	r1, [r0, #8]
  huart->RxISR       = NULL;
 800d47e:	6642      	str	r2, [r0, #100]	; 0x64
  UART_MASK_COMPUTATION(huart);
 800d480:	0164      	lsls	r4, r4, #5
 800d482:	3304      	adds	r3, #4
 800d484:	42a1      	cmp	r1, r4
 800d486:	d124      	bne.n	800d4d2 <UART_Start_Receive_IT+0x66>
 800d488:	6902      	ldr	r2, [r0, #16]
 800d48a:	2a00      	cmp	r2, #0
 800d48c:	d11f      	bne.n	800d4ce <UART_Start_Receive_IT+0x62>
 800d48e:	4a19      	ldr	r2, [pc, #100]	; (800d4f4 <UART_Start_Receive_IT+0x88>)
 800d490:	801a      	strh	r2, [r3, #0]
  huart->ErrorCode = HAL_UART_ERROR_NONE;
 800d492:	2200      	movs	r2, #0
 800d494:	1d03      	adds	r3, r0, #4
 800d496:	67da      	str	r2, [r3, #124]	; 0x7c
  huart->RxState = HAL_UART_STATE_BUSY_RX;
 800d498:	2322      	movs	r3, #34	; 0x22
  SET_BIT(huart->Instance->CR3, USART_CR3_EIE);
 800d49a:	6802      	ldr	r2, [r0, #0]
  huart->RxState = HAL_UART_STATE_BUSY_RX;
 800d49c:	67c3      	str	r3, [r0, #124]	; 0x7c
  SET_BIT(huart->Instance->CR3, USART_CR3_EIE);
 800d49e:	6894      	ldr	r4, [r2, #8]
 800d4a0:	3b21      	subs	r3, #33	; 0x21
 800d4a2:	4323      	orrs	r3, r4
  if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
 800d4a4:	2480      	movs	r4, #128	; 0x80
  SET_BIT(huart->Instance->CR3, USART_CR3_EIE);
 800d4a6:	6093      	str	r3, [r2, #8]
  if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
 800d4a8:	0164      	lsls	r4, r4, #5
    huart->RxISR = UART_RxISR_8BIT;
 800d4aa:	4b13      	ldr	r3, [pc, #76]	; (800d4f8 <UART_Start_Receive_IT+0x8c>)
  if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
 800d4ac:	42a1      	cmp	r1, r4
 800d4ae:	d103      	bne.n	800d4b8 <UART_Start_Receive_IT+0x4c>
 800d4b0:	6901      	ldr	r1, [r0, #16]
 800d4b2:	2900      	cmp	r1, #0
 800d4b4:	d100      	bne.n	800d4b8 <UART_Start_Receive_IT+0x4c>
    huart->RxISR = UART_RxISR_16BIT;
 800d4b6:	4b11      	ldr	r3, [pc, #68]	; (800d4fc <UART_Start_Receive_IT+0x90>)
 800d4b8:	6643      	str	r3, [r0, #100]	; 0x64
  __HAL_UNLOCK(huart);
 800d4ba:	0003      	movs	r3, r0
 800d4bc:	2000      	movs	r0, #0
 800d4be:	3374      	adds	r3, #116	; 0x74
 800d4c0:	7018      	strb	r0, [r3, #0]
  SET_BIT(huart->Instance->CR1, USART_CR1_PEIE | USART_CR1_RXNEIE);
 800d4c2:	2390      	movs	r3, #144	; 0x90
 800d4c4:	6811      	ldr	r1, [r2, #0]
 800d4c6:	005b      	lsls	r3, r3, #1
 800d4c8:	430b      	orrs	r3, r1
 800d4ca:	6013      	str	r3, [r2, #0]
}
 800d4cc:	bd10      	pop	{r4, pc}
  UART_MASK_COMPUTATION(huart);
 800d4ce:	22ff      	movs	r2, #255	; 0xff
 800d4d0:	e7de      	b.n	800d490 <UART_Start_Receive_IT+0x24>
 800d4d2:	2900      	cmp	r1, #0
 800d4d4:	d104      	bne.n	800d4e0 <UART_Start_Receive_IT+0x74>
 800d4d6:	6902      	ldr	r2, [r0, #16]
 800d4d8:	2a00      	cmp	r2, #0
 800d4da:	d0f8      	beq.n	800d4ce <UART_Start_Receive_IT+0x62>
 800d4dc:	227f      	movs	r2, #127	; 0x7f
 800d4de:	e7d7      	b.n	800d490 <UART_Start_Receive_IT+0x24>
 800d4e0:	2480      	movs	r4, #128	; 0x80
 800d4e2:	0564      	lsls	r4, r4, #21
 800d4e4:	42a1      	cmp	r1, r4
 800d4e6:	d1d3      	bne.n	800d490 <UART_Start_Receive_IT+0x24>
 800d4e8:	6902      	ldr	r2, [r0, #16]
 800d4ea:	2a00      	cmp	r2, #0
 800d4ec:	d0f6      	beq.n	800d4dc <UART_Start_Receive_IT+0x70>
 800d4ee:	223f      	movs	r2, #63	; 0x3f
 800d4f0:	e7ce      	b.n	800d490 <UART_Start_Receive_IT+0x24>
 800d4f2:	46c0      	nop			; (mov r8, r8)
 800d4f4:	000001ff 	.word	0x000001ff
 800d4f8:	0800cde9 	.word	0x0800cde9
 800d4fc:	0800ce6d 	.word	0x0800ce6d

0800d500 <HAL_UART_Receive_IT>:
{
 800d500:	b570      	push	{r4, r5, r6, lr}
  if (huart->RxState == HAL_UART_STATE_READY)
 800d502:	6fc4      	ldr	r4, [r0, #124]	; 0x7c
    return HAL_BUSY;
 800d504:	2302      	movs	r3, #2
  if (huart->RxState == HAL_UART_STATE_READY)
 800d506:	2c20      	cmp	r4, #32
 800d508:	d126      	bne.n	800d558 <HAL_UART_Receive_IT+0x58>
      return HAL_ERROR;
 800d50a:	3b01      	subs	r3, #1
    if ((pData == NULL) || (Size == 0U))
 800d50c:	2900      	cmp	r1, #0
 800d50e:	d023      	beq.n	800d558 <HAL_UART_Receive_IT+0x58>
 800d510:	2a00      	cmp	r2, #0
 800d512:	d021      	beq.n	800d558 <HAL_UART_Receive_IT+0x58>
    if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
 800d514:	2380      	movs	r3, #128	; 0x80
 800d516:	6884      	ldr	r4, [r0, #8]
 800d518:	015b      	lsls	r3, r3, #5
 800d51a:	429c      	cmp	r4, r3
 800d51c:	d106      	bne.n	800d52c <HAL_UART_Receive_IT+0x2c>
 800d51e:	6903      	ldr	r3, [r0, #16]
 800d520:	2b00      	cmp	r3, #0
 800d522:	d103      	bne.n	800d52c <HAL_UART_Receive_IT+0x2c>
      if ((((uint32_t)pData) & 1U) != 0U)
 800d524:	2401      	movs	r4, #1
      return HAL_ERROR;
 800d526:	0023      	movs	r3, r4
      if ((((uint32_t)pData) & 1U) != 0U)
 800d528:	4221      	tst	r1, r4
 800d52a:	d115      	bne.n	800d558 <HAL_UART_Receive_IT+0x58>
    __HAL_LOCK(huart);
 800d52c:	0004      	movs	r4, r0
 800d52e:	3474      	adds	r4, #116	; 0x74
 800d530:	7825      	ldrb	r5, [r4, #0]
    return HAL_BUSY;
 800d532:	2302      	movs	r3, #2
    __HAL_LOCK(huart);
 800d534:	2d01      	cmp	r5, #1
 800d536:	d00f      	beq.n	800d558 <HAL_UART_Receive_IT+0x58>
 800d538:	3b01      	subs	r3, #1
 800d53a:	7023      	strb	r3, [r4, #0]
    huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
 800d53c:	2300      	movs	r3, #0
 800d53e:	6603      	str	r3, [r0, #96]	; 0x60
    if(READ_BIT(huart->Instance->CR2, USART_CR2_RTOEN) != 0U)
 800d540:	6803      	ldr	r3, [r0, #0]
 800d542:	685c      	ldr	r4, [r3, #4]
 800d544:	0224      	lsls	r4, r4, #8
 800d546:	d504      	bpl.n	800d552 <HAL_UART_Receive_IT+0x52>
      SET_BIT(huart->Instance->CR1, USART_CR1_RTOIE);
 800d548:	2480      	movs	r4, #128	; 0x80
 800d54a:	681d      	ldr	r5, [r3, #0]
 800d54c:	04e4      	lsls	r4, r4, #19
 800d54e:	432c      	orrs	r4, r5
 800d550:	601c      	str	r4, [r3, #0]
    return(UART_Start_Receive_IT(huart, pData, Size));
 800d552:	f7ff ff8b 	bl	800d46c <UART_Start_Receive_IT>
 800d556:	0003      	movs	r3, r0
}
 800d558:	0018      	movs	r0, r3
 800d55a:	bd70      	pop	{r4, r5, r6, pc}

0800d55c <USB_EnableGlobalInt>:
HAL_StatusTypeDef USB_EnableGlobalInt(USB_TypeDef *USBx)
{
  uint32_t winterruptmask;

  /* Clear pending interrupts */
  USBx->ISTR = 0U;
 800d55c:	1d82      	adds	r2, r0, #6
{
 800d55e:	0003      	movs	r3, r0
  USBx->ISTR = 0U;
 800d560:	2000      	movs	r0, #0
 800d562:	87d0      	strh	r0, [r2, #62]	; 0x3e
                   USB_CNTR_SUSPM | USB_CNTR_ERRM |
                   USB_CNTR_SOFM | USB_CNTR_ESOFM |
                   USB_CNTR_RESETM | USB_CNTR_L1REQM;

  /* Set interrupt mask */
  USBx->CNTR = (uint16_t)winterruptmask;
 800d564:	4a01      	ldr	r2, [pc, #4]	; (800d56c <USB_EnableGlobalInt+0x10>)
 800d566:	3302      	adds	r3, #2
 800d568:	87da      	strh	r2, [r3, #62]	; 0x3e

  return HAL_OK;
}
 800d56a:	4770      	bx	lr
 800d56c:	ffffbf80 	.word	0xffffbf80

0800d570 <USB_DisableGlobalInt>:
                   USB_CNTR_SUSPM | USB_CNTR_ERRM |
                   USB_CNTR_SOFM | USB_CNTR_ESOFM |
                   USB_CNTR_RESETM | USB_CNTR_L1REQM;

  /* Clear interrupt mask */
  USBx->CNTR &= (uint16_t)(~winterruptmask);
 800d570:	3002      	adds	r0, #2
 800d572:	8fc3      	ldrh	r3, [r0, #62]	; 0x3e
 800d574:	4a02      	ldr	r2, [pc, #8]	; (800d580 <USB_DisableGlobalInt+0x10>)
 800d576:	4013      	ands	r3, r2
 800d578:	87c3      	strh	r3, [r0, #62]	; 0x3e

  return HAL_OK;
}
 800d57a:	2000      	movs	r0, #0
 800d57c:	4770      	bx	lr
 800d57e:	46c0      	nop			; (mov r8, r8)
 800d580:	0000407f 	.word	0x0000407f

0800d584 <USB_DevInit>:
  * @param  cfg  pointer to a USB_CfgTypeDef structure that contains
  *         the configuration information for the specified USBx peripheral.
  * @retval HAL status
  */
HAL_StatusTypeDef USB_DevInit(USB_TypeDef *USBx, USB_CfgTypeDef cfg)
{
 800d584:	b084      	sub	sp, #16
 800d586:	b510      	push	{r4, lr}
 800d588:	0004      	movs	r4, r0
 800d58a:	9204      	str	r2, [sp, #16]
 800d58c:	9305      	str	r3, [sp, #20]
  /* Prevent unused argument(s) compilation warning */
  UNUSED(cfg);

  /* Init Device */
  /* CNTR_FRES = 1 */
  USBx->CNTR = (uint16_t)USB_CNTR_FRES;
 800d58e:	2201      	movs	r2, #1
 800d590:	1c83      	adds	r3, r0, #2

  /* CNTR_FRES = 0 */
  USBx->CNTR = 0U;
 800d592:	2000      	movs	r0, #0
  USBx->CNTR = (uint16_t)USB_CNTR_FRES;
 800d594:	87da      	strh	r2, [r3, #62]	; 0x3e
  USBx->CNTR = 0U;
 800d596:	87d8      	strh	r0, [r3, #62]	; 0x3e

  /* Clear pending interrupts */
  USBx->ISTR = 0U;
 800d598:	1da3      	adds	r3, r4, #6

  /*Set Btable Address*/
  USBx->BTABLE = BTABLE_ADDRESS;
 800d59a:	3450      	adds	r4, #80	; 0x50
  USBx->ISTR = 0U;
 800d59c:	87d8      	strh	r0, [r3, #62]	; 0x3e
{
 800d59e:	9103      	str	r1, [sp, #12]
  USBx->BTABLE = BTABLE_ADDRESS;
 800d5a0:	8020      	strh	r0, [r4, #0]

  return HAL_OK;
}
 800d5a2:	bc10      	pop	{r4}
 800d5a4:	bc08      	pop	{r3}
 800d5a6:	b004      	add	sp, #16
 800d5a8:	4718      	bx	r3
	...

0800d5ac <USB_ActivateEndpoint>:
  * @param  USBx Selected device
  * @param  ep pointer to endpoint structure
  * @retval HAL status
  */
HAL_StatusTypeDef USB_ActivateEndpoint(USB_TypeDef *USBx, USB_EPTypeDef *ep)
{
 800d5ac:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
  HAL_StatusTypeDef ret = HAL_OK;
  uint16_t wEpRegVal;

  wEpRegVal = PCD_GET_ENDPOINT(USBx, ep->num) & USB_EP_T_MASK;
 800d5ae:	780d      	ldrb	r5, [r1, #0]
{
 800d5b0:	0003      	movs	r3, r0
  wEpRegVal = PCD_GET_ENDPOINT(USBx, ep->num) & USB_EP_T_MASK;
 800d5b2:	00ad      	lsls	r5, r5, #2
 800d5b4:	1945      	adds	r5, r0, r5
 800d5b6:	882c      	ldrh	r4, [r5, #0]
 800d5b8:	4a8a      	ldr	r2, [pc, #552]	; (800d7e4 <USB_ActivateEndpoint+0x238>)

  /* initialize Endpoint */
  switch (ep->type)
 800d5ba:	78c8      	ldrb	r0, [r1, #3]
  wEpRegVal = PCD_GET_ENDPOINT(USBx, ep->num) & USB_EP_T_MASK;
 800d5bc:	4014      	ands	r4, r2
  switch (ep->type)
 800d5be:	2803      	cmp	r0, #3
 800d5c0:	d84b      	bhi.n	800d65a <USB_ActivateEndpoint+0xae>
 800d5c2:	f7fa fdb3 	bl	800812c <__gnu_thumb1_case_uqi>
 800d5c6:	4802      	.short	0x4802
 800d5c8:	4346      	.short	0x4346
  {
    case EP_TYPE_CTRL:
      wEpRegVal |= USB_EP_CONTROL;
 800d5ca:	2280      	movs	r2, #128	; 0x80
 800d5cc:	0092      	lsls	r2, r2, #2
 800d5ce:	4314      	orrs	r4, r2
    default:
      ret = HAL_ERROR;
      break;
  }

  PCD_SET_ENDPOINT(USBx, ep->num, (wEpRegVal | USB_EP_CTR_RX | USB_EP_CTR_TX));
 800d5d0:	4a85      	ldr	r2, [pc, #532]	; (800d7e8 <USB_ActivateEndpoint+0x23c>)

  PCD_SET_EP_ADDRESS(USBx, ep->num, ep->num);
 800d5d2:	4f86      	ldr	r7, [pc, #536]	; (800d7ec <USB_ActivateEndpoint+0x240>)
  PCD_SET_ENDPOINT(USBx, ep->num, (wEpRegVal | USB_EP_CTR_RX | USB_EP_CTR_TX));
 800d5d4:	4314      	orrs	r4, r2
 800d5d6:	b2a4      	uxth	r4, r4
 800d5d8:	802c      	strh	r4, [r5, #0]
  PCD_SET_EP_ADDRESS(USBx, ep->num, ep->num);
 800d5da:	780e      	ldrb	r6, [r1, #0]
 800d5dc:	46bc      	mov	ip, r7
 800d5de:	00b5      	lsls	r5, r6, #2
 800d5e0:	195d      	adds	r5, r3, r5
 800d5e2:	882c      	ldrh	r4, [r5, #0]
 800d5e4:	403c      	ands	r4, r7
 800d5e6:	4334      	orrs	r4, r6
 800d5e8:	001e      	movs	r6, r3
 800d5ea:	4314      	orrs	r4, r2
 800d5ec:	b2a4      	uxth	r4, r4
 800d5ee:	802c      	strh	r4, [r5, #0]

  if (ep->doublebuffer == 0U)
 800d5f0:	7b0d      	ldrb	r5, [r1, #12]
 800d5f2:	780c      	ldrb	r4, [r1, #0]
 800d5f4:	3650      	adds	r6, #80	; 0x50
 800d5f6:	2d00      	cmp	r5, #0
 800d5f8:	d000      	beq.n	800d5fc <USB_ActivateEndpoint+0x50>
 800d5fa:	e076      	b.n	800d6ea <USB_ActivateEndpoint+0x13e>
  {
    if (ep->is_in != 0U)
 800d5fc:	00e4      	lsls	r4, r4, #3
 800d5fe:	18e4      	adds	r4, r4, r3
 800d600:	88cd      	ldrh	r5, [r1, #6]
 800d602:	9401      	str	r4, [sp, #4]
 800d604:	784c      	ldrb	r4, [r1, #1]
 800d606:	086d      	lsrs	r5, r5, #1
 800d608:	006d      	lsls	r5, r5, #1
 800d60a:	2c00      	cmp	r4, #0
 800d60c:	d02a      	beq.n	800d664 <USB_ActivateEndpoint+0xb8>
    {
      /*Set the endpoint Transmit buffer address */
      PCD_SET_EP_TX_ADDRESS(USBx, ep->num, ep->pmaadress);
 800d60e:	8836      	ldrh	r6, [r6, #0]
 800d610:	9c01      	ldr	r4, [sp, #4]
 800d612:	1934      	adds	r4, r6, r4
 800d614:	2680      	movs	r6, #128	; 0x80
 800d616:	00f6      	lsls	r6, r6, #3
 800d618:	19a4      	adds	r4, r4, r6
 800d61a:	8025      	strh	r5, [r4, #0]
      PCD_CLEAR_TX_DTOG(USBx, ep->num);
 800d61c:	780c      	ldrb	r4, [r1, #0]
 800d61e:	00a4      	lsls	r4, r4, #2
 800d620:	191c      	adds	r4, r3, r4
 800d622:	8825      	ldrh	r5, [r4, #0]
 800d624:	066d      	lsls	r5, r5, #25
 800d626:	d504      	bpl.n	800d632 <USB_ActivateEndpoint+0x86>
 800d628:	8825      	ldrh	r5, [r4, #0]
 800d62a:	402f      	ands	r7, r5
 800d62c:	4d70      	ldr	r5, [pc, #448]	; (800d7f0 <USB_ActivateEndpoint+0x244>)
 800d62e:	432f      	orrs	r7, r5
 800d630:	8027      	strh	r7, [r4, #0]

      if (ep->type != EP_TYPE_ISOC)
 800d632:	780c      	ldrb	r4, [r1, #0]
 800d634:	78c9      	ldrb	r1, [r1, #3]
 800d636:	00a4      	lsls	r4, r4, #2
 800d638:	191b      	adds	r3, r3, r4
 800d63a:	4c6e      	ldr	r4, [pc, #440]	; (800d7f4 <USB_ActivateEndpoint+0x248>)
 800d63c:	2901      	cmp	r1, #1
 800d63e:	d00e      	beq.n	800d65e <USB_ActivateEndpoint+0xb2>
      {
        /* Configure NAK status for the Endpoint */
        PCD_SET_EP_TX_STATUS(USBx, ep->num, USB_EP_TX_NAK);
 800d640:	8819      	ldrh	r1, [r3, #0]
 800d642:	400c      	ands	r4, r1
 800d644:	2120      	movs	r1, #32
      /*Set the endpoint Receive buffer counter*/
      PCD_SET_EP_RX_CNT(USBx, ep->num, ep->maxpacket);
      PCD_CLEAR_RX_DTOG(USBx, ep->num);

      /* Configure VALID status for the Endpoint*/
      PCD_SET_EP_RX_STATUS(USBx, ep->num, USB_EP_RX_VALID);
 800d646:	4061      	eors	r1, r4
      {
        /* Configure TX Endpoint to disabled state */
        PCD_SET_EP_TX_STATUS(USBx, ep->num, USB_EP_TX_DIS);
      }

      PCD_SET_EP_RX_STATUS(USBx, ep->num, USB_EP_RX_DIS);
 800d648:	430a      	orrs	r2, r1
 800d64a:	e09c      	b.n	800d786 <USB_ActivateEndpoint+0x1da>
      wEpRegVal |= USB_EP_INTERRUPT;
 800d64c:	22c0      	movs	r2, #192	; 0xc0
 800d64e:	00d2      	lsls	r2, r2, #3
 800d650:	4314      	orrs	r4, r2
  HAL_StatusTypeDef ret = HAL_OK;
 800d652:	2000      	movs	r0, #0
      break;
 800d654:	e7bc      	b.n	800d5d0 <USB_ActivateEndpoint+0x24>
      wEpRegVal |= USB_EP_ISOCHRONOUS;
 800d656:	2280      	movs	r2, #128	; 0x80
 800d658:	e7f9      	b.n	800d64e <USB_ActivateEndpoint+0xa2>
      ret = HAL_ERROR;
 800d65a:	2001      	movs	r0, #1
 800d65c:	e7b8      	b.n	800d5d0 <USB_ActivateEndpoint+0x24>
        PCD_SET_EP_TX_STATUS(USBx, ep->num, USB_EP_TX_DIS);
 800d65e:	8819      	ldrh	r1, [r3, #0]
      PCD_SET_EP_RX_STATUS(USBx, ep->num, USB_EP_RX_DIS);
 800d660:	4021      	ands	r1, r4
 800d662:	e7f1      	b.n	800d648 <USB_ActivateEndpoint+0x9c>
      PCD_SET_EP_RX_ADDRESS(USBx, ep->num, ep->pmaadress);
 800d664:	8837      	ldrh	r7, [r6, #0]
 800d666:	9c01      	ldr	r4, [sp, #4]
 800d668:	193c      	adds	r4, r7, r4
 800d66a:	4f63      	ldr	r7, [pc, #396]	; (800d7f8 <USB_ActivateEndpoint+0x24c>)
 800d66c:	19e4      	adds	r4, r4, r7
 800d66e:	8025      	strh	r5, [r4, #0]
      PCD_SET_EP_RX_CNT(USBx, ep->num, ep->maxpacket);
 800d670:	780c      	ldrb	r4, [r1, #0]
 800d672:	8835      	ldrh	r5, [r6, #0]
 800d674:	00e4      	lsls	r4, r4, #3
 800d676:	4e61      	ldr	r6, [pc, #388]	; (800d7fc <USB_ActivateEndpoint+0x250>)
 800d678:	18e4      	adds	r4, r4, r3
 800d67a:	19a4      	adds	r4, r4, r6
 800d67c:	1964      	adds	r4, r4, r5
 800d67e:	690d      	ldr	r5, [r1, #16]
 800d680:	2d00      	cmp	r5, #0
 800d682:	d11d      	bne.n	800d6c0 <USB_ActivateEndpoint+0x114>
 800d684:	8825      	ldrh	r5, [r4, #0]
 800d686:	4e5e      	ldr	r6, [pc, #376]	; (800d800 <USB_ActivateEndpoint+0x254>)
 800d688:	4035      	ands	r5, r6
 800d68a:	2680      	movs	r6, #128	; 0x80
 800d68c:	8025      	strh	r5, [r4, #0]
 800d68e:	8825      	ldrh	r5, [r4, #0]
 800d690:	0236      	lsls	r6, r6, #8
 800d692:	4335      	orrs	r5, r6
 800d694:	8025      	strh	r5, [r4, #0]
      PCD_CLEAR_RX_DTOG(USBx, ep->num);
 800d696:	780c      	ldrb	r4, [r1, #0]
 800d698:	00a4      	lsls	r4, r4, #2
 800d69a:	191c      	adds	r4, r3, r4
 800d69c:	8825      	ldrh	r5, [r4, #0]
 800d69e:	046d      	lsls	r5, r5, #17
 800d6a0:	d505      	bpl.n	800d6ae <USB_ActivateEndpoint+0x102>
 800d6a2:	4666      	mov	r6, ip
 800d6a4:	8825      	ldrh	r5, [r4, #0]
 800d6a6:	4035      	ands	r5, r6
 800d6a8:	4e56      	ldr	r6, [pc, #344]	; (800d804 <USB_ActivateEndpoint+0x258>)
 800d6aa:	4335      	orrs	r5, r6
 800d6ac:	8025      	strh	r5, [r4, #0]
      PCD_SET_EP_RX_STATUS(USBx, ep->num, USB_EP_RX_VALID);
 800d6ae:	7809      	ldrb	r1, [r1, #0]
 800d6b0:	4c55      	ldr	r4, [pc, #340]	; (800d808 <USB_ActivateEndpoint+0x25c>)
 800d6b2:	0089      	lsls	r1, r1, #2
 800d6b4:	185b      	adds	r3, r3, r1
 800d6b6:	8819      	ldrh	r1, [r3, #0]
 800d6b8:	400c      	ands	r4, r1
 800d6ba:	21c0      	movs	r1, #192	; 0xc0
 800d6bc:	0189      	lsls	r1, r1, #6
 800d6be:	e7c2      	b.n	800d646 <USB_ActivateEndpoint+0x9a>
      PCD_SET_EP_RX_CNT(USBx, ep->num, ep->maxpacket);
 800d6c0:	2d3e      	cmp	r5, #62	; 0x3e
 800d6c2:	d806      	bhi.n	800d6d2 <USB_ActivateEndpoint+0x126>
 800d6c4:	2701      	movs	r7, #1
 800d6c6:	086e      	lsrs	r6, r5, #1
 800d6c8:	403d      	ands	r5, r7
 800d6ca:	1976      	adds	r6, r6, r5
 800d6cc:	02b6      	lsls	r6, r6, #10
 800d6ce:	b2b5      	uxth	r5, r6
 800d6d0:	e7e0      	b.n	800d694 <USB_ActivateEndpoint+0xe8>
 800d6d2:	271f      	movs	r7, #31
 800d6d4:	096e      	lsrs	r6, r5, #5
 800d6d6:	403d      	ands	r5, r7
 800d6d8:	426f      	negs	r7, r5
 800d6da:	417d      	adcs	r5, r7
 800d6dc:	1b76      	subs	r6, r6, r5
 800d6de:	02b5      	lsls	r5, r6, #10
 800d6e0:	4e4a      	ldr	r6, [pc, #296]	; (800d80c <USB_ActivateEndpoint+0x260>)
 800d6e2:	432e      	orrs	r6, r5
 800d6e4:	b2b6      	uxth	r6, r6
 800d6e6:	8026      	strh	r6, [r4, #0]
 800d6e8:	e7d5      	b.n	800d696 <USB_ActivateEndpoint+0xea>
    PCD_SET_EP_DBUF(USBx, ep->num);
 800d6ea:	00a4      	lsls	r4, r4, #2
 800d6ec:	191c      	adds	r4, r3, r4
 800d6ee:	8825      	ldrh	r5, [r4, #0]
 800d6f0:	403d      	ands	r5, r7
 800d6f2:	4f47      	ldr	r7, [pc, #284]	; (800d810 <USB_ActivateEndpoint+0x264>)
 800d6f4:	433d      	orrs	r5, r7
    PCD_SET_EP_DBUF_ADDR(USBx, ep->num, ep->pmaaddr0, ep->pmaaddr1);
 800d6f6:	2780      	movs	r7, #128	; 0x80
    PCD_SET_EP_DBUF(USBx, ep->num);
 800d6f8:	8025      	strh	r5, [r4, #0]
    PCD_SET_EP_DBUF_ADDR(USBx, ep->num, ep->pmaaddr0, ep->pmaaddr1);
 800d6fa:	780c      	ldrb	r4, [r1, #0]
 800d6fc:	8835      	ldrh	r5, [r6, #0]
 800d6fe:	00e4      	lsls	r4, r4, #3
 800d700:	00ff      	lsls	r7, r7, #3
 800d702:	18e4      	adds	r4, r4, r3
 800d704:	19e4      	adds	r4, r4, r7
 800d706:	1964      	adds	r4, r4, r5
 800d708:	890d      	ldrh	r5, [r1, #8]
 800d70a:	086d      	lsrs	r5, r5, #1
 800d70c:	006d      	lsls	r5, r5, #1
 800d70e:	8025      	strh	r5, [r4, #0]
 800d710:	780c      	ldrb	r4, [r1, #0]
 800d712:	8835      	ldrh	r5, [r6, #0]
 800d714:	00e4      	lsls	r4, r4, #3
 800d716:	4e38      	ldr	r6, [pc, #224]	; (800d7f8 <USB_ActivateEndpoint+0x24c>)
 800d718:	18e4      	adds	r4, r4, r3
 800d71a:	19a4      	adds	r4, r4, r6
 800d71c:	2680      	movs	r6, #128	; 0x80
 800d71e:	1964      	adds	r4, r4, r5
 800d720:	894d      	ldrh	r5, [r1, #10]
 800d722:	01f6      	lsls	r6, r6, #7
 800d724:	086d      	lsrs	r5, r5, #1
 800d726:	006d      	lsls	r5, r5, #1
 800d728:	8025      	strh	r5, [r4, #0]
    if (ep->is_in == 0U)
 800d72a:	780c      	ldrb	r4, [r1, #0]
 800d72c:	784f      	ldrb	r7, [r1, #1]
      PCD_CLEAR_RX_DTOG(USBx, ep->num);
 800d72e:	00a4      	lsls	r4, r4, #2
 800d730:	4d30      	ldr	r5, [pc, #192]	; (800d7f4 <USB_ActivateEndpoint+0x248>)
 800d732:	191c      	adds	r4, r3, r4
    if (ep->is_in == 0U)
 800d734:	2f00      	cmp	r7, #0
 800d736:	d129      	bne.n	800d78c <USB_ActivateEndpoint+0x1e0>
      PCD_CLEAR_RX_DTOG(USBx, ep->num);
 800d738:	8827      	ldrh	r7, [r4, #0]
 800d73a:	4237      	tst	r7, r6
 800d73c:	d005      	beq.n	800d74a <USB_ActivateEndpoint+0x19e>
 800d73e:	4667      	mov	r7, ip
 800d740:	8826      	ldrh	r6, [r4, #0]
 800d742:	403e      	ands	r6, r7
 800d744:	4f2f      	ldr	r7, [pc, #188]	; (800d804 <USB_ActivateEndpoint+0x258>)
 800d746:	433e      	orrs	r6, r7
 800d748:	8026      	strh	r6, [r4, #0]
      PCD_CLEAR_TX_DTOG(USBx, ep->num);
 800d74a:	780c      	ldrb	r4, [r1, #0]
 800d74c:	00a4      	lsls	r4, r4, #2
 800d74e:	191c      	adds	r4, r3, r4
 800d750:	8826      	ldrh	r6, [r4, #0]
 800d752:	0676      	lsls	r6, r6, #25
 800d754:	d505      	bpl.n	800d762 <USB_ActivateEndpoint+0x1b6>
 800d756:	4667      	mov	r7, ip
 800d758:	8826      	ldrh	r6, [r4, #0]
 800d75a:	403e      	ands	r6, r7
 800d75c:	4f24      	ldr	r7, [pc, #144]	; (800d7f0 <USB_ActivateEndpoint+0x244>)
 800d75e:	433e      	orrs	r6, r7
 800d760:	8026      	strh	r6, [r4, #0]
      PCD_SET_EP_RX_STATUS(USBx, ep->num, USB_EP_RX_VALID);
 800d762:	780e      	ldrb	r6, [r1, #0]
 800d764:	4c28      	ldr	r4, [pc, #160]	; (800d808 <USB_ActivateEndpoint+0x25c>)
 800d766:	00b6      	lsls	r6, r6, #2
 800d768:	199e      	adds	r6, r3, r6
 800d76a:	8837      	ldrh	r7, [r6, #0]
 800d76c:	4027      	ands	r7, r4
 800d76e:	24c0      	movs	r4, #192	; 0xc0
 800d770:	01a4      	lsls	r4, r4, #6
 800d772:	407c      	eors	r4, r7
 800d774:	4314      	orrs	r4, r2
 800d776:	b2a4      	uxth	r4, r4
 800d778:	8034      	strh	r4, [r6, #0]
      PCD_SET_EP_TX_STATUS(USBx, ep->num, USB_EP_TX_DIS);
 800d77a:	7809      	ldrb	r1, [r1, #0]
 800d77c:	0089      	lsls	r1, r1, #2
 800d77e:	185b      	adds	r3, r3, r1
 800d780:	8819      	ldrh	r1, [r3, #0]
 800d782:	400d      	ands	r5, r1
 800d784:	432a      	orrs	r2, r5
      PCD_SET_EP_RX_STATUS(USBx, ep->num, USB_EP_RX_DIS);
 800d786:	b292      	uxth	r2, r2
 800d788:	801a      	strh	r2, [r3, #0]
    }
  }

  return ret;
}
 800d78a:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
      PCD_CLEAR_RX_DTOG(USBx, ep->num);
 800d78c:	8827      	ldrh	r7, [r4, #0]
 800d78e:	4237      	tst	r7, r6
 800d790:	d005      	beq.n	800d79e <USB_ActivateEndpoint+0x1f2>
 800d792:	4667      	mov	r7, ip
 800d794:	8826      	ldrh	r6, [r4, #0]
 800d796:	403e      	ands	r6, r7
 800d798:	4f1a      	ldr	r7, [pc, #104]	; (800d804 <USB_ActivateEndpoint+0x258>)
 800d79a:	433e      	orrs	r6, r7
 800d79c:	8026      	strh	r6, [r4, #0]
      PCD_CLEAR_TX_DTOG(USBx, ep->num);
 800d79e:	780c      	ldrb	r4, [r1, #0]
 800d7a0:	00a4      	lsls	r4, r4, #2
 800d7a2:	191c      	adds	r4, r3, r4
 800d7a4:	8826      	ldrh	r6, [r4, #0]
 800d7a6:	0676      	lsls	r6, r6, #25
 800d7a8:	d505      	bpl.n	800d7b6 <USB_ActivateEndpoint+0x20a>
 800d7aa:	4667      	mov	r7, ip
 800d7ac:	8826      	ldrh	r6, [r4, #0]
 800d7ae:	403e      	ands	r6, r7
 800d7b0:	4f0f      	ldr	r7, [pc, #60]	; (800d7f0 <USB_ActivateEndpoint+0x244>)
 800d7b2:	433e      	orrs	r6, r7
 800d7b4:	8026      	strh	r6, [r4, #0]
      if (ep->type != EP_TYPE_ISOC)
 800d7b6:	780c      	ldrb	r4, [r1, #0]
 800d7b8:	78ce      	ldrb	r6, [r1, #3]
 800d7ba:	00a4      	lsls	r4, r4, #2
 800d7bc:	191c      	adds	r4, r3, r4
 800d7be:	2e01      	cmp	r6, #1
 800d7c0:	d00c      	beq.n	800d7dc <USB_ActivateEndpoint+0x230>
        PCD_SET_EP_TX_STATUS(USBx, ep->num, USB_EP_TX_NAK);
 800d7c2:	8826      	ldrh	r6, [r4, #0]
 800d7c4:	402e      	ands	r6, r5
 800d7c6:	2520      	movs	r5, #32
 800d7c8:	4075      	eors	r5, r6
        PCD_SET_EP_TX_STATUS(USBx, ep->num, USB_EP_TX_DIS);
 800d7ca:	4315      	orrs	r5, r2
 800d7cc:	b2ad      	uxth	r5, r5
 800d7ce:	8025      	strh	r5, [r4, #0]
      PCD_SET_EP_RX_STATUS(USBx, ep->num, USB_EP_RX_DIS);
 800d7d0:	7809      	ldrb	r1, [r1, #0]
 800d7d2:	4c0d      	ldr	r4, [pc, #52]	; (800d808 <USB_ActivateEndpoint+0x25c>)
 800d7d4:	0089      	lsls	r1, r1, #2
 800d7d6:	185b      	adds	r3, r3, r1
 800d7d8:	8819      	ldrh	r1, [r3, #0]
 800d7da:	e741      	b.n	800d660 <USB_ActivateEndpoint+0xb4>
        PCD_SET_EP_TX_STATUS(USBx, ep->num, USB_EP_TX_DIS);
 800d7dc:	8826      	ldrh	r6, [r4, #0]
 800d7de:	4035      	ands	r5, r6
 800d7e0:	e7f3      	b.n	800d7ca <USB_ActivateEndpoint+0x21e>
 800d7e2:	46c0      	nop			; (mov r8, r8)
 800d7e4:	ffff898f 	.word	0xffff898f
 800d7e8:	ffff8080 	.word	0xffff8080
 800d7ec:	ffff8f8f 	.word	0xffff8f8f
 800d7f0:	000080c0 	.word	0x000080c0
 800d7f4:	ffff8fbf 	.word	0xffff8fbf
 800d7f8:	00000404 	.word	0x00000404
 800d7fc:	00000406 	.word	0x00000406
 800d800:	ffff83ff 	.word	0xffff83ff
 800d804:	0000c080 	.word	0x0000c080
 800d808:	ffffbf8f 	.word	0xffffbf8f
 800d80c:	ffff8000 	.word	0xffff8000
 800d810:	00008180 	.word	0x00008180

0800d814 <USB_DeactivateEndpoint>:
  * @param  USBx Selected device
  * @param  ep pointer to endpoint structure
  * @retval HAL status
  */
HAL_StatusTypeDef USB_DeactivateEndpoint(USB_TypeDef *USBx, USB_EPTypeDef *ep)
{
 800d814:	b5f0      	push	{r4, r5, r6, r7, lr}
 800d816:	780b      	ldrb	r3, [r1, #0]
  if (ep->doublebuffer == 0U)
 800d818:	7b0d      	ldrb	r5, [r1, #12]
 800d81a:	009b      	lsls	r3, r3, #2
 800d81c:	784c      	ldrb	r4, [r1, #1]
 800d81e:	4a40      	ldr	r2, [pc, #256]	; (800d920 <USB_DeactivateEndpoint+0x10c>)
 800d820:	18c3      	adds	r3, r0, r3
 800d822:	2d00      	cmp	r5, #0
 800d824:	d121      	bne.n	800d86a <USB_DeactivateEndpoint+0x56>
  {
    if (ep->is_in != 0U)
 800d826:	2c00      	cmp	r4, #0
 800d828:	d010      	beq.n	800d84c <USB_DeactivateEndpoint+0x38>
    {
      PCD_CLEAR_TX_DTOG(USBx, ep->num);
 800d82a:	881c      	ldrh	r4, [r3, #0]
 800d82c:	0664      	lsls	r4, r4, #25
 800d82e:	d505      	bpl.n	800d83c <USB_DeactivateEndpoint+0x28>
 800d830:	881c      	ldrh	r4, [r3, #0]
 800d832:	4d3c      	ldr	r5, [pc, #240]	; (800d924 <USB_DeactivateEndpoint+0x110>)
 800d834:	402c      	ands	r4, r5
 800d836:	4d3c      	ldr	r5, [pc, #240]	; (800d928 <USB_DeactivateEndpoint+0x114>)
 800d838:	432c      	orrs	r4, r5
 800d83a:	801c      	strh	r4, [r3, #0]

      /* Configure DISABLE status for the Endpoint*/
      PCD_SET_EP_TX_STATUS(USBx, ep->num, USB_EP_TX_DIS);
 800d83c:	780b      	ldrb	r3, [r1, #0]
 800d83e:	493b      	ldr	r1, [pc, #236]	; (800d92c <USB_DeactivateEndpoint+0x118>)
 800d840:	009b      	lsls	r3, r3, #2
 800d842:	18c0      	adds	r0, r0, r3
 800d844:	8803      	ldrh	r3, [r0, #0]
      PCD_CLEAR_TX_DTOG(USBx, ep->num);
      PCD_RX_DTOG(USBx, ep->num);

      /* Configure DISABLE status for the Endpoint*/
      PCD_SET_EP_TX_STATUS(USBx, ep->num, USB_EP_TX_DIS);
      PCD_SET_EP_RX_STATUS(USBx, ep->num, USB_EP_RX_DIS);
 800d846:	400b      	ands	r3, r1
 800d848:	431a      	orrs	r2, r3
 800d84a:	e03f      	b.n	800d8cc <USB_DeactivateEndpoint+0xb8>
      PCD_CLEAR_RX_DTOG(USBx, ep->num);
 800d84c:	881c      	ldrh	r4, [r3, #0]
 800d84e:	0464      	lsls	r4, r4, #17
 800d850:	d505      	bpl.n	800d85e <USB_DeactivateEndpoint+0x4a>
 800d852:	881c      	ldrh	r4, [r3, #0]
 800d854:	4d33      	ldr	r5, [pc, #204]	; (800d924 <USB_DeactivateEndpoint+0x110>)
 800d856:	402c      	ands	r4, r5
 800d858:	4d35      	ldr	r5, [pc, #212]	; (800d930 <USB_DeactivateEndpoint+0x11c>)
 800d85a:	432c      	orrs	r4, r5
 800d85c:	801c      	strh	r4, [r3, #0]
      PCD_SET_EP_RX_STATUS(USBx, ep->num, USB_EP_RX_DIS);
 800d85e:	780b      	ldrb	r3, [r1, #0]
 800d860:	4934      	ldr	r1, [pc, #208]	; (800d934 <USB_DeactivateEndpoint+0x120>)
 800d862:	009b      	lsls	r3, r3, #2
 800d864:	18c0      	adds	r0, r0, r3
 800d866:	8803      	ldrh	r3, [r0, #0]
 800d868:	e7ed      	b.n	800d846 <USB_DeactivateEndpoint+0x32>
    if (ep->is_in == 0U)
 800d86a:	2680      	movs	r6, #128	; 0x80
 800d86c:	4d2d      	ldr	r5, [pc, #180]	; (800d924 <USB_DeactivateEndpoint+0x110>)
 800d86e:	4f2f      	ldr	r7, [pc, #188]	; (800d92c <USB_DeactivateEndpoint+0x118>)
 800d870:	01f6      	lsls	r6, r6, #7
 800d872:	2c00      	cmp	r4, #0
 800d874:	d12e      	bne.n	800d8d4 <USB_DeactivateEndpoint+0xc0>
      PCD_CLEAR_RX_DTOG(USBx, ep->num);
 800d876:	881c      	ldrh	r4, [r3, #0]
 800d878:	4234      	tst	r4, r6
 800d87a:	d004      	beq.n	800d886 <USB_DeactivateEndpoint+0x72>
 800d87c:	881c      	ldrh	r4, [r3, #0]
 800d87e:	4e2c      	ldr	r6, [pc, #176]	; (800d930 <USB_DeactivateEndpoint+0x11c>)
 800d880:	402c      	ands	r4, r5
 800d882:	4334      	orrs	r4, r6
 800d884:	801c      	strh	r4, [r3, #0]
      PCD_CLEAR_TX_DTOG(USBx, ep->num);
 800d886:	780b      	ldrb	r3, [r1, #0]
 800d888:	4c2b      	ldr	r4, [pc, #172]	; (800d938 <USB_DeactivateEndpoint+0x124>)
 800d88a:	009b      	lsls	r3, r3, #2
 800d88c:	18c3      	adds	r3, r0, r3
 800d88e:	881e      	ldrh	r6, [r3, #0]
 800d890:	0676      	lsls	r6, r6, #25
 800d892:	d504      	bpl.n	800d89e <USB_DeactivateEndpoint+0x8a>
 800d894:	881e      	ldrh	r6, [r3, #0]
 800d896:	402e      	ands	r6, r5
 800d898:	4326      	orrs	r6, r4
 800d89a:	b2b6      	uxth	r6, r6
 800d89c:	801e      	strh	r6, [r3, #0]
      PCD_TX_DTOG(USBx, ep->num);
 800d89e:	780b      	ldrb	r3, [r1, #0]
 800d8a0:	009b      	lsls	r3, r3, #2
 800d8a2:	18c3      	adds	r3, r0, r3
 800d8a4:	881e      	ldrh	r6, [r3, #0]
 800d8a6:	4035      	ands	r5, r6
 800d8a8:	432c      	orrs	r4, r5
 800d8aa:	b2a4      	uxth	r4, r4
 800d8ac:	801c      	strh	r4, [r3, #0]
      PCD_SET_EP_RX_STATUS(USBx, ep->num, USB_EP_RX_DIS);
 800d8ae:	780c      	ldrb	r4, [r1, #0]
 800d8b0:	4d20      	ldr	r5, [pc, #128]	; (800d934 <USB_DeactivateEndpoint+0x120>)
 800d8b2:	00a4      	lsls	r4, r4, #2
 800d8b4:	1904      	adds	r4, r0, r4
 800d8b6:	8823      	ldrh	r3, [r4, #0]
 800d8b8:	402b      	ands	r3, r5
 800d8ba:	4313      	orrs	r3, r2
 800d8bc:	b29b      	uxth	r3, r3
 800d8be:	8023      	strh	r3, [r4, #0]
      PCD_SET_EP_TX_STATUS(USBx, ep->num, USB_EP_TX_DIS);
 800d8c0:	780b      	ldrb	r3, [r1, #0]
 800d8c2:	009b      	lsls	r3, r3, #2
 800d8c4:	18c0      	adds	r0, r0, r3
 800d8c6:	8803      	ldrh	r3, [r0, #0]
 800d8c8:	401f      	ands	r7, r3
 800d8ca:	433a      	orrs	r2, r7
      PCD_SET_EP_RX_STATUS(USBx, ep->num, USB_EP_RX_DIS);
 800d8cc:	b292      	uxth	r2, r2
 800d8ce:	8002      	strh	r2, [r0, #0]
    }
  }

  return HAL_OK;
}
 800d8d0:	2000      	movs	r0, #0
 800d8d2:	bdf0      	pop	{r4, r5, r6, r7, pc}
      PCD_CLEAR_RX_DTOG(USBx, ep->num);
 800d8d4:	881c      	ldrh	r4, [r3, #0]
 800d8d6:	4234      	tst	r4, r6
 800d8d8:	d005      	beq.n	800d8e6 <USB_DeactivateEndpoint+0xd2>
 800d8da:	881e      	ldrh	r6, [r3, #0]
 800d8dc:	4c17      	ldr	r4, [pc, #92]	; (800d93c <USB_DeactivateEndpoint+0x128>)
 800d8de:	402e      	ands	r6, r5
 800d8e0:	4326      	orrs	r6, r4
 800d8e2:	b2b6      	uxth	r6, r6
 800d8e4:	801e      	strh	r6, [r3, #0]
      PCD_CLEAR_TX_DTOG(USBx, ep->num);
 800d8e6:	780b      	ldrb	r3, [r1, #0]
 800d8e8:	009b      	lsls	r3, r3, #2
 800d8ea:	18c3      	adds	r3, r0, r3
 800d8ec:	881e      	ldrh	r6, [r3, #0]
 800d8ee:	0674      	lsls	r4, r6, #25
 800d8f0:	d504      	bpl.n	800d8fc <USB_DeactivateEndpoint+0xe8>
 800d8f2:	881e      	ldrh	r6, [r3, #0]
 800d8f4:	4c0c      	ldr	r4, [pc, #48]	; (800d928 <USB_DeactivateEndpoint+0x114>)
 800d8f6:	402e      	ands	r6, r5
 800d8f8:	4326      	orrs	r6, r4
 800d8fa:	801e      	strh	r6, [r3, #0]
      PCD_RX_DTOG(USBx, ep->num);
 800d8fc:	780b      	ldrb	r3, [r1, #0]
 800d8fe:	4c0f      	ldr	r4, [pc, #60]	; (800d93c <USB_DeactivateEndpoint+0x128>)
 800d900:	009b      	lsls	r3, r3, #2
 800d902:	18c3      	adds	r3, r0, r3
 800d904:	881e      	ldrh	r6, [r3, #0]
 800d906:	4035      	ands	r5, r6
 800d908:	432c      	orrs	r4, r5
 800d90a:	b2a4      	uxth	r4, r4
 800d90c:	801c      	strh	r4, [r3, #0]
      PCD_SET_EP_TX_STATUS(USBx, ep->num, USB_EP_TX_DIS);
 800d90e:	780b      	ldrb	r3, [r1, #0]
 800d910:	009b      	lsls	r3, r3, #2
 800d912:	18c3      	adds	r3, r0, r3
 800d914:	881c      	ldrh	r4, [r3, #0]
 800d916:	4027      	ands	r7, r4
 800d918:	4317      	orrs	r7, r2
 800d91a:	b2bf      	uxth	r7, r7
 800d91c:	801f      	strh	r7, [r3, #0]
 800d91e:	e79e      	b.n	800d85e <USB_DeactivateEndpoint+0x4a>
 800d920:	ffff8080 	.word	0xffff8080
 800d924:	ffff8f8f 	.word	0xffff8f8f
 800d928:	000080c0 	.word	0x000080c0
 800d92c:	ffff8fbf 	.word	0xffff8fbf
 800d930:	0000c080 	.word	0x0000c080
 800d934:	ffffbf8f 	.word	0xffffbf8f
 800d938:	ffff80c0 	.word	0xffff80c0
 800d93c:	ffffc080 	.word	0xffffc080

0800d940 <USB_EPSetStall>:
  * @param  ep pointer to endpoint structure
  * @retval HAL status
  */
HAL_StatusTypeDef USB_EPSetStall(USB_TypeDef *USBx, USB_EPTypeDef *ep)
{
  if (ep->is_in != 0U)
 800d940:	780b      	ldrb	r3, [r1, #0]
 800d942:	4a0b      	ldr	r2, [pc, #44]	; (800d970 <USB_EPSetStall+0x30>)
 800d944:	009b      	lsls	r3, r3, #2
 800d946:	18c0      	adds	r0, r0, r3
 800d948:	784b      	ldrb	r3, [r1, #1]
 800d94a:	2b00      	cmp	r3, #0
 800d94c:	d009      	beq.n	800d962 <USB_EPSetStall+0x22>
  {
    PCD_SET_EP_TX_STATUS(USBx, ep->num, USB_EP_TX_STALL);
 800d94e:	8803      	ldrh	r3, [r0, #0]
 800d950:	4908      	ldr	r1, [pc, #32]	; (800d974 <USB_EPSetStall+0x34>)
 800d952:	4019      	ands	r1, r3
 800d954:	2310      	movs	r3, #16
  }
  else
  {
    PCD_SET_EP_RX_STATUS(USBx, ep->num, USB_EP_RX_STALL);
 800d956:	404b      	eors	r3, r1
 800d958:	4313      	orrs	r3, r2
 800d95a:	b29b      	uxth	r3, r3
 800d95c:	8003      	strh	r3, [r0, #0]
  }

  return HAL_OK;
}
 800d95e:	2000      	movs	r0, #0
 800d960:	4770      	bx	lr
    PCD_SET_EP_RX_STATUS(USBx, ep->num, USB_EP_RX_STALL);
 800d962:	8803      	ldrh	r3, [r0, #0]
 800d964:	4904      	ldr	r1, [pc, #16]	; (800d978 <USB_EPSetStall+0x38>)
 800d966:	4019      	ands	r1, r3
 800d968:	2380      	movs	r3, #128	; 0x80
 800d96a:	015b      	lsls	r3, r3, #5
 800d96c:	e7f3      	b.n	800d956 <USB_EPSetStall+0x16>
 800d96e:	46c0      	nop			; (mov r8, r8)
 800d970:	ffff8080 	.word	0xffff8080
 800d974:	ffff8fbf 	.word	0xffff8fbf
 800d978:	ffffbf8f 	.word	0xffffbf8f

0800d97c <USB_EPClearStall>:
  * @param  ep pointer to endpoint structure
  * @retval HAL status
  */
HAL_StatusTypeDef USB_EPClearStall(USB_TypeDef *USBx, USB_EPTypeDef *ep)
{
  if (ep->doublebuffer == 0U)
 800d97c:	7b0b      	ldrb	r3, [r1, #12]
{
 800d97e:	b510      	push	{r4, lr}
  if (ep->doublebuffer == 0U)
 800d980:	2b00      	cmp	r3, #0
 800d982:	d11c      	bne.n	800d9be <USB_EPClearStall+0x42>
  {
    if (ep->is_in != 0U)
 800d984:	780b      	ldrb	r3, [r1, #0]
 800d986:	784a      	ldrb	r2, [r1, #1]
 800d988:	009b      	lsls	r3, r3, #2
 800d98a:	18c3      	adds	r3, r0, r3
 800d98c:	2a00      	cmp	r2, #0
 800d98e:	d018      	beq.n	800d9c2 <USB_EPClearStall+0x46>
    {
      PCD_CLEAR_TX_DTOG(USBx, ep->num);
 800d990:	881a      	ldrh	r2, [r3, #0]
 800d992:	0652      	lsls	r2, r2, #25
 800d994:	d505      	bpl.n	800d9a2 <USB_EPClearStall+0x26>
 800d996:	881a      	ldrh	r2, [r3, #0]
 800d998:	4c13      	ldr	r4, [pc, #76]	; (800d9e8 <USB_EPClearStall+0x6c>)
 800d99a:	4022      	ands	r2, r4
 800d99c:	4c13      	ldr	r4, [pc, #76]	; (800d9ec <USB_EPClearStall+0x70>)
 800d99e:	4322      	orrs	r2, r4
 800d9a0:	801a      	strh	r2, [r3, #0]

      if (ep->type != EP_TYPE_ISOC)
 800d9a2:	78cb      	ldrb	r3, [r1, #3]
 800d9a4:	2b01      	cmp	r3, #1
 800d9a6:	d00a      	beq.n	800d9be <USB_EPClearStall+0x42>
      {
        /* Configure NAK status for the Endpoint */
        PCD_SET_EP_TX_STATUS(USBx, ep->num, USB_EP_TX_NAK);
 800d9a8:	780b      	ldrb	r3, [r1, #0]
 800d9aa:	4a11      	ldr	r2, [pc, #68]	; (800d9f0 <USB_EPClearStall+0x74>)
 800d9ac:	009b      	lsls	r3, r3, #2
 800d9ae:	18c0      	adds	r0, r0, r3
 800d9b0:	8803      	ldrh	r3, [r0, #0]
 800d9b2:	401a      	ands	r2, r3
 800d9b4:	2320      	movs	r3, #32
    else
    {
      PCD_CLEAR_RX_DTOG(USBx, ep->num);

      /* Configure VALID status for the Endpoint */
      PCD_SET_EP_RX_STATUS(USBx, ep->num, USB_EP_RX_VALID);
 800d9b6:	4053      	eors	r3, r2
 800d9b8:	4a0e      	ldr	r2, [pc, #56]	; (800d9f4 <USB_EPClearStall+0x78>)
 800d9ba:	4313      	orrs	r3, r2
 800d9bc:	8003      	strh	r3, [r0, #0]
    }
  }

  return HAL_OK;
}
 800d9be:	2000      	movs	r0, #0
 800d9c0:	bd10      	pop	{r4, pc}
      PCD_CLEAR_RX_DTOG(USBx, ep->num);
 800d9c2:	881a      	ldrh	r2, [r3, #0]
 800d9c4:	0452      	lsls	r2, r2, #17
 800d9c6:	d505      	bpl.n	800d9d4 <USB_EPClearStall+0x58>
 800d9c8:	881a      	ldrh	r2, [r3, #0]
 800d9ca:	4c07      	ldr	r4, [pc, #28]	; (800d9e8 <USB_EPClearStall+0x6c>)
 800d9cc:	4022      	ands	r2, r4
 800d9ce:	4c0a      	ldr	r4, [pc, #40]	; (800d9f8 <USB_EPClearStall+0x7c>)
 800d9d0:	4322      	orrs	r2, r4
 800d9d2:	801a      	strh	r2, [r3, #0]
      PCD_SET_EP_RX_STATUS(USBx, ep->num, USB_EP_RX_VALID);
 800d9d4:	780b      	ldrb	r3, [r1, #0]
 800d9d6:	4a09      	ldr	r2, [pc, #36]	; (800d9fc <USB_EPClearStall+0x80>)
 800d9d8:	009b      	lsls	r3, r3, #2
 800d9da:	18c0      	adds	r0, r0, r3
 800d9dc:	8803      	ldrh	r3, [r0, #0]
 800d9de:	401a      	ands	r2, r3
 800d9e0:	23c0      	movs	r3, #192	; 0xc0
 800d9e2:	019b      	lsls	r3, r3, #6
 800d9e4:	e7e7      	b.n	800d9b6 <USB_EPClearStall+0x3a>
 800d9e6:	46c0      	nop			; (mov r8, r8)
 800d9e8:	ffff8f8f 	.word	0xffff8f8f
 800d9ec:	000080c0 	.word	0x000080c0
 800d9f0:	ffff8fbf 	.word	0xffff8fbf
 800d9f4:	00008080 	.word	0x00008080
 800d9f8:	0000c080 	.word	0x0000c080
 800d9fc:	ffffbf8f 	.word	0xffffbf8f

0800da00 <USB_SetDevAddress>:
  *          This parameter can be a value from 0 to 255
  * @retval HAL status
  */
HAL_StatusTypeDef  USB_SetDevAddress(USB_TypeDef *USBx, uint8_t address)
{
  if (address == 0U)
 800da00:	2900      	cmp	r1, #0
 800da02:	d102      	bne.n	800da0a <USB_SetDevAddress+0xa>
  {
    /* set device address and enable function */
    USBx->DADDR = (uint16_t)USB_DADDR_EF;
 800da04:	2380      	movs	r3, #128	; 0x80
 800da06:	304c      	adds	r0, #76	; 0x4c
 800da08:	8003      	strh	r3, [r0, #0]
  }

  return HAL_OK;
}
 800da0a:	2000      	movs	r0, #0
 800da0c:	4770      	bx	lr

0800da0e <USB_DevConnect>:
  * @retval HAL status
  */
HAL_StatusTypeDef  USB_DevConnect(USB_TypeDef *USBx)
{
  /* Enabling DP Pull-UP bit to Connect internal PU resistor on USB DP line */
  USBx->BCDR |= (uint16_t)USB_BCDR_DPPU;
 800da0e:	2280      	movs	r2, #128	; 0x80
 800da10:	3058      	adds	r0, #88	; 0x58
 800da12:	8803      	ldrh	r3, [r0, #0]
 800da14:	0212      	lsls	r2, r2, #8
 800da16:	4313      	orrs	r3, r2
 800da18:	8003      	strh	r3, [r0, #0]

  return HAL_OK;
}
 800da1a:	2000      	movs	r0, #0
 800da1c:	4770      	bx	lr

0800da1e <USB_ReadInterrupts>:
  */
uint32_t  USB_ReadInterrupts(USB_TypeDef *USBx)
{
  uint32_t tmpreg;

  tmpreg = USBx->ISTR;
 800da1e:	3006      	adds	r0, #6
 800da20:	8fc0      	ldrh	r0, [r0, #62]	; 0x3e
 800da22:	b280      	uxth	r0, r0
  return tmpreg;
}
 800da24:	4770      	bx	lr

0800da26 <USB_WritePMA>:
  * @param   wPMABufAddr address into PMA.
  * @param   wNBytes no. of bytes to be copied.
  * @retval None
  */
void USB_WritePMA(USB_TypeDef *USBx, uint8_t *pbUsrBuf, uint16_t wPMABufAddr, uint16_t wNBytes)
{
 800da26:	b530      	push	{r4, r5, lr}
  uint32_t BaseAddr = (uint32_t)USBx;
  uint32_t i, temp1, temp2;
  __IO uint16_t *pdwVal;
  uint8_t *pBuf = pbUsrBuf;

  pdwVal = (__IO uint16_t *)(BaseAddr + 0x400U + ((uint32_t)wPMABufAddr * PMA_ACCESS));
 800da28:	2480      	movs	r4, #128	; 0x80
  uint32_t n = ((uint32_t)wNBytes + 1U) >> 1;
 800da2a:	3301      	adds	r3, #1
  pdwVal = (__IO uint16_t *)(BaseAddr + 0x400U + ((uint32_t)wPMABufAddr * PMA_ACCESS));
 800da2c:	00e4      	lsls	r4, r4, #3
 800da2e:	1912      	adds	r2, r2, r4
  uint32_t n = ((uint32_t)wNBytes + 1U) >> 1;
 800da30:	085b      	lsrs	r3, r3, #1
  pdwVal = (__IO uint16_t *)(BaseAddr + 0x400U + ((uint32_t)wPMABufAddr * PMA_ACCESS));
 800da32:	1880      	adds	r0, r0, r2

  for (i = n; i != 0U; i--)
 800da34:	005b      	lsls	r3, r3, #1
 800da36:	18cb      	adds	r3, r1, r3
 800da38:	1a40      	subs	r0, r0, r1
 800da3a:	1844      	adds	r4, r0, r1
 800da3c:	4299      	cmp	r1, r3
 800da3e:	d100      	bne.n	800da42 <USB_WritePMA+0x1c>
    pdwVal++;
#endif

    pBuf++;
  }
}
 800da40:	bd30      	pop	{r4, r5, pc}
    temp2 = temp1 | ((uint16_t)((uint16_t) *pBuf << 8));
 800da42:	784a      	ldrb	r2, [r1, #1]
 800da44:	780d      	ldrb	r5, [r1, #0]
 800da46:	0212      	lsls	r2, r2, #8
 800da48:	432a      	orrs	r2, r5
    *pdwVal = (uint16_t)temp2;
 800da4a:	8022      	strh	r2, [r4, #0]
    pBuf++;
 800da4c:	3102      	adds	r1, #2
  for (i = n; i != 0U; i--)
 800da4e:	e7f4      	b.n	800da3a <USB_WritePMA+0x14>

0800da50 <USB_EPStartXfer>:
{
 800da50:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
 800da52:	000c      	movs	r4, r1
  if (ep->is_in == 1U)
 800da54:	7849      	ldrb	r1, [r1, #1]
{
 800da56:	0005      	movs	r5, r0
 800da58:	7b22      	ldrb	r2, [r4, #12]
  if (ep->is_in == 1U)
 800da5a:	2901      	cmp	r1, #1
 800da5c:	d000      	beq.n	800da60 <USB_EPStartXfer+0x10>
 800da5e:	e19d      	b.n	800dd9c <USB_EPStartXfer+0x34c>
    if (ep->xfer_len > ep->maxpacket)
 800da60:	6927      	ldr	r7, [r4, #16]
 800da62:	69a6      	ldr	r6, [r4, #24]
 800da64:	42be      	cmp	r6, r7
 800da66:	d900      	bls.n	800da6a <USB_EPStartXfer+0x1a>
 800da68:	003e      	movs	r6, r7
    if (ep->doublebuffer == 0U)
 800da6a:	6961      	ldr	r1, [r4, #20]
 800da6c:	2a00      	cmp	r2, #0
 800da6e:	d11d      	bne.n	800daac <USB_EPStartXfer+0x5c>
      USB_WritePMA(USBx, ep->xfer_buff, ep->pmaadress, (uint16_t)len);
 800da70:	b2b6      	uxth	r6, r6
 800da72:	0033      	movs	r3, r6
 800da74:	88e2      	ldrh	r2, [r4, #6]
 800da76:	0028      	movs	r0, r5
 800da78:	f7ff ffd5 	bl	800da26 <USB_WritePMA>
      PCD_SET_EP_TX_CNT(USBx, ep->num, len);
 800da7c:	002b      	movs	r3, r5
 800da7e:	4abc      	ldr	r2, [pc, #752]	; (800dd70 <USB_EPStartXfer+0x320>)
 800da80:	3350      	adds	r3, #80	; 0x50
 800da82:	8819      	ldrh	r1, [r3, #0]
 800da84:	7823      	ldrb	r3, [r4, #0]
 800da86:	18aa      	adds	r2, r5, r2
 800da88:	00db      	lsls	r3, r3, #3
 800da8a:	1852      	adds	r2, r2, r1
 800da8c:	189b      	adds	r3, r3, r2
 800da8e:	801e      	strh	r6, [r3, #0]
    PCD_SET_EP_TX_STATUS(USBx, ep->num, USB_EP_TX_VALID);
 800da90:	7820      	ldrb	r0, [r4, #0]
 800da92:	4ab8      	ldr	r2, [pc, #736]	; (800dd74 <USB_EPStartXfer+0x324>)
 800da94:	0080      	lsls	r0, r0, #2
 800da96:	182d      	adds	r5, r5, r0
 800da98:	882b      	ldrh	r3, [r5, #0]
 800da9a:	401a      	ands	r2, r3
 800da9c:	2330      	movs	r3, #48	; 0x30
 800da9e:	4053      	eors	r3, r2
 800daa0:	4ab5      	ldr	r2, [pc, #724]	; (800dd78 <USB_EPStartXfer+0x328>)
 800daa2:	4313      	orrs	r3, r2
 800daa4:	b29b      	uxth	r3, r3
  return HAL_OK;
 800daa6:	2000      	movs	r0, #0
    PCD_SET_EP_RX_STATUS(USBx, ep->num, USB_EP_RX_VALID);
 800daa8:	802b      	strh	r3, [r5, #0]
}
 800daaa:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
      if (ep->type == EP_TYPE_BULK)
 800daac:	7820      	ldrb	r0, [r4, #0]
 800daae:	78e3      	ldrb	r3, [r4, #3]
 800dab0:	0082      	lsls	r2, r0, #2
 800dab2:	18aa      	adds	r2, r5, r2
 800dab4:	2b02      	cmp	r3, #2
 800dab6:	d000      	beq.n	800daba <USB_EPStartXfer+0x6a>
 800dab8:	e12b      	b.n	800dd12 <USB_EPStartXfer+0x2c2>
        if (ep->xfer_len_db > ep->maxpacket)
 800daba:	6a23      	ldr	r3, [r4, #32]
          PCD_SET_EP_DBUF(USBx, ep->num);
 800dabc:	8810      	ldrh	r0, [r2, #0]
        if (ep->xfer_len_db > ep->maxpacket)
 800dabe:	429f      	cmp	r7, r3
 800dac0:	d300      	bcc.n	800dac4 <USB_EPStartXfer+0x74>
 800dac2:	e115      	b.n	800dcf0 <USB_EPStartXfer+0x2a0>
          PCD_SET_EP_DBUF(USBx, ep->num);
 800dac4:	4fad      	ldr	r7, [pc, #692]	; (800dd7c <USB_EPStartXfer+0x32c>)
          ep->xfer_len_db -= len;
 800dac6:	1b9b      	subs	r3, r3, r6
          PCD_SET_EP_DBUF(USBx, ep->num);
 800dac8:	4038      	ands	r0, r7
 800daca:	4fad      	ldr	r7, [pc, #692]	; (800dd80 <USB_EPStartXfer+0x330>)
 800dacc:	4338      	orrs	r0, r7
 800dace:	8010      	strh	r0, [r2, #0]
          if ((PCD_GET_ENDPOINT(USBx, ep->num) & USB_EP_DTOG_TX) != 0U)
 800dad0:	7820      	ldrb	r0, [r4, #0]
          ep->xfer_len_db -= len;
 800dad2:	6223      	str	r3, [r4, #32]
          if ((PCD_GET_ENDPOINT(USBx, ep->num) & USB_EP_DTOG_TX) != 0U)
 800dad4:	0083      	lsls	r3, r0, #2
 800dad6:	18eb      	adds	r3, r5, r3
 800dad8:	881f      	ldrh	r7, [r3, #0]
 800dada:	b2b3      	uxth	r3, r6
 800dadc:	7862      	ldrb	r2, [r4, #1]
 800dade:	9301      	str	r3, [sp, #4]
 800dae0:	067b      	lsls	r3, r7, #25
 800dae2:	d400      	bmi.n	800dae6 <USB_EPStartXfer+0x96>
 800dae4:	e080      	b.n	800dbe8 <USB_EPStartXfer+0x198>
            PCD_SET_EP_DBUF1_CNT(USBx, ep->num, ep->is_in, len);
 800dae6:	2a00      	cmp	r2, #0
 800dae8:	d14f      	bne.n	800db8a <USB_EPStartXfer+0x13a>
 800daea:	002a      	movs	r2, r5
 800daec:	3250      	adds	r2, #80	; 0x50
 800daee:	8817      	ldrh	r7, [r2, #0]
 800daf0:	4aa4      	ldr	r2, [pc, #656]	; (800dd84 <USB_EPStartXfer+0x334>)
 800daf2:	00c0      	lsls	r0, r0, #3
 800daf4:	18aa      	adds	r2, r5, r2
 800daf6:	19d2      	adds	r2, r2, r7
 800daf8:	1812      	adds	r2, r2, r0
 800dafa:	2e00      	cmp	r6, #0
 800dafc:	d132      	bne.n	800db64 <USB_EPStartXfer+0x114>
 800dafe:	8810      	ldrh	r0, [r2, #0]
 800db00:	4fa1      	ldr	r7, [pc, #644]	; (800dd88 <USB_EPStartXfer+0x338>)
 800db02:	4038      	ands	r0, r7
 800db04:	2780      	movs	r7, #128	; 0x80
 800db06:	8010      	strh	r0, [r2, #0]
 800db08:	8810      	ldrh	r0, [r2, #0]
 800db0a:	023f      	lsls	r7, r7, #8
 800db0c:	4338      	orrs	r0, r7
 800db0e:	8010      	strh	r0, [r2, #0]
            USB_WritePMA(USBx, ep->xfer_buff, pmabuffer, (uint16_t)len);
 800db10:	0028      	movs	r0, r5
 800db12:	8962      	ldrh	r2, [r4, #10]
 800db14:	b2b3      	uxth	r3, r6
 800db16:	f7ff ff86 	bl	800da26 <USB_WritePMA>
            ep->xfer_buff += len;
 800db1a:	6963      	ldr	r3, [r4, #20]
            if (ep->xfer_len_db > ep->maxpacket)
 800db1c:	6a22      	ldr	r2, [r4, #32]
 800db1e:	6920      	ldr	r0, [r4, #16]
            ep->xfer_buff += len;
 800db20:	1999      	adds	r1, r3, r6
 800db22:	6161      	str	r1, [r4, #20]
              ep->xfer_len_db = 0U;
 800db24:	2300      	movs	r3, #0
            if (ep->xfer_len_db > ep->maxpacket)
 800db26:	4282      	cmp	r2, r0
 800db28:	d901      	bls.n	800db2e <USB_EPStartXfer+0xde>
              ep->xfer_len_db -= len;
 800db2a:	1b93      	subs	r3, r2, r6
 800db2c:	0032      	movs	r2, r6
            PCD_SET_EP_DBUF0_CNT(USBx, ep->num, ep->is_in, len);
 800db2e:	7860      	ldrb	r0, [r4, #1]
 800db30:	6223      	str	r3, [r4, #32]
 800db32:	b293      	uxth	r3, r2
 800db34:	2800      	cmp	r0, #0
 800db36:	d14a      	bne.n	800dbce <USB_EPStartXfer+0x17e>
 800db38:	0028      	movs	r0, r5
 800db3a:	3050      	adds	r0, #80	; 0x50
 800db3c:	8807      	ldrh	r7, [r0, #0]
 800db3e:	488c      	ldr	r0, [pc, #560]	; (800dd70 <USB_EPStartXfer+0x320>)
 800db40:	7826      	ldrb	r6, [r4, #0]
 800db42:	1828      	adds	r0, r5, r0
 800db44:	00f6      	lsls	r6, r6, #3
 800db46:	19c0      	adds	r0, r0, r7
 800db48:	1830      	adds	r0, r6, r0
 800db4a:	2a00      	cmp	r2, #0
 800db4c:	d12a      	bne.n	800dba4 <USB_EPStartXfer+0x154>
 800db4e:	8802      	ldrh	r2, [r0, #0]
 800db50:	4e8d      	ldr	r6, [pc, #564]	; (800dd88 <USB_EPStartXfer+0x338>)
 800db52:	4032      	ands	r2, r6
 800db54:	2680      	movs	r6, #128	; 0x80
 800db56:	8002      	strh	r2, [r0, #0]
 800db58:	8802      	ldrh	r2, [r0, #0]
 800db5a:	0236      	lsls	r6, r6, #8
 800db5c:	4332      	orrs	r2, r6
 800db5e:	8002      	strh	r2, [r0, #0]
          USB_WritePMA(USBx, ep->xfer_buff, pmabuffer, (uint16_t)len);
 800db60:	8922      	ldrh	r2, [r4, #8]
 800db62:	e07f      	b.n	800dc64 <USB_EPStartXfer+0x214>
            PCD_SET_EP_DBUF1_CNT(USBx, ep->num, ep->is_in, len);
 800db64:	2e3e      	cmp	r6, #62	; 0x3e
 800db66:	d806      	bhi.n	800db76 <USB_EPStartXfer+0x126>
 800db68:	2701      	movs	r7, #1
 800db6a:	0870      	lsrs	r0, r6, #1
 800db6c:	4037      	ands	r7, r6
 800db6e:	19c0      	adds	r0, r0, r7
 800db70:	0280      	lsls	r0, r0, #10
 800db72:	b280      	uxth	r0, r0
 800db74:	e7cb      	b.n	800db0e <USB_EPStartXfer+0xbe>
 800db76:	271f      	movs	r7, #31
 800db78:	4037      	ands	r7, r6
 800db7a:	427b      	negs	r3, r7
 800db7c:	417b      	adcs	r3, r7
 800db7e:	0970      	lsrs	r0, r6, #5
 800db80:	1ac0      	subs	r0, r0, r3
 800db82:	0287      	lsls	r7, r0, #10
 800db84:	4881      	ldr	r0, [pc, #516]	; (800dd8c <USB_EPStartXfer+0x33c>)
 800db86:	4338      	orrs	r0, r7
 800db88:	e7f3      	b.n	800db72 <USB_EPStartXfer+0x122>
 800db8a:	2a01      	cmp	r2, #1
 800db8c:	d1c0      	bne.n	800db10 <USB_EPStartXfer+0xc0>
 800db8e:	002a      	movs	r2, r5
 800db90:	4b7c      	ldr	r3, [pc, #496]	; (800dd84 <USB_EPStartXfer+0x334>)
 800db92:	3250      	adds	r2, #80	; 0x50
 800db94:	8812      	ldrh	r2, [r2, #0]
 800db96:	18ef      	adds	r7, r5, r3
 800db98:	18bf      	adds	r7, r7, r2
 800db9a:	00c0      	lsls	r0, r0, #3
 800db9c:	1838      	adds	r0, r7, r0
 800db9e:	b2b3      	uxth	r3, r6
 800dba0:	8003      	strh	r3, [r0, #0]
 800dba2:	e7b5      	b.n	800db10 <USB_EPStartXfer+0xc0>
            PCD_SET_EP_DBUF0_CNT(USBx, ep->num, ep->is_in, len);
 800dba4:	2a3e      	cmp	r2, #62	; 0x3e
 800dba6:	d806      	bhi.n	800dbb6 <USB_EPStartXfer+0x166>
 800dba8:	2701      	movs	r7, #1
 800dbaa:	0856      	lsrs	r6, r2, #1
 800dbac:	403a      	ands	r2, r7
 800dbae:	18b6      	adds	r6, r6, r2
 800dbb0:	02b6      	lsls	r6, r6, #10
 800dbb2:	b2b2      	uxth	r2, r6
 800dbb4:	e7d3      	b.n	800db5e <USB_EPStartXfer+0x10e>
 800dbb6:	271f      	movs	r7, #31
 800dbb8:	0956      	lsrs	r6, r2, #5
 800dbba:	403a      	ands	r2, r7
 800dbbc:	4257      	negs	r7, r2
 800dbbe:	417a      	adcs	r2, r7
 800dbc0:	1ab6      	subs	r6, r6, r2
 800dbc2:	02b2      	lsls	r2, r6, #10
 800dbc4:	4e71      	ldr	r6, [pc, #452]	; (800dd8c <USB_EPStartXfer+0x33c>)
 800dbc6:	4316      	orrs	r6, r2
 800dbc8:	b2b6      	uxth	r6, r6
 800dbca:	8006      	strh	r6, [r0, #0]
 800dbcc:	e7c8      	b.n	800db60 <USB_EPStartXfer+0x110>
 800dbce:	2801      	cmp	r0, #1
 800dbd0:	d1c6      	bne.n	800db60 <USB_EPStartXfer+0x110>
 800dbd2:	002a      	movs	r2, r5
 800dbd4:	4866      	ldr	r0, [pc, #408]	; (800dd70 <USB_EPStartXfer+0x320>)
 800dbd6:	3250      	adds	r2, #80	; 0x50
 800dbd8:	8816      	ldrh	r6, [r2, #0]
 800dbda:	7822      	ldrb	r2, [r4, #0]
 800dbdc:	1828      	adds	r0, r5, r0
 800dbde:	00d2      	lsls	r2, r2, #3
 800dbe0:	1980      	adds	r0, r0, r6
 800dbe2:	1812      	adds	r2, r2, r0
          PCD_SET_EP_TX_CNT(USBx, ep->num, len);
 800dbe4:	8013      	strh	r3, [r2, #0]
 800dbe6:	e7bb      	b.n	800db60 <USB_EPStartXfer+0x110>
            PCD_SET_EP_DBUF0_CNT(USBx, ep->num, ep->is_in, len);
 800dbe8:	2a00      	cmp	r2, #0
 800dbea:	d152      	bne.n	800dc92 <USB_EPStartXfer+0x242>
 800dbec:	002a      	movs	r2, r5
 800dbee:	4b60      	ldr	r3, [pc, #384]	; (800dd70 <USB_EPStartXfer+0x320>)
 800dbf0:	3250      	adds	r2, #80	; 0x50
 800dbf2:	8817      	ldrh	r7, [r2, #0]
 800dbf4:	18ea      	adds	r2, r5, r3
 800dbf6:	19d2      	adds	r2, r2, r7
 800dbf8:	00c0      	lsls	r0, r0, #3
 800dbfa:	1812      	adds	r2, r2, r0
 800dbfc:	2e00      	cmp	r6, #0
 800dbfe:	d135      	bne.n	800dc6c <USB_EPStartXfer+0x21c>
 800dc00:	8810      	ldrh	r0, [r2, #0]
 800dc02:	4f61      	ldr	r7, [pc, #388]	; (800dd88 <USB_EPStartXfer+0x338>)
 800dc04:	4038      	ands	r0, r7
 800dc06:	2780      	movs	r7, #128	; 0x80
 800dc08:	8010      	strh	r0, [r2, #0]
 800dc0a:	8810      	ldrh	r0, [r2, #0]
 800dc0c:	023f      	lsls	r7, r7, #8
 800dc0e:	4338      	orrs	r0, r7
 800dc10:	8010      	strh	r0, [r2, #0]
            USB_WritePMA(USBx, ep->xfer_buff, pmabuffer, (uint16_t)len);
 800dc12:	0028      	movs	r0, r5
 800dc14:	8922      	ldrh	r2, [r4, #8]
 800dc16:	b2b3      	uxth	r3, r6
 800dc18:	f7ff ff05 	bl	800da26 <USB_WritePMA>
            ep->xfer_buff += len;
 800dc1c:	6963      	ldr	r3, [r4, #20]
            if (ep->xfer_len_db > ep->maxpacket)
 800dc1e:	6a22      	ldr	r2, [r4, #32]
 800dc20:	6920      	ldr	r0, [r4, #16]
            ep->xfer_buff += len;
 800dc22:	1999      	adds	r1, r3, r6
 800dc24:	6161      	str	r1, [r4, #20]
              ep->xfer_len_db = 0U;
 800dc26:	2300      	movs	r3, #0
            if (ep->xfer_len_db > ep->maxpacket)
 800dc28:	4282      	cmp	r2, r0
 800dc2a:	d901      	bls.n	800dc30 <USB_EPStartXfer+0x1e0>
              ep->xfer_len_db -= len;
 800dc2c:	1b93      	subs	r3, r2, r6
 800dc2e:	0032      	movs	r2, r6
            PCD_SET_EP_DBUF1_CNT(USBx, ep->num, ep->is_in, len);
 800dc30:	7860      	ldrb	r0, [r4, #1]
 800dc32:	6223      	str	r3, [r4, #32]
 800dc34:	b293      	uxth	r3, r2
 800dc36:	2800      	cmp	r0, #0
 800dc38:	d14d      	bne.n	800dcd6 <USB_EPStartXfer+0x286>
 800dc3a:	0028      	movs	r0, r5
 800dc3c:	3050      	adds	r0, #80	; 0x50
 800dc3e:	8807      	ldrh	r7, [r0, #0]
 800dc40:	4850      	ldr	r0, [pc, #320]	; (800dd84 <USB_EPStartXfer+0x334>)
 800dc42:	7826      	ldrb	r6, [r4, #0]
 800dc44:	1828      	adds	r0, r5, r0
 800dc46:	00f6      	lsls	r6, r6, #3
 800dc48:	19c0      	adds	r0, r0, r7
 800dc4a:	1830      	adds	r0, r6, r0
 800dc4c:	2a00      	cmp	r2, #0
 800dc4e:	d12d      	bne.n	800dcac <USB_EPStartXfer+0x25c>
 800dc50:	8802      	ldrh	r2, [r0, #0]
 800dc52:	4e4d      	ldr	r6, [pc, #308]	; (800dd88 <USB_EPStartXfer+0x338>)
 800dc54:	4032      	ands	r2, r6
 800dc56:	2680      	movs	r6, #128	; 0x80
 800dc58:	8002      	strh	r2, [r0, #0]
 800dc5a:	8802      	ldrh	r2, [r0, #0]
 800dc5c:	0236      	lsls	r6, r6, #8
 800dc5e:	4332      	orrs	r2, r6
 800dc60:	8002      	strh	r2, [r0, #0]
            USB_WritePMA(USBx, ep->xfer_buff, pmabuffer, (uint16_t)len);
 800dc62:	8962      	ldrh	r2, [r4, #10]
          USB_WritePMA(USBx, ep->xfer_buff, pmabuffer, (uint16_t)len);
 800dc64:	0028      	movs	r0, r5
 800dc66:	f7ff fede 	bl	800da26 <USB_WritePMA>
 800dc6a:	e711      	b.n	800da90 <USB_EPStartXfer+0x40>
            PCD_SET_EP_DBUF0_CNT(USBx, ep->num, ep->is_in, len);
 800dc6c:	2e3e      	cmp	r6, #62	; 0x3e
 800dc6e:	d806      	bhi.n	800dc7e <USB_EPStartXfer+0x22e>
 800dc70:	2701      	movs	r7, #1
 800dc72:	0870      	lsrs	r0, r6, #1
 800dc74:	4037      	ands	r7, r6
 800dc76:	19c0      	adds	r0, r0, r7
 800dc78:	0280      	lsls	r0, r0, #10
 800dc7a:	b280      	uxth	r0, r0
 800dc7c:	e7c8      	b.n	800dc10 <USB_EPStartXfer+0x1c0>
 800dc7e:	271f      	movs	r7, #31
 800dc80:	4037      	ands	r7, r6
 800dc82:	427b      	negs	r3, r7
 800dc84:	417b      	adcs	r3, r7
 800dc86:	0970      	lsrs	r0, r6, #5
 800dc88:	1ac0      	subs	r0, r0, r3
 800dc8a:	0287      	lsls	r7, r0, #10
 800dc8c:	483f      	ldr	r0, [pc, #252]	; (800dd8c <USB_EPStartXfer+0x33c>)
 800dc8e:	4338      	orrs	r0, r7
 800dc90:	e7f3      	b.n	800dc7a <USB_EPStartXfer+0x22a>
 800dc92:	2a01      	cmp	r2, #1
 800dc94:	d1bd      	bne.n	800dc12 <USB_EPStartXfer+0x1c2>
 800dc96:	002a      	movs	r2, r5
 800dc98:	4b35      	ldr	r3, [pc, #212]	; (800dd70 <USB_EPStartXfer+0x320>)
 800dc9a:	3250      	adds	r2, #80	; 0x50
 800dc9c:	8817      	ldrh	r7, [r2, #0]
 800dc9e:	18ea      	adds	r2, r5, r3
 800dca0:	19d2      	adds	r2, r2, r7
 800dca2:	00c0      	lsls	r0, r0, #3
 800dca4:	1810      	adds	r0, r2, r0
 800dca6:	b2b3      	uxth	r3, r6
 800dca8:	8003      	strh	r3, [r0, #0]
 800dcaa:	e7b2      	b.n	800dc12 <USB_EPStartXfer+0x1c2>
            PCD_SET_EP_DBUF1_CNT(USBx, ep->num, ep->is_in, len);
 800dcac:	2a3e      	cmp	r2, #62	; 0x3e
 800dcae:	d806      	bhi.n	800dcbe <USB_EPStartXfer+0x26e>
 800dcb0:	2701      	movs	r7, #1
 800dcb2:	0856      	lsrs	r6, r2, #1
 800dcb4:	403a      	ands	r2, r7
 800dcb6:	18b6      	adds	r6, r6, r2
 800dcb8:	02b6      	lsls	r6, r6, #10
 800dcba:	b2b2      	uxth	r2, r6
 800dcbc:	e7d0      	b.n	800dc60 <USB_EPStartXfer+0x210>
 800dcbe:	271f      	movs	r7, #31
 800dcc0:	0956      	lsrs	r6, r2, #5
 800dcc2:	403a      	ands	r2, r7
 800dcc4:	4257      	negs	r7, r2
 800dcc6:	417a      	adcs	r2, r7
 800dcc8:	1ab6      	subs	r6, r6, r2
 800dcca:	02b2      	lsls	r2, r6, #10
 800dccc:	4e2f      	ldr	r6, [pc, #188]	; (800dd8c <USB_EPStartXfer+0x33c>)
 800dcce:	4316      	orrs	r6, r2
 800dcd0:	b2b6      	uxth	r6, r6
 800dcd2:	8006      	strh	r6, [r0, #0]
 800dcd4:	e7c5      	b.n	800dc62 <USB_EPStartXfer+0x212>
 800dcd6:	2801      	cmp	r0, #1
 800dcd8:	d1c3      	bne.n	800dc62 <USB_EPStartXfer+0x212>
 800dcda:	002a      	movs	r2, r5
 800dcdc:	4829      	ldr	r0, [pc, #164]	; (800dd84 <USB_EPStartXfer+0x334>)
 800dcde:	3250      	adds	r2, #80	; 0x50
 800dce0:	8816      	ldrh	r6, [r2, #0]
 800dce2:	7822      	ldrb	r2, [r4, #0]
 800dce4:	1828      	adds	r0, r5, r0
 800dce6:	00d2      	lsls	r2, r2, #3
 800dce8:	1980      	adds	r0, r0, r6
 800dcea:	1812      	adds	r2, r2, r0
 800dcec:	8013      	strh	r3, [r2, #0]
 800dcee:	e7b8      	b.n	800dc62 <USB_EPStartXfer+0x212>
          PCD_CLEAR_EP_DBUF(USBx, ep->num);
 800dcf0:	4e27      	ldr	r6, [pc, #156]	; (800dd90 <USB_EPStartXfer+0x340>)
          PCD_SET_EP_TX_CNT(USBx, ep->num, len);
 800dcf2:	b29b      	uxth	r3, r3
          PCD_CLEAR_EP_DBUF(USBx, ep->num);
 800dcf4:	4030      	ands	r0, r6
 800dcf6:	4e20      	ldr	r6, [pc, #128]	; (800dd78 <USB_EPStartXfer+0x328>)
 800dcf8:	4330      	orrs	r0, r6
 800dcfa:	b280      	uxth	r0, r0
 800dcfc:	8010      	strh	r0, [r2, #0]
          PCD_SET_EP_TX_CNT(USBx, ep->num, len);
 800dcfe:	002a      	movs	r2, r5
 800dd00:	481b      	ldr	r0, [pc, #108]	; (800dd70 <USB_EPStartXfer+0x320>)
 800dd02:	3250      	adds	r2, #80	; 0x50
 800dd04:	8816      	ldrh	r6, [r2, #0]
 800dd06:	7822      	ldrb	r2, [r4, #0]
 800dd08:	1828      	adds	r0, r5, r0
 800dd0a:	00d2      	lsls	r2, r2, #3
 800dd0c:	1980      	adds	r0, r0, r6
 800dd0e:	1812      	adds	r2, r2, r0
 800dd10:	e768      	b.n	800dbe4 <USB_EPStartXfer+0x194>
        if ((PCD_GET_ENDPOINT(USBx, ep->num) & USB_EP_DTOG_TX) != 0U)
 800dd12:	b2b3      	uxth	r3, r6
 800dd14:	002e      	movs	r6, r5
 800dd16:	8812      	ldrh	r2, [r2, #0]
 800dd18:	3650      	adds	r6, #80	; 0x50
          PCD_SET_EP_DBUF1_CNT(USBx, ep->num, ep->is_in, len);
 800dd1a:	8836      	ldrh	r6, [r6, #0]
 800dd1c:	00c0      	lsls	r0, r0, #3
        if ((PCD_GET_ENDPOINT(USBx, ep->num) & USB_EP_DTOG_TX) != 0U)
 800dd1e:	0652      	lsls	r2, r2, #25
 800dd20:	d515      	bpl.n	800dd4e <USB_EPStartXfer+0x2fe>
          PCD_SET_EP_DBUF1_CNT(USBx, ep->num, ep->is_in, len);
 800dd22:	4a18      	ldr	r2, [pc, #96]	; (800dd84 <USB_EPStartXfer+0x334>)
 800dd24:	18aa      	adds	r2, r5, r2
 800dd26:	1992      	adds	r2, r2, r6
 800dd28:	1812      	adds	r2, r2, r0
 800dd2a:	8013      	strh	r3, [r2, #0]
          pmabuffer = ep->pmaaddr1;
 800dd2c:	8962      	ldrh	r2, [r4, #10]
        USB_WritePMA(USBx, ep->xfer_buff, pmabuffer, (uint16_t)len);
 800dd2e:	0028      	movs	r0, r5
 800dd30:	f7ff fe79 	bl	800da26 <USB_WritePMA>
        PCD_FreeUserBuffer(USBx, ep->num, ep->is_in);
 800dd34:	7862      	ldrb	r2, [r4, #1]
 800dd36:	7823      	ldrb	r3, [r4, #0]
 800dd38:	2a00      	cmp	r2, #0
 800dd3a:	d10f      	bne.n	800dd5c <USB_EPStartXfer+0x30c>
 800dd3c:	009b      	lsls	r3, r3, #2
 800dd3e:	18eb      	adds	r3, r5, r3
 800dd40:	490e      	ldr	r1, [pc, #56]	; (800dd7c <USB_EPStartXfer+0x32c>)
 800dd42:	881a      	ldrh	r2, [r3, #0]
 800dd44:	400a      	ands	r2, r1
 800dd46:	4913      	ldr	r1, [pc, #76]	; (800dd94 <USB_EPStartXfer+0x344>)
 800dd48:	430a      	orrs	r2, r1
 800dd4a:	801a      	strh	r2, [r3, #0]
 800dd4c:	e6a0      	b.n	800da90 <USB_EPStartXfer+0x40>
          PCD_SET_EP_DBUF0_CNT(USBx, ep->num, ep->is_in, len);
 800dd4e:	4a08      	ldr	r2, [pc, #32]	; (800dd70 <USB_EPStartXfer+0x320>)
 800dd50:	18aa      	adds	r2, r5, r2
 800dd52:	1992      	adds	r2, r2, r6
 800dd54:	1812      	adds	r2, r2, r0
 800dd56:	8013      	strh	r3, [r2, #0]
          pmabuffer = ep->pmaaddr0;
 800dd58:	8922      	ldrh	r2, [r4, #8]
 800dd5a:	e7e8      	b.n	800dd2e <USB_EPStartXfer+0x2de>
        PCD_FreeUserBuffer(USBx, ep->num, ep->is_in);
 800dd5c:	2a01      	cmp	r2, #1
 800dd5e:	d000      	beq.n	800dd62 <USB_EPStartXfer+0x312>
 800dd60:	e696      	b.n	800da90 <USB_EPStartXfer+0x40>
 800dd62:	009b      	lsls	r3, r3, #2
 800dd64:	18eb      	adds	r3, r5, r3
 800dd66:	4905      	ldr	r1, [pc, #20]	; (800dd7c <USB_EPStartXfer+0x32c>)
 800dd68:	881a      	ldrh	r2, [r3, #0]
 800dd6a:	400a      	ands	r2, r1
 800dd6c:	490a      	ldr	r1, [pc, #40]	; (800dd98 <USB_EPStartXfer+0x348>)
 800dd6e:	e7eb      	b.n	800dd48 <USB_EPStartXfer+0x2f8>
 800dd70:	00000402 	.word	0x00000402
 800dd74:	ffff8fbf 	.word	0xffff8fbf
 800dd78:	ffff8080 	.word	0xffff8080
 800dd7c:	ffff8f8f 	.word	0xffff8f8f
 800dd80:	00008180 	.word	0x00008180
 800dd84:	00000406 	.word	0x00000406
 800dd88:	ffff83ff 	.word	0xffff83ff
 800dd8c:	ffff8000 	.word	0xffff8000
 800dd90:	ffff8e8f 	.word	0xffff8e8f
 800dd94:	000080c0 	.word	0x000080c0
 800dd98:	0000c080 	.word	0x0000c080
    if (ep->doublebuffer == 0U)
 800dd9c:	2a00      	cmp	r2, #0
 800dd9e:	d11c      	bne.n	800ddda <USB_EPStartXfer+0x38a>
      if (ep->xfer_len > ep->maxpacket)
 800dda0:	69a3      	ldr	r3, [r4, #24]
 800dda2:	6921      	ldr	r1, [r4, #16]
 800dda4:	428b      	cmp	r3, r1
 800dda6:	d901      	bls.n	800ddac <USB_EPStartXfer+0x35c>
        ep->xfer_len -= len;
 800dda8:	1a5a      	subs	r2, r3, r1
 800ddaa:	000b      	movs	r3, r1
 800ddac:	61a2      	str	r2, [r4, #24]
      PCD_SET_EP_RX_CNT(USBx, ep->num, len);
 800ddae:	002a      	movs	r2, r5
 800ddb0:	4980      	ldr	r1, [pc, #512]	; (800dfb4 <USB_EPStartXfer+0x564>)
 800ddb2:	3250      	adds	r2, #80	; 0x50
 800ddb4:	8810      	ldrh	r0, [r2, #0]
 800ddb6:	7822      	ldrb	r2, [r4, #0]
 800ddb8:	1869      	adds	r1, r5, r1
 800ddba:	00d2      	lsls	r2, r2, #3
 800ddbc:	1809      	adds	r1, r1, r0
        PCD_SET_EP_DBUF_CNT(USBx, ep->num, ep->is_in, len);
 800ddbe:	1889      	adds	r1, r1, r2
 800ddc0:	2b00      	cmp	r3, #0
 800ddc2:	d000      	beq.n	800ddc6 <USB_EPStartXfer+0x376>
 800ddc4:	e0d4      	b.n	800df70 <USB_EPStartXfer+0x520>
 800ddc6:	880b      	ldrh	r3, [r1, #0]
 800ddc8:	4a7b      	ldr	r2, [pc, #492]	; (800dfb8 <USB_EPStartXfer+0x568>)
 800ddca:	4013      	ands	r3, r2
 800ddcc:	2280      	movs	r2, #128	; 0x80
 800ddce:	800b      	strh	r3, [r1, #0]
 800ddd0:	880b      	ldrh	r3, [r1, #0]
 800ddd2:	0212      	lsls	r2, r2, #8
 800ddd4:	4313      	orrs	r3, r2
 800ddd6:	800b      	strh	r3, [r1, #0]
 800ddd8:	e064      	b.n	800dea4 <USB_EPStartXfer+0x454>
      if (ep->type == EP_TYPE_BULK)
 800ddda:	78e3      	ldrb	r3, [r4, #3]
 800dddc:	2b02      	cmp	r3, #2
 800ddde:	d000      	beq.n	800dde2 <USB_EPStartXfer+0x392>
 800dde0:	e085      	b.n	800deee <USB_EPStartXfer+0x49e>
        PCD_SET_EP_DBUF_CNT(USBx, ep->num, ep->is_in, ep->maxpacket);
 800dde2:	2900      	cmp	r1, #0
 800dde4:	d11e      	bne.n	800de24 <USB_EPStartXfer+0x3d4>
 800dde6:	0003      	movs	r3, r0
 800dde8:	4a74      	ldr	r2, [pc, #464]	; (800dfbc <USB_EPStartXfer+0x56c>)
 800ddea:	3350      	adds	r3, #80	; 0x50
 800ddec:	8819      	ldrh	r1, [r3, #0]
 800ddee:	7823      	ldrb	r3, [r4, #0]
 800ddf0:	1882      	adds	r2, r0, r2
 800ddf2:	00db      	lsls	r3, r3, #3
 800ddf4:	1852      	adds	r2, r2, r1
 800ddf6:	189a      	adds	r2, r3, r2
 800ddf8:	6923      	ldr	r3, [r4, #16]
 800ddfa:	2b00      	cmp	r3, #0
 800ddfc:	d109      	bne.n	800de12 <USB_EPStartXfer+0x3c2>
 800ddfe:	8813      	ldrh	r3, [r2, #0]
 800de00:	496d      	ldr	r1, [pc, #436]	; (800dfb8 <USB_EPStartXfer+0x568>)
 800de02:	400b      	ands	r3, r1
 800de04:	2180      	movs	r1, #128	; 0x80
 800de06:	8013      	strh	r3, [r2, #0]
 800de08:	8813      	ldrh	r3, [r2, #0]
 800de0a:	0209      	lsls	r1, r1, #8
 800de0c:	430b      	orrs	r3, r1
 800de0e:	8013      	strh	r3, [r2, #0]
 800de10:	e008      	b.n	800de24 <USB_EPStartXfer+0x3d4>
 800de12:	2b3e      	cmp	r3, #62	; 0x3e
 800de14:	d81f      	bhi.n	800de56 <USB_EPStartXfer+0x406>
 800de16:	2001      	movs	r0, #1
 800de18:	0859      	lsrs	r1, r3, #1
 800de1a:	4003      	ands	r3, r0
 800de1c:	18c9      	adds	r1, r1, r3
 800de1e:	0289      	lsls	r1, r1, #10
 800de20:	b289      	uxth	r1, r1
 800de22:	8011      	strh	r1, [r2, #0]
 800de24:	7862      	ldrb	r2, [r4, #1]
 800de26:	7823      	ldrb	r3, [r4, #0]
 800de28:	2a00      	cmp	r2, #0
 800de2a:	d152      	bne.n	800ded2 <USB_EPStartXfer+0x482>
 800de2c:	002a      	movs	r2, r5
 800de2e:	3250      	adds	r2, #80	; 0x50
 800de30:	8811      	ldrh	r1, [r2, #0]
 800de32:	4a60      	ldr	r2, [pc, #384]	; (800dfb4 <USB_EPStartXfer+0x564>)
 800de34:	00db      	lsls	r3, r3, #3
 800de36:	18aa      	adds	r2, r5, r2
 800de38:	1852      	adds	r2, r2, r1
 800de3a:	18d2      	adds	r2, r2, r3
 800de3c:	6923      	ldr	r3, [r4, #16]
 800de3e:	2b00      	cmp	r3, #0
 800de40:	d114      	bne.n	800de6c <USB_EPStartXfer+0x41c>
 800de42:	8813      	ldrh	r3, [r2, #0]
 800de44:	495c      	ldr	r1, [pc, #368]	; (800dfb8 <USB_EPStartXfer+0x568>)
 800de46:	400b      	ands	r3, r1
 800de48:	2180      	movs	r1, #128	; 0x80
 800de4a:	8013      	strh	r3, [r2, #0]
 800de4c:	8813      	ldrh	r3, [r2, #0]
 800de4e:	0209      	lsls	r1, r1, #8
 800de50:	430b      	orrs	r3, r1
 800de52:	8013      	strh	r3, [r2, #0]
 800de54:	e013      	b.n	800de7e <USB_EPStartXfer+0x42e>
 800de56:	201f      	movs	r0, #31
 800de58:	0959      	lsrs	r1, r3, #5
 800de5a:	4003      	ands	r3, r0
 800de5c:	4258      	negs	r0, r3
 800de5e:	4143      	adcs	r3, r0
 800de60:	1ac9      	subs	r1, r1, r3
 800de62:	4b57      	ldr	r3, [pc, #348]	; (800dfc0 <USB_EPStartXfer+0x570>)
 800de64:	0289      	lsls	r1, r1, #10
 800de66:	430b      	orrs	r3, r1
 800de68:	b29b      	uxth	r3, r3
 800de6a:	e7d0      	b.n	800de0e <USB_EPStartXfer+0x3be>
 800de6c:	2b3e      	cmp	r3, #62	; 0x3e
 800de6e:	d825      	bhi.n	800debc <USB_EPStartXfer+0x46c>
 800de70:	2001      	movs	r0, #1
 800de72:	0859      	lsrs	r1, r3, #1
 800de74:	4003      	ands	r3, r0
 800de76:	18c9      	adds	r1, r1, r3
 800de78:	0289      	lsls	r1, r1, #10
 800de7a:	b289      	uxth	r1, r1
 800de7c:	8011      	strh	r1, [r2, #0]
        if (ep->xfer_count != 0U)
 800de7e:	69e3      	ldr	r3, [r4, #28]
 800de80:	2b00      	cmp	r3, #0
 800de82:	d00f      	beq.n	800dea4 <USB_EPStartXfer+0x454>
 800de84:	7823      	ldrb	r3, [r4, #0]
 800de86:	494f      	ldr	r1, [pc, #316]	; (800dfc4 <USB_EPStartXfer+0x574>)
 800de88:	009b      	lsls	r3, r3, #2
 800de8a:	18eb      	adds	r3, r5, r3
          wEPVal = PCD_GET_ENDPOINT(USBx, ep->num);
 800de8c:	881a      	ldrh	r2, [r3, #0]
          if ((((wEPVal & USB_EP_DTOG_RX) != 0U) && ((wEPVal & USB_EP_DTOG_TX) != 0U)) ||
 800de8e:	400a      	ands	r2, r1
 800de90:	428a      	cmp	r2, r1
 800de92:	d001      	beq.n	800de98 <USB_EPStartXfer+0x448>
 800de94:	2a00      	cmp	r2, #0
 800de96:	d105      	bne.n	800dea4 <USB_EPStartXfer+0x454>
            PCD_FreeUserBuffer(USBx, ep->num, 0U);
 800de98:	881a      	ldrh	r2, [r3, #0]
 800de9a:	494b      	ldr	r1, [pc, #300]	; (800dfc8 <USB_EPStartXfer+0x578>)
 800de9c:	400a      	ands	r2, r1
 800de9e:	494b      	ldr	r1, [pc, #300]	; (800dfcc <USB_EPStartXfer+0x57c>)
 800dea0:	430a      	orrs	r2, r1
 800dea2:	801a      	strh	r2, [r3, #0]
    PCD_SET_EP_RX_STATUS(USBx, ep->num, USB_EP_RX_VALID);
 800dea4:	7820      	ldrb	r0, [r4, #0]
 800dea6:	4a4a      	ldr	r2, [pc, #296]	; (800dfd0 <USB_EPStartXfer+0x580>)
 800dea8:	0080      	lsls	r0, r0, #2
 800deaa:	182d      	adds	r5, r5, r0
 800deac:	882b      	ldrh	r3, [r5, #0]
 800deae:	401a      	ands	r2, r3
 800deb0:	23c0      	movs	r3, #192	; 0xc0
 800deb2:	019b      	lsls	r3, r3, #6
 800deb4:	4053      	eors	r3, r2
 800deb6:	4a47      	ldr	r2, [pc, #284]	; (800dfd4 <USB_EPStartXfer+0x584>)
 800deb8:	4313      	orrs	r3, r2
 800deba:	e5f4      	b.n	800daa6 <USB_EPStartXfer+0x56>
        PCD_SET_EP_DBUF_CNT(USBx, ep->num, ep->is_in, ep->maxpacket);
 800debc:	201f      	movs	r0, #31
 800debe:	0959      	lsrs	r1, r3, #5
 800dec0:	4003      	ands	r3, r0
 800dec2:	4258      	negs	r0, r3
 800dec4:	4143      	adcs	r3, r0
 800dec6:	1ac9      	subs	r1, r1, r3
 800dec8:	4b3d      	ldr	r3, [pc, #244]	; (800dfc0 <USB_EPStartXfer+0x570>)
 800deca:	0289      	lsls	r1, r1, #10
 800decc:	430b      	orrs	r3, r1
 800dece:	b29b      	uxth	r3, r3
 800ded0:	e7bf      	b.n	800de52 <USB_EPStartXfer+0x402>
 800ded2:	2a01      	cmp	r2, #1
 800ded4:	d1d3      	bne.n	800de7e <USB_EPStartXfer+0x42e>
 800ded6:	002a      	movs	r2, r5
 800ded8:	4936      	ldr	r1, [pc, #216]	; (800dfb4 <USB_EPStartXfer+0x564>)
 800deda:	3250      	adds	r2, #80	; 0x50
 800dedc:	8812      	ldrh	r2, [r2, #0]
 800dede:	1869      	adds	r1, r5, r1
 800dee0:	1889      	adds	r1, r1, r2
 800dee2:	6922      	ldr	r2, [r4, #16]
 800dee4:	00db      	lsls	r3, r3, #3
 800dee6:	18cb      	adds	r3, r1, r3
 800dee8:	b292      	uxth	r2, r2
 800deea:	801a      	strh	r2, [r3, #0]
 800deec:	e7c7      	b.n	800de7e <USB_EPStartXfer+0x42e>
        return HAL_ERROR;
 800deee:	2001      	movs	r0, #1
      else if (ep->type == EP_TYPE_ISOC)
 800def0:	4283      	cmp	r3, r0
 800def2:	d000      	beq.n	800def6 <USB_EPStartXfer+0x4a6>
 800def4:	e5d9      	b.n	800daaa <USB_EPStartXfer+0x5a>
        if (ep->xfer_len > ep->maxpacket)
 800def6:	69a3      	ldr	r3, [r4, #24]
 800def8:	6922      	ldr	r2, [r4, #16]
          ep->xfer_len = 0U;
 800defa:	2000      	movs	r0, #0
        if (ep->xfer_len > ep->maxpacket)
 800defc:	4293      	cmp	r3, r2
 800defe:	d901      	bls.n	800df04 <USB_EPStartXfer+0x4b4>
          ep->xfer_len -= len;
 800df00:	1a98      	subs	r0, r3, r2
 800df02:	0013      	movs	r3, r2
 800df04:	61a0      	str	r0, [r4, #24]
        PCD_SET_EP_DBUF_CNT(USBx, ep->num, ep->is_in, len);
 800df06:	2900      	cmp	r1, #0
 800df08:	d113      	bne.n	800df32 <USB_EPStartXfer+0x4e2>
 800df0a:	002a      	movs	r2, r5
 800df0c:	492b      	ldr	r1, [pc, #172]	; (800dfbc <USB_EPStartXfer+0x56c>)
 800df0e:	3250      	adds	r2, #80	; 0x50
 800df10:	8810      	ldrh	r0, [r2, #0]
 800df12:	7822      	ldrb	r2, [r4, #0]
 800df14:	1869      	adds	r1, r5, r1
 800df16:	00d2      	lsls	r2, r2, #3
 800df18:	1809      	adds	r1, r1, r0
 800df1a:	1851      	adds	r1, r2, r1
 800df1c:	2b00      	cmp	r3, #0
 800df1e:	d114      	bne.n	800df4a <USB_EPStartXfer+0x4fa>
 800df20:	880a      	ldrh	r2, [r1, #0]
 800df22:	4825      	ldr	r0, [pc, #148]	; (800dfb8 <USB_EPStartXfer+0x568>)
 800df24:	4002      	ands	r2, r0
 800df26:	2080      	movs	r0, #128	; 0x80
 800df28:	800a      	strh	r2, [r1, #0]
 800df2a:	880a      	ldrh	r2, [r1, #0]
 800df2c:	0200      	lsls	r0, r0, #8
 800df2e:	4302      	orrs	r2, r0
 800df30:	800a      	strh	r2, [r1, #0]
 800df32:	7861      	ldrb	r1, [r4, #1]
 800df34:	7822      	ldrb	r2, [r4, #0]
 800df36:	2900      	cmp	r1, #0
 800df38:	d12f      	bne.n	800df9a <USB_EPStartXfer+0x54a>
 800df3a:	0029      	movs	r1, r5
 800df3c:	481d      	ldr	r0, [pc, #116]	; (800dfb4 <USB_EPStartXfer+0x564>)
 800df3e:	3150      	adds	r1, #80	; 0x50
 800df40:	8809      	ldrh	r1, [r1, #0]
 800df42:	1828      	adds	r0, r5, r0
 800df44:	1841      	adds	r1, r0, r1
 800df46:	00d2      	lsls	r2, r2, #3
 800df48:	e739      	b.n	800ddbe <USB_EPStartXfer+0x36e>
 800df4a:	2b3e      	cmp	r3, #62	; 0x3e
 800df4c:	d806      	bhi.n	800df5c <USB_EPStartXfer+0x50c>
 800df4e:	2001      	movs	r0, #1
 800df50:	085a      	lsrs	r2, r3, #1
 800df52:	4018      	ands	r0, r3
 800df54:	1812      	adds	r2, r2, r0
 800df56:	0292      	lsls	r2, r2, #10
 800df58:	b292      	uxth	r2, r2
 800df5a:	e7e9      	b.n	800df30 <USB_EPStartXfer+0x4e0>
 800df5c:	201f      	movs	r0, #31
 800df5e:	4018      	ands	r0, r3
 800df60:	4246      	negs	r6, r0
 800df62:	4170      	adcs	r0, r6
 800df64:	095a      	lsrs	r2, r3, #5
 800df66:	1a12      	subs	r2, r2, r0
 800df68:	0290      	lsls	r0, r2, #10
 800df6a:	4a15      	ldr	r2, [pc, #84]	; (800dfc0 <USB_EPStartXfer+0x570>)
 800df6c:	4302      	orrs	r2, r0
 800df6e:	e7f3      	b.n	800df58 <USB_EPStartXfer+0x508>
 800df70:	2b3e      	cmp	r3, #62	; 0x3e
 800df72:	d807      	bhi.n	800df84 <USB_EPStartXfer+0x534>
 800df74:	2001      	movs	r0, #1
 800df76:	085a      	lsrs	r2, r3, #1
 800df78:	4003      	ands	r3, r0
 800df7a:	18d2      	adds	r2, r2, r3
 800df7c:	0292      	lsls	r2, r2, #10
 800df7e:	b292      	uxth	r2, r2
 800df80:	800a      	strh	r2, [r1, #0]
 800df82:	e78f      	b.n	800dea4 <USB_EPStartXfer+0x454>
 800df84:	201f      	movs	r0, #31
 800df86:	095a      	lsrs	r2, r3, #5
 800df88:	4003      	ands	r3, r0
 800df8a:	4258      	negs	r0, r3
 800df8c:	4143      	adcs	r3, r0
 800df8e:	1ad2      	subs	r2, r2, r3
 800df90:	4b0b      	ldr	r3, [pc, #44]	; (800dfc0 <USB_EPStartXfer+0x570>)
 800df92:	0292      	lsls	r2, r2, #10
 800df94:	4313      	orrs	r3, r2
 800df96:	b29b      	uxth	r3, r3
 800df98:	e71d      	b.n	800ddd6 <USB_EPStartXfer+0x386>
 800df9a:	2901      	cmp	r1, #1
 800df9c:	d000      	beq.n	800dfa0 <USB_EPStartXfer+0x550>
 800df9e:	e781      	b.n	800dea4 <USB_EPStartXfer+0x454>
 800dfa0:	0029      	movs	r1, r5
 800dfa2:	3150      	adds	r1, #80	; 0x50
 800dfa4:	8808      	ldrh	r0, [r1, #0]
 800dfa6:	4903      	ldr	r1, [pc, #12]	; (800dfb4 <USB_EPStartXfer+0x564>)
 800dfa8:	00d2      	lsls	r2, r2, #3
 800dfaa:	1869      	adds	r1, r5, r1
 800dfac:	1809      	adds	r1, r1, r0
 800dfae:	1889      	adds	r1, r1, r2
 800dfb0:	e7f1      	b.n	800df96 <USB_EPStartXfer+0x546>
 800dfb2:	46c0      	nop			; (mov r8, r8)
 800dfb4:	00000406 	.word	0x00000406
 800dfb8:	ffff83ff 	.word	0xffff83ff
 800dfbc:	00000402 	.word	0x00000402
 800dfc0:	ffff8000 	.word	0xffff8000
 800dfc4:	00004040 	.word	0x00004040
 800dfc8:	ffff8f8f 	.word	0xffff8f8f
 800dfcc:	000080c0 	.word	0x000080c0
 800dfd0:	ffffbf8f 	.word	0xffffbf8f
 800dfd4:	00008080 	.word	0x00008080

0800dfd8 <USB_ReadPMA>:
  * @param   wPMABufAddr address into PMA.
  * @param   wNBytes no. of bytes to be copied.
  * @retval None
  */
void USB_ReadPMA(USB_TypeDef *USBx, uint8_t *pbUsrBuf, uint16_t wPMABufAddr, uint16_t wNBytes)
{
 800dfd8:	b5f0      	push	{r4, r5, r6, r7, lr}
  uint32_t BaseAddr = (uint32_t)USBx;
  uint32_t i, temp;
  __IO uint16_t *pdwVal;
  uint8_t *pBuf = pbUsrBuf;

  pdwVal = (__IO uint16_t *)(BaseAddr + 0x400U + ((uint32_t)wPMABufAddr * PMA_ACCESS));
 800dfda:	2580      	movs	r5, #128	; 0x80
  uint32_t n = (uint32_t)wNBytes >> 1;
 800dfdc:	085c      	lsrs	r4, r3, #1
  pdwVal = (__IO uint16_t *)(BaseAddr + 0x400U + ((uint32_t)wPMABufAddr * PMA_ACCESS));
 800dfde:	00ed      	lsls	r5, r5, #3
 800dfe0:	1952      	adds	r2, r2, r5

  for (i = n; i != 0U; i--)
 800dfe2:	0026      	movs	r6, r4
  uint8_t *pBuf = pbUsrBuf;
 800dfe4:	000d      	movs	r5, r1
  pdwVal = (__IO uint16_t *)(BaseAddr + 0x400U + ((uint32_t)wPMABufAddr * PMA_ACCESS));
 800dfe6:	1880      	adds	r0, r0, r2
  for (i = n; i != 0U; i--)
 800dfe8:	1a47      	subs	r7, r0, r1
 800dfea:	197a      	adds	r2, r7, r5
 800dfec:	2e00      	cmp	r6, #0
 800dfee:	d107      	bne.n	800e000 <USB_ReadPMA+0x28>
 800dff0:	0064      	lsls	r4, r4, #1
 800dff2:	1900      	adds	r0, r0, r4
 800dff4:	1909      	adds	r1, r1, r4
#if PMA_ACCESS > 1U
    pdwVal++;
#endif
  }

  if ((wNBytes % 2U) != 0U)
 800dff6:	07db      	lsls	r3, r3, #31
 800dff8:	d501      	bpl.n	800dffe <USB_ReadPMA+0x26>
  {
    temp = *pdwVal;
 800dffa:	8803      	ldrh	r3, [r0, #0]
    *pBuf = (uint8_t)((temp >> 0) & 0xFFU);
 800dffc:	700b      	strb	r3, [r1, #0]
  }
}
 800dffe:	bdf0      	pop	{r4, r5, r6, r7, pc}
    temp = *(__IO uint16_t *)pdwVal;
 800e000:	8812      	ldrh	r2, [r2, #0]
  for (i = n; i != 0U; i--)
 800e002:	3e01      	subs	r6, #1
    temp = *(__IO uint16_t *)pdwVal;
 800e004:	b292      	uxth	r2, r2
    *pBuf = (uint8_t)((temp >> 0) & 0xFFU);
 800e006:	702a      	strb	r2, [r5, #0]
    *pBuf = (uint8_t)((temp >> 8) & 0xFFU);
 800e008:	0a12      	lsrs	r2, r2, #8
 800e00a:	706a      	strb	r2, [r5, #1]
    pBuf++;
 800e00c:	3502      	adds	r5, #2
  for (i = n; i != 0U; i--)
 800e00e:	e7ec      	b.n	800dfea <USB_ReadPMA+0x12>

0800e010 <USBD_CDC_EP0_RxReady>:
  */
static uint8_t  USBD_CDC_EP0_RxReady(USBD_HandleTypeDef *pdev)
{
  USBD_CDC_HandleTypeDef   *hcdc = (USBD_CDC_HandleTypeDef *) pdev->pClassData;

  if ((pdev->pUserData != NULL) && (hcdc->CmdOpCode != 0xFFU))
 800e010:	23af      	movs	r3, #175	; 0xaf
 800e012:	009b      	lsls	r3, r3, #2
 800e014:	58c3      	ldr	r3, [r0, r3]
{
 800e016:	b570      	push	{r4, r5, r6, lr}
  if ((pdev->pUserData != NULL) && (hcdc->CmdOpCode != 0xFFU))
 800e018:	2b00      	cmp	r3, #0
 800e01a:	d00e      	beq.n	800e03a <USBD_CDC_EP0_RxReady+0x2a>
  USBD_CDC_HandleTypeDef   *hcdc = (USBD_CDC_HandleTypeDef *) pdev->pClassData;
 800e01c:	22ae      	movs	r2, #174	; 0xae
  if ((pdev->pUserData != NULL) && (hcdc->CmdOpCode != 0xFFU))
 800e01e:	2580      	movs	r5, #128	; 0x80
  USBD_CDC_HandleTypeDef   *hcdc = (USBD_CDC_HandleTypeDef *) pdev->pClassData;
 800e020:	0092      	lsls	r2, r2, #2
 800e022:	5884      	ldr	r4, [r0, r2]
  if ((pdev->pUserData != NULL) && (hcdc->CmdOpCode != 0xFFU))
 800e024:	00ad      	lsls	r5, r5, #2
 800e026:	5d60      	ldrb	r0, [r4, r5]
 800e028:	28ff      	cmp	r0, #255	; 0xff
 800e02a:	d006      	beq.n	800e03a <USBD_CDC_EP0_RxReady+0x2a>
  {
    ((USBD_CDC_ItfTypeDef *)pdev->pUserData)->Control(hcdc->CmdOpCode,
 800e02c:	4a04      	ldr	r2, [pc, #16]	; (800e040 <USBD_CDC_EP0_RxReady+0x30>)
 800e02e:	689b      	ldr	r3, [r3, #8]
 800e030:	0021      	movs	r1, r4
 800e032:	5ca2      	ldrb	r2, [r4, r2]
 800e034:	4798      	blx	r3
                                                      (uint8_t *)(void *)hcdc->data,
                                                      (uint16_t)hcdc->CmdLength);
    hcdc->CmdOpCode = 0xFFU;
 800e036:	23ff      	movs	r3, #255	; 0xff
 800e038:	5563      	strb	r3, [r4, r5]

  }
  return USBD_OK;
}
 800e03a:	2000      	movs	r0, #0
 800e03c:	bd70      	pop	{r4, r5, r6, pc}
 800e03e:	46c0      	nop			; (mov r8, r8)
 800e040:	00000201 	.word	0x00000201

0800e044 <USBD_CDC_GetFSCfgDesc>:
  * @param  length : pointer data length
  * @retval pointer to descriptor buffer
  */
static uint8_t  *USBD_CDC_GetFSCfgDesc(uint16_t *length)
{
  *length = sizeof(USBD_CDC_CfgFSDesc);
 800e044:	2343      	movs	r3, #67	; 0x43
 800e046:	8003      	strh	r3, [r0, #0]
  return USBD_CDC_CfgFSDesc;
}
 800e048:	4800      	ldr	r0, [pc, #0]	; (800e04c <USBD_CDC_GetFSCfgDesc+0x8>)
 800e04a:	4770      	bx	lr
 800e04c:	2000049c 	.word	0x2000049c

0800e050 <USBD_CDC_GetHSCfgDesc>:
  * @param  length : pointer data length
  * @retval pointer to descriptor buffer
  */
static uint8_t  *USBD_CDC_GetHSCfgDesc(uint16_t *length)
{
  *length = sizeof(USBD_CDC_CfgHSDesc);
 800e050:	2343      	movs	r3, #67	; 0x43
 800e052:	8003      	strh	r3, [r0, #0]
  return USBD_CDC_CfgHSDesc;
}
 800e054:	4800      	ldr	r0, [pc, #0]	; (800e058 <USBD_CDC_GetHSCfgDesc+0x8>)
 800e056:	4770      	bx	lr
 800e058:	200004e0 	.word	0x200004e0

0800e05c <USBD_CDC_GetOtherSpeedCfgDesc>:
  * @param  length : pointer data length
  * @retval pointer to descriptor buffer
  */
static uint8_t  *USBD_CDC_GetOtherSpeedCfgDesc(uint16_t *length)
{
  *length = sizeof(USBD_CDC_OtherSpeedCfgDesc);
 800e05c:	2343      	movs	r3, #67	; 0x43
 800e05e:	8003      	strh	r3, [r0, #0]
  return USBD_CDC_OtherSpeedCfgDesc;
}
 800e060:	4800      	ldr	r0, [pc, #0]	; (800e064 <USBD_CDC_GetOtherSpeedCfgDesc+0x8>)
 800e062:	4770      	bx	lr
 800e064:	20000530 	.word	0x20000530

0800e068 <USBD_CDC_GetDeviceQualifierDescriptor>:
* @param  length : pointer data length
* @retval pointer to descriptor buffer
*/
uint8_t  *USBD_CDC_GetDeviceQualifierDescriptor(uint16_t *length)
{
  *length = sizeof(USBD_CDC_DeviceQualifierDesc);
 800e068:	230a      	movs	r3, #10
 800e06a:	8003      	strh	r3, [r0, #0]
  return USBD_CDC_DeviceQualifierDesc;
}
 800e06c:	4800      	ldr	r0, [pc, #0]	; (800e070 <USBD_CDC_GetDeviceQualifierDescriptor+0x8>)
 800e06e:	4770      	bx	lr
 800e070:	20000524 	.word	0x20000524

0800e074 <USBD_CDC_DataOut>:
{
 800e074:	b570      	push	{r4, r5, r6, lr}
  USBD_CDC_HandleTypeDef   *hcdc = (USBD_CDC_HandleTypeDef *) pdev->pClassData;
 800e076:	26ae      	movs	r6, #174	; 0xae
 800e078:	00b6      	lsls	r6, r6, #2
{
 800e07a:	0004      	movs	r4, r0
  USBD_CDC_HandleTypeDef   *hcdc = (USBD_CDC_HandleTypeDef *) pdev->pClassData;
 800e07c:	5985      	ldr	r5, [r0, r6]
  hcdc->RxLength = USBD_LL_GetRxDataSize(pdev, epnum);
 800e07e:	f001 fcc9 	bl	800fa14 <USBD_LL_GetRxDataSize>
 800e082:	2383      	movs	r3, #131	; 0x83
 800e084:	009b      	lsls	r3, r3, #2
 800e086:	50e8      	str	r0, [r5, r3]
  if (pdev->pClassData != NULL)
 800e088:	59a3      	ldr	r3, [r4, r6]
    return USBD_FAIL;
 800e08a:	2002      	movs	r0, #2
  if (pdev->pClassData != NULL)
 800e08c:	2b00      	cmp	r3, #0
 800e08e:	d00a      	beq.n	800e0a6 <USBD_CDC_DataOut+0x32>
    ((USBD_CDC_ItfTypeDef *)pdev->pUserData)->Receive(hcdc->RxBuffer, &hcdc->RxLength);
 800e090:	2383      	movs	r3, #131	; 0x83
 800e092:	2281      	movs	r2, #129	; 0x81
 800e094:	009b      	lsls	r3, r3, #2
 800e096:	18e9      	adds	r1, r5, r3
 800e098:	33b0      	adds	r3, #176	; 0xb0
 800e09a:	58e3      	ldr	r3, [r4, r3]
 800e09c:	0092      	lsls	r2, r2, #2
 800e09e:	68db      	ldr	r3, [r3, #12]
 800e0a0:	58a8      	ldr	r0, [r5, r2]
 800e0a2:	4798      	blx	r3
    return USBD_OK;
 800e0a4:	2000      	movs	r0, #0
}
 800e0a6:	bd70      	pop	{r4, r5, r6, pc}

0800e0a8 <USBD_CDC_DataIn>:
  USBD_CDC_HandleTypeDef *hcdc = (USBD_CDC_HandleTypeDef *)pdev->pClassData;
 800e0a8:	23ae      	movs	r3, #174	; 0xae
{
 800e0aa:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
  USBD_CDC_HandleTypeDef *hcdc = (USBD_CDC_HandleTypeDef *)pdev->pClassData;
 800e0ac:	009b      	lsls	r3, r3, #2
 800e0ae:	58c3      	ldr	r3, [r0, r3]
{
 800e0b0:	0005      	movs	r5, r0
 800e0b2:	000f      	movs	r7, r1
    return USBD_FAIL;
 800e0b4:	2002      	movs	r0, #2
  USBD_CDC_HandleTypeDef *hcdc = (USBD_CDC_HandleTypeDef *)pdev->pClassData;
 800e0b6:	9301      	str	r3, [sp, #4]
  if (pdev->pClassData != NULL)
 800e0b8:	2b00      	cmp	r3, #0
 800e0ba:	d018      	beq.n	800e0ee <USBD_CDC_DataIn+0x46>
    if ((pdev->ep_in[epnum].total_length > 0U) && ((pdev->ep_in[epnum].total_length % hpcd->IN_ep[epnum].maxpacket) == 0U))
 800e0bc:	2614      	movs	r6, #20
 800e0be:	434e      	muls	r6, r1
 800e0c0:	19ae      	adds	r6, r5, r6
 800e0c2:	69f0      	ldr	r0, [r6, #28]
 800e0c4:	2800      	cmp	r0, #0
 800e0c6:	d013      	beq.n	800e0f0 <USBD_CDC_DataIn+0x48>
 800e0c8:	2228      	movs	r2, #40	; 0x28
 800e0ca:	23b0      	movs	r3, #176	; 0xb0
 800e0cc:	434a      	muls	r2, r1
 800e0ce:	009b      	lsls	r3, r3, #2
 800e0d0:	58eb      	ldr	r3, [r5, r3]
 800e0d2:	189b      	adds	r3, r3, r2
 800e0d4:	6b99      	ldr	r1, [r3, #56]	; 0x38
 800e0d6:	f7fa f8cd 	bl	8008274 <__aeabi_uidivmod>
 800e0da:	1e0c      	subs	r4, r1, #0
 800e0dc:	d108      	bne.n	800e0f0 <USBD_CDC_DataIn+0x48>
      USBD_LL_Transmit(pdev, epnum, NULL, 0U);
 800e0de:	000b      	movs	r3, r1
 800e0e0:	000a      	movs	r2, r1
      pdev->ep_in[epnum].total_length = 0U;
 800e0e2:	61f1      	str	r1, [r6, #28]
      USBD_LL_Transmit(pdev, epnum, NULL, 0U);
 800e0e4:	0028      	movs	r0, r5
 800e0e6:	0039      	movs	r1, r7
 800e0e8:	f001 fc74 	bl	800f9d4 <USBD_LL_Transmit>
    return USBD_OK;
 800e0ec:	0020      	movs	r0, r4
}
 800e0ee:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
      hcdc->TxState = 0U;
 800e0f0:	2385      	movs	r3, #133	; 0x85
 800e0f2:	2000      	movs	r0, #0
 800e0f4:	9a01      	ldr	r2, [sp, #4]
 800e0f6:	009b      	lsls	r3, r3, #2
 800e0f8:	50d0      	str	r0, [r2, r3]
 800e0fa:	e7f8      	b.n	800e0ee <USBD_CDC_DataIn+0x46>

0800e0fc <USBD_CDC_Setup>:
  USBD_CDC_HandleTypeDef   *hcdc = (USBD_CDC_HandleTypeDef *) pdev->pClassData;
 800e0fc:	23ae      	movs	r3, #174	; 0xae
{
 800e0fe:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
  USBD_CDC_HandleTypeDef   *hcdc = (USBD_CDC_HandleTypeDef *) pdev->pClassData;
 800e100:	009b      	lsls	r3, r3, #2
 800e102:	58c7      	ldr	r7, [r0, r3]
  uint8_t ifalt = 0U;
 800e104:	466b      	mov	r3, sp
  uint16_t status_info = 0U;
 800e106:	466a      	mov	r2, sp
{
 800e108:	000e      	movs	r6, r1
  uint8_t ifalt = 0U;
 800e10a:	1d59      	adds	r1, r3, #5
 800e10c:	2300      	movs	r3, #0
{
 800e10e:	0005      	movs	r5, r0
  uint8_t ifalt = 0U;
 800e110:	700b      	strb	r3, [r1, #0]
  uint16_t status_info = 0U;
 800e112:	80d3      	strh	r3, [r2, #6]
  switch (req->bmRequest & USB_REQ_TYPE_MASK)
 800e114:	7833      	ldrb	r3, [r6, #0]
  uint16_t status_info = 0U;
 800e116:	1d90      	adds	r0, r2, #6
 800e118:	001c      	movs	r4, r3
 800e11a:	2260      	movs	r2, #96	; 0x60
 800e11c:	4014      	ands	r4, r2
  switch (req->bmRequest & USB_REQ_TYPE_MASK)
 800e11e:	4213      	tst	r3, r2
 800e120:	d02a      	beq.n	800e178 <USBD_CDC_Setup+0x7c>
 800e122:	2c20      	cmp	r4, #32
 800e124:	d146      	bne.n	800e1b4 <USBD_CDC_Setup+0xb8>
      if (req->wLength)
 800e126:	88f4      	ldrh	r4, [r6, #6]
 800e128:	7870      	ldrb	r0, [r6, #1]
 800e12a:	2c00      	cmp	r4, #0
 800e12c:	d01c      	beq.n	800e168 <USBD_CDC_Setup+0x6c>
        if (req->bmRequest & 0x80U)
 800e12e:	b25b      	sxtb	r3, r3
 800e130:	2b00      	cmp	r3, #0
 800e132:	da0e      	bge.n	800e152 <USBD_CDC_Setup+0x56>
          ((USBD_CDC_ItfTypeDef *)pdev->pUserData)->Control(req->bRequest,
 800e134:	23af      	movs	r3, #175	; 0xaf
 800e136:	009b      	lsls	r3, r3, #2
 800e138:	58eb      	ldr	r3, [r5, r3]
 800e13a:	0022      	movs	r2, r4
 800e13c:	0039      	movs	r1, r7
 800e13e:	689b      	ldr	r3, [r3, #8]
 800e140:	4798      	blx	r3
          USBD_CtlSendData(pdev, (uint8_t *)(void *)hcdc->data, req->wLength);
 800e142:	0039      	movs	r1, r7
 800e144:	0028      	movs	r0, r5
 800e146:	88f2      	ldrh	r2, [r6, #6]
 800e148:	f000 fcac 	bl	800eaa4 <USBD_CtlSendData>
  uint8_t ret = USBD_OK;
 800e14c:	2400      	movs	r4, #0
}
 800e14e:	0020      	movs	r0, r4
 800e150:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
          hcdc->CmdOpCode = req->bRequest;
 800e152:	2380      	movs	r3, #128	; 0x80
 800e154:	009b      	lsls	r3, r3, #2
 800e156:	54f8      	strb	r0, [r7, r3]
          hcdc->CmdLength = (uint8_t)req->wLength;
 800e158:	4b19      	ldr	r3, [pc, #100]	; (800e1c0 <USBD_CDC_Setup+0xc4>)
          USBD_CtlPrepareRx(pdev, (uint8_t *)(void *)hcdc->data, req->wLength);
 800e15a:	0022      	movs	r2, r4
 800e15c:	0039      	movs	r1, r7
 800e15e:	0028      	movs	r0, r5
          hcdc->CmdLength = (uint8_t)req->wLength;
 800e160:	54fc      	strb	r4, [r7, r3]
          USBD_CtlPrepareRx(pdev, (uint8_t *)(void *)hcdc->data, req->wLength);
 800e162:	f000 fcb5 	bl	800ead0 <USBD_CtlPrepareRx>
 800e166:	e7f1      	b.n	800e14c <USBD_CDC_Setup+0x50>
        ((USBD_CDC_ItfTypeDef *)pdev->pUserData)->Control(req->bRequest,
 800e168:	23af      	movs	r3, #175	; 0xaf
 800e16a:	009b      	lsls	r3, r3, #2
 800e16c:	58eb      	ldr	r3, [r5, r3]
 800e16e:	0022      	movs	r2, r4
 800e170:	0031      	movs	r1, r6
 800e172:	689b      	ldr	r3, [r3, #8]
 800e174:	4798      	blx	r3
 800e176:	e7ea      	b.n	800e14e <USBD_CDC_Setup+0x52>
      switch (req->bRequest)
 800e178:	7873      	ldrb	r3, [r6, #1]
 800e17a:	2b0a      	cmp	r3, #10
 800e17c:	d00e      	beq.n	800e19c <USBD_CDC_Setup+0xa0>
 800e17e:	2b0b      	cmp	r3, #11
 800e180:	d013      	beq.n	800e1aa <USBD_CDC_Setup+0xae>
 800e182:	2b00      	cmp	r3, #0
 800e184:	d116      	bne.n	800e1b4 <USBD_CDC_Setup+0xb8>
          if (pdev->dev_state == USBD_STATE_CONFIGURED)
 800e186:	23a7      	movs	r3, #167	; 0xa7
 800e188:	009b      	lsls	r3, r3, #2
 800e18a:	5ceb      	ldrb	r3, [r5, r3]
 800e18c:	2b03      	cmp	r3, #3
 800e18e:	d111      	bne.n	800e1b4 <USBD_CDC_Setup+0xb8>
            USBD_CtlSendData(pdev, (uint8_t *)(void *)&status_info, 2U);
 800e190:	2202      	movs	r2, #2
 800e192:	0001      	movs	r1, r0
            USBD_CtlSendData(pdev, &ifalt, 1U);
 800e194:	0028      	movs	r0, r5
 800e196:	f000 fc85 	bl	800eaa4 <USBD_CtlSendData>
 800e19a:	e7d8      	b.n	800e14e <USBD_CDC_Setup+0x52>
          if (pdev->dev_state == USBD_STATE_CONFIGURED)
 800e19c:	23a7      	movs	r3, #167	; 0xa7
 800e19e:	009b      	lsls	r3, r3, #2
 800e1a0:	5ceb      	ldrb	r3, [r5, r3]
 800e1a2:	2b03      	cmp	r3, #3
 800e1a4:	d106      	bne.n	800e1b4 <USBD_CDC_Setup+0xb8>
            USBD_CtlSendData(pdev, &ifalt, 1U);
 800e1a6:	2201      	movs	r2, #1
 800e1a8:	e7f4      	b.n	800e194 <USBD_CDC_Setup+0x98>
          if (pdev->dev_state != USBD_STATE_CONFIGURED)
 800e1aa:	23a7      	movs	r3, #167	; 0xa7
 800e1ac:	009b      	lsls	r3, r3, #2
 800e1ae:	5ceb      	ldrb	r3, [r5, r3]
 800e1b0:	2b03      	cmp	r3, #3
 800e1b2:	d0cc      	beq.n	800e14e <USBD_CDC_Setup+0x52>
          USBD_CtlError(pdev, req);
 800e1b4:	0031      	movs	r1, r6
 800e1b6:	0028      	movs	r0, r5
 800e1b8:	f000 fc4c 	bl	800ea54 <USBD_CtlError>
          ret = USBD_FAIL;
 800e1bc:	2402      	movs	r4, #2
          break;
 800e1be:	e7c6      	b.n	800e14e <USBD_CDC_Setup+0x52>
 800e1c0:	00000201 	.word	0x00000201

0800e1c4 <USBD_CDC_DeInit>:
{
 800e1c4:	b570      	push	{r4, r5, r6, lr}
 800e1c6:	0004      	movs	r4, r0
  pdev->ep_in[CDC_IN_EP & 0xFU].is_used = 0U;
 800e1c8:	2500      	movs	r5, #0
  USBD_LL_CloseEP(pdev, CDC_IN_EP);
 800e1ca:	2181      	movs	r1, #129	; 0x81
 800e1cc:	f001 fbac 	bl	800f928 <USBD_LL_CloseEP>
  USBD_LL_CloseEP(pdev, CDC_OUT_EP);
 800e1d0:	2101      	movs	r1, #1
 800e1d2:	0020      	movs	r0, r4
  pdev->ep_in[CDC_IN_EP & 0xFU].is_used = 0U;
 800e1d4:	62e5      	str	r5, [r4, #44]	; 0x2c
  USBD_LL_CloseEP(pdev, CDC_OUT_EP);
 800e1d6:	f001 fba7 	bl	800f928 <USBD_LL_CloseEP>
  pdev->ep_out[CDC_OUT_EP & 0xFU].is_used = 0U;
 800e1da:	0023      	movs	r3, r4
  if (pdev->pClassData != NULL)
 800e1dc:	26ae      	movs	r6, #174	; 0xae
  pdev->ep_out[CDC_OUT_EP & 0xFU].is_used = 0U;
 800e1de:	33fc      	adds	r3, #252	; 0xfc
 800e1e0:	671d      	str	r5, [r3, #112]	; 0x70
  USBD_LL_CloseEP(pdev, CDC_CMD_EP);
 800e1e2:	2182      	movs	r1, #130	; 0x82
 800e1e4:	0020      	movs	r0, r4
  if (pdev->pClassData != NULL)
 800e1e6:	00b6      	lsls	r6, r6, #2
  USBD_LL_CloseEP(pdev, CDC_CMD_EP);
 800e1e8:	f001 fb9e 	bl	800f928 <USBD_LL_CloseEP>
  if (pdev->pClassData != NULL)
 800e1ec:	59a3      	ldr	r3, [r4, r6]
  pdev->ep_in[CDC_CMD_EP & 0xFU].is_used = 0U;
 800e1ee:	6425      	str	r5, [r4, #64]	; 0x40
  if (pdev->pClassData != NULL)
 800e1f0:	42ab      	cmp	r3, r5
 800e1f2:	d008      	beq.n	800e206 <USBD_CDC_DeInit+0x42>
    ((USBD_CDC_ItfTypeDef *)pdev->pUserData)->DeInit();
 800e1f4:	23af      	movs	r3, #175	; 0xaf
 800e1f6:	009b      	lsls	r3, r3, #2
 800e1f8:	58e3      	ldr	r3, [r4, r3]
 800e1fa:	685b      	ldr	r3, [r3, #4]
 800e1fc:	4798      	blx	r3
    USBD_free(pdev->pClassData);
 800e1fe:	59a0      	ldr	r0, [r4, r6]
 800e200:	f001 fc14 	bl	800fa2c <USBD_static_free>
    pdev->pClassData = NULL;
 800e204:	51a5      	str	r5, [r4, r6]
}
 800e206:	2000      	movs	r0, #0
 800e208:	bd70      	pop	{r4, r5, r6, pc}

0800e20a <USBD_CDC_Init>:
{
 800e20a:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800e20c:	0006      	movs	r6, r0
  if (pdev->dev_speed == USBD_SPEED_HIGH)
 800e20e:	7c03      	ldrb	r3, [r0, #16]
{
 800e210:	0004      	movs	r4, r0
 800e212:	36fc      	adds	r6, #252	; 0xfc
  if (pdev->dev_speed == USBD_SPEED_HIGH)
 800e214:	2b00      	cmp	r3, #0
 800e216:	d139      	bne.n	800e28c <USBD_CDC_Init+0x82>
    USBD_LL_OpenEP(pdev, CDC_IN_EP, USBD_EP_TYPE_BULK,
 800e218:	2380      	movs	r3, #128	; 0x80
 800e21a:	2202      	movs	r2, #2
 800e21c:	009b      	lsls	r3, r3, #2
 800e21e:	2181      	movs	r1, #129	; 0x81
 800e220:	f001 fb70 	bl	800f904 <USBD_LL_OpenEP>
    pdev->ep_in[CDC_IN_EP & 0xFU].is_used = 1U;
 800e224:	2501      	movs	r5, #1
    USBD_LL_OpenEP(pdev, CDC_OUT_EP, USBD_EP_TYPE_BULK,
 800e226:	2380      	movs	r3, #128	; 0x80
    pdev->ep_in[CDC_IN_EP & 0xFU].is_used = 1U;
 800e228:	62e5      	str	r5, [r4, #44]	; 0x2c
    USBD_LL_OpenEP(pdev, CDC_OUT_EP, USBD_EP_TYPE_BULK,
 800e22a:	009b      	lsls	r3, r3, #2
    USBD_LL_OpenEP(pdev, CDC_OUT_EP, USBD_EP_TYPE_BULK,
 800e22c:	0029      	movs	r1, r5
 800e22e:	2202      	movs	r2, #2
 800e230:	0020      	movs	r0, r4
 800e232:	f001 fb67 	bl	800f904 <USBD_LL_OpenEP>
  USBD_LL_OpenEP(pdev, CDC_CMD_EP, USBD_EP_TYPE_INTR, CDC_CMD_PACKET_SIZE);
 800e236:	2308      	movs	r3, #8
    pdev->ep_out[CDC_OUT_EP & 0xFU].is_used = 1U;
 800e238:	6735      	str	r5, [r6, #112]	; 0x70
  USBD_LL_OpenEP(pdev, CDC_CMD_EP, USBD_EP_TYPE_INTR, CDC_CMD_PACKET_SIZE);
 800e23a:	2203      	movs	r2, #3
 800e23c:	2182      	movs	r1, #130	; 0x82
 800e23e:	0020      	movs	r0, r4
 800e240:	f001 fb60 	bl	800f904 <USBD_LL_OpenEP>
  pdev->ep_in[CDC_CMD_EP & 0xFU].is_used = 1U;
 800e244:	2701      	movs	r7, #1
  pdev->pClassData = USBD_malloc(sizeof(USBD_CDC_HandleTypeDef));
 800e246:	2087      	movs	r0, #135	; 0x87
  pdev->ep_in[CDC_CMD_EP & 0xFU].is_used = 1U;
 800e248:	6427      	str	r7, [r4, #64]	; 0x40
  pdev->pClassData = USBD_malloc(sizeof(USBD_CDC_HandleTypeDef));
 800e24a:	0080      	lsls	r0, r0, #2
 800e24c:	f001 fbea 	bl	800fa24 <USBD_static_malloc>
 800e250:	23ae      	movs	r3, #174	; 0xae
 800e252:	009b      	lsls	r3, r3, #2
 800e254:	0005      	movs	r5, r0
    ret = 1U;
 800e256:	003e      	movs	r6, r7
  pdev->pClassData = USBD_malloc(sizeof(USBD_CDC_HandleTypeDef));
 800e258:	50e0      	str	r0, [r4, r3]
  if (pdev->pClassData == NULL)
 800e25a:	2800      	cmp	r0, #0
 800e25c:	d014      	beq.n	800e288 <USBD_CDC_Init+0x7e>
    ((USBD_CDC_ItfTypeDef *)pdev->pUserData)->Init();
 800e25e:	3304      	adds	r3, #4
 800e260:	58e3      	ldr	r3, [r4, r3]
 800e262:	681b      	ldr	r3, [r3, #0]
 800e264:	4798      	blx	r3
    hcdc->TxState = 0U;
 800e266:	2385      	movs	r3, #133	; 0x85
 800e268:	2200      	movs	r2, #0
 800e26a:	009b      	lsls	r3, r3, #2
 800e26c:	50ea      	str	r2, [r5, r3]
    hcdc->RxState = 0U;
 800e26e:	3304      	adds	r3, #4
 800e270:	50ea      	str	r2, [r5, r3]
    if (pdev->dev_speed == USBD_SPEED_HIGH)
 800e272:	2281      	movs	r2, #129	; 0x81
 800e274:	7c26      	ldrb	r6, [r4, #16]
 800e276:	0092      	lsls	r2, r2, #2
 800e278:	2e00      	cmp	r6, #0
 800e27a:	d110      	bne.n	800e29e <USBD_CDC_Init+0x94>
      USBD_LL_PrepareReceive(pdev, CDC_OUT_EP, hcdc->RxBuffer,
 800e27c:	0039      	movs	r1, r7
 800e27e:	0020      	movs	r0, r4
 800e280:	58aa      	ldr	r2, [r5, r2]
 800e282:	3b18      	subs	r3, #24
 800e284:	f001 fbb6 	bl	800f9f4 <USBD_LL_PrepareReceive>
}
 800e288:	0030      	movs	r0, r6
 800e28a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    pdev->ep_in[CDC_IN_EP & 0xFU].is_used = 1U;
 800e28c:	2501      	movs	r5, #1
    USBD_LL_OpenEP(pdev, CDC_IN_EP, USBD_EP_TYPE_BULK,
 800e28e:	2340      	movs	r3, #64	; 0x40
 800e290:	2202      	movs	r2, #2
 800e292:	2181      	movs	r1, #129	; 0x81
 800e294:	f001 fb36 	bl	800f904 <USBD_LL_OpenEP>
    USBD_LL_OpenEP(pdev, CDC_OUT_EP, USBD_EP_TYPE_BULK,
 800e298:	2340      	movs	r3, #64	; 0x40
    pdev->ep_in[CDC_IN_EP & 0xFU].is_used = 1U;
 800e29a:	62e5      	str	r5, [r4, #44]	; 0x2c
    USBD_LL_OpenEP(pdev, CDC_OUT_EP, USBD_EP_TYPE_BULK,
 800e29c:	e7c6      	b.n	800e22c <USBD_CDC_Init+0x22>
      USBD_LL_PrepareReceive(pdev, CDC_OUT_EP, hcdc->RxBuffer,
 800e29e:	2340      	movs	r3, #64	; 0x40
 800e2a0:	0039      	movs	r1, r7
 800e2a2:	0020      	movs	r0, r4
 800e2a4:	58aa      	ldr	r2, [r5, r2]
 800e2a6:	f001 fba5 	bl	800f9f4 <USBD_LL_PrepareReceive>
  uint8_t ret = 0U;
 800e2aa:	2600      	movs	r6, #0
 800e2ac:	e7ec      	b.n	800e288 <USBD_CDC_Init+0x7e>

0800e2ae <USBD_CDC_RegisterInterface>:
  * @param  fops: CD  Interface callback
  * @retval status
  */
uint8_t  USBD_CDC_RegisterInterface(USBD_HandleTypeDef   *pdev,
                                    USBD_CDC_ItfTypeDef *fops)
{
 800e2ae:	0003      	movs	r3, r0
  uint8_t  ret = USBD_FAIL;
 800e2b0:	2002      	movs	r0, #2

  if (fops != NULL)
 800e2b2:	2900      	cmp	r1, #0
 800e2b4:	d003      	beq.n	800e2be <USBD_CDC_RegisterInterface+0x10>
  {
    pdev->pUserData = fops;
 800e2b6:	22af      	movs	r2, #175	; 0xaf
    ret = USBD_OK;
 800e2b8:	2000      	movs	r0, #0
    pdev->pUserData = fops;
 800e2ba:	0092      	lsls	r2, r2, #2
 800e2bc:	5099      	str	r1, [r3, r2]
  }

  return ret;
}
 800e2be:	4770      	bx	lr

0800e2c0 <USBD_CDC_SetTxBuffer>:
  */
uint8_t  USBD_CDC_SetTxBuffer(USBD_HandleTypeDef   *pdev,
                              uint8_t  *pbuff,
                              uint16_t length)
{
  USBD_CDC_HandleTypeDef   *hcdc = (USBD_CDC_HandleTypeDef *) pdev->pClassData;
 800e2c0:	23ae      	movs	r3, #174	; 0xae
 800e2c2:	009b      	lsls	r3, r3, #2
 800e2c4:	58c3      	ldr	r3, [r0, r3]

  hcdc->TxBuffer = pbuff;
 800e2c6:	2082      	movs	r0, #130	; 0x82
 800e2c8:	0080      	lsls	r0, r0, #2
 800e2ca:	5019      	str	r1, [r3, r0]
  hcdc->TxLength = length;
 800e2cc:	2184      	movs	r1, #132	; 0x84
 800e2ce:	0089      	lsls	r1, r1, #2

  return USBD_OK;
}
 800e2d0:	2000      	movs	r0, #0
  hcdc->TxLength = length;
 800e2d2:	505a      	str	r2, [r3, r1]
}
 800e2d4:	4770      	bx	lr

0800e2d6 <USBD_CDC_SetRxBuffer>:
uint8_t  USBD_CDC_SetRxBuffer(USBD_HandleTypeDef   *pdev,
                              uint8_t  *pbuff)
{
  USBD_CDC_HandleTypeDef   *hcdc = (USBD_CDC_HandleTypeDef *) pdev->pClassData;

  hcdc->RxBuffer = pbuff;
 800e2d6:	23ae      	movs	r3, #174	; 0xae
 800e2d8:	009b      	lsls	r3, r3, #2
 800e2da:	58c2      	ldr	r2, [r0, r3]
 800e2dc:	3bb4      	subs	r3, #180	; 0xb4

  return USBD_OK;
}
 800e2de:	2000      	movs	r0, #0
  hcdc->RxBuffer = pbuff;
 800e2e0:	50d1      	str	r1, [r2, r3]
}
 800e2e2:	4770      	bx	lr

0800e2e4 <USBD_CDC_TransmitPacket>:
  * @param  pdev: device instance
  * @retval status
  */
uint8_t  USBD_CDC_TransmitPacket(USBD_HandleTypeDef *pdev)
{
  USBD_CDC_HandleTypeDef   *hcdc = (USBD_CDC_HandleTypeDef *) pdev->pClassData;
 800e2e4:	23ae      	movs	r3, #174	; 0xae
 800e2e6:	009b      	lsls	r3, r3, #2
 800e2e8:	58c2      	ldr	r2, [r0, r3]
{
 800e2ea:	b510      	push	{r4, lr}
      return USBD_BUSY;
    }
  }
  else
  {
    return USBD_FAIL;
 800e2ec:	2302      	movs	r3, #2
  if (pdev->pClassData != NULL)
 800e2ee:	2a00      	cmp	r2, #0
 800e2f0:	d012      	beq.n	800e318 <USBD_CDC_TransmitPacket+0x34>
    if (hcdc->TxState == 0U)
 800e2f2:	2185      	movs	r1, #133	; 0x85
 800e2f4:	0089      	lsls	r1, r1, #2
 800e2f6:	5854      	ldr	r4, [r2, r1]
 800e2f8:	3b01      	subs	r3, #1
 800e2fa:	2c00      	cmp	r4, #0
 800e2fc:	d10c      	bne.n	800e318 <USBD_CDC_TransmitPacket+0x34>
      hcdc->TxState = 1U;
 800e2fe:	5053      	str	r3, [r2, r1]
      pdev->ep_in[CDC_IN_EP & 0xFU].total_length = hcdc->TxLength;
 800e300:	2384      	movs	r3, #132	; 0x84
 800e302:	009b      	lsls	r3, r3, #2
 800e304:	58d3      	ldr	r3, [r2, r3]
      USBD_LL_Transmit(pdev, CDC_IN_EP, hcdc->TxBuffer,
 800e306:	390c      	subs	r1, #12
 800e308:	5852      	ldr	r2, [r2, r1]
 800e30a:	3988      	subs	r1, #136	; 0x88
      pdev->ep_in[CDC_IN_EP & 0xFU].total_length = hcdc->TxLength;
 800e30c:	6303      	str	r3, [r0, #48]	; 0x30
      USBD_LL_Transmit(pdev, CDC_IN_EP, hcdc->TxBuffer,
 800e30e:	39ff      	subs	r1, #255	; 0xff
 800e310:	b29b      	uxth	r3, r3
 800e312:	f001 fb5f 	bl	800f9d4 <USBD_LL_Transmit>
      return USBD_OK;
 800e316:	0023      	movs	r3, r4
  }
}
 800e318:	0018      	movs	r0, r3
 800e31a:	bd10      	pop	{r4, pc}

0800e31c <USBD_CDC_ReceivePacket>:
  * @param  pdev: device instance
  * @retval status
  */
uint8_t  USBD_CDC_ReceivePacket(USBD_HandleTypeDef *pdev)
{
  USBD_CDC_HandleTypeDef   *hcdc = (USBD_CDC_HandleTypeDef *) pdev->pClassData;
 800e31c:	23ae      	movs	r3, #174	; 0xae
 800e31e:	009b      	lsls	r3, r3, #2
 800e320:	58c3      	ldr	r3, [r0, r3]
{
 800e322:	b510      	push	{r4, lr}
    }
    return USBD_OK;
  }
  else
  {
    return USBD_FAIL;
 800e324:	2402      	movs	r4, #2
  if (pdev->pClassData != NULL)
 800e326:	2b00      	cmp	r3, #0
 800e328:	d00a      	beq.n	800e340 <USBD_CDC_ReceivePacket+0x24>
    if (pdev->dev_speed == USBD_SPEED_HIGH)
 800e32a:	2281      	movs	r2, #129	; 0x81
 800e32c:	7c04      	ldrb	r4, [r0, #16]
 800e32e:	0092      	lsls	r2, r2, #2
 800e330:	589a      	ldr	r2, [r3, r2]
 800e332:	2c00      	cmp	r4, #0
 800e334:	d106      	bne.n	800e344 <USBD_CDC_ReceivePacket+0x28>
      USBD_LL_PrepareReceive(pdev,
 800e336:	2380      	movs	r3, #128	; 0x80
 800e338:	2101      	movs	r1, #1
 800e33a:	009b      	lsls	r3, r3, #2
 800e33c:	f001 fb5a 	bl	800f9f4 <USBD_LL_PrepareReceive>
  }
}
 800e340:	0020      	movs	r0, r4
 800e342:	bd10      	pop	{r4, pc}
      USBD_LL_PrepareReceive(pdev,
 800e344:	2340      	movs	r3, #64	; 0x40
 800e346:	2101      	movs	r1, #1
 800e348:	f001 fb54 	bl	800f9f4 <USBD_LL_PrepareReceive>
    return USBD_OK;
 800e34c:	2400      	movs	r4, #0
 800e34e:	e7f7      	b.n	800e340 <USBD_CDC_ReceivePacket+0x24>

0800e350 <USBD_Init>:
  if (pdev == NULL)
  {
#if (USBD_DEBUG_LEVEL > 1U)
    USBD_ErrLog("Invalid Device handle");
#endif
    return USBD_FAIL;
 800e350:	2302      	movs	r3, #2
{
 800e352:	b510      	push	{r4, lr}
  if (pdev == NULL)
 800e354:	2800      	cmp	r0, #0
 800e356:	d013      	beq.n	800e380 <USBD_Init+0x30>
  }

  /* Unlink previous class*/
  if (pdev->pClass != NULL)
 800e358:	23ad      	movs	r3, #173	; 0xad
 800e35a:	009b      	lsls	r3, r3, #2
 800e35c:	58c4      	ldr	r4, [r0, r3]
 800e35e:	2c00      	cmp	r4, #0
 800e360:	d001      	beq.n	800e366 <USBD_Init+0x16>
  {
    pdev->pClass = NULL;
 800e362:	2400      	movs	r4, #0
 800e364:	50c4      	str	r4, [r0, r3]
  }

  /* Assign USBD Descriptors */
  if (pdesc != NULL)
 800e366:	2900      	cmp	r1, #0
 800e368:	d002      	beq.n	800e370 <USBD_Init+0x20>
  {
    pdev->pDesc = pdesc;
 800e36a:	23ac      	movs	r3, #172	; 0xac
 800e36c:	009b      	lsls	r3, r3, #2
 800e36e:	50c1      	str	r1, [r0, r3]
  }

  /* Set Device initial State */
  pdev->dev_state = USBD_STATE_DEFAULT;
 800e370:	23a7      	movs	r3, #167	; 0xa7
 800e372:	2101      	movs	r1, #1
 800e374:	009b      	lsls	r3, r3, #2
 800e376:	54c1      	strb	r1, [r0, r3]
  pdev->id = id;
 800e378:	7002      	strb	r2, [r0, #0]
  /* Initialize low level driver */
  USBD_LL_Init(pdev);
 800e37a:	f001 fa73 	bl	800f864 <USBD_LL_Init>

  return USBD_OK;
 800e37e:	2300      	movs	r3, #0
}
 800e380:	0018      	movs	r0, r3
 800e382:	bd10      	pop	{r4, pc}

0800e384 <USBD_RegisterClass>:
  * @param  pDevice : Device Handle
  * @param  pclass: Class handle
  * @retval USBD Status
  */
USBD_StatusTypeDef  USBD_RegisterClass(USBD_HandleTypeDef *pdev, USBD_ClassTypeDef *pclass)
{
 800e384:	0003      	movs	r3, r0
  else
  {
#if (USBD_DEBUG_LEVEL > 1U)
    USBD_ErrLog("Invalid Class handle");
#endif
    status = USBD_FAIL;
 800e386:	2002      	movs	r0, #2
  if (pclass != NULL)
 800e388:	2900      	cmp	r1, #0
 800e38a:	d003      	beq.n	800e394 <USBD_RegisterClass+0x10>
    pdev->pClass = pclass;
 800e38c:	22ad      	movs	r2, #173	; 0xad
    status = USBD_OK;
 800e38e:	2000      	movs	r0, #0
    pdev->pClass = pclass;
 800e390:	0092      	lsls	r2, r2, #2
 800e392:	5099      	str	r1, [r3, r2]
  }

  return status;
}
 800e394:	4770      	bx	lr

0800e396 <USBD_Start>:
  *         Start the USB Device Core.
  * @param  pdev: Device Handle
  * @retval USBD Status
  */
USBD_StatusTypeDef  USBD_Start(USBD_HandleTypeDef *pdev)
{
 800e396:	b510      	push	{r4, lr}
  /* Start the low level driver  */
  USBD_LL_Start(pdev);
 800e398:	f001 faa4 	bl	800f8e4 <USBD_LL_Start>

  return USBD_OK;
}
 800e39c:	2000      	movs	r0, #0
 800e39e:	bd10      	pop	{r4, pc}

0800e3a0 <USBD_SetClassConfig>:

USBD_StatusTypeDef USBD_SetClassConfig(USBD_HandleTypeDef  *pdev, uint8_t cfgidx)
{
  USBD_StatusTypeDef ret = USBD_FAIL;

  if (pdev->pClass != NULL)
 800e3a0:	23ad      	movs	r3, #173	; 0xad
 800e3a2:	009b      	lsls	r3, r3, #2
 800e3a4:	58c3      	ldr	r3, [r0, r3]
{
 800e3a6:	b510      	push	{r4, lr}
  if (pdev->pClass != NULL)
 800e3a8:	2b00      	cmp	r3, #0
 800e3aa:	d101      	bne.n	800e3b0 <USBD_SetClassConfig+0x10>
  USBD_StatusTypeDef ret = USBD_FAIL;
 800e3ac:	2002      	movs	r0, #2
      ret = USBD_OK;
    }
  }

  return ret;
}
 800e3ae:	bd10      	pop	{r4, pc}
    if (pdev->pClass->Init(pdev, cfgidx) == 0U)
 800e3b0:	681b      	ldr	r3, [r3, #0]
 800e3b2:	4798      	blx	r3
 800e3b4:	2800      	cmp	r0, #0
 800e3b6:	d0fa      	beq.n	800e3ae <USBD_SetClassConfig+0xe>
 800e3b8:	e7f8      	b.n	800e3ac <USBD_SetClassConfig+0xc>

0800e3ba <USBD_ClrClassConfig>:
* @retval status: USBD_StatusTypeDef
*/
USBD_StatusTypeDef USBD_ClrClassConfig(USBD_HandleTypeDef  *pdev, uint8_t cfgidx)
{
  /* Clear configuration  and De-initialize the Class process*/
  pdev->pClass->DeInit(pdev, cfgidx);
 800e3ba:	23ad      	movs	r3, #173	; 0xad
{
 800e3bc:	b510      	push	{r4, lr}
  pdev->pClass->DeInit(pdev, cfgidx);
 800e3be:	009b      	lsls	r3, r3, #2
 800e3c0:	58c3      	ldr	r3, [r0, r3]
 800e3c2:	685b      	ldr	r3, [r3, #4]
 800e3c4:	4798      	blx	r3

  return USBD_OK;
}
 800e3c6:	2000      	movs	r0, #0
 800e3c8:	bd10      	pop	{r4, pc}
	...

0800e3cc <USBD_LL_SetupStage>:
* @param  pdev: device instance
* @retval status
*/
USBD_StatusTypeDef USBD_LL_SetupStage(USBD_HandleTypeDef *pdev, uint8_t *psetup)
{
  USBD_ParseSetupRequest(&pdev->request, psetup);
 800e3cc:	23aa      	movs	r3, #170	; 0xaa
 800e3ce:	009b      	lsls	r3, r3, #2
{
 800e3d0:	b570      	push	{r4, r5, r6, lr}
  USBD_ParseSetupRequest(&pdev->request, psetup);
 800e3d2:	18c5      	adds	r5, r0, r3
{
 800e3d4:	0004      	movs	r4, r0
  USBD_ParseSetupRequest(&pdev->request, psetup);
 800e3d6:	0028      	movs	r0, r5
 800e3d8:	f000 fb28 	bl	800ea2c <USBD_ParseSetupRequest>

  pdev->ep0_state = USBD_EP0_SETUP;
 800e3dc:	23a5      	movs	r3, #165	; 0xa5
 800e3de:	2201      	movs	r2, #1
 800e3e0:	009b      	lsls	r3, r3, #2
 800e3e2:	50e2      	str	r2, [r4, r3]

  pdev->ep0_data_len = pdev->request.wLength;
 800e3e4:	4b11      	ldr	r3, [pc, #68]	; (800e42c <USBD_LL_SetupStage+0x60>)
 800e3e6:	5ae2      	ldrh	r2, [r4, r3]
 800e3e8:	3b16      	subs	r3, #22
 800e3ea:	50e2      	str	r2, [r4, r3]

  switch (pdev->request.bmRequest & 0x1FU)
 800e3ec:	3310      	adds	r3, #16
 800e3ee:	5ce1      	ldrb	r1, [r4, r3]
 800e3f0:	231f      	movs	r3, #31
 800e3f2:	400b      	ands	r3, r1
 800e3f4:	2b01      	cmp	r3, #1
 800e3f6:	d009      	beq.n	800e40c <USBD_LL_SetupStage+0x40>
 800e3f8:	2b02      	cmp	r3, #2
 800e3fa:	d00c      	beq.n	800e416 <USBD_LL_SetupStage+0x4a>
 800e3fc:	2b00      	cmp	r3, #0
 800e3fe:	d10f      	bne.n	800e420 <USBD_LL_SetupStage+0x54>
  {
    case USB_REQ_RECIPIENT_DEVICE:
      USBD_StdDevReq(pdev, &pdev->request);
 800e400:	0029      	movs	r1, r5
 800e402:	0020      	movs	r0, r4
 800e404:	f000 f91e 	bl	800e644 <USBD_StdDevReq>
      USBD_LL_StallEP(pdev, (pdev->request.bmRequest & 0x80U));
      break;
  }

  return USBD_OK;
}
 800e408:	2000      	movs	r0, #0
 800e40a:	bd70      	pop	{r4, r5, r6, pc}
      USBD_StdItfReq(pdev, &pdev->request);
 800e40c:	0029      	movs	r1, r5
 800e40e:	0020      	movs	r0, r4
 800e410:	f000 fa4e 	bl	800e8b0 <USBD_StdItfReq>
      break;
 800e414:	e7f8      	b.n	800e408 <USBD_LL_SetupStage+0x3c>
      USBD_StdEPReq(pdev, &pdev->request);
 800e416:	0029      	movs	r1, r5
 800e418:	0020      	movs	r0, r4
 800e41a:	f000 fa71 	bl	800e900 <USBD_StdEPReq>
      break;
 800e41e:	e7f3      	b.n	800e408 <USBD_LL_SetupStage+0x3c>
      USBD_LL_StallEP(pdev, (pdev->request.bmRequest & 0x80U));
 800e420:	237f      	movs	r3, #127	; 0x7f
 800e422:	0020      	movs	r0, r4
 800e424:	4399      	bics	r1, r3
 800e426:	f001 fa8f 	bl	800f948 <USBD_LL_StallEP>
      break;
 800e42a:	e7ed      	b.n	800e408 <USBD_LL_SetupStage+0x3c>
 800e42c:	000002ae 	.word	0x000002ae

0800e430 <USBD_LL_DataOutStage>:
* @param  epnum: endpoint index
* @retval status
*/
USBD_StatusTypeDef USBD_LL_DataOutStage(USBD_HandleTypeDef *pdev,
                                        uint8_t epnum, uint8_t *pdata)
{
 800e430:	b570      	push	{r4, r5, r6, lr}
 800e432:	000d      	movs	r5, r1
 800e434:	0004      	movs	r4, r0
 800e436:	0011      	movs	r1, r2
  USBD_EndpointTypeDef *pep;

  if (epnum == 0U)
 800e438:	2d00      	cmp	r5, #0
 800e43a:	d12e      	bne.n	800e49a <USBD_LL_DataOutStage+0x6a>
  {
    pep = &pdev->ep_out[0];

    if (pdev->ep0_state == USBD_EP0_DATA_OUT)
 800e43c:	23a5      	movs	r3, #165	; 0xa5
 800e43e:	009b      	lsls	r3, r3, #2
 800e440:	58c2      	ldr	r2, [r0, r3]
 800e442:	2a03      	cmp	r2, #3
 800e444:	d122      	bne.n	800e48c <USBD_LL_DataOutStage+0x5c>
    {
      if (pep->rem_length > pep->maxpacket)
 800e446:	0002      	movs	r2, r0
 800e448:	3255      	adds	r2, #85	; 0x55
 800e44a:	32ff      	adds	r2, #255	; 0xff
 800e44c:	68d3      	ldr	r3, [r2, #12]
 800e44e:	6910      	ldr	r0, [r2, #16]
 800e450:	4283      	cmp	r3, r0
 800e452:	d90a      	bls.n	800e46a <USBD_LL_DataOutStage+0x3a>
      {
        pep->rem_length -= pep->maxpacket;
 800e454:	1a1b      	subs	r3, r3, r0
 800e456:	60d3      	str	r3, [r2, #12]

        USBD_CtlContinueRx(pdev, pdata,
 800e458:	b282      	uxth	r2, r0
 800e45a:	4298      	cmp	r0, r3
 800e45c:	d900      	bls.n	800e460 <USBD_LL_DataOutStage+0x30>
 800e45e:	b29a      	uxth	r2, r3
 800e460:	0020      	movs	r0, r4
 800e462:	f000 fb45 	bl	800eaf0 <USBD_CtlContinueRx>
    /* should never be in this condition */
    return USBD_FAIL;
  }

  return USBD_OK;
}
 800e466:	0028      	movs	r0, r5
 800e468:	bd70      	pop	{r4, r5, r6, pc}
        if ((pdev->pClass->EP0_RxReady != NULL) &&
 800e46a:	23ad      	movs	r3, #173	; 0xad
 800e46c:	009b      	lsls	r3, r3, #2
 800e46e:	58e3      	ldr	r3, [r4, r3]
 800e470:	691b      	ldr	r3, [r3, #16]
 800e472:	2b00      	cmp	r3, #0
 800e474:	d006      	beq.n	800e484 <USBD_LL_DataOutStage+0x54>
            (pdev->dev_state == USBD_STATE_CONFIGURED))
 800e476:	22a7      	movs	r2, #167	; 0xa7
 800e478:	0092      	lsls	r2, r2, #2
        if ((pdev->pClass->EP0_RxReady != NULL) &&
 800e47a:	5ca2      	ldrb	r2, [r4, r2]
 800e47c:	2a03      	cmp	r2, #3
 800e47e:	d101      	bne.n	800e484 <USBD_LL_DataOutStage+0x54>
          pdev->pClass->EP0_RxReady(pdev);
 800e480:	0020      	movs	r0, r4
 800e482:	4798      	blx	r3
        USBD_CtlSendStatus(pdev);
 800e484:	0020      	movs	r0, r4
 800e486:	f000 fb3b 	bl	800eb00 <USBD_CtlSendStatus>
 800e48a:	e7ec      	b.n	800e466 <USBD_LL_DataOutStage+0x36>
      if (pdev->ep0_state == USBD_EP0_STATUS_OUT)
 800e48c:	2a05      	cmp	r2, #5
 800e48e:	d1ea      	bne.n	800e466 <USBD_LL_DataOutStage+0x36>
        USBD_LL_StallEP(pdev, 0U);
 800e490:	0029      	movs	r1, r5
        pdev->ep0_state = USBD_EP0_IDLE;
 800e492:	50c5      	str	r5, [r0, r3]
        USBD_LL_StallEP(pdev, 0U);
 800e494:	f001 fa58 	bl	800f948 <USBD_LL_StallEP>
 800e498:	e7e5      	b.n	800e466 <USBD_LL_DataOutStage+0x36>
  else if ((pdev->pClass->DataOut != NULL) &&
 800e49a:	23ad      	movs	r3, #173	; 0xad
 800e49c:	009b      	lsls	r3, r3, #2
 800e49e:	58c3      	ldr	r3, [r0, r3]
 800e4a0:	699b      	ldr	r3, [r3, #24]
 800e4a2:	2b00      	cmp	r3, #0
 800e4a4:	d008      	beq.n	800e4b8 <USBD_LL_DataOutStage+0x88>
           (pdev->dev_state == USBD_STATE_CONFIGURED))
 800e4a6:	22a7      	movs	r2, #167	; 0xa7
 800e4a8:	0092      	lsls	r2, r2, #2
  else if ((pdev->pClass->DataOut != NULL) &&
 800e4aa:	5c82      	ldrb	r2, [r0, r2]
 800e4ac:	2a03      	cmp	r2, #3
 800e4ae:	d103      	bne.n	800e4b8 <USBD_LL_DataOutStage+0x88>
    pdev->pClass->DataOut(pdev, epnum);
 800e4b0:	0029      	movs	r1, r5
 800e4b2:	4798      	blx	r3
  return USBD_OK;
 800e4b4:	2500      	movs	r5, #0
    pdev->pClass->DataOut(pdev, epnum);
 800e4b6:	e7d6      	b.n	800e466 <USBD_LL_DataOutStage+0x36>
    return USBD_FAIL;
 800e4b8:	2502      	movs	r5, #2
 800e4ba:	e7d4      	b.n	800e466 <USBD_LL_DataOutStage+0x36>

0800e4bc <USBD_LL_DataInStage>:
* @param  epnum: endpoint index
* @retval status
*/
USBD_StatusTypeDef USBD_LL_DataInStage(USBD_HandleTypeDef *pdev,
                                       uint8_t epnum, uint8_t *pdata)
{
 800e4bc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800e4be:	000d      	movs	r5, r1
 800e4c0:	0004      	movs	r4, r0
 800e4c2:	0011      	movs	r1, r2
  USBD_EndpointTypeDef *pep;

  if (epnum == 0U)
 800e4c4:	2d00      	cmp	r5, #0
 800e4c6:	d14d      	bne.n	800e564 <USBD_LL_DataInStage+0xa8>
  {
    pep = &pdev->ep_in[0];

    if (pdev->ep0_state == USBD_EP0_DATA_IN)
 800e4c8:	23a5      	movs	r3, #165	; 0xa5
 800e4ca:	009b      	lsls	r3, r3, #2
 800e4cc:	58c3      	ldr	r3, [r0, r3]
 800e4ce:	2b02      	cmp	r3, #2
 800e4d0:	d141      	bne.n	800e556 <USBD_LL_DataInStage+0x9a>
    {
      if (pep->rem_length > pep->maxpacket)
 800e4d2:	6a03      	ldr	r3, [r0, #32]
 800e4d4:	6a46      	ldr	r6, [r0, #36]	; 0x24
 800e4d6:	42b3      	cmp	r3, r6
 800e4d8:	d913      	bls.n	800e502 <USBD_LL_DataInStage+0x46>
      {
        pep->rem_length -= pep->maxpacket;
 800e4da:	1b9b      	subs	r3, r3, r6
 800e4dc:	6203      	str	r3, [r0, #32]

        USBD_CtlContinueSendData(pdev, pdata, (uint16_t)pep->rem_length);
 800e4de:	b29a      	uxth	r2, r3
 800e4e0:	f000 faee 	bl	800eac0 <USBD_CtlContinueSendData>
        {
          USBD_CtlContinueSendData(pdev, NULL, 0U);
          pdev->ep0_data_len = 0U;

          /* Prepare endpoint for premature end of transfer */
          USBD_LL_PrepareReceive(pdev, 0U, NULL, 0U);
 800e4e4:	002b      	movs	r3, r5
 800e4e6:	002a      	movs	r2, r5
 800e4e8:	0029      	movs	r1, r5
 800e4ea:	0020      	movs	r0, r4
 800e4ec:	f001 fa82 	bl	800f9f4 <USBD_LL_PrepareReceive>
      {
        USBD_LL_StallEP(pdev, 0x80U);
      }
    }

    if (pdev->dev_test_mode == 1U)
 800e4f0:	23a8      	movs	r3, #168	; 0xa8
 800e4f2:	009b      	lsls	r3, r3, #2
 800e4f4:	5ce2      	ldrb	r2, [r4, r3]
 800e4f6:	2a01      	cmp	r2, #1
 800e4f8:	d101      	bne.n	800e4fe <USBD_LL_DataInStage+0x42>
    {
      USBD_RunTestMode(pdev);
      pdev->dev_test_mode = 0U;
 800e4fa:	2200      	movs	r2, #0
 800e4fc:	54e2      	strb	r2, [r4, r3]
    /* should never be in this condition */
    return USBD_FAIL;
  }

  return USBD_OK;
}
 800e4fe:	0028      	movs	r0, r5
 800e500:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        if ((pep->total_length % pep->maxpacket == 0U) &&
 800e502:	69c7      	ldr	r7, [r0, #28]
 800e504:	0031      	movs	r1, r6
 800e506:	0038      	movs	r0, r7
 800e508:	f7f9 feb4 	bl	8008274 <__aeabi_uidivmod>
 800e50c:	2900      	cmp	r1, #0
 800e50e:	d10d      	bne.n	800e52c <USBD_LL_DataInStage+0x70>
 800e510:	42be      	cmp	r6, r7
 800e512:	d80b      	bhi.n	800e52c <USBD_LL_DataInStage+0x70>
            (pep->total_length < pdev->ep0_data_len))
 800e514:	26a6      	movs	r6, #166	; 0xa6
 800e516:	00b6      	lsls	r6, r6, #2
            (pep->total_length >= pep->maxpacket) &&
 800e518:	59a3      	ldr	r3, [r4, r6]
 800e51a:	429f      	cmp	r7, r3
 800e51c:	d206      	bcs.n	800e52c <USBD_LL_DataInStage+0x70>
          USBD_CtlContinueSendData(pdev, NULL, 0U);
 800e51e:	002a      	movs	r2, r5
 800e520:	0029      	movs	r1, r5
 800e522:	0020      	movs	r0, r4
 800e524:	f000 facc 	bl	800eac0 <USBD_CtlContinueSendData>
          pdev->ep0_data_len = 0U;
 800e528:	51a5      	str	r5, [r4, r6]
 800e52a:	e7db      	b.n	800e4e4 <USBD_LL_DataInStage+0x28>
          if ((pdev->pClass->EP0_TxSent != NULL) &&
 800e52c:	23ad      	movs	r3, #173	; 0xad
 800e52e:	009b      	lsls	r3, r3, #2
 800e530:	58e3      	ldr	r3, [r4, r3]
 800e532:	68db      	ldr	r3, [r3, #12]
 800e534:	2b00      	cmp	r3, #0
 800e536:	d006      	beq.n	800e546 <USBD_LL_DataInStage+0x8a>
              (pdev->dev_state == USBD_STATE_CONFIGURED))
 800e538:	22a7      	movs	r2, #167	; 0xa7
 800e53a:	0092      	lsls	r2, r2, #2
          if ((pdev->pClass->EP0_TxSent != NULL) &&
 800e53c:	5ca2      	ldrb	r2, [r4, r2]
 800e53e:	2a03      	cmp	r2, #3
 800e540:	d101      	bne.n	800e546 <USBD_LL_DataInStage+0x8a>
            pdev->pClass->EP0_TxSent(pdev);
 800e542:	0020      	movs	r0, r4
 800e544:	4798      	blx	r3
          USBD_LL_StallEP(pdev, 0x80U);
 800e546:	2180      	movs	r1, #128	; 0x80
 800e548:	0020      	movs	r0, r4
 800e54a:	f001 f9fd 	bl	800f948 <USBD_LL_StallEP>
          USBD_CtlReceiveStatus(pdev);
 800e54e:	0020      	movs	r0, r4
 800e550:	f000 fae2 	bl	800eb18 <USBD_CtlReceiveStatus>
 800e554:	e7cc      	b.n	800e4f0 <USBD_LL_DataInStage+0x34>
      if ((pdev->ep0_state == USBD_EP0_STATUS_IN) ||
 800e556:	2204      	movs	r2, #4
 800e558:	4393      	bics	r3, r2
 800e55a:	d1c9      	bne.n	800e4f0 <USBD_LL_DataInStage+0x34>
        USBD_LL_StallEP(pdev, 0x80U);
 800e55c:	2180      	movs	r1, #128	; 0x80
 800e55e:	f001 f9f3 	bl	800f948 <USBD_LL_StallEP>
 800e562:	e7c5      	b.n	800e4f0 <USBD_LL_DataInStage+0x34>
  else if ((pdev->pClass->DataIn != NULL) &&
 800e564:	23ad      	movs	r3, #173	; 0xad
 800e566:	009b      	lsls	r3, r3, #2
 800e568:	58c3      	ldr	r3, [r0, r3]
 800e56a:	695b      	ldr	r3, [r3, #20]
 800e56c:	2b00      	cmp	r3, #0
 800e56e:	d008      	beq.n	800e582 <USBD_LL_DataInStage+0xc6>
           (pdev->dev_state == USBD_STATE_CONFIGURED))
 800e570:	22a7      	movs	r2, #167	; 0xa7
 800e572:	0092      	lsls	r2, r2, #2
  else if ((pdev->pClass->DataIn != NULL) &&
 800e574:	5c82      	ldrb	r2, [r0, r2]
 800e576:	2a03      	cmp	r2, #3
 800e578:	d103      	bne.n	800e582 <USBD_LL_DataInStage+0xc6>
    pdev->pClass->DataIn(pdev, epnum);
 800e57a:	0029      	movs	r1, r5
 800e57c:	4798      	blx	r3
  return USBD_OK;
 800e57e:	2500      	movs	r5, #0
    pdev->pClass->DataIn(pdev, epnum);
 800e580:	e7bd      	b.n	800e4fe <USBD_LL_DataInStage+0x42>
    return USBD_FAIL;
 800e582:	2502      	movs	r5, #2
 800e584:	e7bb      	b.n	800e4fe <USBD_LL_DataInStage+0x42>

0800e586 <USBD_LL_Reset>:
*/

USBD_StatusTypeDef USBD_LL_Reset(USBD_HandleTypeDef *pdev)
{
  /* Open EP0 OUT */
  USBD_LL_OpenEP(pdev, 0x00U, USBD_EP_TYPE_CTRL, USB_MAX_EP0_SIZE);
 800e586:	2200      	movs	r2, #0
{
 800e588:	b570      	push	{r4, r5, r6, lr}
 800e58a:	0004      	movs	r4, r0
  USBD_LL_OpenEP(pdev, 0x00U, USBD_EP_TYPE_CTRL, USB_MAX_EP0_SIZE);
 800e58c:	0011      	movs	r1, r2
 800e58e:	2340      	movs	r3, #64	; 0x40
 800e590:	f001 f9b8 	bl	800f904 <USBD_LL_OpenEP>
  pdev->ep_out[0x00U & 0xFU].is_used = 1U;
 800e594:	0023      	movs	r3, r4
 800e596:	2501      	movs	r5, #1

  pdev->ep_out[0].maxpacket = USB_MAX_EP0_SIZE;
 800e598:	2640      	movs	r6, #64	; 0x40
  pdev->ep_out[0x00U & 0xFU].is_used = 1U;
 800e59a:	33fc      	adds	r3, #252	; 0xfc

  /* Open EP0 IN */
  USBD_LL_OpenEP(pdev, 0x80U, USBD_EP_TYPE_CTRL, USB_MAX_EP0_SIZE);
 800e59c:	2180      	movs	r1, #128	; 0x80
  pdev->ep_out[0x00U & 0xFU].is_used = 1U;
 800e59e:	65dd      	str	r5, [r3, #92]	; 0x5c
  pdev->ep_out[0].maxpacket = USB_MAX_EP0_SIZE;
 800e5a0:	669e      	str	r6, [r3, #104]	; 0x68
  USBD_LL_OpenEP(pdev, 0x80U, USBD_EP_TYPE_CTRL, USB_MAX_EP0_SIZE);
 800e5a2:	2200      	movs	r2, #0
 800e5a4:	0033      	movs	r3, r6
 800e5a6:	0020      	movs	r0, r4
 800e5a8:	f001 f9ac 	bl	800f904 <USBD_LL_OpenEP>
  pdev->ep_in[0x80U & 0xFU].is_used = 1U;

  pdev->ep_in[0].maxpacket = USB_MAX_EP0_SIZE;

  /* Upon Reset call user call back */
  pdev->dev_state = USBD_STATE_DEFAULT;
 800e5ac:	23a7      	movs	r3, #167	; 0xa7
  pdev->ep0_state = USBD_EP0_IDLE;
 800e5ae:	2100      	movs	r1, #0
  pdev->dev_state = USBD_STATE_DEFAULT;
 800e5b0:	009b      	lsls	r3, r3, #2
  pdev->ep_in[0x80U & 0xFU].is_used = 1U;
 800e5b2:	61a5      	str	r5, [r4, #24]
  pdev->ep_in[0].maxpacket = USB_MAX_EP0_SIZE;
 800e5b4:	6266      	str	r6, [r4, #36]	; 0x24
  pdev->dev_state = USBD_STATE_DEFAULT;
 800e5b6:	54e5      	strb	r5, [r4, r3]
  pdev->ep0_state = USBD_EP0_IDLE;
 800e5b8:	3b08      	subs	r3, #8
 800e5ba:	50e1      	str	r1, [r4, r3]
  pdev->dev_config = 0U;
  pdev->dev_remote_wakeup = 0U;
 800e5bc:	3310      	adds	r3, #16
  pdev->dev_config = 0U;
 800e5be:	6061      	str	r1, [r4, #4]
  pdev->dev_remote_wakeup = 0U;
 800e5c0:	50e1      	str	r1, [r4, r3]

  if (pdev->pClassData)
 800e5c2:	3314      	adds	r3, #20
 800e5c4:	58e3      	ldr	r3, [r4, r3]
 800e5c6:	428b      	cmp	r3, r1
 800e5c8:	d005      	beq.n	800e5d6 <USBD_LL_Reset+0x50>
  {
    pdev->pClass->DeInit(pdev, (uint8_t)pdev->dev_config);
 800e5ca:	23ad      	movs	r3, #173	; 0xad
 800e5cc:	009b      	lsls	r3, r3, #2
 800e5ce:	58e3      	ldr	r3, [r4, r3]
 800e5d0:	0020      	movs	r0, r4
 800e5d2:	685b      	ldr	r3, [r3, #4]
 800e5d4:	4798      	blx	r3
  }

  return USBD_OK;
}
 800e5d6:	2000      	movs	r0, #0
 800e5d8:	bd70      	pop	{r4, r5, r6, pc}

0800e5da <USBD_LL_SetSpeed>:
* @retval status
*/
USBD_StatusTypeDef USBD_LL_SetSpeed(USBD_HandleTypeDef *pdev,
                                    USBD_SpeedTypeDef speed)
{
  pdev->dev_speed = speed;
 800e5da:	7401      	strb	r1, [r0, #16]

  return USBD_OK;
}
 800e5dc:	2000      	movs	r0, #0
 800e5de:	4770      	bx	lr

0800e5e0 <USBD_LL_Suspend>:
* @retval status
*/

USBD_StatusTypeDef USBD_LL_Suspend(USBD_HandleTypeDef *pdev)
{
  pdev->dev_old_state =  pdev->dev_state;
 800e5e0:	23a7      	movs	r3, #167	; 0xa7
 800e5e2:	009b      	lsls	r3, r3, #2
 800e5e4:	5cc1      	ldrb	r1, [r0, r3]
 800e5e6:	4a03      	ldr	r2, [pc, #12]	; (800e5f4 <USBD_LL_Suspend+0x14>)
 800e5e8:	5481      	strb	r1, [r0, r2]
  pdev->dev_state  = USBD_STATE_SUSPENDED;
 800e5ea:	2204      	movs	r2, #4
 800e5ec:	54c2      	strb	r2, [r0, r3]

  return USBD_OK;
}
 800e5ee:	2000      	movs	r0, #0
 800e5f0:	4770      	bx	lr
 800e5f2:	46c0      	nop			; (mov r8, r8)
 800e5f4:	0000029d 	.word	0x0000029d

0800e5f8 <USBD_LL_Resume>:
* @retval status
*/

USBD_StatusTypeDef USBD_LL_Resume(USBD_HandleTypeDef *pdev)
{
  if (pdev->dev_state == USBD_STATE_SUSPENDED)
 800e5f8:	23a7      	movs	r3, #167	; 0xa7
 800e5fa:	009b      	lsls	r3, r3, #2
 800e5fc:	5cc2      	ldrb	r2, [r0, r3]
 800e5fe:	2a04      	cmp	r2, #4
 800e600:	d102      	bne.n	800e608 <USBD_LL_Resume+0x10>
  {
    pdev->dev_state = pdev->dev_old_state;
 800e602:	4a02      	ldr	r2, [pc, #8]	; (800e60c <USBD_LL_Resume+0x14>)
 800e604:	5c82      	ldrb	r2, [r0, r2]
 800e606:	54c2      	strb	r2, [r0, r3]
  }

  return USBD_OK;
}
 800e608:	2000      	movs	r0, #0
 800e60a:	4770      	bx	lr
 800e60c:	0000029d 	.word	0x0000029d

0800e610 <USBD_LL_SOF>:
* @retval status
*/

USBD_StatusTypeDef USBD_LL_SOF(USBD_HandleTypeDef *pdev)
{
  if (pdev->dev_state == USBD_STATE_CONFIGURED)
 800e610:	23a7      	movs	r3, #167	; 0xa7
{
 800e612:	b510      	push	{r4, lr}
  if (pdev->dev_state == USBD_STATE_CONFIGURED)
 800e614:	009b      	lsls	r3, r3, #2
 800e616:	5cc3      	ldrb	r3, [r0, r3]
 800e618:	2b03      	cmp	r3, #3
 800e61a:	d106      	bne.n	800e62a <USBD_LL_SOF+0x1a>
  {
    if (pdev->pClass->SOF != NULL)
 800e61c:	23ad      	movs	r3, #173	; 0xad
 800e61e:	009b      	lsls	r3, r3, #2
 800e620:	58c3      	ldr	r3, [r0, r3]
 800e622:	69db      	ldr	r3, [r3, #28]
 800e624:	2b00      	cmp	r3, #0
 800e626:	d000      	beq.n	800e62a <USBD_LL_SOF+0x1a>
    {
      pdev->pClass->SOF(pdev);
 800e628:	4798      	blx	r3
    }
  }

  return USBD_OK;
}
 800e62a:	2000      	movs	r0, #0
 800e62c:	bd10      	pop	{r4, pc}

0800e62e <USBD_CtlError.constprop.0>:
* @param  pdev: device instance
* @param  req: usb request
* @retval None
*/

void USBD_CtlError(USBD_HandleTypeDef *pdev,
 800e62e:	b510      	push	{r4, lr}
 800e630:	0004      	movs	r4, r0
                   USBD_SetupReqTypedef *req)
{
  USBD_LL_StallEP(pdev, 0x80U);
 800e632:	2180      	movs	r1, #128	; 0x80
 800e634:	f001 f988 	bl	800f948 <USBD_LL_StallEP>
  USBD_LL_StallEP(pdev, 0U);
 800e638:	2100      	movs	r1, #0
 800e63a:	0020      	movs	r0, r4
 800e63c:	f001 f984 	bl	800f948 <USBD_LL_StallEP>
}
 800e640:	bd10      	pop	{r4, pc}
	...

0800e644 <USBD_StdDevReq>:
{
 800e644:	2260      	movs	r2, #96	; 0x60
 800e646:	780b      	ldrb	r3, [r1, #0]
 800e648:	b573      	push	{r0, r1, r4, r5, r6, lr}
 800e64a:	4013      	ands	r3, r2
 800e64c:	000d      	movs	r5, r1
  switch (req->bmRequest & USB_REQ_TYPE_MASK)
 800e64e:	0019      	movs	r1, r3
 800e650:	1892      	adds	r2, r2, r2
 800e652:	3920      	subs	r1, #32
{
 800e654:	0004      	movs	r4, r0
  switch (req->bmRequest & USB_REQ_TYPE_MASK)
 800e656:	4211      	tst	r1, r2
 800e658:	d012      	beq.n	800e680 <USBD_StdDevReq+0x3c>
 800e65a:	2b00      	cmp	r3, #0
 800e65c:	d000      	beq.n	800e660 <USBD_StdDevReq+0x1c>
 800e65e:	e096      	b.n	800e78e <USBD_StdDevReq+0x14a>
      switch (req->bRequest)
 800e660:	7868      	ldrb	r0, [r5, #1]
 800e662:	2809      	cmp	r0, #9
 800e664:	d900      	bls.n	800e668 <USBD_StdDevReq+0x24>
 800e666:	e092      	b.n	800e78e <USBD_StdDevReq+0x14a>
 800e668:	f7f9 fd74 	bl	8008154 <__gnu_thumb1_case_uhi>
 800e66c:	010e00f0 	.word	0x010e00f0
 800e670:	01060091 	.word	0x01060091
 800e674:	00830091 	.word	0x00830091
 800e678:	00910012 	.word	0x00910012
 800e67c:	00a400da 	.word	0x00a400da
      pdev->pClass->Setup(pdev, req);
 800e680:	23ad      	movs	r3, #173	; 0xad
 800e682:	009b      	lsls	r3, r3, #2
 800e684:	58c3      	ldr	r3, [r0, r3]
 800e686:	0029      	movs	r1, r5
 800e688:	689b      	ldr	r3, [r3, #8]
 800e68a:	4798      	blx	r3
}
 800e68c:	2000      	movs	r0, #0
 800e68e:	bd76      	pop	{r1, r2, r4, r5, r6, pc}
  uint16_t len = 0U;
 800e690:	2300      	movs	r3, #0
 800e692:	466a      	mov	r2, sp
 800e694:	80d3      	strh	r3, [r2, #6]
  switch (req->wValue >> 8)
 800e696:	886b      	ldrh	r3, [r5, #2]
 800e698:	0a18      	lsrs	r0, r3, #8
 800e69a:	3801      	subs	r0, #1
 800e69c:	2806      	cmp	r0, #6
 800e69e:	d876      	bhi.n	800e78e <USBD_StdDevReq+0x14a>
 800e6a0:	f7f9 fd44 	bl	800812c <__gnu_thumb1_case_uqi>
 800e6a4:	75261704 	.word	0x75261704
 800e6a8:	4075      	.short	0x4075
 800e6aa:	4b          	.byte	0x4b
 800e6ab:	00          	.byte	0x00
      pbuf = pdev->pDesc->GetDeviceDescriptor(pdev->dev_speed, &len);
 800e6ac:	23ac      	movs	r3, #172	; 0xac
 800e6ae:	009b      	lsls	r3, r3, #2
 800e6b0:	58e3      	ldr	r3, [r4, r3]
 800e6b2:	7c20      	ldrb	r0, [r4, #16]
 800e6b4:	681b      	ldr	r3, [r3, #0]
            pbuf = pdev->pDesc->GetLangIDStrDescriptor(pdev->dev_speed, &len);
 800e6b6:	466a      	mov	r2, sp
 800e6b8:	1d91      	adds	r1, r2, #6
 800e6ba:	4798      	blx	r3
    if ((len != 0U) && (req->wLength != 0U))
 800e6bc:	466b      	mov	r3, sp
 800e6be:	88d9      	ldrh	r1, [r3, #6]
 800e6c0:	2900      	cmp	r1, #0
 800e6c2:	d051      	beq.n	800e768 <USBD_StdDevReq+0x124>
 800e6c4:	88ea      	ldrh	r2, [r5, #6]
 800e6c6:	2a00      	cmp	r2, #0
 800e6c8:	d143      	bne.n	800e752 <USBD_StdDevReq+0x10e>
        USBD_CtlSendStatus(pdev);
 800e6ca:	0020      	movs	r0, r4
 800e6cc:	f000 fa18 	bl	800eb00 <USBD_CtlSendStatus>
 800e6d0:	e7dc      	b.n	800e68c <USBD_StdDevReq+0x48>
      if (pdev->dev_speed == USBD_SPEED_HIGH)
 800e6d2:	23ad      	movs	r3, #173	; 0xad
 800e6d4:	7c22      	ldrb	r2, [r4, #16]
 800e6d6:	009b      	lsls	r3, r3, #2
 800e6d8:	58e3      	ldr	r3, [r4, r3]
 800e6da:	2a00      	cmp	r2, #0
 800e6dc:	d106      	bne.n	800e6ec <USBD_StdDevReq+0xa8>
        pbuf = pdev->pClass->GetHSConfigDescriptor(&len);
 800e6de:	6a9b      	ldr	r3, [r3, #40]	; 0x28
        pbuf = pdev->pClass->GetFSConfigDescriptor(&len);
 800e6e0:	466a      	mov	r2, sp
 800e6e2:	1d90      	adds	r0, r2, #6
 800e6e4:	4798      	blx	r3
        pbuf[1] = USB_DESC_TYPE_CONFIGURATION;
 800e6e6:	2302      	movs	r3, #2
        pbuf[1] = USB_DESC_TYPE_OTHER_SPEED_CONFIGURATION;
 800e6e8:	7043      	strb	r3, [r0, #1]
  if (err != 0U)
 800e6ea:	e7e7      	b.n	800e6bc <USBD_StdDevReq+0x78>
        pbuf = pdev->pClass->GetFSConfigDescriptor(&len);
 800e6ec:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800e6ee:	e7f7      	b.n	800e6e0 <USBD_StdDevReq+0x9c>
      switch ((uint8_t)(req->wValue))
 800e6f0:	b2d8      	uxtb	r0, r3
 800e6f2:	2805      	cmp	r0, #5
 800e6f4:	d84b      	bhi.n	800e78e <USBD_StdDevReq+0x14a>
 800e6f6:	23ac      	movs	r3, #172	; 0xac
 800e6f8:	009b      	lsls	r3, r3, #2
          if (pdev->pDesc->GetInterfaceStrDescriptor != NULL)
 800e6fa:	58e3      	ldr	r3, [r4, r3]
 800e6fc:	f7f9 fd16 	bl	800812c <__gnu_thumb1_case_uqi>
 800e700:	0c0a0803 	.word	0x0c0a0803
 800e704:	100e      	.short	0x100e
          if (pdev->pDesc->GetLangIDStrDescriptor != NULL)
 800e706:	685b      	ldr	r3, [r3, #4]
 800e708:	2b00      	cmp	r3, #0
 800e70a:	d040      	beq.n	800e78e <USBD_StdDevReq+0x14a>
            pbuf = pdev->pDesc->GetLangIDStrDescriptor(pdev->dev_speed, &len);
 800e70c:	7c20      	ldrb	r0, [r4, #16]
 800e70e:	e7d2      	b.n	800e6b6 <USBD_StdDevReq+0x72>
          if (pdev->pDesc->GetManufacturerStrDescriptor != NULL)
 800e710:	689b      	ldr	r3, [r3, #8]
 800e712:	e7f9      	b.n	800e708 <USBD_StdDevReq+0xc4>
          if (pdev->pDesc->GetProductStrDescriptor != NULL)
 800e714:	68db      	ldr	r3, [r3, #12]
 800e716:	e7f7      	b.n	800e708 <USBD_StdDevReq+0xc4>
          if (pdev->pDesc->GetSerialStrDescriptor != NULL)
 800e718:	691b      	ldr	r3, [r3, #16]
 800e71a:	e7f5      	b.n	800e708 <USBD_StdDevReq+0xc4>
          if (pdev->pDesc->GetConfigurationStrDescriptor != NULL)
 800e71c:	695b      	ldr	r3, [r3, #20]
 800e71e:	e7f3      	b.n	800e708 <USBD_StdDevReq+0xc4>
          if (pdev->pDesc->GetInterfaceStrDescriptor != NULL)
 800e720:	699b      	ldr	r3, [r3, #24]
 800e722:	e7f1      	b.n	800e708 <USBD_StdDevReq+0xc4>
      if (pdev->dev_speed == USBD_SPEED_HIGH)
 800e724:	7c23      	ldrb	r3, [r4, #16]
 800e726:	2b00      	cmp	r3, #0
 800e728:	d131      	bne.n	800e78e <USBD_StdDevReq+0x14a>
        pbuf = pdev->pClass->GetDeviceQualifierDescriptor(&len);
 800e72a:	23ad      	movs	r3, #173	; 0xad
 800e72c:	466a      	mov	r2, sp
 800e72e:	009b      	lsls	r3, r3, #2
 800e730:	58e3      	ldr	r3, [r4, r3]
 800e732:	1d90      	adds	r0, r2, #6
 800e734:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 800e736:	4798      	blx	r3
  if (err != 0U)
 800e738:	e7c0      	b.n	800e6bc <USBD_StdDevReq+0x78>
      if (pdev->dev_speed == USBD_SPEED_HIGH)
 800e73a:	7c23      	ldrb	r3, [r4, #16]
 800e73c:	2b00      	cmp	r3, #0
 800e73e:	d126      	bne.n	800e78e <USBD_StdDevReq+0x14a>
        pbuf = pdev->pClass->GetOtherSpeedConfigDescriptor(&len);
 800e740:	23ad      	movs	r3, #173	; 0xad
 800e742:	466a      	mov	r2, sp
 800e744:	009b      	lsls	r3, r3, #2
 800e746:	58e3      	ldr	r3, [r4, r3]
 800e748:	1d90      	adds	r0, r2, #6
 800e74a:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800e74c:	4798      	blx	r3
        pbuf[1] = USB_DESC_TYPE_OTHER_SPEED_CONFIGURATION;
 800e74e:	2307      	movs	r3, #7
 800e750:	e7ca      	b.n	800e6e8 <USBD_StdDevReq+0xa4>
      len = MIN(len, req->wLength);
 800e752:	1c0b      	adds	r3, r1, #0
 800e754:	4291      	cmp	r1, r2
 800e756:	d900      	bls.n	800e75a <USBD_StdDevReq+0x116>
 800e758:	1c13      	adds	r3, r2, #0
 800e75a:	4669      	mov	r1, sp
 800e75c:	b29a      	uxth	r2, r3
 800e75e:	80cb      	strh	r3, [r1, #6]
      (void)USBD_CtlSendData(pdev, pbuf, len);
 800e760:	0001      	movs	r1, r0
 800e762:	0020      	movs	r0, r4
 800e764:	f000 f99e 	bl	800eaa4 <USBD_CtlSendData>
    if (req->wLength == 0U)
 800e768:	88eb      	ldrh	r3, [r5, #6]
 800e76a:	2b00      	cmp	r3, #0
 800e76c:	d000      	beq.n	800e770 <USBD_StdDevReq+0x12c>
 800e76e:	e78d      	b.n	800e68c <USBD_StdDevReq+0x48>
 800e770:	e7ab      	b.n	800e6ca <USBD_StdDevReq+0x86>
  if ((req->wIndex == 0U) && (req->wLength == 0U) && (req->wValue < 128U))
 800e772:	88ab      	ldrh	r3, [r5, #4]
 800e774:	2b00      	cmp	r3, #0
 800e776:	d10a      	bne.n	800e78e <USBD_StdDevReq+0x14a>
 800e778:	88eb      	ldrh	r3, [r5, #6]
 800e77a:	2b00      	cmp	r3, #0
 800e77c:	d107      	bne.n	800e78e <USBD_StdDevReq+0x14a>
 800e77e:	886e      	ldrh	r6, [r5, #2]
 800e780:	2e7f      	cmp	r6, #127	; 0x7f
 800e782:	d804      	bhi.n	800e78e <USBD_StdDevReq+0x14a>
    if (pdev->dev_state == USBD_STATE_CONFIGURED)
 800e784:	25a7      	movs	r5, #167	; 0xa7
 800e786:	00ad      	lsls	r5, r5, #2
 800e788:	5d63      	ldrb	r3, [r4, r5]
 800e78a:	2b03      	cmp	r3, #3
 800e78c:	d103      	bne.n	800e796 <USBD_StdDevReq+0x152>
        USBD_CtlError(pdev, req);
 800e78e:	0020      	movs	r0, r4
 800e790:	f7ff ff4d 	bl	800e62e <USBD_CtlError.constprop.0>
        break;
 800e794:	e77a      	b.n	800e68c <USBD_StdDevReq+0x48>
      pdev->dev_address = dev_addr;
 800e796:	4b44      	ldr	r3, [pc, #272]	; (800e8a8 <USBD_StdDevReq+0x264>)
    dev_addr = (uint8_t)(req->wValue) & 0x7FU;
 800e798:	b2f1      	uxtb	r1, r6
      pdev->dev_address = dev_addr;
 800e79a:	54e1      	strb	r1, [r4, r3]
      USBD_LL_SetUSBAddress(pdev, dev_addr);
 800e79c:	0020      	movs	r0, r4
 800e79e:	f001 f909 	bl	800f9b4 <USBD_LL_SetUSBAddress>
      USBD_CtlSendStatus(pdev);
 800e7a2:	0020      	movs	r0, r4
 800e7a4:	f000 f9ac 	bl	800eb00 <USBD_CtlSendStatus>
        pdev->dev_state = USBD_STATE_ADDRESSED;
 800e7a8:	2302      	movs	r3, #2
      if (dev_addr != 0U)
 800e7aa:	2e00      	cmp	r6, #0
 800e7ac:	d100      	bne.n	800e7b0 <USBD_StdDevReq+0x16c>
        pdev->dev_state = USBD_STATE_DEFAULT;
 800e7ae:	2301      	movs	r3, #1
 800e7b0:	5563      	strb	r3, [r4, r5]
 800e7b2:	e76b      	b.n	800e68c <USBD_StdDevReq+0x48>
  cfgidx = (uint8_t)(req->wValue);
 800e7b4:	78a9      	ldrb	r1, [r5, #2]
 800e7b6:	4d3d      	ldr	r5, [pc, #244]	; (800e8ac <USBD_StdDevReq+0x268>)
 800e7b8:	7029      	strb	r1, [r5, #0]
  if (cfgidx > USBD_MAX_NUM_CONFIGURATION)
 800e7ba:	2901      	cmp	r1, #1
 800e7bc:	d8e7      	bhi.n	800e78e <USBD_StdDevReq+0x14a>
    switch (pdev->dev_state)
 800e7be:	23a7      	movs	r3, #167	; 0xa7
 800e7c0:	009b      	lsls	r3, r3, #2
 800e7c2:	5ce2      	ldrb	r2, [r4, r3]
 800e7c4:	2a02      	cmp	r2, #2
 800e7c6:	d009      	beq.n	800e7dc <USBD_StdDevReq+0x198>
 800e7c8:	2a03      	cmp	r2, #3
 800e7ca:	d015      	beq.n	800e7f8 <USBD_StdDevReq+0x1b4>
        USBD_CtlError(pdev, req);
 800e7cc:	0020      	movs	r0, r4
 800e7ce:	f7ff ff2e 	bl	800e62e <USBD_CtlError.constprop.0>
        USBD_ClrClassConfig(pdev, cfgidx);
 800e7d2:	0020      	movs	r0, r4
 800e7d4:	7829      	ldrb	r1, [r5, #0]
 800e7d6:	f7ff fdf0 	bl	800e3ba <USBD_ClrClassConfig>
        break;
 800e7da:	e757      	b.n	800e68c <USBD_StdDevReq+0x48>
        if (cfgidx)
 800e7dc:	2900      	cmp	r1, #0
 800e7de:	d100      	bne.n	800e7e2 <USBD_StdDevReq+0x19e>
 800e7e0:	e773      	b.n	800e6ca <USBD_StdDevReq+0x86>
          pdev->dev_config = cfgidx;
 800e7e2:	2101      	movs	r1, #1
          pdev->dev_state = USBD_STATE_CONFIGURED;
 800e7e4:	2203      	movs	r2, #3
          pdev->dev_config = cfgidx;
 800e7e6:	6061      	str	r1, [r4, #4]
          pdev->dev_state = USBD_STATE_CONFIGURED;
 800e7e8:	54e2      	strb	r2, [r4, r3]
          if (USBD_SetClassConfig(pdev, cfgidx) == USBD_FAIL)
 800e7ea:	0020      	movs	r0, r4
 800e7ec:	f7ff fdd8 	bl	800e3a0 <USBD_SetClassConfig>
 800e7f0:	2802      	cmp	r0, #2
 800e7f2:	d000      	beq.n	800e7f6 <USBD_StdDevReq+0x1b2>
 800e7f4:	e769      	b.n	800e6ca <USBD_StdDevReq+0x86>
 800e7f6:	e7ca      	b.n	800e78e <USBD_StdDevReq+0x14a>
        if (cfgidx == 0U)
 800e7f8:	2900      	cmp	r1, #0
 800e7fa:	d106      	bne.n	800e80a <USBD_StdDevReq+0x1c6>
          pdev->dev_state = USBD_STATE_ADDRESSED;
 800e7fc:	2202      	movs	r2, #2
          USBD_ClrClassConfig(pdev, cfgidx);
 800e7fe:	0020      	movs	r0, r4
          pdev->dev_state = USBD_STATE_ADDRESSED;
 800e800:	54e2      	strb	r2, [r4, r3]
          pdev->dev_config = cfgidx;
 800e802:	6061      	str	r1, [r4, #4]
          USBD_ClrClassConfig(pdev, cfgidx);
 800e804:	f7ff fdd9 	bl	800e3ba <USBD_ClrClassConfig>
          USBD_CtlSendStatus(pdev);
 800e808:	e75f      	b.n	800e6ca <USBD_StdDevReq+0x86>
        else if (cfgidx != pdev->dev_config)
 800e80a:	6861      	ldr	r1, [r4, #4]
 800e80c:	2901      	cmp	r1, #1
 800e80e:	d100      	bne.n	800e812 <USBD_StdDevReq+0x1ce>
 800e810:	e75b      	b.n	800e6ca <USBD_StdDevReq+0x86>
          USBD_ClrClassConfig(pdev, (uint8_t)pdev->dev_config);
 800e812:	b2c9      	uxtb	r1, r1
 800e814:	0020      	movs	r0, r4
 800e816:	f7ff fdd0 	bl	800e3ba <USBD_ClrClassConfig>
          pdev->dev_config = cfgidx;
 800e81a:	7829      	ldrb	r1, [r5, #0]
 800e81c:	6061      	str	r1, [r4, #4]
 800e81e:	e7e4      	b.n	800e7ea <USBD_StdDevReq+0x1a6>
  if (req->wLength != 1U)
 800e820:	88ea      	ldrh	r2, [r5, #6]
 800e822:	2a01      	cmp	r2, #1
 800e824:	d1b3      	bne.n	800e78e <USBD_StdDevReq+0x14a>
    switch (pdev->dev_state)
 800e826:	23a7      	movs	r3, #167	; 0xa7
 800e828:	009b      	lsls	r3, r3, #2
 800e82a:	5ce3      	ldrb	r3, [r4, r3]
 800e82c:	2b02      	cmp	r3, #2
 800e82e:	d806      	bhi.n	800e83e <USBD_StdDevReq+0x1fa>
 800e830:	2b00      	cmp	r3, #0
 800e832:	d0ac      	beq.n	800e78e <USBD_StdDevReq+0x14a>
        pdev->dev_default_config = 0U;
 800e834:	2300      	movs	r3, #0
        USBD_CtlSendData(pdev, (uint8_t *)(void *)&pdev->dev_default_config, 1U);
 800e836:	0021      	movs	r1, r4
        pdev->dev_default_config = 0U;
 800e838:	60a3      	str	r3, [r4, #8]
        USBD_CtlSendData(pdev, (uint8_t *)(void *)&pdev->dev_default_config, 1U);
 800e83a:	3108      	adds	r1, #8
 800e83c:	e002      	b.n	800e844 <USBD_StdDevReq+0x200>
        USBD_CtlSendData(pdev, (uint8_t *)(void *)&pdev->dev_config, 1U);
 800e83e:	1d21      	adds	r1, r4, #4
    switch (pdev->dev_state)
 800e840:	2b03      	cmp	r3, #3
 800e842:	d1a4      	bne.n	800e78e <USBD_StdDevReq+0x14a>
      USBD_CtlSendData(pdev, (uint8_t *)(void *)&pdev->dev_config_status, 2U);
 800e844:	0020      	movs	r0, r4
 800e846:	f000 f92d 	bl	800eaa4 <USBD_CtlSendData>
      break;
 800e84a:	e71f      	b.n	800e68c <USBD_StdDevReq+0x48>
  switch (pdev->dev_state)
 800e84c:	23a7      	movs	r3, #167	; 0xa7
 800e84e:	009b      	lsls	r3, r3, #2
 800e850:	5ce3      	ldrb	r3, [r4, r3]
 800e852:	3b01      	subs	r3, #1
 800e854:	2b02      	cmp	r3, #2
 800e856:	d89a      	bhi.n	800e78e <USBD_StdDevReq+0x14a>
      if (req->wLength != 0x2U)
 800e858:	88eb      	ldrh	r3, [r5, #6]
 800e85a:	2b02      	cmp	r3, #2
 800e85c:	d197      	bne.n	800e78e <USBD_StdDevReq+0x14a>
      pdev->dev_config_status = USB_CONFIG_SELF_POWERED;
 800e85e:	3b01      	subs	r3, #1
 800e860:	60e3      	str	r3, [r4, #12]
      if (pdev->dev_remote_wakeup)
 800e862:	23a9      	movs	r3, #169	; 0xa9
 800e864:	009b      	lsls	r3, r3, #2
 800e866:	58e3      	ldr	r3, [r4, r3]
 800e868:	2b00      	cmp	r3, #0
 800e86a:	d001      	beq.n	800e870 <USBD_StdDevReq+0x22c>
        pdev->dev_config_status |= USB_CONFIG_REMOTE_WAKEUP;
 800e86c:	2303      	movs	r3, #3
 800e86e:	60e3      	str	r3, [r4, #12]
      USBD_CtlSendData(pdev, (uint8_t *)(void *)&pdev->dev_config_status, 2U);
 800e870:	0021      	movs	r1, r4
 800e872:	2202      	movs	r2, #2
 800e874:	310c      	adds	r1, #12
 800e876:	e7e5      	b.n	800e844 <USBD_StdDevReq+0x200>
  if (req->wValue == USB_FEATURE_REMOTE_WAKEUP)
 800e878:	886b      	ldrh	r3, [r5, #2]
 800e87a:	2b01      	cmp	r3, #1
 800e87c:	d000      	beq.n	800e880 <USBD_StdDevReq+0x23c>
 800e87e:	e705      	b.n	800e68c <USBD_StdDevReq+0x48>
    pdev->dev_remote_wakeup = 1U;
 800e880:	22a9      	movs	r2, #169	; 0xa9
 800e882:	0092      	lsls	r2, r2, #2
 800e884:	50a3      	str	r3, [r4, r2]
    USBD_CtlSendStatus(pdev);
 800e886:	e720      	b.n	800e6ca <USBD_StdDevReq+0x86>
  switch (pdev->dev_state)
 800e888:	23a7      	movs	r3, #167	; 0xa7
 800e88a:	009b      	lsls	r3, r3, #2
 800e88c:	5ce3      	ldrb	r3, [r4, r3]
 800e88e:	3b01      	subs	r3, #1
 800e890:	2b02      	cmp	r3, #2
 800e892:	d900      	bls.n	800e896 <USBD_StdDevReq+0x252>
 800e894:	e77b      	b.n	800e78e <USBD_StdDevReq+0x14a>
      if (req->wValue == USB_FEATURE_REMOTE_WAKEUP)
 800e896:	886b      	ldrh	r3, [r5, #2]
 800e898:	2b01      	cmp	r3, #1
 800e89a:	d000      	beq.n	800e89e <USBD_StdDevReq+0x25a>
 800e89c:	e6f6      	b.n	800e68c <USBD_StdDevReq+0x48>
        pdev->dev_remote_wakeup = 0U;
 800e89e:	23a9      	movs	r3, #169	; 0xa9
 800e8a0:	2200      	movs	r2, #0
 800e8a2:	009b      	lsls	r3, r3, #2
 800e8a4:	50e2      	str	r2, [r4, r3]
 800e8a6:	e710      	b.n	800e6ca <USBD_StdDevReq+0x86>
 800e8a8:	0000029e 	.word	0x0000029e
 800e8ac:	20000ab6 	.word	0x20000ab6

0800e8b0 <USBD_StdItfReq>:
  switch (req->bmRequest & USB_REQ_TYPE_MASK)
 800e8b0:	2360      	movs	r3, #96	; 0x60
 800e8b2:	780a      	ldrb	r2, [r1, #0]
{
 800e8b4:	b570      	push	{r4, r5, r6, lr}
  switch (req->bmRequest & USB_REQ_TYPE_MASK)
 800e8b6:	4013      	ands	r3, r2
{
 800e8b8:	0004      	movs	r4, r0
 800e8ba:	000d      	movs	r5, r1
  switch (req->bmRequest & USB_REQ_TYPE_MASK)
 800e8bc:	2b40      	cmp	r3, #64	; 0x40
 800e8be:	d001      	beq.n	800e8c4 <USBD_StdItfReq+0x14>
 800e8c0:	0653      	lsls	r3, r2, #25
 800e8c2:	d419      	bmi.n	800e8f8 <USBD_StdItfReq+0x48>
      switch (pdev->dev_state)
 800e8c4:	23a7      	movs	r3, #167	; 0xa7
 800e8c6:	009b      	lsls	r3, r3, #2
 800e8c8:	5ce3      	ldrb	r3, [r4, r3]
 800e8ca:	3b01      	subs	r3, #1
 800e8cc:	2b02      	cmp	r3, #2
 800e8ce:	d813      	bhi.n	800e8f8 <USBD_StdItfReq+0x48>
          if (LOBYTE(req->wIndex) <= USBD_MAX_NUM_INTERFACES)
 800e8d0:	792b      	ldrb	r3, [r5, #4]
 800e8d2:	2b01      	cmp	r3, #1
 800e8d4:	d810      	bhi.n	800e8f8 <USBD_StdItfReq+0x48>
            ret = (USBD_StatusTypeDef)pdev->pClass->Setup(pdev, req);
 800e8d6:	23ad      	movs	r3, #173	; 0xad
 800e8d8:	009b      	lsls	r3, r3, #2
 800e8da:	58e3      	ldr	r3, [r4, r3]
 800e8dc:	0029      	movs	r1, r5
 800e8de:	689b      	ldr	r3, [r3, #8]
 800e8e0:	0020      	movs	r0, r4
 800e8e2:	4798      	blx	r3
            if ((req->wLength == 0U) && (ret == USBD_OK))
 800e8e4:	88eb      	ldrh	r3, [r5, #6]
 800e8e6:	2b00      	cmp	r3, #0
 800e8e8:	d104      	bne.n	800e8f4 <USBD_StdItfReq+0x44>
 800e8ea:	2800      	cmp	r0, #0
 800e8ec:	d102      	bne.n	800e8f4 <USBD_StdItfReq+0x44>
              USBD_CtlSendStatus(pdev);
 800e8ee:	0020      	movs	r0, r4
 800e8f0:	f000 f906 	bl	800eb00 <USBD_CtlSendStatus>
}
 800e8f4:	2000      	movs	r0, #0
 800e8f6:	bd70      	pop	{r4, r5, r6, pc}
          USBD_CtlError(pdev, req);
 800e8f8:	0020      	movs	r0, r4
 800e8fa:	f7ff fe98 	bl	800e62e <USBD_CtlError.constprop.0>
          break;
 800e8fe:	e7f9      	b.n	800e8f4 <USBD_StdItfReq+0x44>

0800e900 <USBD_StdEPReq>:
{
 800e900:	780a      	ldrb	r2, [r1, #0]
 800e902:	000b      	movs	r3, r1
 800e904:	2160      	movs	r1, #96	; 0x60
 800e906:	400a      	ands	r2, r1
 800e908:	b570      	push	{r4, r5, r6, lr}
 800e90a:	0004      	movs	r4, r0
  switch (req->bmRequest & USB_REQ_TYPE_MASK)
 800e90c:	0010      	movs	r0, r2
 800e90e:	1849      	adds	r1, r1, r1
 800e910:	3820      	subs	r0, #32
 800e912:	4208      	tst	r0, r1
 800e914:	d029      	beq.n	800e96a <USBD_StdEPReq+0x6a>
 800e916:	2a00      	cmp	r2, #0
 800e918:	d137      	bne.n	800e98a <USBD_StdEPReq+0x8a>
  ep_addr  = LOBYTE(req->wIndex);
 800e91a:	8898      	ldrh	r0, [r3, #4]
      switch (req->bRequest)
 800e91c:	785a      	ldrb	r2, [r3, #1]
  ep_addr  = LOBYTE(req->wIndex);
 800e91e:	b2c1      	uxtb	r1, r0
      switch (req->bRequest)
 800e920:	2a01      	cmp	r2, #1
 800e922:	d045      	beq.n	800e9b0 <USBD_StdEPReq+0xb0>
 800e924:	2a03      	cmp	r2, #3
 800e926:	d029      	beq.n	800e97c <USBD_StdEPReq+0x7c>
 800e928:	2a00      	cmp	r2, #0
 800e92a:	d12e      	bne.n	800e98a <USBD_StdEPReq+0x8a>
          switch (pdev->dev_state)
 800e92c:	23a7      	movs	r3, #167	; 0xa7
 800e92e:	009b      	lsls	r3, r3, #2
 800e930:	5ce3      	ldrb	r3, [r4, r3]
 800e932:	2b02      	cmp	r3, #2
 800e934:	d056      	beq.n	800e9e4 <USBD_StdEPReq+0xe4>
 800e936:	2b03      	cmp	r3, #3
 800e938:	d127      	bne.n	800e98a <USBD_StdEPReq+0x8a>
              if ((ep_addr & 0x80U) == 0x80U)
 800e93a:	220f      	movs	r2, #15
 800e93c:	2314      	movs	r3, #20
 800e93e:	400a      	ands	r2, r1
                if (pdev->ep_in[ep_addr & 0xFU].is_used == 0U)
 800e940:	435a      	muls	r2, r3
 800e942:	18a2      	adds	r2, r4, r2
              if ((ep_addr & 0x80U) == 0x80U)
 800e944:	0600      	lsls	r0, r0, #24
 800e946:	d55d      	bpl.n	800ea04 <USBD_StdEPReq+0x104>
                if (pdev->ep_in[ep_addr & 0xFU].is_used == 0U)
 800e948:	6992      	ldr	r2, [r2, #24]
 800e94a:	2a00      	cmp	r2, #0
 800e94c:	d01d      	beq.n	800e98a <USBD_StdEPReq+0x8a>
              pep = ((ep_addr & 0x80U) == 0x80U) ? &pdev->ep_in[ep_addr & 0x7FU] : \
 800e94e:	257f      	movs	r5, #127	; 0x7f
 800e950:	400d      	ands	r5, r1
 800e952:	3501      	adds	r5, #1
 800e954:	435d      	muls	r5, r3
              if ((ep_addr == 0x00U) || (ep_addr == 0x80U))
 800e956:	237f      	movs	r3, #127	; 0x7f
 800e958:	000a      	movs	r2, r1
              pep = ((ep_addr & 0x80U) == 0x80U) ? &pdev->ep_in[ep_addr & 0x7FU] : \
 800e95a:	1965      	adds	r5, r4, r5
              if ((ep_addr == 0x00U) || (ep_addr == 0x80U))
 800e95c:	401a      	ands	r2, r3
 800e95e:	4219      	tst	r1, r3
 800e960:	d15a      	bne.n	800ea18 <USBD_StdEPReq+0x118>
                pep->status = 0x0000U;
 800e962:	602a      	str	r2, [r5, #0]
              USBD_CtlSendData(pdev, (uint8_t *)(void *)&pep->status, 2U);
 800e964:	2202      	movs	r2, #2
 800e966:	0029      	movs	r1, r5
 800e968:	e048      	b.n	800e9fc <USBD_StdEPReq+0xfc>
      pdev->pClass->Setup(pdev, req);
 800e96a:	22ad      	movs	r2, #173	; 0xad
 800e96c:	0092      	lsls	r2, r2, #2
 800e96e:	58a2      	ldr	r2, [r4, r2]
 800e970:	0019      	movs	r1, r3
 800e972:	0020      	movs	r0, r4
 800e974:	6892      	ldr	r2, [r2, #8]
 800e976:	4790      	blx	r2
}
 800e978:	2000      	movs	r0, #0
 800e97a:	bd70      	pop	{r4, r5, r6, pc}
          switch (pdev->dev_state)
 800e97c:	22a7      	movs	r2, #167	; 0xa7
 800e97e:	0092      	lsls	r2, r2, #2
 800e980:	5ca2      	ldrb	r2, [r4, r2]
 800e982:	2a02      	cmp	r2, #2
 800e984:	d024      	beq.n	800e9d0 <USBD_StdEPReq+0xd0>
 800e986:	2a03      	cmp	r2, #3
 800e988:	d003      	beq.n	800e992 <USBD_StdEPReq+0x92>
              USBD_CtlError(pdev, req);
 800e98a:	0020      	movs	r0, r4
 800e98c:	f7ff fe4f 	bl	800e62e <USBD_CtlError.constprop.0>
              break;
 800e990:	e7f2      	b.n	800e978 <USBD_StdEPReq+0x78>
              if (req->wValue == USB_FEATURE_EP_HALT)
 800e992:	885a      	ldrh	r2, [r3, #2]
 800e994:	2a00      	cmp	r2, #0
 800e996:	d107      	bne.n	800e9a8 <USBD_StdEPReq+0xa8>
                if ((ep_addr != 0x00U) &&
 800e998:	064a      	lsls	r2, r1, #25
 800e99a:	d005      	beq.n	800e9a8 <USBD_StdEPReq+0xa8>
                    (ep_addr != 0x80U) && (req->wLength == 0x00U))
 800e99c:	88db      	ldrh	r3, [r3, #6]
 800e99e:	2b00      	cmp	r3, #0
 800e9a0:	d102      	bne.n	800e9a8 <USBD_StdEPReq+0xa8>
                  USBD_LL_StallEP(pdev, ep_addr);
 800e9a2:	0020      	movs	r0, r4
 800e9a4:	f000 ffd0 	bl	800f948 <USBD_LL_StallEP>
              USBD_CtlSendStatus(pdev);
 800e9a8:	0020      	movs	r0, r4
 800e9aa:	f000 f8a9 	bl	800eb00 <USBD_CtlSendStatus>
              break;
 800e9ae:	e7e3      	b.n	800e978 <USBD_StdEPReq+0x78>
          switch (pdev->dev_state)
 800e9b0:	22a7      	movs	r2, #167	; 0xa7
 800e9b2:	0092      	lsls	r2, r2, #2
 800e9b4:	5ca2      	ldrb	r2, [r4, r2]
 800e9b6:	2a02      	cmp	r2, #2
 800e9b8:	d00a      	beq.n	800e9d0 <USBD_StdEPReq+0xd0>
 800e9ba:	2a03      	cmp	r2, #3
 800e9bc:	d1e5      	bne.n	800e98a <USBD_StdEPReq+0x8a>
              if (req->wValue == USB_FEATURE_EP_HALT)
 800e9be:	885b      	ldrh	r3, [r3, #2]
 800e9c0:	2b00      	cmp	r3, #0
 800e9c2:	d1d9      	bne.n	800e978 <USBD_StdEPReq+0x78>
                if ((ep_addr & 0x7FU) != 0x00U)
 800e9c4:	064b      	lsls	r3, r1, #25
 800e9c6:	d0ef      	beq.n	800e9a8 <USBD_StdEPReq+0xa8>
                  USBD_LL_ClearStallEP(pdev, ep_addr);
 800e9c8:	0020      	movs	r0, r4
 800e9ca:	f000 ffcd 	bl	800f968 <USBD_LL_ClearStallEP>
 800e9ce:	e7eb      	b.n	800e9a8 <USBD_StdEPReq+0xa8>
              if ((ep_addr != 0x00U) && (ep_addr != 0x80U))
 800e9d0:	064b      	lsls	r3, r1, #25
 800e9d2:	d0da      	beq.n	800e98a <USBD_StdEPReq+0x8a>
                USBD_LL_StallEP(pdev, ep_addr);
 800e9d4:	0020      	movs	r0, r4
 800e9d6:	f000 ffb7 	bl	800f948 <USBD_LL_StallEP>
                USBD_LL_StallEP(pdev, 0x80U);
 800e9da:	2180      	movs	r1, #128	; 0x80
 800e9dc:	0020      	movs	r0, r4
 800e9de:	f000 ffb3 	bl	800f948 <USBD_LL_StallEP>
 800e9e2:	e7c9      	b.n	800e978 <USBD_StdEPReq+0x78>
              if ((ep_addr != 0x00U) && (ep_addr != 0x80U))
 800e9e4:	064b      	lsls	r3, r1, #25
 800e9e6:	d1d0      	bne.n	800e98a <USBD_StdEPReq+0x8a>
              pep = ((ep_addr & 0x80U) == 0x80U) ? &pdev->ep_in[ep_addr & 0x7FU] : \
 800e9e8:	0021      	movs	r1, r4
 800e9ea:	3155      	adds	r1, #85	; 0x55
 800e9ec:	31ff      	adds	r1, #255	; 0xff
 800e9ee:	0603      	lsls	r3, r0, #24
 800e9f0:	d501      	bpl.n	800e9f6 <USBD_StdEPReq+0xf6>
 800e9f2:	3941      	subs	r1, #65	; 0x41
 800e9f4:	39ff      	subs	r1, #255	; 0xff
              pep->status = 0x0000U;
 800e9f6:	2300      	movs	r3, #0
              USBD_CtlSendData(pdev, (uint8_t *)(void *)&pep->status, 2U);
 800e9f8:	2202      	movs	r2, #2
              pep->status = 0x0000U;
 800e9fa:	600b      	str	r3, [r1, #0]
              USBD_CtlSendData(pdev, (uint8_t *)(void *)&pep->status, 2U);
 800e9fc:	0020      	movs	r0, r4
 800e9fe:	f000 f851 	bl	800eaa4 <USBD_CtlSendData>
              break;
 800ea02:	e7b9      	b.n	800e978 <USBD_StdEPReq+0x78>
                if (pdev->ep_out[ep_addr & 0xFU].is_used == 0U)
 800ea04:	32fc      	adds	r2, #252	; 0xfc
 800ea06:	6dd2      	ldr	r2, [r2, #92]	; 0x5c
 800ea08:	2a00      	cmp	r2, #0
 800ea0a:	d0be      	beq.n	800e98a <USBD_StdEPReq+0x8a>
                    &pdev->ep_out[ep_addr & 0x7FU];
 800ea0c:	257f      	movs	r5, #127	; 0x7f
 800ea0e:	400d      	ands	r5, r1
              pep = ((ep_addr & 0x80U) == 0x80U) ? &pdev->ep_in[ep_addr & 0x7FU] : \
 800ea10:	435d      	muls	r5, r3
 800ea12:	3555      	adds	r5, #85	; 0x55
 800ea14:	35ff      	adds	r5, #255	; 0xff
 800ea16:	e79e      	b.n	800e956 <USBD_StdEPReq+0x56>
              else if (USBD_LL_IsStallEP(pdev, ep_addr))
 800ea18:	0020      	movs	r0, r4
 800ea1a:	f000 ffb5 	bl	800f988 <USBD_LL_IsStallEP>
 800ea1e:	2800      	cmp	r0, #0
 800ea20:	d002      	beq.n	800ea28 <USBD_StdEPReq+0x128>
                pep->status = 0x0001U;
 800ea22:	2301      	movs	r3, #1
 800ea24:	602b      	str	r3, [r5, #0]
 800ea26:	e79d      	b.n	800e964 <USBD_StdEPReq+0x64>
                pep->status = 0x0000U;
 800ea28:	6028      	str	r0, [r5, #0]
 800ea2a:	e79b      	b.n	800e964 <USBD_StdEPReq+0x64>

0800ea2c <USBD_ParseSetupRequest>:
  req->bmRequest = *(uint8_t *)(pdata);
 800ea2c:	780b      	ldrb	r3, [r1, #0]
 800ea2e:	7003      	strb	r3, [r0, #0]
  req->bRequest = *(uint8_t *)(pdata + 1U);
 800ea30:	784b      	ldrb	r3, [r1, #1]
 800ea32:	7043      	strb	r3, [r0, #1]
  req->wValue = SWAPBYTE(pdata + 2U);
 800ea34:	78ca      	ldrb	r2, [r1, #3]
 800ea36:	788b      	ldrb	r3, [r1, #2]
 800ea38:	0212      	lsls	r2, r2, #8
 800ea3a:	189b      	adds	r3, r3, r2
 800ea3c:	8043      	strh	r3, [r0, #2]
  req->wIndex = SWAPBYTE(pdata + 4U);
 800ea3e:	794a      	ldrb	r2, [r1, #5]
 800ea40:	790b      	ldrb	r3, [r1, #4]
 800ea42:	0212      	lsls	r2, r2, #8
 800ea44:	189b      	adds	r3, r3, r2
 800ea46:	8083      	strh	r3, [r0, #4]
  req->wLength = SWAPBYTE(pdata + 6U);
 800ea48:	79ca      	ldrb	r2, [r1, #7]
 800ea4a:	798b      	ldrb	r3, [r1, #6]
 800ea4c:	0212      	lsls	r2, r2, #8
 800ea4e:	189b      	adds	r3, r3, r2
 800ea50:	80c3      	strh	r3, [r0, #6]
}
 800ea52:	4770      	bx	lr

0800ea54 <USBD_CtlError>:
{
 800ea54:	b510      	push	{r4, lr}
 800ea56:	0004      	movs	r4, r0
  USBD_LL_StallEP(pdev, 0x80U);
 800ea58:	2180      	movs	r1, #128	; 0x80
 800ea5a:	f000 ff75 	bl	800f948 <USBD_LL_StallEP>
  USBD_LL_StallEP(pdev, 0U);
 800ea5e:	2100      	movs	r1, #0
 800ea60:	0020      	movs	r0, r4
 800ea62:	f000 ff71 	bl	800f948 <USBD_LL_StallEP>
}
 800ea66:	bd10      	pop	{r4, pc}

0800ea68 <USBD_GetString>:
  * @param  unicode : Formatted string buffer (unicode)
  * @param  len : descriptor length
  * @retval None
  */
void USBD_GetString(uint8_t *desc, uint8_t *unicode, uint16_t *len)
{
 800ea68:	b570      	push	{r4, r5, r6, lr}
 800ea6a:	2500      	movs	r5, #0
  */
static uint8_t USBD_GetLen(uint8_t *buf)
{
  uint8_t  len = 0U;

  while (*buf != '\0')
 800ea6c:	1e46      	subs	r6, r0, #1
  if (desc != NULL)
 800ea6e:	42a8      	cmp	r0, r5
 800ea70:	d00f      	beq.n	800ea92 <USBD_GetString+0x2a>
  while (*buf != '\0')
 800ea72:	002b      	movs	r3, r5
 800ea74:	3501      	adds	r5, #1
 800ea76:	5d74      	ldrb	r4, [r6, r5]
 800ea78:	2c00      	cmp	r4, #0
 800ea7a:	d1fa      	bne.n	800ea72 <USBD_GetString+0xa>
    *len = (uint16_t)USBD_GetLen(desc) * 2U + 2U;
 800ea7c:	b2db      	uxtb	r3, r3
 800ea7e:	3301      	adds	r3, #1
 800ea80:	005b      	lsls	r3, r3, #1
 800ea82:	8013      	strh	r3, [r2, #0]
    unicode[idx++] = *(uint8_t *)(void *)len;
 800ea84:	700b      	strb	r3, [r1, #0]
    unicode[idx++] = USB_DESC_TYPE_STRING;
 800ea86:	2303      	movs	r3, #3
 800ea88:	704b      	strb	r3, [r1, #1]
 800ea8a:	3b01      	subs	r3, #1
    while (*desc != '\0')
 800ea8c:	7805      	ldrb	r5, [r0, #0]
 800ea8e:	2d00      	cmp	r5, #0
 800ea90:	d100      	bne.n	800ea94 <USBD_GetString+0x2c>
}
 800ea92:	bd70      	pop	{r4, r5, r6, pc}
      unicode[idx++] = *desc++;
 800ea94:	1c5a      	adds	r2, r3, #1
 800ea96:	54cd      	strb	r5, [r1, r3]
 800ea98:	b2d2      	uxtb	r2, r2
      unicode[idx++] =  0U;
 800ea9a:	3302      	adds	r3, #2
      unicode[idx++] = *desc++;
 800ea9c:	3001      	adds	r0, #1
      unicode[idx++] =  0U;
 800ea9e:	b2db      	uxtb	r3, r3
 800eaa0:	548c      	strb	r4, [r1, r2]
 800eaa2:	e7f3      	b.n	800ea8c <USBD_GetString+0x24>

0800eaa4 <USBD_CtlSendData>:
* @param  len: length of data to be sent
* @retval status
*/
USBD_StatusTypeDef USBD_CtlSendData(USBD_HandleTypeDef *pdev,
                                    uint8_t *pbuf, uint16_t len)
{
 800eaa4:	0013      	movs	r3, r2
  /* Set EP0 State */
  pdev->ep0_state = USBD_EP0_DATA_IN;
 800eaa6:	22a5      	movs	r2, #165	; 0xa5
{
 800eaa8:	b510      	push	{r4, lr}
  pdev->ep0_state = USBD_EP0_DATA_IN;
 800eaaa:	2402      	movs	r4, #2
 800eaac:	0092      	lsls	r2, r2, #2
 800eaae:	5084      	str	r4, [r0, r2]
  pdev->ep_in[0].total_length = len;
  pdev->ep_in[0].rem_length   = len;

  /* Start the transfer */
  USBD_LL_Transmit(pdev, 0x00U, pbuf, len);
 800eab0:	000a      	movs	r2, r1
  pdev->ep_in[0].total_length = len;
 800eab2:	61c3      	str	r3, [r0, #28]
  USBD_LL_Transmit(pdev, 0x00U, pbuf, len);
 800eab4:	2100      	movs	r1, #0
  pdev->ep_in[0].rem_length   = len;
 800eab6:	6203      	str	r3, [r0, #32]
  USBD_LL_Transmit(pdev, 0x00U, pbuf, len);
 800eab8:	f000 ff8c 	bl	800f9d4 <USBD_LL_Transmit>

  return USBD_OK;
}
 800eabc:	2000      	movs	r0, #0
 800eabe:	bd10      	pop	{r4, pc}

0800eac0 <USBD_CtlContinueSendData>:
* @param  len: length of data to be sent
* @retval status
*/
USBD_StatusTypeDef USBD_CtlContinueSendData(USBD_HandleTypeDef *pdev,
                                            uint8_t *pbuf, uint16_t len)
{
 800eac0:	b510      	push	{r4, lr}
 800eac2:	0013      	movs	r3, r2
  /* Start the next transfer */
  USBD_LL_Transmit(pdev, 0x00U, pbuf, len);
 800eac4:	000a      	movs	r2, r1
 800eac6:	2100      	movs	r1, #0
 800eac8:	f000 ff84 	bl	800f9d4 <USBD_LL_Transmit>

  return USBD_OK;
}
 800eacc:	2000      	movs	r0, #0
 800eace:	bd10      	pop	{r4, pc}

0800ead0 <USBD_CtlPrepareRx>:
* @param  len: length of data to be received
* @retval status
*/
USBD_StatusTypeDef USBD_CtlPrepareRx(USBD_HandleTypeDef *pdev,
                                     uint8_t *pbuf, uint16_t len)
{
 800ead0:	0013      	movs	r3, r2
  /* Set EP0 State */
  pdev->ep0_state = USBD_EP0_DATA_OUT;
 800ead2:	22a5      	movs	r2, #165	; 0xa5
{
 800ead4:	b510      	push	{r4, lr}
  pdev->ep0_state = USBD_EP0_DATA_OUT;
 800ead6:	2403      	movs	r4, #3
 800ead8:	0092      	lsls	r2, r2, #2
 800eada:	5084      	str	r4, [r0, r2]
  pdev->ep_out[0].total_length = len;
 800eadc:	0002      	movs	r2, r0
 800eade:	32fc      	adds	r2, #252	; 0xfc
 800eae0:	6613      	str	r3, [r2, #96]	; 0x60
  pdev->ep_out[0].rem_length   = len;
 800eae2:	6653      	str	r3, [r2, #100]	; 0x64

  /* Start the transfer */
  USBD_LL_PrepareReceive(pdev, 0U, pbuf, len);
 800eae4:	000a      	movs	r2, r1
 800eae6:	2100      	movs	r1, #0
 800eae8:	f000 ff84 	bl	800f9f4 <USBD_LL_PrepareReceive>

  return USBD_OK;
}
 800eaec:	2000      	movs	r0, #0
 800eaee:	bd10      	pop	{r4, pc}

0800eaf0 <USBD_CtlContinueRx>:
* @param  len: length of data to be received
* @retval status
*/
USBD_StatusTypeDef USBD_CtlContinueRx(USBD_HandleTypeDef *pdev,
                                      uint8_t *pbuf, uint16_t len)
{
 800eaf0:	b510      	push	{r4, lr}
 800eaf2:	0013      	movs	r3, r2
  USBD_LL_PrepareReceive(pdev, 0U, pbuf, len);
 800eaf4:	000a      	movs	r2, r1
 800eaf6:	2100      	movs	r1, #0
 800eaf8:	f000 ff7c 	bl	800f9f4 <USBD_LL_PrepareReceive>

  return USBD_OK;
}
 800eafc:	2000      	movs	r0, #0
 800eafe:	bd10      	pop	{r4, pc}

0800eb00 <USBD_CtlSendStatus>:
* @retval status
*/
USBD_StatusTypeDef USBD_CtlSendStatus(USBD_HandleTypeDef *pdev)
{
  /* Set EP0 State */
  pdev->ep0_state = USBD_EP0_STATUS_IN;
 800eb00:	23a5      	movs	r3, #165	; 0xa5
 800eb02:	2204      	movs	r2, #4
 800eb04:	009b      	lsls	r3, r3, #2
{
 800eb06:	b510      	push	{r4, lr}
  pdev->ep0_state = USBD_EP0_STATUS_IN;
 800eb08:	50c2      	str	r2, [r0, r3]

  /* Start the transfer */
  USBD_LL_Transmit(pdev, 0x00U, NULL, 0U);
 800eb0a:	2300      	movs	r3, #0
 800eb0c:	001a      	movs	r2, r3
 800eb0e:	0019      	movs	r1, r3
 800eb10:	f000 ff60 	bl	800f9d4 <USBD_LL_Transmit>

  return USBD_OK;
}
 800eb14:	2000      	movs	r0, #0
 800eb16:	bd10      	pop	{r4, pc}

0800eb18 <USBD_CtlReceiveStatus>:
* @retval status
*/
USBD_StatusTypeDef USBD_CtlReceiveStatus(USBD_HandleTypeDef *pdev)
{
  /* Set EP0 State */
  pdev->ep0_state = USBD_EP0_STATUS_OUT;
 800eb18:	23a5      	movs	r3, #165	; 0xa5
 800eb1a:	2205      	movs	r2, #5
 800eb1c:	009b      	lsls	r3, r3, #2
{
 800eb1e:	b510      	push	{r4, lr}
  pdev->ep0_state = USBD_EP0_STATUS_OUT;
 800eb20:	50c2      	str	r2, [r0, r3]

  /* Start the transfer */
  USBD_LL_PrepareReceive(pdev, 0U, NULL, 0U);
 800eb22:	2300      	movs	r3, #0
 800eb24:	001a      	movs	r2, r3
 800eb26:	0019      	movs	r1, r3
 800eb28:	f000 ff64 	bl	800f9f4 <USBD_LL_PrepareReceive>

  return USBD_OK;
}
 800eb2c:	2000      	movs	r0, #0
 800eb2e:	bd10      	pop	{r4, pc}

0800eb30 <osKernelStart>:
* @param  argument      pointer that is passed to the thread function as start argument.
* @retval status code that indicates the execution status of the function
* @note   MUST REMAIN UNCHANGED: \b osKernelStart shall be consistent in every CMSIS-RTOS.
*/
osStatus osKernelStart (void)
{
 800eb30:	b510      	push	{r4, lr}
  vTaskStartScheduler();
 800eb32:	f000 fa1d 	bl	800ef70 <vTaskStartScheduler>
  
  return osOK;
}
 800eb36:	2000      	movs	r0, #0
 800eb38:	bd10      	pop	{r4, pc}

0800eb3a <osThreadCreate>:
* @param  argument      pointer that is passed to the thread function as start argument.
* @retval thread ID for reference by other functions or NULL in case of error.
* @note   MUST REMAIN UNCHANGED: \b osThreadCreate shall be consistent in every CMSIS-RTOS.
*/
osThreadId osThreadCreate (const osThreadDef_t *thread_def, void *argument)
{
 800eb3a:	b5f0      	push	{r4, r5, r6, r7, lr}
 800eb3c:	0004      	movs	r4, r0
  TaskHandle_t handle;
  
#if( configSUPPORT_STATIC_ALLOCATION == 1 ) &&  ( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
  if((thread_def->buffer != NULL) && (thread_def->controlblock != NULL)) {
 800eb3e:	6946      	ldr	r6, [r0, #20]
{
 800eb40:	000b      	movs	r3, r1
 800eb42:	6840      	ldr	r0, [r0, #4]
 800eb44:	6821      	ldr	r1, [r4, #0]
 800eb46:	6922      	ldr	r2, [r4, #16]
 800eb48:	2708      	movs	r7, #8
 800eb4a:	5fe5      	ldrsh	r5, [r4, r7]
 800eb4c:	b087      	sub	sp, #28
  if((thread_def->buffer != NULL) && (thread_def->controlblock != NULL)) {
 800eb4e:	2e00      	cmp	r6, #0
 800eb50:	d00e      	beq.n	800eb70 <osThreadCreate+0x36>
 800eb52:	69a7      	ldr	r7, [r4, #24]
 800eb54:	2f00      	cmp	r7, #0
 800eb56:	d00b      	beq.n	800eb70 <osThreadCreate+0x36>
  unsigned portBASE_TYPE fpriority = tskIDLE_PRIORITY;
 800eb58:	2400      	movs	r4, #0
  if (priority != osPriorityError) {
 800eb5a:	2d84      	cmp	r5, #132	; 0x84
 800eb5c:	d000      	beq.n	800eb60 <osThreadCreate+0x26>
    fpriority += (priority - osPriorityIdle);
 800eb5e:	1cec      	adds	r4, r5, #3
    handle = xTaskCreateStatic((TaskFunction_t)thread_def->pthread,(const portCHAR *)thread_def->name,
 800eb60:	9702      	str	r7, [sp, #8]
 800eb62:	9601      	str	r6, [sp, #4]
 800eb64:	9400      	str	r4, [sp, #0]
 800eb66:	f000 f9b1 	bl	800eecc <xTaskCreateStatic>
 800eb6a:	9005      	str	r0, [sp, #20]
                   &handle) != pdPASS)  {
    return NULL;
  }     
#endif
  
  return handle;
 800eb6c:	9b05      	ldr	r3, [sp, #20]
 800eb6e:	e00c      	b.n	800eb8a <osThreadCreate+0x50>
  unsigned portBASE_TYPE fpriority = tskIDLE_PRIORITY;
 800eb70:	2400      	movs	r4, #0
    if (xTaskCreate((TaskFunction_t)thread_def->pthread,(const portCHAR *)thread_def->name,
 800eb72:	b292      	uxth	r2, r2
  if (priority != osPriorityError) {
 800eb74:	2d84      	cmp	r5, #132	; 0x84
 800eb76:	d000      	beq.n	800eb7a <osThreadCreate+0x40>
    fpriority += (priority - osPriorityIdle);
 800eb78:	1cec      	adds	r4, r5, #3
    if (xTaskCreate((TaskFunction_t)thread_def->pthread,(const portCHAR *)thread_def->name,
 800eb7a:	ad05      	add	r5, sp, #20
 800eb7c:	9501      	str	r5, [sp, #4]
 800eb7e:	9400      	str	r4, [sp, #0]
 800eb80:	f000 f9c9 	bl	800ef16 <xTaskCreate>
      return NULL;
 800eb84:	2300      	movs	r3, #0
    if (xTaskCreate((TaskFunction_t)thread_def->pthread,(const portCHAR *)thread_def->name,
 800eb86:	2801      	cmp	r0, #1
 800eb88:	d0f0      	beq.n	800eb6c <osThreadCreate+0x32>
}
 800eb8a:	0018      	movs	r0, r3
 800eb8c:	b007      	add	sp, #28
 800eb8e:	bdf0      	pop	{r4, r5, r6, r7, pc}

0800eb90 <osDelay>:
* @brief   Wait for Timeout (Time Delay)
* @param   millisec      time delay value
* @retval  status code that indicates the execution status of the function.
*/
osStatus osDelay (uint32_t millisec)
{
 800eb90:	b510      	push	{r4, lr}
#if INCLUDE_vTaskDelay
  TickType_t ticks = millisec / portTICK_PERIOD_MS;
  
  vTaskDelay(ticks ? ticks : 1);          /* Minimum delay = 1 tick */
 800eb92:	2800      	cmp	r0, #0
 800eb94:	d100      	bne.n	800eb98 <osDelay+0x8>
 800eb96:	3001      	adds	r0, #1
 800eb98:	f000 fb0a 	bl	800f1b0 <vTaskDelay>
#else
  (void) millisec;
  
  return osErrorResource;
#endif
}
 800eb9c:	2000      	movs	r0, #0
 800eb9e:	bd10      	pop	{r4, pc}

0800eba0 <vListInitialise>:
void vListInitialise( List_t * const pxList )
{
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 800eba0:	0003      	movs	r3, r0

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
 800eba2:	2201      	movs	r2, #1
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 800eba4:	3308      	adds	r3, #8
 800eba6:	6043      	str	r3, [r0, #4]

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 800eba8:	60c3      	str	r3, [r0, #12]
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 800ebaa:	6103      	str	r3, [r0, #16]

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
 800ebac:	2300      	movs	r3, #0
	pxList->xListEnd.xItemValue = portMAX_DELAY;
 800ebae:	4252      	negs	r2, r2
 800ebb0:	6082      	str	r2, [r0, #8]
	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
 800ebb2:	6003      	str	r3, [r0, #0]

	/* Write known values into the list if
	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
	listSET_LIST_INTEGRITY_CHECK_1_VALUE( pxList );
	listSET_LIST_INTEGRITY_CHECK_2_VALUE( pxList );
}
 800ebb4:	4770      	bx	lr

0800ebb6 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
 800ebb6:	2300      	movs	r3, #0
 800ebb8:	6103      	str	r3, [r0, #16]

	/* Write known values into the list item if
	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
	listSET_FIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
 800ebba:	4770      	bx	lr

0800ebbc <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
ListItem_t * const pxIndex = pxList->pxIndex;
 800ebbc:	6843      	ldr	r3, [r0, #4]

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
 800ebbe:	689a      	ldr	r2, [r3, #8]
	pxNewListItem->pxNext = pxIndex;
 800ebc0:	604b      	str	r3, [r1, #4]
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
 800ebc2:	608a      	str	r2, [r1, #8]

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
 800ebc4:	689a      	ldr	r2, [r3, #8]
 800ebc6:	6051      	str	r1, [r2, #4]
	pxIndex->pxPrevious = pxNewListItem;
 800ebc8:	6099      	str	r1, [r3, #8]

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;

	( pxList->uxNumberOfItems )++;
 800ebca:	6803      	ldr	r3, [r0, #0]
	pxNewListItem->pvContainer = ( void * ) pxList;
 800ebcc:	6108      	str	r0, [r1, #16]
	( pxList->uxNumberOfItems )++;
 800ebce:	3301      	adds	r3, #1
 800ebd0:	6003      	str	r3, [r0, #0]
}
 800ebd2:	4770      	bx	lr

0800ebd4 <vListInsert>:
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 800ebd4:	0002      	movs	r2, r0
{
 800ebd6:	b530      	push	{r4, r5, lr}
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
 800ebd8:	680c      	ldr	r4, [r1, #0]
		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 800ebda:	3208      	adds	r2, #8
	if( xValueOfInsertion == portMAX_DELAY )
 800ebdc:	1c63      	adds	r3, r4, #1
 800ebde:	d10a      	bne.n	800ebf6 <vListInsert+0x22>
		pxIterator = pxList->xListEnd.pxPrevious;
 800ebe0:	6903      	ldr	r3, [r0, #16]
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
 800ebe2:	685a      	ldr	r2, [r3, #4]
 800ebe4:	604a      	str	r2, [r1, #4]
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
 800ebe6:	6091      	str	r1, [r2, #8]
	pxNewListItem->pxPrevious = pxIterator;
 800ebe8:	608b      	str	r3, [r1, #8]
	pxIterator->pxNext = pxNewListItem;
 800ebea:	6059      	str	r1, [r3, #4]

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;

	( pxList->uxNumberOfItems )++;
 800ebec:	6803      	ldr	r3, [r0, #0]
	pxNewListItem->pvContainer = ( void * ) pxList;
 800ebee:	6108      	str	r0, [r1, #16]
	( pxList->uxNumberOfItems )++;
 800ebf0:	3301      	adds	r3, #1
 800ebf2:	6003      	str	r3, [r0, #0]
}
 800ebf4:	bd30      	pop	{r4, r5, pc}
		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 800ebf6:	0013      	movs	r3, r2
 800ebf8:	6852      	ldr	r2, [r2, #4]
 800ebfa:	6815      	ldr	r5, [r2, #0]
 800ebfc:	42a5      	cmp	r5, r4
 800ebfe:	d9fa      	bls.n	800ebf6 <vListInsert+0x22>
 800ec00:	e7ef      	b.n	800ebe2 <vListInsert+0xe>

0800ec02 <uxListRemove>:

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
 800ec02:	6903      	ldr	r3, [r0, #16]

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
 800ec04:	6841      	ldr	r1, [r0, #4]
 800ec06:	6882      	ldr	r2, [r0, #8]
 800ec08:	608a      	str	r2, [r1, #8]
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
 800ec0a:	6051      	str	r1, [r2, #4]

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
 800ec0c:	6859      	ldr	r1, [r3, #4]
 800ec0e:	4281      	cmp	r1, r0
 800ec10:	d100      	bne.n	800ec14 <uxListRemove+0x12>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
 800ec12:	605a      	str	r2, [r3, #4]
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
 800ec14:	2200      	movs	r2, #0
 800ec16:	6102      	str	r2, [r0, #16]
	( pxList->uxNumberOfItems )--;
 800ec18:	681a      	ldr	r2, [r3, #0]
 800ec1a:	3a01      	subs	r2, #1
 800ec1c:	601a      	str	r2, [r3, #0]

	return pxList->uxNumberOfItems;
 800ec1e:	6818      	ldr	r0, [r3, #0]
}
 800ec20:	4770      	bx	lr
	...

0800ec24 <prvAddNewTaskToReadyList>:
	}
}
/*-----------------------------------------------------------*/

static void prvAddNewTaskToReadyList( TCB_t *pxNewTCB )
{
 800ec24:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800ec26:	0004      	movs	r4, r0
	/* Ensure interrupts don't access the task lists while the lists are being
	updated. */
	taskENTER_CRITICAL();
 800ec28:	f000 fb94 	bl	800f354 <vPortEnterCritical>
	{
		uxCurrentNumberOfTasks++;
 800ec2c:	4b2f      	ldr	r3, [pc, #188]	; (800ecec <prvAddNewTaskToReadyList+0xc8>)
		if( pxCurrentTCB == NULL )
 800ec2e:	4d30      	ldr	r5, [pc, #192]	; (800ecf0 <prvAddNewTaskToReadyList+0xcc>)
		uxCurrentNumberOfTasks++;
 800ec30:	681a      	ldr	r2, [r3, #0]
 800ec32:	4e30      	ldr	r6, [pc, #192]	; (800ecf4 <prvAddNewTaskToReadyList+0xd0>)
 800ec34:	3201      	adds	r2, #1
 800ec36:	601a      	str	r2, [r3, #0]
		if( pxCurrentTCB == NULL )
 800ec38:	682a      	ldr	r2, [r5, #0]
 800ec3a:	2a00      	cmp	r2, #0
 800ec3c:	d14b      	bne.n	800ecd6 <prvAddNewTaskToReadyList+0xb2>
		{
			/* There are no other tasks, or all the other tasks are in
			the suspended state - make this the current task. */
			pxCurrentTCB = pxNewTCB;
 800ec3e:	602c      	str	r4, [r5, #0]

			if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
 800ec40:	681b      	ldr	r3, [r3, #0]
 800ec42:	2b01      	cmp	r3, #1
 800ec44:	d129      	bne.n	800ec9a <prvAddNewTaskToReadyList+0x76>
{
UBaseType_t uxPriority;

	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
 800ec46:	482c      	ldr	r0, [pc, #176]	; (800ecf8 <prvAddNewTaskToReadyList+0xd4>)
 800ec48:	f7ff ffaa 	bl	800eba0 <vListInitialise>
 800ec4c:	482b      	ldr	r0, [pc, #172]	; (800ecfc <prvAddNewTaskToReadyList+0xd8>)
 800ec4e:	f7ff ffa7 	bl	800eba0 <vListInitialise>
 800ec52:	482b      	ldr	r0, [pc, #172]	; (800ed00 <prvAddNewTaskToReadyList+0xdc>)
 800ec54:	f7ff ffa4 	bl	800eba0 <vListInitialise>
 800ec58:	482a      	ldr	r0, [pc, #168]	; (800ed04 <prvAddNewTaskToReadyList+0xe0>)
 800ec5a:	f7ff ffa1 	bl	800eba0 <vListInitialise>
 800ec5e:	482a      	ldr	r0, [pc, #168]	; (800ed08 <prvAddNewTaskToReadyList+0xe4>)
 800ec60:	f7ff ff9e 	bl	800eba0 <vListInitialise>
 800ec64:	4829      	ldr	r0, [pc, #164]	; (800ed0c <prvAddNewTaskToReadyList+0xe8>)
 800ec66:	f7ff ff9b 	bl	800eba0 <vListInitialise>
 800ec6a:	4829      	ldr	r0, [pc, #164]	; (800ed10 <prvAddNewTaskToReadyList+0xec>)
 800ec6c:	f7ff ff98 	bl	800eba0 <vListInitialise>
	}

	vListInitialise( &xDelayedTaskList1 );
 800ec70:	4f28      	ldr	r7, [pc, #160]	; (800ed14 <prvAddNewTaskToReadyList+0xf0>)
 800ec72:	0038      	movs	r0, r7
 800ec74:	f7ff ff94 	bl	800eba0 <vListInitialise>
	vListInitialise( &xDelayedTaskList2 );
 800ec78:	4827      	ldr	r0, [pc, #156]	; (800ed18 <prvAddNewTaskToReadyList+0xf4>)
 800ec7a:	f7ff ff91 	bl	800eba0 <vListInitialise>
	vListInitialise( &xPendingReadyList );
 800ec7e:	4827      	ldr	r0, [pc, #156]	; (800ed1c <prvAddNewTaskToReadyList+0xf8>)
 800ec80:	f7ff ff8e 	bl	800eba0 <vListInitialise>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( &xTasksWaitingTermination );
 800ec84:	4826      	ldr	r0, [pc, #152]	; (800ed20 <prvAddNewTaskToReadyList+0xfc>)
 800ec86:	f7ff ff8b 	bl	800eba0 <vListInitialise>
	}
	#endif /* INCLUDE_vTaskDelete */

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		vListInitialise( &xSuspendedTaskList );
 800ec8a:	4826      	ldr	r0, [pc, #152]	; (800ed24 <prvAddNewTaskToReadyList+0x100>)
 800ec8c:	f7ff ff88 	bl	800eba0 <vListInitialise>
	}
	#endif /* INCLUDE_vTaskSuspend */

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
 800ec90:	4b25      	ldr	r3, [pc, #148]	; (800ed28 <prvAddNewTaskToReadyList+0x104>)
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
 800ec92:	4a21      	ldr	r2, [pc, #132]	; (800ed18 <prvAddNewTaskToReadyList+0xf4>)
	pxDelayedTaskList = &xDelayedTaskList1;
 800ec94:	601f      	str	r7, [r3, #0]
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
 800ec96:	4b25      	ldr	r3, [pc, #148]	; (800ed2c <prvAddNewTaskToReadyList+0x108>)
 800ec98:	601a      	str	r2, [r3, #0]
		uxTaskNumber++;
 800ec9a:	4a25      	ldr	r2, [pc, #148]	; (800ed30 <prvAddNewTaskToReadyList+0x10c>)
 800ec9c:	6813      	ldr	r3, [r2, #0]
 800ec9e:	3301      	adds	r3, #1
 800eca0:	6013      	str	r3, [r2, #0]
		prvAddTaskToReadyList( pxNewTCB );
 800eca2:	4a24      	ldr	r2, [pc, #144]	; (800ed34 <prvAddNewTaskToReadyList+0x110>)
 800eca4:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 800eca6:	6811      	ldr	r1, [r2, #0]
 800eca8:	428b      	cmp	r3, r1
 800ecaa:	d900      	bls.n	800ecae <prvAddNewTaskToReadyList+0x8a>
 800ecac:	6013      	str	r3, [r2, #0]
 800ecae:	2014      	movs	r0, #20
 800ecb0:	4358      	muls	r0, r3
 800ecb2:	4b11      	ldr	r3, [pc, #68]	; (800ecf8 <prvAddNewTaskToReadyList+0xd4>)
 800ecb4:	1d21      	adds	r1, r4, #4
 800ecb6:	1818      	adds	r0, r3, r0
 800ecb8:	f7ff ff80 	bl	800ebbc <vListInsertEnd>
	taskEXIT_CRITICAL();
 800ecbc:	f000 fb56 	bl	800f36c <vPortExitCritical>
	if( xSchedulerRunning != pdFALSE )
 800ecc0:	6833      	ldr	r3, [r6, #0]
 800ecc2:	2b00      	cmp	r3, #0
 800ecc4:	d006      	beq.n	800ecd4 <prvAddNewTaskToReadyList+0xb0>
		if( pxCurrentTCB->uxPriority < pxNewTCB->uxPriority )
 800ecc6:	682b      	ldr	r3, [r5, #0]
 800ecc8:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 800ecca:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 800eccc:	429a      	cmp	r2, r3
 800ecce:	d201      	bcs.n	800ecd4 <prvAddNewTaskToReadyList+0xb0>
			taskYIELD_IF_USING_PREEMPTION();
 800ecd0:	f000 fb34 	bl	800f33c <vPortYield>
}
 800ecd4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
			if( xSchedulerRunning == pdFALSE )
 800ecd6:	6833      	ldr	r3, [r6, #0]
 800ecd8:	2b00      	cmp	r3, #0
 800ecda:	d1de      	bne.n	800ec9a <prvAddNewTaskToReadyList+0x76>
				if( pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority )
 800ecdc:	682b      	ldr	r3, [r5, #0]
 800ecde:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
 800ece0:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800ece2:	4293      	cmp	r3, r2
 800ece4:	d8d9      	bhi.n	800ec9a <prvAddNewTaskToReadyList+0x76>
					pxCurrentTCB = pxNewTCB;
 800ece6:	602c      	str	r4, [r5, #0]
 800ece8:	e7d7      	b.n	800ec9a <prvAddNewTaskToReadyList+0x76>
 800ecea:	46c0      	nop			; (mov r8, r8)
 800ecec:	20000b50 	.word	0x20000b50
 800ecf0:	20000ab8 	.word	0x20000ab8
 800ecf4:	20000bac 	.word	0x20000bac
 800ecf8:	20000ac4 	.word	0x20000ac4
 800ecfc:	20000ad8 	.word	0x20000ad8
 800ed00:	20000aec 	.word	0x20000aec
 800ed04:	20000b00 	.word	0x20000b00
 800ed08:	20000b14 	.word	0x20000b14
 800ed0c:	20000b28 	.word	0x20000b28
 800ed10:	20000b3c 	.word	0x20000b3c
 800ed14:	20000b68 	.word	0x20000b68
 800ed18:	20000b7c 	.word	0x20000b7c
 800ed1c:	20000b98 	.word	0x20000b98
 800ed20:	20000bc4 	.word	0x20000bc4
 800ed24:	20000bb0 	.word	0x20000bb0
 800ed28:	20000abc 	.word	0x20000abc
 800ed2c:	20000ac0 	.word	0x20000ac0
 800ed30:	20000b60 	.word	0x20000b60
 800ed34:	20000b64 	.word	0x20000b64

0800ed38 <prvResetNextTaskUnblockTime>:

static void prvResetNextTaskUnblockTime( void )
{
TCB_t *pxTCB;

	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 800ed38:	4a07      	ldr	r2, [pc, #28]	; (800ed58 <prvResetNextTaskUnblockTime+0x20>)
 800ed3a:	6813      	ldr	r3, [r2, #0]
 800ed3c:	6819      	ldr	r1, [r3, #0]
 800ed3e:	4b07      	ldr	r3, [pc, #28]	; (800ed5c <prvResetNextTaskUnblockTime+0x24>)
 800ed40:	2900      	cmp	r1, #0
 800ed42:	d103      	bne.n	800ed4c <prvResetNextTaskUnblockTime+0x14>
	{
		/* The new current delayed list is empty.  Set xNextTaskUnblockTime to
		the maximum possible value so it is	extremely unlikely that the
		if( xTickCount >= xNextTaskUnblockTime ) test will pass until
		there is an item in the delayed list. */
		xNextTaskUnblockTime = portMAX_DELAY;
 800ed44:	2201      	movs	r2, #1
 800ed46:	4252      	negs	r2, r2
		/* The new current delayed list is not empty, get the value of
		the item at the head of the delayed list.  This is the time at
		which the task at the head of the delayed list should be removed
		from the Blocked state. */
		( pxTCB ) = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xStateListItem ) );
 800ed48:	601a      	str	r2, [r3, #0]
	}
}
 800ed4a:	4770      	bx	lr
		( pxTCB ) = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
 800ed4c:	6812      	ldr	r2, [r2, #0]
 800ed4e:	68d2      	ldr	r2, [r2, #12]
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xStateListItem ) );
 800ed50:	68d2      	ldr	r2, [r2, #12]
 800ed52:	6852      	ldr	r2, [r2, #4]
 800ed54:	e7f8      	b.n	800ed48 <prvResetNextTaskUnblockTime+0x10>
 800ed56:	46c0      	nop			; (mov r8, r8)
 800ed58:	20000abc 	.word	0x20000abc
 800ed5c:	20000b90 	.word	0x20000b90

0800ed60 <prvInitialiseNewTask.isra.0>:
static void prvInitialiseNewTask( 	TaskFunction_t pxTaskCode,
 800ed60:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
 800ed62:	9c0a      	ldr	r4, [sp, #40]	; 0x28
 800ed64:	9301      	str	r3, [sp, #4]
		pxTopOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
 800ed66:	4b1d      	ldr	r3, [pc, #116]	; (800eddc <prvInitialiseNewTask.isra.0+0x7c>)
static void prvInitialiseNewTask( 	TaskFunction_t pxTaskCode,
 800ed68:	9000      	str	r0, [sp, #0]
		pxTopOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
 800ed6a:	18d2      	adds	r2, r2, r3
 800ed6c:	6b23      	ldr	r3, [r4, #48]	; 0x30
 800ed6e:	0092      	lsls	r2, r2, #2
 800ed70:	189a      	adds	r2, r3, r2
		pxTopOfStack = ( StackType_t * ) ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) ); /*lint !e923 MISRA exception.  Avoiding casts between pointers and integers is not practical.  Size differences accounted for using portPOINTER_SIZE_TYPE type. */
 800ed72:	2307      	movs	r3, #7
 800ed74:	439a      	bics	r2, r3
 800ed76:	0017      	movs	r7, r2
		pxNewTCB->pcTaskName[ x ] = pcName[ x ];
 800ed78:	0022      	movs	r2, r4
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
 800ed7a:	2300      	movs	r3, #0
		pxNewTCB->pcTaskName[ x ] = pcName[ x ];
 800ed7c:	3234      	adds	r2, #52	; 0x34
 800ed7e:	5cc8      	ldrb	r0, [r1, r3]
 800ed80:	54d0      	strb	r0, [r2, r3]
		if( pcName[ x ] == 0x00 )
 800ed82:	5cc8      	ldrb	r0, [r1, r3]
 800ed84:	2800      	cmp	r0, #0
 800ed86:	d002      	beq.n	800ed8e <prvInitialiseNewTask.isra.0+0x2e>
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
 800ed88:	3301      	adds	r3, #1
 800ed8a:	2b10      	cmp	r3, #16
 800ed8c:	d1f7      	bne.n	800ed7e <prvInitialiseNewTask.isra.0+0x1e>
	pxNewTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
 800ed8e:	0023      	movs	r3, r4
 800ed90:	2500      	movs	r5, #0
 800ed92:	9e08      	ldr	r6, [sp, #32]
 800ed94:	3343      	adds	r3, #67	; 0x43
 800ed96:	701d      	strb	r5, [r3, #0]
	if( uxPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
 800ed98:	2e06      	cmp	r6, #6
 800ed9a:	d900      	bls.n	800ed9e <prvInitialiseNewTask.isra.0+0x3e>
 800ed9c:	2606      	movs	r6, #6
	pxNewTCB->uxPriority = uxPriority;
 800ed9e:	62e6      	str	r6, [r4, #44]	; 0x2c
		pxNewTCB->uxBasePriority = uxPriority;
 800eda0:	6466      	str	r6, [r4, #68]	; 0x44
	vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
 800eda2:	1d20      	adds	r0, r4, #4
		pxNewTCB->uxMutexesHeld = 0;
 800eda4:	64a5      	str	r5, [r4, #72]	; 0x48
	vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
 800eda6:	f7ff ff06 	bl	800ebb6 <vListInitialiseItem>
	vListInitialiseItem( &( pxNewTCB->xEventListItem ) );
 800edaa:	0020      	movs	r0, r4
 800edac:	3018      	adds	r0, #24
 800edae:	f7ff ff02 	bl	800ebb6 <vListInitialiseItem>
	listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 800edb2:	2307      	movs	r3, #7
 800edb4:	1b9e      	subs	r6, r3, r6
		pxNewTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
 800edb6:	0023      	movs	r3, r4
 800edb8:	3350      	adds	r3, #80	; 0x50
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xStateListItem ), pxNewTCB );
 800edba:	6124      	str	r4, [r4, #16]
	listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 800edbc:	61a6      	str	r6, [r4, #24]
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xEventListItem ), pxNewTCB );
 800edbe:	6264      	str	r4, [r4, #36]	; 0x24
		pxNewTCB->ulNotifiedValue = 0;
 800edc0:	64e5      	str	r5, [r4, #76]	; 0x4c
		pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
 800edc2:	0038      	movs	r0, r7
		pxNewTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
 800edc4:	701d      	strb	r5, [r3, #0]
		pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
 800edc6:	9a01      	ldr	r2, [sp, #4]
 800edc8:	9900      	ldr	r1, [sp, #0]
 800edca:	f000 fa73 	bl	800f2b4 <pxPortInitialiseStack>
	if( ( void * ) pxCreatedTask != NULL )
 800edce:	9b09      	ldr	r3, [sp, #36]	; 0x24
		pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
 800edd0:	6020      	str	r0, [r4, #0]
	if( ( void * ) pxCreatedTask != NULL )
 800edd2:	2b00      	cmp	r3, #0
 800edd4:	d000      	beq.n	800edd8 <prvInitialiseNewTask.isra.0+0x78>
		*pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
 800edd6:	601c      	str	r4, [r3, #0]
}
 800edd8:	bdf7      	pop	{r0, r1, r2, r4, r5, r6, r7, pc}
 800edda:	46c0      	nop			; (mov r8, r8)
 800eddc:	3fffffff 	.word	0x3fffffff

0800ede0 <prvDeleteTCB>:
			if( pxTCB->ucStaticallyAllocated == tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB )
 800ede0:	0003      	movs	r3, r0
	{
 800ede2:	b510      	push	{r4, lr}
			if( pxTCB->ucStaticallyAllocated == tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB )
 800ede4:	3351      	adds	r3, #81	; 0x51
 800ede6:	781b      	ldrb	r3, [r3, #0]
	{
 800ede8:	0004      	movs	r4, r0
			if( pxTCB->ucStaticallyAllocated == tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB )
 800edea:	2b00      	cmp	r3, #0
 800edec:	d106      	bne.n	800edfc <prvDeleteTCB+0x1c>
				vPortFree( pxTCB->pxStack );
 800edee:	6b00      	ldr	r0, [r0, #48]	; 0x30
 800edf0:	f000 fbac 	bl	800f54c <vPortFree>
				vPortFree( pxTCB );
 800edf4:	0020      	movs	r0, r4
 800edf6:	f000 fba9 	bl	800f54c <vPortFree>
	}
 800edfa:	bd10      	pop	{r4, pc}
			else if( pxTCB->ucStaticallyAllocated == tskSTATICALLY_ALLOCATED_STACK_ONLY )
 800edfc:	2b01      	cmp	r3, #1
 800edfe:	d0f9      	beq.n	800edf4 <prvDeleteTCB+0x14>
				configASSERT( pxTCB->ucStaticallyAllocated == tskSTATICALLY_ALLOCATED_STACK_AND_TCB	);
 800ee00:	2b02      	cmp	r3, #2
 800ee02:	d0fa      	beq.n	800edfa <prvDeleteTCB+0x1a>
 800ee04:	b672      	cpsid	i
 800ee06:	e7fe      	b.n	800ee06 <prvDeleteTCB+0x26>

0800ee08 <prvIdleTask>:
{
 800ee08:	b570      	push	{r4, r5, r6, lr}
		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
 800ee0a:	4c10      	ldr	r4, [pc, #64]	; (800ee4c <prvIdleTask+0x44>)
 800ee0c:	6823      	ldr	r3, [r4, #0]
 800ee0e:	2b00      	cmp	r3, #0
 800ee10:	d106      	bne.n	800ee20 <prvIdleTask+0x18>
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
 800ee12:	4b0f      	ldr	r3, [pc, #60]	; (800ee50 <prvIdleTask+0x48>)
 800ee14:	681b      	ldr	r3, [r3, #0]
 800ee16:	2b01      	cmp	r3, #1
 800ee18:	d9f7      	bls.n	800ee0a <prvIdleTask+0x2>
				taskYIELD();
 800ee1a:	f000 fa8f 	bl	800f33c <vPortYield>
 800ee1e:	e7f4      	b.n	800ee0a <prvIdleTask+0x2>
			taskENTER_CRITICAL();
 800ee20:	f000 fa98 	bl	800f354 <vPortEnterCritical>
				pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) );
 800ee24:	4b0b      	ldr	r3, [pc, #44]	; (800ee54 <prvIdleTask+0x4c>)
 800ee26:	68db      	ldr	r3, [r3, #12]
 800ee28:	68dd      	ldr	r5, [r3, #12]
				( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 800ee2a:	1d28      	adds	r0, r5, #4
 800ee2c:	f7ff fee9 	bl	800ec02 <uxListRemove>
				--uxCurrentNumberOfTasks;
 800ee30:	4a09      	ldr	r2, [pc, #36]	; (800ee58 <prvIdleTask+0x50>)
 800ee32:	6813      	ldr	r3, [r2, #0]
 800ee34:	3b01      	subs	r3, #1
 800ee36:	6013      	str	r3, [r2, #0]
				--uxDeletedTasksWaitingCleanUp;
 800ee38:	6823      	ldr	r3, [r4, #0]
 800ee3a:	3b01      	subs	r3, #1
 800ee3c:	6023      	str	r3, [r4, #0]
			taskEXIT_CRITICAL();
 800ee3e:	f000 fa95 	bl	800f36c <vPortExitCritical>
			prvDeleteTCB( pxTCB );
 800ee42:	0028      	movs	r0, r5
 800ee44:	f7ff ffcc 	bl	800ede0 <prvDeleteTCB>
 800ee48:	e7df      	b.n	800ee0a <prvIdleTask+0x2>
 800ee4a:	46c0      	nop			; (mov r8, r8)
 800ee4c:	20000b54 	.word	0x20000b54
 800ee50:	20000ac4 	.word	0x20000ac4
 800ee54:	20000bc4 	.word	0x20000bc4
 800ee58:	20000b50 	.word	0x20000b50

0800ee5c <prvAddCurrentTaskToDelayedList>:
#endif /* configUSE_TASK_NOTIFICATIONS */
/*-----------------------------------------------------------*/


static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait, const BaseType_t xCanBlockIndefinitely )
{
 800ee5c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800ee5e:	0004      	movs	r4, r0
TickType_t xTimeToWake;
const TickType_t xConstTickCount = xTickCount;
 800ee60:	4b14      	ldr	r3, [pc, #80]	; (800eeb4 <prvAddCurrentTaskToDelayedList+0x58>)
	}
	#endif

	/* Remove the task from the ready list before adding it to the blocked list
	as the same list item is used for both lists. */
	if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 800ee62:	4d15      	ldr	r5, [pc, #84]	; (800eeb8 <prvAddCurrentTaskToDelayedList+0x5c>)
const TickType_t xConstTickCount = xTickCount;
 800ee64:	681e      	ldr	r6, [r3, #0]
	if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 800ee66:	6828      	ldr	r0, [r5, #0]
{
 800ee68:	000f      	movs	r7, r1
	if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 800ee6a:	3004      	adds	r0, #4
 800ee6c:	f7ff fec9 	bl	800ec02 <uxListRemove>
		mtCOVERAGE_TEST_MARKER();
	}

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( ( xTicksToWait == portMAX_DELAY ) && ( xCanBlockIndefinitely != pdFALSE ) )
 800ee70:	1c63      	adds	r3, r4, #1
 800ee72:	d107      	bne.n	800ee84 <prvAddCurrentTaskToDelayedList+0x28>
 800ee74:	2f00      	cmp	r7, #0
 800ee76:	d005      	beq.n	800ee84 <prvAddCurrentTaskToDelayedList+0x28>
		{
			/* Add the task to the suspended task list instead of a delayed task
			list to ensure it is not woken by a timing event.  It will block
			indefinitely. */
			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xStateListItem ) );
 800ee78:	6829      	ldr	r1, [r5, #0]
 800ee7a:	4810      	ldr	r0, [pc, #64]	; (800eebc <prvAddCurrentTaskToDelayedList+0x60>)
 800ee7c:	3104      	adds	r1, #4
 800ee7e:	f7ff fe9d 	bl	800ebbc <vListInsertEnd>

		/* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
		( void ) xCanBlockIndefinitely;
	}
	#endif /* INCLUDE_vTaskSuspend */
}
 800ee82:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
			listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
 800ee84:	682b      	ldr	r3, [r5, #0]
			xTimeToWake = xConstTickCount + xTicksToWait;
 800ee86:	1934      	adds	r4, r6, r4
			listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
 800ee88:	605c      	str	r4, [r3, #4]
			if( xTimeToWake < xConstTickCount )
 800ee8a:	42a6      	cmp	r6, r4
 800ee8c:	d906      	bls.n	800ee9c <prvAddCurrentTaskToDelayedList+0x40>
				vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
 800ee8e:	4b0c      	ldr	r3, [pc, #48]	; (800eec0 <prvAddCurrentTaskToDelayedList+0x64>)
 800ee90:	6818      	ldr	r0, [r3, #0]
 800ee92:	6829      	ldr	r1, [r5, #0]
 800ee94:	3104      	adds	r1, #4
 800ee96:	f7ff fe9d 	bl	800ebd4 <vListInsert>
 800ee9a:	e7f2      	b.n	800ee82 <prvAddCurrentTaskToDelayedList+0x26>
				vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
 800ee9c:	4b09      	ldr	r3, [pc, #36]	; (800eec4 <prvAddCurrentTaskToDelayedList+0x68>)
 800ee9e:	6818      	ldr	r0, [r3, #0]
 800eea0:	6829      	ldr	r1, [r5, #0]
 800eea2:	3104      	adds	r1, #4
 800eea4:	f7ff fe96 	bl	800ebd4 <vListInsert>
				if( xTimeToWake < xNextTaskUnblockTime )
 800eea8:	4b07      	ldr	r3, [pc, #28]	; (800eec8 <prvAddCurrentTaskToDelayedList+0x6c>)
 800eeaa:	681a      	ldr	r2, [r3, #0]
 800eeac:	42a2      	cmp	r2, r4
 800eeae:	d9e8      	bls.n	800ee82 <prvAddCurrentTaskToDelayedList+0x26>
					xNextTaskUnblockTime = xTimeToWake;
 800eeb0:	601c      	str	r4, [r3, #0]
}
 800eeb2:	e7e6      	b.n	800ee82 <prvAddCurrentTaskToDelayedList+0x26>
 800eeb4:	20000bd8 	.word	0x20000bd8
 800eeb8:	20000ab8 	.word	0x20000ab8
 800eebc:	20000bb0 	.word	0x20000bb0
 800eec0:	20000ac0 	.word	0x20000ac0
 800eec4:	20000abc 	.word	0x20000abc
 800eec8:	20000b90 	.word	0x20000b90

0800eecc <xTaskCreateStatic>:
	{
 800eecc:	b570      	push	{r4, r5, r6, lr}
 800eece:	b086      	sub	sp, #24
 800eed0:	9d0b      	ldr	r5, [sp, #44]	; 0x2c
 800eed2:	9c0c      	ldr	r4, [sp, #48]	; 0x30
		configASSERT( puxStackBuffer != NULL );
 800eed4:	2d00      	cmp	r5, #0
 800eed6:	d101      	bne.n	800eedc <xTaskCreateStatic+0x10>
 800eed8:	b672      	cpsid	i
 800eeda:	e7fe      	b.n	800eeda <xTaskCreateStatic+0xe>
		configASSERT( pxTaskBuffer != NULL );
 800eedc:	2c00      	cmp	r4, #0
 800eede:	d101      	bne.n	800eee4 <xTaskCreateStatic+0x18>
 800eee0:	b672      	cpsid	i
 800eee2:	e7fe      	b.n	800eee2 <xTaskCreateStatic+0x16>
			volatile size_t xSize = sizeof( StaticTask_t );
 800eee4:	2654      	movs	r6, #84	; 0x54
 800eee6:	9604      	str	r6, [sp, #16]
			configASSERT( xSize == sizeof( TCB_t ) );
 800eee8:	9e04      	ldr	r6, [sp, #16]
 800eeea:	2e54      	cmp	r6, #84	; 0x54
 800eeec:	d001      	beq.n	800eef2 <xTaskCreateStatic+0x26>
 800eeee:	b672      	cpsid	i
 800eef0:	e7fe      	b.n	800eef0 <xTaskCreateStatic+0x24>
			pxNewTCB->pxStack = ( StackType_t * ) puxStackBuffer;
 800eef2:	6325      	str	r5, [r4, #48]	; 0x30
				pxNewTCB->ucStaticallyAllocated = tskSTATICALLY_ALLOCATED_STACK_AND_TCB;
 800eef4:	0025      	movs	r5, r4
 800eef6:	2602      	movs	r6, #2
 800eef8:	3551      	adds	r5, #81	; 0x51
 800eefa:	702e      	strb	r6, [r5, #0]
			prvInitialiseNewTask( pxTaskCode, pcName, ulStackDepth, pvParameters, uxPriority, &xReturn, pxNewTCB, NULL );
 800eefc:	ad05      	add	r5, sp, #20
 800eefe:	9501      	str	r5, [sp, #4]
 800ef00:	9d0a      	ldr	r5, [sp, #40]	; 0x28
 800ef02:	9402      	str	r4, [sp, #8]
 800ef04:	9500      	str	r5, [sp, #0]
 800ef06:	f7ff ff2b 	bl	800ed60 <prvInitialiseNewTask.isra.0>
			prvAddNewTaskToReadyList( pxNewTCB );
 800ef0a:	0020      	movs	r0, r4
 800ef0c:	f7ff fe8a 	bl	800ec24 <prvAddNewTaskToReadyList>
	}
 800ef10:	9805      	ldr	r0, [sp, #20]
 800ef12:	b006      	add	sp, #24
 800ef14:	bd70      	pop	{r4, r5, r6, pc}

0800ef16 <xTaskCreate>:
	{
 800ef16:	b5f0      	push	{r4, r5, r6, r7, lr}
 800ef18:	0007      	movs	r7, r0
 800ef1a:	b087      	sub	sp, #28
			pxStack = ( StackType_t * ) pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 800ef1c:	0090      	lsls	r0, r2, #2
	{
 800ef1e:	0016      	movs	r6, r2
 800ef20:	9104      	str	r1, [sp, #16]
 800ef22:	9305      	str	r3, [sp, #20]
			pxStack = ( StackType_t * ) pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 800ef24:	f000 fa94 	bl	800f450 <pvPortMalloc>
 800ef28:	1e05      	subs	r5, r0, #0
			if( pxStack != NULL )
 800ef2a:	d01d      	beq.n	800ef68 <xTaskCreate+0x52>
				pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) ); /*lint !e961 MISRA exception as the casts are only redundant for some paths. */
 800ef2c:	2054      	movs	r0, #84	; 0x54
 800ef2e:	f000 fa8f 	bl	800f450 <pvPortMalloc>
 800ef32:	1e04      	subs	r4, r0, #0
				if( pxNewTCB != NULL )
 800ef34:	d015      	beq.n	800ef62 <xTaskCreate+0x4c>
				pxNewTCB->ucStaticallyAllocated = tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB;
 800ef36:	0003      	movs	r3, r0
 800ef38:	2200      	movs	r2, #0
 800ef3a:	3351      	adds	r3, #81	; 0x51
					pxNewTCB->pxStack = pxStack;
 800ef3c:	6305      	str	r5, [r0, #48]	; 0x30
				pxNewTCB->ucStaticallyAllocated = tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB;
 800ef3e:	701a      	strb	r2, [r3, #0]
			prvInitialiseNewTask( pxTaskCode, pcName, ( uint32_t ) usStackDepth, pvParameters, uxPriority, pxCreatedTask, pxNewTCB, NULL );
 800ef40:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 800ef42:	0032      	movs	r2, r6
 800ef44:	9301      	str	r3, [sp, #4]
 800ef46:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 800ef48:	9904      	ldr	r1, [sp, #16]
 800ef4a:	9002      	str	r0, [sp, #8]
 800ef4c:	9300      	str	r3, [sp, #0]
 800ef4e:	0038      	movs	r0, r7
 800ef50:	9b05      	ldr	r3, [sp, #20]
 800ef52:	f7ff ff05 	bl	800ed60 <prvInitialiseNewTask.isra.0>
			prvAddNewTaskToReadyList( pxNewTCB );
 800ef56:	0020      	movs	r0, r4
 800ef58:	f7ff fe64 	bl	800ec24 <prvAddNewTaskToReadyList>
			xReturn = pdPASS;
 800ef5c:	2001      	movs	r0, #1
	}
 800ef5e:	b007      	add	sp, #28
 800ef60:	bdf0      	pop	{r4, r5, r6, r7, pc}
					vPortFree( pxStack );
 800ef62:	0028      	movs	r0, r5
 800ef64:	f000 faf2 	bl	800f54c <vPortFree>
			xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
 800ef68:	2001      	movs	r0, #1
 800ef6a:	4240      	negs	r0, r0
		return xReturn;
 800ef6c:	e7f7      	b.n	800ef5e <xTaskCreate+0x48>
	...

0800ef70 <vTaskStartScheduler>:
{
 800ef70:	b510      	push	{r4, lr}
		StaticTask_t *pxIdleTaskTCBBuffer = NULL;
 800ef72:	2400      	movs	r4, #0
{
 800ef74:	b088      	sub	sp, #32
		vApplicationGetIdleTaskMemory( &pxIdleTaskTCBBuffer, &pxIdleTaskStackBuffer, &ulIdleTaskStackSize );
 800ef76:	aa07      	add	r2, sp, #28
 800ef78:	a906      	add	r1, sp, #24
 800ef7a:	a805      	add	r0, sp, #20
		StaticTask_t *pxIdleTaskTCBBuffer = NULL;
 800ef7c:	9405      	str	r4, [sp, #20]
		StackType_t *pxIdleTaskStackBuffer = NULL;
 800ef7e:	9406      	str	r4, [sp, #24]
		vApplicationGetIdleTaskMemory( &pxIdleTaskTCBBuffer, &pxIdleTaskStackBuffer, &ulIdleTaskStackSize );
 800ef80:	f7f9 fac0 	bl	8008504 <vApplicationGetIdleTaskMemory>
		xIdleTaskHandle = xTaskCreateStatic(	prvIdleTask,
 800ef84:	9b05      	ldr	r3, [sp, #20]
 800ef86:	9a07      	ldr	r2, [sp, #28]
 800ef88:	9302      	str	r3, [sp, #8]
 800ef8a:	9b06      	ldr	r3, [sp, #24]
 800ef8c:	490b      	ldr	r1, [pc, #44]	; (800efbc <vTaskStartScheduler+0x4c>)
 800ef8e:	9301      	str	r3, [sp, #4]
 800ef90:	480b      	ldr	r0, [pc, #44]	; (800efc0 <vTaskStartScheduler+0x50>)
 800ef92:	0023      	movs	r3, r4
 800ef94:	9400      	str	r4, [sp, #0]
 800ef96:	f7ff ff99 	bl	800eecc <xTaskCreateStatic>
		if( xIdleTaskHandle != NULL )
 800ef9a:	42a0      	cmp	r0, r4
 800ef9c:	d00b      	beq.n	800efb6 <vTaskStartScheduler+0x46>
		portDISABLE_INTERRUPTS();
 800ef9e:	b672      	cpsid	i
		xNextTaskUnblockTime = portMAX_DELAY;
 800efa0:	2201      	movs	r2, #1
 800efa2:	4b08      	ldr	r3, [pc, #32]	; (800efc4 <vTaskStartScheduler+0x54>)
 800efa4:	4252      	negs	r2, r2
 800efa6:	601a      	str	r2, [r3, #0]
		xSchedulerRunning = pdTRUE;
 800efa8:	4b07      	ldr	r3, [pc, #28]	; (800efc8 <vTaskStartScheduler+0x58>)
 800efaa:	3202      	adds	r2, #2
 800efac:	601a      	str	r2, [r3, #0]
		xTickCount = ( TickType_t ) 0U;
 800efae:	4b07      	ldr	r3, [pc, #28]	; (800efcc <vTaskStartScheduler+0x5c>)
 800efb0:	601c      	str	r4, [r3, #0]
		if( xPortStartScheduler() != pdFALSE )
 800efb2:	f000 f991 	bl	800f2d8 <xPortStartScheduler>
}
 800efb6:	b008      	add	sp, #32
 800efb8:	bd10      	pop	{r4, pc}
 800efba:	46c0      	nop			; (mov r8, r8)
 800efbc:	080109ef 	.word	0x080109ef
 800efc0:	0800ee09 	.word	0x0800ee09
 800efc4:	20000b90 	.word	0x20000b90
 800efc8:	20000bac 	.word	0x20000bac
 800efcc:	20000bd8 	.word	0x20000bd8

0800efd0 <vTaskSuspendAll>:
	++uxSchedulerSuspended;
 800efd0:	4a02      	ldr	r2, [pc, #8]	; (800efdc <vTaskSuspendAll+0xc>)
 800efd2:	6813      	ldr	r3, [r2, #0]
 800efd4:	3301      	adds	r3, #1
 800efd6:	6013      	str	r3, [r2, #0]
}
 800efd8:	4770      	bx	lr
 800efda:	46c0      	nop			; (mov r8, r8)
 800efdc:	20000b5c 	.word	0x20000b5c

0800efe0 <xTaskIncrementTick>:
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 800efe0:	4b34      	ldr	r3, [pc, #208]	; (800f0b4 <xTaskIncrementTick+0xd4>)
{
 800efe2:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 800efe4:	681b      	ldr	r3, [r3, #0]
 800efe6:	2b00      	cmp	r3, #0
 800efe8:	d15e      	bne.n	800f0a8 <xTaskIncrementTick+0xc8>
		const TickType_t xConstTickCount = xTickCount + ( TickType_t ) 1;
 800efea:	4b33      	ldr	r3, [pc, #204]	; (800f0b8 <xTaskIncrementTick+0xd8>)
 800efec:	681a      	ldr	r2, [r3, #0]
 800efee:	3201      	adds	r2, #1
 800eff0:	9200      	str	r2, [sp, #0]
		xTickCount = xConstTickCount;
 800eff2:	601a      	str	r2, [r3, #0]
		if( xConstTickCount == ( TickType_t ) 0U ) /*lint !e774 'if' does not always evaluate to false as it is looking for an overflow. */
 800eff4:	2a00      	cmp	r2, #0
 800eff6:	d111      	bne.n	800f01c <xTaskIncrementTick+0x3c>
			taskSWITCH_DELAYED_LISTS();
 800eff8:	4b30      	ldr	r3, [pc, #192]	; (800f0bc <xTaskIncrementTick+0xdc>)
 800effa:	681a      	ldr	r2, [r3, #0]
 800effc:	6812      	ldr	r2, [r2, #0]
 800effe:	2a00      	cmp	r2, #0
 800f000:	d001      	beq.n	800f006 <xTaskIncrementTick+0x26>
 800f002:	b672      	cpsid	i
 800f004:	e7fe      	b.n	800f004 <xTaskIncrementTick+0x24>
 800f006:	4a2e      	ldr	r2, [pc, #184]	; (800f0c0 <xTaskIncrementTick+0xe0>)
 800f008:	6819      	ldr	r1, [r3, #0]
 800f00a:	6810      	ldr	r0, [r2, #0]
 800f00c:	6018      	str	r0, [r3, #0]
 800f00e:	6011      	str	r1, [r2, #0]
 800f010:	4a2c      	ldr	r2, [pc, #176]	; (800f0c4 <xTaskIncrementTick+0xe4>)
 800f012:	6813      	ldr	r3, [r2, #0]
 800f014:	3301      	adds	r3, #1
 800f016:	6013      	str	r3, [r2, #0]
 800f018:	f7ff fe8e 	bl	800ed38 <prvResetNextTaskUnblockTime>
		if( xConstTickCount >= xNextTaskUnblockTime )
 800f01c:	4e2a      	ldr	r6, [pc, #168]	; (800f0c8 <xTaskIncrementTick+0xe8>)
 800f01e:	9a00      	ldr	r2, [sp, #0]
 800f020:	6833      	ldr	r3, [r6, #0]
BaseType_t xSwitchRequired = pdFALSE;
 800f022:	2400      	movs	r4, #0
 800f024:	4f29      	ldr	r7, [pc, #164]	; (800f0cc <xTaskIncrementTick+0xec>)
		if( xConstTickCount >= xNextTaskUnblockTime )
 800f026:	4293      	cmp	r3, r2
 800f028:	d935      	bls.n	800f096 <xTaskIncrementTick+0xb6>
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
 800f02a:	683b      	ldr	r3, [r7, #0]
 800f02c:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 800f02e:	2314      	movs	r3, #20
 800f030:	4353      	muls	r3, r2
 800f032:	4a27      	ldr	r2, [pc, #156]	; (800f0d0 <xTaskIncrementTick+0xf0>)
 800f034:	58d3      	ldr	r3, [r2, r3]
 800f036:	2b01      	cmp	r3, #1
 800f038:	d900      	bls.n	800f03c <xTaskIncrementTick+0x5c>
				xSwitchRequired = pdTRUE;
 800f03a:	2401      	movs	r4, #1
		if( xYieldPending != pdFALSE )
 800f03c:	4b25      	ldr	r3, [pc, #148]	; (800f0d4 <xTaskIncrementTick+0xf4>)
 800f03e:	681b      	ldr	r3, [r3, #0]
 800f040:	2b00      	cmp	r3, #0
 800f042:	d000      	beq.n	800f046 <xTaskIncrementTick+0x66>
			xSwitchRequired = pdTRUE;
 800f044:	2401      	movs	r4, #1
}
 800f046:	0020      	movs	r0, r4
 800f048:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
 800f04a:	681b      	ldr	r3, [r3, #0]
					if( xConstTickCount < xItemValue )
 800f04c:	9a00      	ldr	r2, [sp, #0]
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
 800f04e:	68db      	ldr	r3, [r3, #12]
 800f050:	68dd      	ldr	r5, [r3, #12]
					xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xStateListItem ) );
 800f052:	686b      	ldr	r3, [r5, #4]
					if( xConstTickCount < xItemValue )
 800f054:	429a      	cmp	r2, r3
 800f056:	d325      	bcc.n	800f0a4 <xTaskIncrementTick+0xc4>
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 800f058:	1d2b      	adds	r3, r5, #4
 800f05a:	0018      	movs	r0, r3
 800f05c:	9301      	str	r3, [sp, #4]
 800f05e:	f7ff fdd0 	bl	800ec02 <uxListRemove>
					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
 800f062:	6aab      	ldr	r3, [r5, #40]	; 0x28
 800f064:	2b00      	cmp	r3, #0
 800f066:	d003      	beq.n	800f070 <xTaskIncrementTick+0x90>
						( void ) uxListRemove( &( pxTCB->xEventListItem ) );
 800f068:	0028      	movs	r0, r5
 800f06a:	3018      	adds	r0, #24
 800f06c:	f7ff fdc9 	bl	800ec02 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
 800f070:	4b19      	ldr	r3, [pc, #100]	; (800f0d8 <xTaskIncrementTick+0xf8>)
 800f072:	6ae8      	ldr	r0, [r5, #44]	; 0x2c
 800f074:	681a      	ldr	r2, [r3, #0]
 800f076:	4290      	cmp	r0, r2
 800f078:	d900      	bls.n	800f07c <xTaskIncrementTick+0x9c>
 800f07a:	6018      	str	r0, [r3, #0]
 800f07c:	2314      	movs	r3, #20
 800f07e:	4358      	muls	r0, r3
 800f080:	4b13      	ldr	r3, [pc, #76]	; (800f0d0 <xTaskIncrementTick+0xf0>)
 800f082:	1d29      	adds	r1, r5, #4
 800f084:	1818      	adds	r0, r3, r0
 800f086:	f7ff fd99 	bl	800ebbc <vListInsertEnd>
						if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 800f08a:	683b      	ldr	r3, [r7, #0]
 800f08c:	6aea      	ldr	r2, [r5, #44]	; 0x2c
 800f08e:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800f090:	429a      	cmp	r2, r3
 800f092:	d300      	bcc.n	800f096 <xTaskIncrementTick+0xb6>
							xSwitchRequired = pdTRUE;
 800f094:	2401      	movs	r4, #1
				if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 800f096:	4b09      	ldr	r3, [pc, #36]	; (800f0bc <xTaskIncrementTick+0xdc>)
 800f098:	681a      	ldr	r2, [r3, #0]
 800f09a:	6812      	ldr	r2, [r2, #0]
 800f09c:	2a00      	cmp	r2, #0
 800f09e:	d1d4      	bne.n	800f04a <xTaskIncrementTick+0x6a>
					xNextTaskUnblockTime = portMAX_DELAY; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 800f0a0:	2301      	movs	r3, #1
 800f0a2:	425b      	negs	r3, r3
						xNextTaskUnblockTime = xItemValue;
 800f0a4:	6033      	str	r3, [r6, #0]
						break;
 800f0a6:	e7c0      	b.n	800f02a <xTaskIncrementTick+0x4a>
		++uxPendedTicks;
 800f0a8:	4a0c      	ldr	r2, [pc, #48]	; (800f0dc <xTaskIncrementTick+0xfc>)
BaseType_t xSwitchRequired = pdFALSE;
 800f0aa:	2400      	movs	r4, #0
		++uxPendedTicks;
 800f0ac:	6813      	ldr	r3, [r2, #0]
 800f0ae:	3301      	adds	r3, #1
 800f0b0:	6013      	str	r3, [r2, #0]
 800f0b2:	e7c3      	b.n	800f03c <xTaskIncrementTick+0x5c>
 800f0b4:	20000b5c 	.word	0x20000b5c
 800f0b8:	20000bd8 	.word	0x20000bd8
 800f0bc:	20000abc 	.word	0x20000abc
 800f0c0:	20000ac0 	.word	0x20000ac0
 800f0c4:	20000b94 	.word	0x20000b94
 800f0c8:	20000b90 	.word	0x20000b90
 800f0cc:	20000ab8 	.word	0x20000ab8
 800f0d0:	20000ac4 	.word	0x20000ac4
 800f0d4:	20000bdc 	.word	0x20000bdc
 800f0d8:	20000b64 	.word	0x20000b64
 800f0dc:	20000b58 	.word	0x20000b58

0800f0e0 <xTaskResumeAll>:
{
 800f0e0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	configASSERT( uxSchedulerSuspended );
 800f0e2:	4c2b      	ldr	r4, [pc, #172]	; (800f190 <xTaskResumeAll+0xb0>)
 800f0e4:	6823      	ldr	r3, [r4, #0]
 800f0e6:	2b00      	cmp	r3, #0
 800f0e8:	d101      	bne.n	800f0ee <xTaskResumeAll+0xe>
 800f0ea:	b672      	cpsid	i
 800f0ec:	e7fe      	b.n	800f0ec <xTaskResumeAll+0xc>
	taskENTER_CRITICAL();
 800f0ee:	f000 f931 	bl	800f354 <vPortEnterCritical>
		--uxSchedulerSuspended;
 800f0f2:	6823      	ldr	r3, [r4, #0]
 800f0f4:	3b01      	subs	r3, #1
 800f0f6:	6023      	str	r3, [r4, #0]
		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 800f0f8:	6824      	ldr	r4, [r4, #0]
 800f0fa:	2c00      	cmp	r4, #0
 800f0fc:	d004      	beq.n	800f108 <xTaskResumeAll+0x28>
BaseType_t xAlreadyYielded = pdFALSE;
 800f0fe:	2400      	movs	r4, #0
	taskEXIT_CRITICAL();
 800f100:	f000 f934 	bl	800f36c <vPortExitCritical>
}
 800f104:	0020      	movs	r0, r4
 800f106:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
 800f108:	4b22      	ldr	r3, [pc, #136]	; (800f194 <xTaskResumeAll+0xb4>)
 800f10a:	681b      	ldr	r3, [r3, #0]
 800f10c:	2b00      	cmp	r3, #0
 800f10e:	d0f6      	beq.n	800f0fe <xTaskResumeAll+0x1e>
					prvAddTaskToReadyList( pxTCB );
 800f110:	2614      	movs	r6, #20
						xYieldPending = pdTRUE;
 800f112:	2701      	movs	r7, #1
 800f114:	e01d      	b.n	800f152 <xTaskResumeAll+0x72>
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) );
 800f116:	68db      	ldr	r3, [r3, #12]
 800f118:	68dc      	ldr	r4, [r3, #12]
					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
 800f11a:	0020      	movs	r0, r4
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 800f11c:	1d25      	adds	r5, r4, #4
					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
 800f11e:	3018      	adds	r0, #24
 800f120:	f7ff fd6f 	bl	800ec02 <uxListRemove>
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 800f124:	0028      	movs	r0, r5
 800f126:	f7ff fd6c 	bl	800ec02 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
 800f12a:	4b1b      	ldr	r3, [pc, #108]	; (800f198 <xTaskResumeAll+0xb8>)
 800f12c:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
 800f12e:	681a      	ldr	r2, [r3, #0]
 800f130:	4290      	cmp	r0, r2
 800f132:	d900      	bls.n	800f136 <xTaskResumeAll+0x56>
 800f134:	6018      	str	r0, [r3, #0]
 800f136:	4370      	muls	r0, r6
 800f138:	4b18      	ldr	r3, [pc, #96]	; (800f19c <xTaskResumeAll+0xbc>)
 800f13a:	0029      	movs	r1, r5
 800f13c:	18c0      	adds	r0, r0, r3
 800f13e:	f7ff fd3d 	bl	800ebbc <vListInsertEnd>
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 800f142:	4b17      	ldr	r3, [pc, #92]	; (800f1a0 <xTaskResumeAll+0xc0>)
 800f144:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
 800f146:	681b      	ldr	r3, [r3, #0]
 800f148:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800f14a:	429a      	cmp	r2, r3
 800f14c:	d301      	bcc.n	800f152 <xTaskResumeAll+0x72>
						xYieldPending = pdTRUE;
 800f14e:	4b15      	ldr	r3, [pc, #84]	; (800f1a4 <xTaskResumeAll+0xc4>)
 800f150:	601f      	str	r7, [r3, #0]
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
 800f152:	4b15      	ldr	r3, [pc, #84]	; (800f1a8 <xTaskResumeAll+0xc8>)
 800f154:	681a      	ldr	r2, [r3, #0]
 800f156:	2a00      	cmp	r2, #0
 800f158:	d1dd      	bne.n	800f116 <xTaskResumeAll+0x36>
				if( pxTCB != NULL )
 800f15a:	2c00      	cmp	r4, #0
 800f15c:	d001      	beq.n	800f162 <xTaskResumeAll+0x82>
					prvResetNextTaskUnblockTime();
 800f15e:	f7ff fdeb 	bl	800ed38 <prvResetNextTaskUnblockTime>
					UBaseType_t uxPendedCounts = uxPendedTicks; /* Non-volatile copy. */
 800f162:	4d12      	ldr	r5, [pc, #72]	; (800f1ac <xTaskResumeAll+0xcc>)
 800f164:	682c      	ldr	r4, [r5, #0]
					if( uxPendedCounts > ( UBaseType_t ) 0U )
 800f166:	2c00      	cmp	r4, #0
 800f168:	d00a      	beq.n	800f180 <xTaskResumeAll+0xa0>
								xYieldPending = pdTRUE;
 800f16a:	2601      	movs	r6, #1
							if( xTaskIncrementTick() != pdFALSE )
 800f16c:	f7ff ff38 	bl	800efe0 <xTaskIncrementTick>
 800f170:	2800      	cmp	r0, #0
 800f172:	d001      	beq.n	800f178 <xTaskResumeAll+0x98>
								xYieldPending = pdTRUE;
 800f174:	4b0b      	ldr	r3, [pc, #44]	; (800f1a4 <xTaskResumeAll+0xc4>)
 800f176:	601e      	str	r6, [r3, #0]
							--uxPendedCounts;
 800f178:	3c01      	subs	r4, #1
						} while( uxPendedCounts > ( UBaseType_t ) 0U );
 800f17a:	2c00      	cmp	r4, #0
 800f17c:	d1f6      	bne.n	800f16c <xTaskResumeAll+0x8c>
						uxPendedTicks = 0;
 800f17e:	602c      	str	r4, [r5, #0]
				if( xYieldPending != pdFALSE )
 800f180:	4b08      	ldr	r3, [pc, #32]	; (800f1a4 <xTaskResumeAll+0xc4>)
 800f182:	681b      	ldr	r3, [r3, #0]
 800f184:	2b00      	cmp	r3, #0
 800f186:	d0ba      	beq.n	800f0fe <xTaskResumeAll+0x1e>
					taskYIELD_IF_USING_PREEMPTION();
 800f188:	f000 f8d8 	bl	800f33c <vPortYield>
						xAlreadyYielded = pdTRUE;
 800f18c:	2401      	movs	r4, #1
 800f18e:	e7b7      	b.n	800f100 <xTaskResumeAll+0x20>
 800f190:	20000b5c 	.word	0x20000b5c
 800f194:	20000b50 	.word	0x20000b50
 800f198:	20000b64 	.word	0x20000b64
 800f19c:	20000ac4 	.word	0x20000ac4
 800f1a0:	20000ab8 	.word	0x20000ab8
 800f1a4:	20000bdc 	.word	0x20000bdc
 800f1a8:	20000b98 	.word	0x20000b98
 800f1ac:	20000b58 	.word	0x20000b58

0800f1b0 <vTaskDelay>:
	{
 800f1b0:	b570      	push	{r4, r5, r6, lr}
 800f1b2:	1e04      	subs	r4, r0, #0
		if( xTicksToDelay > ( TickType_t ) 0U )
 800f1b4:	d102      	bne.n	800f1bc <vTaskDelay+0xc>
			portYIELD_WITHIN_API();
 800f1b6:	f000 f8c1 	bl	800f33c <vPortYield>
	}
 800f1ba:	bd70      	pop	{r4, r5, r6, pc}
			configASSERT( uxSchedulerSuspended == 0 );
 800f1bc:	4b08      	ldr	r3, [pc, #32]	; (800f1e0 <vTaskDelay+0x30>)
 800f1be:	681d      	ldr	r5, [r3, #0]
 800f1c0:	2d00      	cmp	r5, #0
 800f1c2:	d001      	beq.n	800f1c8 <vTaskDelay+0x18>
 800f1c4:	b672      	cpsid	i
 800f1c6:	e7fe      	b.n	800f1c6 <vTaskDelay+0x16>
			vTaskSuspendAll();
 800f1c8:	f7ff ff02 	bl	800efd0 <vTaskSuspendAll>
				prvAddCurrentTaskToDelayedList( xTicksToDelay, pdFALSE );
 800f1cc:	0029      	movs	r1, r5
 800f1ce:	0020      	movs	r0, r4
 800f1d0:	f7ff fe44 	bl	800ee5c <prvAddCurrentTaskToDelayedList>
			xAlreadyYielded = xTaskResumeAll();
 800f1d4:	f7ff ff84 	bl	800f0e0 <xTaskResumeAll>
		if( xAlreadyYielded == pdFALSE )
 800f1d8:	2800      	cmp	r0, #0
 800f1da:	d0ec      	beq.n	800f1b6 <vTaskDelay+0x6>
 800f1dc:	e7ed      	b.n	800f1ba <vTaskDelay+0xa>
 800f1de:	46c0      	nop			; (mov r8, r8)
 800f1e0:	20000b5c 	.word	0x20000b5c

0800f1e4 <vTaskSwitchContext>:
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
 800f1e4:	4b15      	ldr	r3, [pc, #84]	; (800f23c <vTaskSwitchContext+0x58>)
{
 800f1e6:	b530      	push	{r4, r5, lr}
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
 800f1e8:	681a      	ldr	r2, [r3, #0]
 800f1ea:	4b15      	ldr	r3, [pc, #84]	; (800f240 <vTaskSwitchContext+0x5c>)
 800f1ec:	2a00      	cmp	r2, #0
 800f1ee:	d002      	beq.n	800f1f6 <vTaskSwitchContext+0x12>
		xYieldPending = pdTRUE;
 800f1f0:	2201      	movs	r2, #1
 800f1f2:	601a      	str	r2, [r3, #0]
}
 800f1f4:	bd30      	pop	{r4, r5, pc}
		taskSELECT_HIGHEST_PRIORITY_TASK();
 800f1f6:	2514      	movs	r5, #20
 800f1f8:	4812      	ldr	r0, [pc, #72]	; (800f244 <vTaskSwitchContext+0x60>)
		xYieldPending = pdFALSE;
 800f1fa:	601a      	str	r2, [r3, #0]
		taskSELECT_HIGHEST_PRIORITY_TASK();
 800f1fc:	6802      	ldr	r2, [r0, #0]
 800f1fe:	4912      	ldr	r1, [pc, #72]	; (800f248 <vTaskSwitchContext+0x64>)
 800f200:	002b      	movs	r3, r5
 800f202:	4353      	muls	r3, r2
 800f204:	585c      	ldr	r4, [r3, r1]
 800f206:	2c00      	cmp	r4, #0
 800f208:	d012      	beq.n	800f230 <vTaskSwitchContext+0x4c>
 800f20a:	18cc      	adds	r4, r1, r3
 800f20c:	6865      	ldr	r5, [r4, #4]
 800f20e:	3308      	adds	r3, #8
 800f210:	686d      	ldr	r5, [r5, #4]
 800f212:	185b      	adds	r3, r3, r1
 800f214:	6065      	str	r5, [r4, #4]
 800f216:	429d      	cmp	r5, r3
 800f218:	d101      	bne.n	800f21e <vTaskSwitchContext+0x3a>
 800f21a:	686b      	ldr	r3, [r5, #4]
 800f21c:	6063      	str	r3, [r4, #4]
 800f21e:	2314      	movs	r3, #20
 800f220:	4353      	muls	r3, r2
 800f222:	18c9      	adds	r1, r1, r3
 800f224:	684b      	ldr	r3, [r1, #4]
 800f226:	68d9      	ldr	r1, [r3, #12]
 800f228:	4b08      	ldr	r3, [pc, #32]	; (800f24c <vTaskSwitchContext+0x68>)
 800f22a:	6019      	str	r1, [r3, #0]
 800f22c:	6002      	str	r2, [r0, #0]
}
 800f22e:	e7e1      	b.n	800f1f4 <vTaskSwitchContext+0x10>
		taskSELECT_HIGHEST_PRIORITY_TASK();
 800f230:	2a00      	cmp	r2, #0
 800f232:	d101      	bne.n	800f238 <vTaskSwitchContext+0x54>
 800f234:	b672      	cpsid	i
 800f236:	e7fe      	b.n	800f236 <vTaskSwitchContext+0x52>
 800f238:	3a01      	subs	r2, #1
 800f23a:	e7e1      	b.n	800f200 <vTaskSwitchContext+0x1c>
 800f23c:	20000b5c 	.word	0x20000b5c
 800f240:	20000bdc 	.word	0x20000bdc
 800f244:	20000b64 	.word	0x20000b64
 800f248:	20000ac4 	.word	0x20000ac4
 800f24c:	20000ab8 	.word	0x20000ab8

0800f250 <prvTaskExitError>:
}
/*-----------------------------------------------------------*/

static void prvTaskExitError( void )
{
volatile uint32_t ulDummy = 0UL;
 800f250:	2300      	movs	r3, #0
{
 800f252:	b082      	sub	sp, #8
volatile uint32_t ulDummy = 0UL;
 800f254:	9301      	str	r3, [sp, #4]
	its caller as there is nothing to return to.  If a task wants to exit it
	should instead call vTaskDelete( NULL ).

	Artificially force an assert() to be triggered if configASSERT() is
	defined, then stop here so application writers can catch the error. */
	configASSERT( uxCriticalNesting == ~0UL );
 800f256:	4b06      	ldr	r3, [pc, #24]	; (800f270 <prvTaskExitError+0x20>)
 800f258:	681b      	ldr	r3, [r3, #0]
 800f25a:	3301      	adds	r3, #1
 800f25c:	d001      	beq.n	800f262 <prvTaskExitError+0x12>
 800f25e:	b672      	cpsid	i
 800f260:	e7fe      	b.n	800f260 <prvTaskExitError+0x10>
	portDISABLE_INTERRUPTS();
 800f262:	b672      	cpsid	i
	while( ulDummy == 0 )
 800f264:	9b01      	ldr	r3, [sp, #4]
 800f266:	2b00      	cmp	r3, #0
 800f268:	d0fc      	beq.n	800f264 <prvTaskExitError+0x14>
		about code appearing after this function is called - making ulDummy
		volatile makes the compiler think the function could return and
		therefore not output an 'unreachable code' warning for code that appears
		after it. */
	}
}
 800f26a:	b002      	add	sp, #8
 800f26c:	4770      	bx	lr
 800f26e:	46c0      	nop			; (mov r8, r8)
 800f270:	20000574 	.word	0x20000574
	...

0800f280 <vPortStartFirstTask>:
void vPortStartFirstTask( void )
{
	/* The MSP stack is not reset as, unlike on M3/4 parts, there is no vector
	table offset register that can be used to locate the initial stack value.
	Not all M0 parts have the application vector table at address 0. */
	__asm volatile(
 800f280:	4a0b      	ldr	r2, [pc, #44]	; (800f2b0 <pxCurrentTCBConst2>)
 800f282:	6813      	ldr	r3, [r2, #0]
 800f284:	6818      	ldr	r0, [r3, #0]
 800f286:	3020      	adds	r0, #32
 800f288:	f380 8809 	msr	PSP, r0
 800f28c:	2002      	movs	r0, #2
 800f28e:	f380 8814 	msr	CONTROL, r0
 800f292:	f3bf 8f6f 	isb	sy
 800f296:	bc3f      	pop	{r0, r1, r2, r3, r4, r5}
 800f298:	46ae      	mov	lr, r5
 800f29a:	bc08      	pop	{r3}
 800f29c:	bc04      	pop	{r2}
 800f29e:	b662      	cpsie	i
 800f2a0:	4718      	bx	r3
 800f2a2:	46c0      	nop			; (mov r8, r8)
 800f2a4:	46c0      	nop			; (mov r8, r8)
 800f2a6:	46c0      	nop			; (mov r8, r8)
 800f2a8:	46c0      	nop			; (mov r8, r8)
 800f2aa:	46c0      	nop			; (mov r8, r8)
 800f2ac:	46c0      	nop			; (mov r8, r8)
 800f2ae:	46c0      	nop			; (mov r8, r8)

0800f2b0 <pxCurrentTCBConst2>:
 800f2b0:	20000ab8 	.word	0x20000ab8

0800f2b4 <pxPortInitialiseStack>:
{
 800f2b4:	b510      	push	{r4, lr}
	*pxTopOfStack = portINITIAL_XPSR;	/* xPSR */
 800f2b6:	2480      	movs	r4, #128	; 0x80
 800f2b8:	1f03      	subs	r3, r0, #4
 800f2ba:	0464      	lsls	r4, r4, #17
 800f2bc:	601c      	str	r4, [r3, #0]
	*pxTopOfStack = ( StackType_t ) pxCode;	/* PC */
 800f2be:	3b04      	subs	r3, #4
 800f2c0:	6019      	str	r1, [r3, #0]
	*pxTopOfStack = ( StackType_t ) portTASK_RETURN_ADDRESS;	/* LR */
 800f2c2:	4903      	ldr	r1, [pc, #12]	; (800f2d0 <pxPortInitialiseStack+0x1c>)
 800f2c4:	3b04      	subs	r3, #4
 800f2c6:	6019      	str	r1, [r3, #0]
	*pxTopOfStack = ( StackType_t ) pvParameters;	/* R0 */
 800f2c8:	3b14      	subs	r3, #20
	pxTopOfStack -= 8; /* R11..R4. */
 800f2ca:	3840      	subs	r0, #64	; 0x40
	*pxTopOfStack = ( StackType_t ) pvParameters;	/* R0 */
 800f2cc:	601a      	str	r2, [r3, #0]
}
 800f2ce:	bd10      	pop	{r4, pc}
 800f2d0:	0800f251 	.word	0x0800f251

0800f2d4 <SVC_Handler>:
}
 800f2d4:	4770      	bx	lr
	...

0800f2d8 <xPortStartScheduler>:
 * See header file for description.
 */
BaseType_t xPortStartScheduler( void )
{
	/* Make PendSV, CallSV and SysTick the same priroity as the kernel. */
	*(portNVIC_SYSPRI2) |= portNVIC_PENDSV_PRI;
 800f2d8:	22ff      	movs	r2, #255	; 0xff
 800f2da:	4b12      	ldr	r3, [pc, #72]	; (800f324 <xPortStartScheduler+0x4c>)
 800f2dc:	0412      	lsls	r2, r2, #16
 800f2de:	6819      	ldr	r1, [r3, #0]
{
 800f2e0:	b570      	push	{r4, r5, r6, lr}
	*(portNVIC_SYSPRI2) |= portNVIC_PENDSV_PRI;
 800f2e2:	430a      	orrs	r2, r1
 800f2e4:	601a      	str	r2, [r3, #0]
	*(portNVIC_SYSPRI2) |= portNVIC_SYSTICK_PRI;
 800f2e6:	22ff      	movs	r2, #255	; 0xff
 800f2e8:	6819      	ldr	r1, [r3, #0]
   ulStoppedTimerCompensation = portMISSED_COUNTS_FACTOR / ( configCPU_CLOCK_HZ / configSYSTICK_CLOCK_HZ );
 }
 #endif /* configUSE_TICKLESS_IDLE */

/* Stop and reset the SysTick. */
	portNVIC_SYSTICK_CTRL = 0UL;
 800f2ea:	2400      	movs	r4, #0
	*(portNVIC_SYSPRI2) |= portNVIC_SYSTICK_PRI;
 800f2ec:	0612      	lsls	r2, r2, #24
 800f2ee:	430a      	orrs	r2, r1
	portNVIC_SYSTICK_CURRENT_VALUE = 0UL;

 /* Configure SysTick to interrupt at the requested rate. */
 portNVIC_SYSTICK_LOAD = ( configCPU_CLOCK_HZ / configTICK_RATE_HZ ) - 1UL;
 800f2f0:	21fa      	movs	r1, #250	; 0xfa
	*(portNVIC_SYSPRI2) |= portNVIC_SYSTICK_PRI;
 800f2f2:	601a      	str	r2, [r3, #0]
	portNVIC_SYSTICK_CTRL = 0UL;
 800f2f4:	4d0c      	ldr	r5, [pc, #48]	; (800f328 <xPortStartScheduler+0x50>)
	portNVIC_SYSTICK_CURRENT_VALUE = 0UL;
 800f2f6:	4b0d      	ldr	r3, [pc, #52]	; (800f32c <xPortStartScheduler+0x54>)
	portNVIC_SYSTICK_CTRL = 0UL;
 800f2f8:	602c      	str	r4, [r5, #0]
	portNVIC_SYSTICK_CURRENT_VALUE = 0UL;
 800f2fa:	601c      	str	r4, [r3, #0]
 portNVIC_SYSTICK_LOAD = ( configCPU_CLOCK_HZ / configTICK_RATE_HZ ) - 1UL;
 800f2fc:	4b0c      	ldr	r3, [pc, #48]	; (800f330 <xPortStartScheduler+0x58>)
 800f2fe:	0089      	lsls	r1, r1, #2
 800f300:	6818      	ldr	r0, [r3, #0]
 800f302:	f7f8 ff31 	bl	8008168 <__udivsi3>
 800f306:	4b0b      	ldr	r3, [pc, #44]	; (800f334 <xPortStartScheduler+0x5c>)
 800f308:	3801      	subs	r0, #1
 800f30a:	6018      	str	r0, [r3, #0]
 portNVIC_SYSTICK_CTRL = portNVIC_SYSTICK_CLK | portNVIC_SYSTICK_INT | portNVIC_SYSTICK_ENABLE;
 800f30c:	2307      	movs	r3, #7
 800f30e:	602b      	str	r3, [r5, #0]
	uxCriticalNesting = 0;
 800f310:	4b09      	ldr	r3, [pc, #36]	; (800f338 <xPortStartScheduler+0x60>)
 800f312:	601c      	str	r4, [r3, #0]
	vPortStartFirstTask();
 800f314:	f7ff ffb4 	bl	800f280 <vPortStartFirstTask>
	vTaskSwitchContext();
 800f318:	f7ff ff64 	bl	800f1e4 <vTaskSwitchContext>
	prvTaskExitError();
 800f31c:	f7ff ff98 	bl	800f250 <prvTaskExitError>
}
 800f320:	0020      	movs	r0, r4
 800f322:	bd70      	pop	{r4, r5, r6, pc}
 800f324:	e000ed20 	.word	0xe000ed20
 800f328:	e000e010 	.word	0xe000e010
 800f32c:	e000e018 	.word	0xe000e018
 800f330:	2000045c 	.word	0x2000045c
 800f334:	e000e014 	.word	0xe000e014
 800f338:	20000574 	.word	0x20000574

0800f33c <vPortYield>:
	*( portNVIC_INT_CTRL ) = portNVIC_PENDSVSET;
 800f33c:	2280      	movs	r2, #128	; 0x80
 800f33e:	4b04      	ldr	r3, [pc, #16]	; (800f350 <vPortYield+0x14>)
 800f340:	0552      	lsls	r2, r2, #21
 800f342:	601a      	str	r2, [r3, #0]
	__asm volatile( "dsb" ::: "memory" );
 800f344:	f3bf 8f4f 	dsb	sy
	__asm volatile( "isb" );
 800f348:	f3bf 8f6f 	isb	sy
}
 800f34c:	4770      	bx	lr
 800f34e:	46c0      	nop			; (mov r8, r8)
 800f350:	e000ed04 	.word	0xe000ed04

0800f354 <vPortEnterCritical>:
    portDISABLE_INTERRUPTS();
 800f354:	b672      	cpsid	i
    uxCriticalNesting++;
 800f356:	4a04      	ldr	r2, [pc, #16]	; (800f368 <vPortEnterCritical+0x14>)
 800f358:	6813      	ldr	r3, [r2, #0]
 800f35a:	3301      	adds	r3, #1
 800f35c:	6013      	str	r3, [r2, #0]
	__asm volatile( "dsb" ::: "memory" );
 800f35e:	f3bf 8f4f 	dsb	sy
	__asm volatile( "isb" );
 800f362:	f3bf 8f6f 	isb	sy
}
 800f366:	4770      	bx	lr
 800f368:	20000574 	.word	0x20000574

0800f36c <vPortExitCritical>:
	configASSERT( uxCriticalNesting );
 800f36c:	4a05      	ldr	r2, [pc, #20]	; (800f384 <vPortExitCritical+0x18>)
 800f36e:	6813      	ldr	r3, [r2, #0]
 800f370:	2b00      	cmp	r3, #0
 800f372:	d101      	bne.n	800f378 <vPortExitCritical+0xc>
 800f374:	b672      	cpsid	i
 800f376:	e7fe      	b.n	800f376 <vPortExitCritical+0xa>
    uxCriticalNesting--;
 800f378:	3b01      	subs	r3, #1
 800f37a:	6013      	str	r3, [r2, #0]
    if( uxCriticalNesting == 0 )
 800f37c:	2b00      	cmp	r3, #0
 800f37e:	d100      	bne.n	800f382 <vPortExitCritical+0x16>
        portENABLE_INTERRUPTS();
 800f380:	b662      	cpsie	i
}
 800f382:	4770      	bx	lr
 800f384:	20000574 	.word	0x20000574

0800f388 <ulSetInterruptMaskFromISR>:
	__asm volatile(
 800f388:	f3ef 8010 	mrs	r0, PRIMASK
 800f38c:	b672      	cpsid	i
 800f38e:	4770      	bx	lr

0800f390 <vClearInterruptMaskFromISR>:
	__asm volatile(
 800f390:	f380 8810 	msr	PRIMASK, r0
 800f394:	4770      	bx	lr
	...

0800f3a0 <PendSV_Handler>:
	__asm volatile
 800f3a0:	f3ef 8009 	mrs	r0, PSP
 800f3a4:	4b0e      	ldr	r3, [pc, #56]	; (800f3e0 <pxCurrentTCBConst>)
 800f3a6:	681a      	ldr	r2, [r3, #0]
 800f3a8:	3820      	subs	r0, #32
 800f3aa:	6010      	str	r0, [r2, #0]
 800f3ac:	c0f0      	stmia	r0!, {r4, r5, r6, r7}
 800f3ae:	4644      	mov	r4, r8
 800f3b0:	464d      	mov	r5, r9
 800f3b2:	4656      	mov	r6, sl
 800f3b4:	465f      	mov	r7, fp
 800f3b6:	c0f0      	stmia	r0!, {r4, r5, r6, r7}
 800f3b8:	b508      	push	{r3, lr}
 800f3ba:	b672      	cpsid	i
 800f3bc:	f7ff ff12 	bl	800f1e4 <vTaskSwitchContext>
 800f3c0:	b662      	cpsie	i
 800f3c2:	bc0c      	pop	{r2, r3}
 800f3c4:	6811      	ldr	r1, [r2, #0]
 800f3c6:	6808      	ldr	r0, [r1, #0]
 800f3c8:	3010      	adds	r0, #16
 800f3ca:	c8f0      	ldmia	r0!, {r4, r5, r6, r7}
 800f3cc:	46a0      	mov	r8, r4
 800f3ce:	46a9      	mov	r9, r5
 800f3d0:	46b2      	mov	sl, r6
 800f3d2:	46bb      	mov	fp, r7
 800f3d4:	f380 8809 	msr	PSP, r0
 800f3d8:	3820      	subs	r0, #32
 800f3da:	c8f0      	ldmia	r0!, {r4, r5, r6, r7}
 800f3dc:	4718      	bx	r3
 800f3de:	46c0      	nop			; (mov r8, r8)

0800f3e0 <pxCurrentTCBConst>:
 800f3e0:	20000ab8 	.word	0x20000ab8

0800f3e4 <SysTick_Handler>:
{
 800f3e4:	b510      	push	{r4, lr}
	ulPreviousMask = portSET_INTERRUPT_MASK_FROM_ISR();
 800f3e6:	f7ff ffcf 	bl	800f388 <ulSetInterruptMaskFromISR>
 800f3ea:	0004      	movs	r4, r0
		if( xTaskIncrementTick() != pdFALSE )
 800f3ec:	f7ff fdf8 	bl	800efe0 <xTaskIncrementTick>
 800f3f0:	2800      	cmp	r0, #0
 800f3f2:	d003      	beq.n	800f3fc <SysTick_Handler+0x18>
			*(portNVIC_INT_CTRL) = portNVIC_PENDSVSET;
 800f3f4:	2280      	movs	r2, #128	; 0x80
 800f3f6:	4b03      	ldr	r3, [pc, #12]	; (800f404 <SysTick_Handler+0x20>)
 800f3f8:	0552      	lsls	r2, r2, #21
 800f3fa:	601a      	str	r2, [r3, #0]
	portCLEAR_INTERRUPT_MASK_FROM_ISR( ulPreviousMask );
 800f3fc:	0020      	movs	r0, r4
 800f3fe:	f7ff ffc7 	bl	800f390 <vClearInterruptMaskFromISR>
}
 800f402:	bd10      	pop	{r4, pc}
 800f404:	e000ed04 	.word	0xe000ed04

0800f408 <prvInsertBlockIntoFreeList>:
	xBlockAllocatedBit = ( ( size_t ) 1 ) << ( ( sizeof( size_t ) * heapBITS_PER_BYTE ) - 1 );
}
/*-----------------------------------------------------------*/

static void prvInsertBlockIntoFreeList( BlockLink_t *pxBlockToInsert )
{
 800f408:	b510      	push	{r4, lr}
BlockLink_t *pxIterator;
uint8_t *puc;

	/* Iterate through the list until a block is found that has a higher address
	than the block being inserted. */
	for( pxIterator = &xStart; pxIterator->pxNextFreeBlock < pxBlockToInsert; pxIterator = pxIterator->pxNextFreeBlock )
 800f40a:	4b0f      	ldr	r3, [pc, #60]	; (800f448 <prvInsertBlockIntoFreeList+0x40>)
 800f40c:	001a      	movs	r2, r3
 800f40e:	681b      	ldr	r3, [r3, #0]
 800f410:	4283      	cmp	r3, r0
 800f412:	d3fb      	bcc.n	800f40c <prvInsertBlockIntoFreeList+0x4>
	}

	/* Do the block being inserted, and the block it is being inserted after
	make a contiguous block of memory? */
	puc = ( uint8_t * ) pxIterator;
	if( ( puc + pxIterator->xBlockSize ) == ( uint8_t * ) pxBlockToInsert )
 800f414:	6854      	ldr	r4, [r2, #4]
 800f416:	1911      	adds	r1, r2, r4
 800f418:	4288      	cmp	r0, r1
 800f41a:	d103      	bne.n	800f424 <prvInsertBlockIntoFreeList+0x1c>
	{
		pxIterator->xBlockSize += pxBlockToInsert->xBlockSize;
 800f41c:	6841      	ldr	r1, [r0, #4]
 800f41e:	0010      	movs	r0, r2
 800f420:	1909      	adds	r1, r1, r4
 800f422:	6051      	str	r1, [r2, #4]
	}

	/* Do the block being inserted, and the block it is being inserted before
	make a contiguous block of memory? */
	puc = ( uint8_t * ) pxBlockToInsert;
	if( ( puc + pxBlockToInsert->xBlockSize ) == ( uint8_t * ) pxIterator->pxNextFreeBlock )
 800f424:	6841      	ldr	r1, [r0, #4]
 800f426:	1844      	adds	r4, r0, r1
 800f428:	42a3      	cmp	r3, r4
 800f42a:	d107      	bne.n	800f43c <prvInsertBlockIntoFreeList+0x34>
	{
		if( pxIterator->pxNextFreeBlock != pxEnd )
 800f42c:	4c07      	ldr	r4, [pc, #28]	; (800f44c <prvInsertBlockIntoFreeList+0x44>)
 800f42e:	6824      	ldr	r4, [r4, #0]
 800f430:	42a3      	cmp	r3, r4
 800f432:	d003      	beq.n	800f43c <prvInsertBlockIntoFreeList+0x34>
		{
			/* Form one big block from the two blocks. */
			pxBlockToInsert->xBlockSize += pxIterator->pxNextFreeBlock->xBlockSize;
 800f434:	685c      	ldr	r4, [r3, #4]
			pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock->pxNextFreeBlock;
 800f436:	681b      	ldr	r3, [r3, #0]
			pxBlockToInsert->xBlockSize += pxIterator->pxNextFreeBlock->xBlockSize;
 800f438:	1861      	adds	r1, r4, r1
 800f43a:	6041      	str	r1, [r0, #4]
			pxBlockToInsert->pxNextFreeBlock = pxEnd;
		}
	}
	else
	{
		pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock;
 800f43c:	6003      	str	r3, [r0, #0]

	/* If the block being inserted plugged a gab, so was merged with the block
	before and the block after, then it's pxNextFreeBlock pointer will have
	already been set, and should not be set here as that would make it point
	to itself. */
	if( pxIterator != pxBlockToInsert )
 800f43e:	4290      	cmp	r0, r2
 800f440:	d000      	beq.n	800f444 <prvInsertBlockIntoFreeList+0x3c>
	{
		pxIterator->pxNextFreeBlock = pxBlockToInsert;
 800f442:	6010      	str	r0, [r2, #0]
	}
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}
}
 800f444:	bd10      	pop	{r4, pc}
 800f446:	46c0      	nop			; (mov r8, r8)
 800f448:	200017f0 	.word	0x200017f0
 800f44c:	20000be0 	.word	0x20000be0

0800f450 <pvPortMalloc>:
{
 800f450:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800f452:	0004      	movs	r4, r0
	vTaskSuspendAll();
 800f454:	f7ff fdbc 	bl	800efd0 <vTaskSuspendAll>
		if( pxEnd == NULL )
 800f458:	4a35      	ldr	r2, [pc, #212]	; (800f530 <pvPortMalloc+0xe0>)
 800f45a:	4d36      	ldr	r5, [pc, #216]	; (800f534 <pvPortMalloc+0xe4>)
 800f45c:	6813      	ldr	r3, [r2, #0]
 800f45e:	2b00      	cmp	r3, #0
 800f460:	d11b      	bne.n	800f49a <pvPortMalloc+0x4a>
	if( ( uxAddress & portBYTE_ALIGNMENT_MASK ) != 0 )
 800f462:	2007      	movs	r0, #7
	uxAddress = ( size_t ) ucHeap;
 800f464:	4b34      	ldr	r3, [pc, #208]	; (800f538 <pvPortMalloc+0xe8>)
	if( ( uxAddress & portBYTE_ALIGNMENT_MASK ) != 0 )
 800f466:	0019      	movs	r1, r3
 800f468:	4203      	tst	r3, r0
 800f46a:	d001      	beq.n	800f470 <pvPortMalloc+0x20>
		uxAddress += ( portBYTE_ALIGNMENT - 1 );
 800f46c:	1819      	adds	r1, r3, r0
		uxAddress &= ~( ( size_t ) portBYTE_ALIGNMENT_MASK );
 800f46e:	4381      	bics	r1, r0
	xStart.xBlockSize = ( size_t ) 0;
 800f470:	2000      	movs	r0, #0
	xStart.pxNextFreeBlock = ( void * ) pucAlignedHeap;
 800f472:	4e32      	ldr	r6, [pc, #200]	; (800f53c <pvPortMalloc+0xec>)
	xStart.xBlockSize = ( size_t ) 0;
 800f474:	6070      	str	r0, [r6, #4]
	xStart.pxNextFreeBlock = ( void * ) pucAlignedHeap;
 800f476:	6031      	str	r1, [r6, #0]
	uxAddress -= xHeapStructSize;
 800f478:	4e31      	ldr	r6, [pc, #196]	; (800f540 <pvPortMalloc+0xf0>)
 800f47a:	199b      	adds	r3, r3, r6
	uxAddress &= ~( ( size_t ) portBYTE_ALIGNMENT_MASK );
 800f47c:	2607      	movs	r6, #7
 800f47e:	43b3      	bics	r3, r6
	pxEnd->pxNextFreeBlock = NULL;
 800f480:	6018      	str	r0, [r3, #0]
	pxEnd->xBlockSize = 0;
 800f482:	6058      	str	r0, [r3, #4]
	pxEnd = ( void * ) uxAddress;
 800f484:	6013      	str	r3, [r2, #0]
	pxFirstFreeBlock->xBlockSize = uxAddress - ( size_t ) pxFirstFreeBlock;
 800f486:	1a58      	subs	r0, r3, r1
	pxFirstFreeBlock->pxNextFreeBlock = pxEnd;
 800f488:	600b      	str	r3, [r1, #0]
	xMinimumEverFreeBytesRemaining = pxFirstFreeBlock->xBlockSize;
 800f48a:	4b2e      	ldr	r3, [pc, #184]	; (800f544 <pvPortMalloc+0xf4>)
	pxFirstFreeBlock->xBlockSize = uxAddress - ( size_t ) pxFirstFreeBlock;
 800f48c:	6048      	str	r0, [r1, #4]
	xMinimumEverFreeBytesRemaining = pxFirstFreeBlock->xBlockSize;
 800f48e:	6018      	str	r0, [r3, #0]
	xFreeBytesRemaining = pxFirstFreeBlock->xBlockSize;
 800f490:	4b2d      	ldr	r3, [pc, #180]	; (800f548 <pvPortMalloc+0xf8>)
 800f492:	6018      	str	r0, [r3, #0]
	xBlockAllocatedBit = ( ( size_t ) 1 ) << ( ( sizeof( size_t ) * heapBITS_PER_BYTE ) - 1 );
 800f494:	2380      	movs	r3, #128	; 0x80
 800f496:	061b      	lsls	r3, r3, #24
 800f498:	602b      	str	r3, [r5, #0]
		if( ( xWantedSize & xBlockAllocatedBit ) == 0 )
 800f49a:	682e      	ldr	r6, [r5, #0]
 800f49c:	4234      	tst	r4, r6
 800f49e:	d142      	bne.n	800f526 <pvPortMalloc+0xd6>
			if( xWantedSize > 0 )
 800f4a0:	2c00      	cmp	r4, #0
 800f4a2:	d040      	beq.n	800f526 <pvPortMalloc+0xd6>
				xWantedSize += xHeapStructSize;
 800f4a4:	0023      	movs	r3, r4
				if( ( xWantedSize & portBYTE_ALIGNMENT_MASK ) != 0x00 )
 800f4a6:	2107      	movs	r1, #7
				xWantedSize += xHeapStructSize;
 800f4a8:	3308      	adds	r3, #8
				if( ( xWantedSize & portBYTE_ALIGNMENT_MASK ) != 0x00 )
 800f4aa:	420b      	tst	r3, r1
 800f4ac:	d001      	beq.n	800f4b2 <pvPortMalloc+0x62>
					xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
 800f4ae:	438b      	bics	r3, r1
 800f4b0:	3308      	adds	r3, #8
			if( ( xWantedSize > 0 ) && ( xWantedSize <= xFreeBytesRemaining ) )
 800f4b2:	2b00      	cmp	r3, #0
 800f4b4:	d037      	beq.n	800f526 <pvPortMalloc+0xd6>
 800f4b6:	4924      	ldr	r1, [pc, #144]	; (800f548 <pvPortMalloc+0xf8>)
 800f4b8:	680d      	ldr	r5, [r1, #0]
 800f4ba:	429d      	cmp	r5, r3
 800f4bc:	d333      	bcc.n	800f526 <pvPortMalloc+0xd6>
				pxBlock = xStart.pxNextFreeBlock;
 800f4be:	491f      	ldr	r1, [pc, #124]	; (800f53c <pvPortMalloc+0xec>)
 800f4c0:	680c      	ldr	r4, [r1, #0]
				while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
 800f4c2:	6860      	ldr	r0, [r4, #4]
 800f4c4:	4298      	cmp	r0, r3
 800f4c6:	d203      	bcs.n	800f4d0 <pvPortMalloc+0x80>
 800f4c8:	6827      	ldr	r7, [r4, #0]
 800f4ca:	46bc      	mov	ip, r7
 800f4cc:	2f00      	cmp	r7, #0
 800f4ce:	d10e      	bne.n	800f4ee <pvPortMalloc+0x9e>
				if( pxBlock != pxEnd )
 800f4d0:	6812      	ldr	r2, [r2, #0]
 800f4d2:	42a2      	cmp	r2, r4
 800f4d4:	d027      	beq.n	800f526 <pvPortMalloc+0xd6>
					pvReturn = ( void * ) ( ( ( uint8_t * ) pxPreviousBlock->pxNextFreeBlock ) + xHeapStructSize );
 800f4d6:	680a      	ldr	r2, [r1, #0]
 800f4d8:	0017      	movs	r7, r2
					pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;
 800f4da:	6822      	ldr	r2, [r4, #0]
 800f4dc:	600a      	str	r2, [r1, #0]
					if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )
 800f4de:	1ac2      	subs	r2, r0, r3
 800f4e0:	2a10      	cmp	r2, #16
 800f4e2:	d90b      	bls.n	800f4fc <pvPortMalloc+0xac>
						pxNewBlockLink = ( void * ) ( ( ( uint8_t * ) pxBlock ) + xWantedSize );
 800f4e4:	18e0      	adds	r0, r4, r3
						configASSERT( ( ( ( size_t ) pxNewBlockLink ) & portBYTE_ALIGNMENT_MASK ) == 0 );
 800f4e6:	0741      	lsls	r1, r0, #29
 800f4e8:	d004      	beq.n	800f4f4 <pvPortMalloc+0xa4>
 800f4ea:	b672      	cpsid	i
 800f4ec:	e7fe      	b.n	800f4ec <pvPortMalloc+0x9c>
 800f4ee:	0021      	movs	r1, r4
 800f4f0:	4664      	mov	r4, ip
 800f4f2:	e7e6      	b.n	800f4c2 <pvPortMalloc+0x72>
						pxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xWantedSize;
 800f4f4:	6042      	str	r2, [r0, #4]
						pxBlock->xBlockSize = xWantedSize;
 800f4f6:	6063      	str	r3, [r4, #4]
						prvInsertBlockIntoFreeList( pxNewBlockLink );
 800f4f8:	f7ff ff86 	bl	800f408 <prvInsertBlockIntoFreeList>
					xFreeBytesRemaining -= pxBlock->xBlockSize;
 800f4fc:	6863      	ldr	r3, [r4, #4]
 800f4fe:	4a12      	ldr	r2, [pc, #72]	; (800f548 <pvPortMalloc+0xf8>)
 800f500:	1aed      	subs	r5, r5, r3
 800f502:	6015      	str	r5, [r2, #0]
					if( xFreeBytesRemaining < xMinimumEverFreeBytesRemaining )
 800f504:	4a0f      	ldr	r2, [pc, #60]	; (800f544 <pvPortMalloc+0xf4>)
 800f506:	6811      	ldr	r1, [r2, #0]
 800f508:	428d      	cmp	r5, r1
 800f50a:	d200      	bcs.n	800f50e <pvPortMalloc+0xbe>
						xMinimumEverFreeBytesRemaining = xFreeBytesRemaining;
 800f50c:	6015      	str	r5, [r2, #0]
					pxBlock->xBlockSize |= xBlockAllocatedBit;
 800f50e:	431e      	orrs	r6, r3
					pvReturn = ( void * ) ( ( ( uint8_t * ) pxPreviousBlock->pxNextFreeBlock ) + xHeapStructSize );
 800f510:	003d      	movs	r5, r7
					pxBlock->pxNextFreeBlock = NULL;
 800f512:	2300      	movs	r3, #0
					pvReturn = ( void * ) ( ( ( uint8_t * ) pxPreviousBlock->pxNextFreeBlock ) + xHeapStructSize );
 800f514:	3508      	adds	r5, #8
					pxBlock->xBlockSize |= xBlockAllocatedBit;
 800f516:	6066      	str	r6, [r4, #4]
					pxBlock->pxNextFreeBlock = NULL;
 800f518:	6023      	str	r3, [r4, #0]
	( void ) xTaskResumeAll();
 800f51a:	f7ff fde1 	bl	800f0e0 <xTaskResumeAll>
	configASSERT( ( ( ( size_t ) pvReturn ) & ( size_t ) portBYTE_ALIGNMENT_MASK ) == 0 );
 800f51e:	076b      	lsls	r3, r5, #29
 800f520:	d003      	beq.n	800f52a <pvPortMalloc+0xda>
 800f522:	b672      	cpsid	i
 800f524:	e7fe      	b.n	800f524 <pvPortMalloc+0xd4>
void *pvReturn = NULL;
 800f526:	2500      	movs	r5, #0
 800f528:	e7f7      	b.n	800f51a <pvPortMalloc+0xca>
}
 800f52a:	0028      	movs	r0, r5
 800f52c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 800f52e:	46c0      	nop			; (mov r8, r8)
 800f530:	20000be0 	.word	0x20000be0
 800f534:	200017e4 	.word	0x200017e4
 800f538:	20000be4 	.word	0x20000be4
 800f53c:	200017f0 	.word	0x200017f0
 800f540:	00000bf8 	.word	0x00000bf8
 800f544:	200017ec 	.word	0x200017ec
 800f548:	200017e8 	.word	0x200017e8

0800f54c <vPortFree>:
{
 800f54c:	b510      	push	{r4, lr}
	if( pv != NULL )
 800f54e:	2800      	cmp	r0, #0
 800f550:	d01b      	beq.n	800f58a <vPortFree+0x3e>
		configASSERT( ( pxLink->xBlockSize & xBlockAllocatedBit ) != 0 );
 800f552:	4a0e      	ldr	r2, [pc, #56]	; (800f58c <vPortFree+0x40>)
 800f554:	3808      	subs	r0, #8
 800f556:	6843      	ldr	r3, [r0, #4]
 800f558:	6812      	ldr	r2, [r2, #0]
 800f55a:	0004      	movs	r4, r0
 800f55c:	421a      	tst	r2, r3
 800f55e:	d101      	bne.n	800f564 <vPortFree+0x18>
 800f560:	b672      	cpsid	i
 800f562:	e7fe      	b.n	800f562 <vPortFree+0x16>
		configASSERT( pxLink->pxNextFreeBlock == NULL );
 800f564:	6801      	ldr	r1, [r0, #0]
 800f566:	2900      	cmp	r1, #0
 800f568:	d001      	beq.n	800f56e <vPortFree+0x22>
 800f56a:	b672      	cpsid	i
 800f56c:	e7fe      	b.n	800f56c <vPortFree+0x20>
				pxLink->xBlockSize &= ~xBlockAllocatedBit;
 800f56e:	4393      	bics	r3, r2
 800f570:	6043      	str	r3, [r0, #4]
				vTaskSuspendAll();
 800f572:	f7ff fd2d 	bl	800efd0 <vTaskSuspendAll>
					xFreeBytesRemaining += pxLink->xBlockSize;
 800f576:	4a06      	ldr	r2, [pc, #24]	; (800f590 <vPortFree+0x44>)
 800f578:	6863      	ldr	r3, [r4, #4]
 800f57a:	6811      	ldr	r1, [r2, #0]
					prvInsertBlockIntoFreeList( ( ( BlockLink_t * ) pxLink ) );
 800f57c:	0020      	movs	r0, r4
					xFreeBytesRemaining += pxLink->xBlockSize;
 800f57e:	185b      	adds	r3, r3, r1
 800f580:	6013      	str	r3, [r2, #0]
					prvInsertBlockIntoFreeList( ( ( BlockLink_t * ) pxLink ) );
 800f582:	f7ff ff41 	bl	800f408 <prvInsertBlockIntoFreeList>
				( void ) xTaskResumeAll();
 800f586:	f7ff fdab 	bl	800f0e0 <xTaskResumeAll>
}
 800f58a:	bd10      	pop	{r4, pc}
 800f58c:	200017e4 	.word	0x200017e4
 800f590:	200017e8 	.word	0x200017e8

0800f594 <MX_USB_DEVICE_Init>:
/**
  * Init USB device Library, add supported class and start the library
  * @retval None
  */
void MX_USB_DEVICE_Init(void)
{
 800f594:	b510      	push	{r4, lr}
  /* USER CODE BEGIN USB_DEVICE_Init_PreTreatment */

  /* USER CODE END USB_DEVICE_Init_PreTreatment */

  /* Init Device Library, add supported class and start the library. */
  if (USBD_Init(&hUsbDeviceFS, &FS_Desc, DEVICE_FS) != USBD_OK)
 800f596:	4c11      	ldr	r4, [pc, #68]	; (800f5dc <MX_USB_DEVICE_Init+0x48>)
 800f598:	2200      	movs	r2, #0
 800f59a:	0020      	movs	r0, r4
 800f59c:	4910      	ldr	r1, [pc, #64]	; (800f5e0 <MX_USB_DEVICE_Init+0x4c>)
 800f59e:	f7fe fed7 	bl	800e350 <USBD_Init>
 800f5a2:	2800      	cmp	r0, #0
 800f5a4:	d001      	beq.n	800f5aa <MX_USB_DEVICE_Init+0x16>
  {
    Error_Handler();
 800f5a6:	f7f9 f9c1 	bl	800892c <Error_Handler>
  }
  if (USBD_RegisterClass(&hUsbDeviceFS, &USBD_CDC) != USBD_OK)
 800f5aa:	0020      	movs	r0, r4
 800f5ac:	490d      	ldr	r1, [pc, #52]	; (800f5e4 <MX_USB_DEVICE_Init+0x50>)
 800f5ae:	f7fe fee9 	bl	800e384 <USBD_RegisterClass>
 800f5b2:	2800      	cmp	r0, #0
 800f5b4:	d001      	beq.n	800f5ba <MX_USB_DEVICE_Init+0x26>
  {
    Error_Handler();
 800f5b6:	f7f9 f9b9 	bl	800892c <Error_Handler>
  }
  if (USBD_CDC_RegisterInterface(&hUsbDeviceFS, &USBD_Interface_fops_FS) != USBD_OK)
 800f5ba:	0020      	movs	r0, r4
 800f5bc:	490a      	ldr	r1, [pc, #40]	; (800f5e8 <MX_USB_DEVICE_Init+0x54>)
 800f5be:	f7fe fe76 	bl	800e2ae <USBD_CDC_RegisterInterface>
 800f5c2:	2800      	cmp	r0, #0
 800f5c4:	d001      	beq.n	800f5ca <MX_USB_DEVICE_Init+0x36>
  {
    Error_Handler();
 800f5c6:	f7f9 f9b1 	bl	800892c <Error_Handler>
  }
  if (USBD_Start(&hUsbDeviceFS) != USBD_OK)
 800f5ca:	0020      	movs	r0, r4
 800f5cc:	f7fe fee3 	bl	800e396 <USBD_Start>
 800f5d0:	2800      	cmp	r0, #0
 800f5d2:	d001      	beq.n	800f5d8 <MX_USB_DEVICE_Init+0x44>
  {
    Error_Handler();
 800f5d4:	f7f9 f9aa 	bl	800892c <Error_Handler>
  }

  /* USER CODE BEGIN USB_DEVICE_Init_PostTreatment */

  /* USER CODE END USB_DEVICE_Init_PostTreatment */
}
 800f5d8:	bd10      	pop	{r4, pc}
 800f5da:	46c0      	nop			; (mov r8, r8)
 800f5dc:	20002258 	.word	0x20002258
 800f5e0:	20000588 	.word	0x20000588
 800f5e4:	20000464 	.word	0x20000464
 800f5e8:	20000578 	.word	0x20000578

0800f5ec <CDC_DeInit_FS>:
static int8_t CDC_DeInit_FS(void)
{
  /* USER CODE BEGIN 4 */
  return (USBD_OK);
  /* USER CODE END 4 */
}
 800f5ec:	2000      	movs	r0, #0
 800f5ee:	4770      	bx	lr

0800f5f0 <CDC_Control_FS>:
    break;
  }

  return (USBD_OK);
  /* USER CODE END 5 */
}
 800f5f0:	2000      	movs	r0, #0
 800f5f2:	4770      	bx	lr

0800f5f4 <CDC_Init_FS>:
{
 800f5f4:	b510      	push	{r4, lr}
  USBD_CDC_SetTxBuffer(&hUsbDeviceFS, UserTxBufferFS, 0);
 800f5f6:	4c06      	ldr	r4, [pc, #24]	; (800f610 <CDC_Init_FS+0x1c>)
 800f5f8:	2200      	movs	r2, #0
 800f5fa:	0020      	movs	r0, r4
 800f5fc:	4905      	ldr	r1, [pc, #20]	; (800f614 <CDC_Init_FS+0x20>)
 800f5fe:	f7fe fe5f 	bl	800e2c0 <USBD_CDC_SetTxBuffer>
  USBD_CDC_SetRxBuffer(&hUsbDeviceFS, UserRxBufferFS);
 800f602:	0020      	movs	r0, r4
 800f604:	4904      	ldr	r1, [pc, #16]	; (800f618 <CDC_Init_FS+0x24>)
 800f606:	f7fe fe66 	bl	800e2d6 <USBD_CDC_SetRxBuffer>
}
 800f60a:	2000      	movs	r0, #0
 800f60c:	bd10      	pop	{r4, pc}
 800f60e:	46c0      	nop			; (mov r8, r8)
 800f610:	20002258 	.word	0x20002258
 800f614:	20002904 	.word	0x20002904
 800f618:	2000251c 	.word	0x2000251c

0800f61c <CDC_Transmit_FS>:
  * @param  Buf: Buffer of data to be sent
  * @param  Len: Number of data to be sent (in bytes)
  * @retval USBD_OK if all operations are OK else USBD_FAIL or USBD_BUSY
  */
uint8_t CDC_Transmit_FS(uint8_t* Buf, uint16_t Len)
{
 800f61c:	000a      	movs	r2, r1
  uint8_t result = USBD_OK;
  /* USER CODE BEGIN 7 */
  USBD_CDC_HandleTypeDef *hcdc = (USBD_CDC_HandleTypeDef*)hUsbDeviceFS.pClassData;
 800f61e:	21ae      	movs	r1, #174	; 0xae
{
 800f620:	b510      	push	{r4, lr}
  USBD_CDC_HandleTypeDef *hcdc = (USBD_CDC_HandleTypeDef*)hUsbDeviceFS.pClassData;
 800f622:	4c08      	ldr	r4, [pc, #32]	; (800f644 <CDC_Transmit_FS+0x28>)
 800f624:	0089      	lsls	r1, r1, #2
{
 800f626:	0003      	movs	r3, r0
  USBD_CDC_HandleTypeDef *hcdc = (USBD_CDC_HandleTypeDef*)hUsbDeviceFS.pClassData;
 800f628:	5860      	ldr	r0, [r4, r1]
  if (hcdc->TxState != 0){
 800f62a:	39a4      	subs	r1, #164	; 0xa4
 800f62c:	5841      	ldr	r1, [r0, r1]
    return USBD_BUSY;
 800f62e:	2001      	movs	r0, #1
  if (hcdc->TxState != 0){
 800f630:	2900      	cmp	r1, #0
 800f632:	d106      	bne.n	800f642 <CDC_Transmit_FS+0x26>
  }
  USBD_CDC_SetTxBuffer(&hUsbDeviceFS, Buf, Len);
 800f634:	0019      	movs	r1, r3
 800f636:	0020      	movs	r0, r4
 800f638:	f7fe fe42 	bl	800e2c0 <USBD_CDC_SetTxBuffer>
  result = USBD_CDC_TransmitPacket(&hUsbDeviceFS);
 800f63c:	0020      	movs	r0, r4
 800f63e:	f7fe fe51 	bl	800e2e4 <USBD_CDC_TransmitPacket>
  /* USER CODE END 7 */
  return result;
}
 800f642:	bd10      	pop	{r4, pc}
 800f644:	20002258 	.word	0x20002258

0800f648 <CDC_Receive_FS>:
{
 800f648:	b570      	push	{r4, r5, r6, lr}
 800f64a:	000d      	movs	r5, r1
 800f64c:	0004      	movs	r4, r0
  USBD_CDC_SetRxBuffer(&hUsbDeviceFS, &Buf[0]);
 800f64e:	4e09      	ldr	r6, [pc, #36]	; (800f674 <CDC_Receive_FS+0x2c>)
 800f650:	0001      	movs	r1, r0
 800f652:	0030      	movs	r0, r6
 800f654:	f7fe fe3f 	bl	800e2d6 <USBD_CDC_SetRxBuffer>
  USBD_CDC_ReceivePacket(&hUsbDeviceFS);
 800f658:	0030      	movs	r0, r6
 800f65a:	f7fe fe5f 	bl	800e31c <USBD_CDC_ReceivePacket>
  CDC_Transmit_FS(Buf, *Len);
 800f65e:	6829      	ldr	r1, [r5, #0]
 800f660:	0020      	movs	r0, r4
 800f662:	b289      	uxth	r1, r1
 800f664:	f7ff ffda 	bl	800f61c <CDC_Transmit_FS>
  il_usb_read_irq_handler_keyboard(&usb, Buf);
 800f668:	0021      	movs	r1, r4
 800f66a:	4803      	ldr	r0, [pc, #12]	; (800f678 <CDC_Receive_FS+0x30>)
 800f66c:	f7f9 fe82 	bl	8009374 <il_usb_read_irq_handler_keyboard>
}
 800f670:	2000      	movs	r0, #0
 800f672:	bd70      	pop	{r4, r5, r6, pc}
 800f674:	20002258 	.word	0x20002258
 800f678:	2000208c 	.word	0x2000208c

0800f67c <USBD_FS_DeviceDescriptor>:
  * @retval Pointer to descriptor buffer
  */
uint8_t * USBD_FS_DeviceDescriptor(USBD_SpeedTypeDef speed, uint16_t *length)
{
  UNUSED(speed);
  *length = sizeof(USBD_FS_DeviceDesc);
 800f67c:	2312      	movs	r3, #18
  return USBD_FS_DeviceDesc;
}
 800f67e:	4801      	ldr	r0, [pc, #4]	; (800f684 <USBD_FS_DeviceDescriptor+0x8>)
  *length = sizeof(USBD_FS_DeviceDesc);
 800f680:	800b      	strh	r3, [r1, #0]
}
 800f682:	4770      	bx	lr
 800f684:	200005a4 	.word	0x200005a4

0800f688 <USBD_FS_LangIDStrDescriptor>:
  * @retval Pointer to descriptor buffer
  */
uint8_t * USBD_FS_LangIDStrDescriptor(USBD_SpeedTypeDef speed, uint16_t *length)
{
  UNUSED(speed);
  *length = sizeof(USBD_LangIDDesc);
 800f688:	2304      	movs	r3, #4
  return USBD_LangIDDesc;
}
 800f68a:	4801      	ldr	r0, [pc, #4]	; (800f690 <USBD_FS_LangIDStrDescriptor+0x8>)
  *length = sizeof(USBD_LangIDDesc);
 800f68c:	800b      	strh	r3, [r1, #0]
}
 800f68e:	4770      	bx	lr
 800f690:	200005b8 	.word	0x200005b8

0800f694 <IntToUnicode>:
  * @param  pbuf: pointer to the buffer
  * @param  len: buffer length
  * @retval None
  */
static void IntToUnicode(uint32_t value, uint8_t * pbuf, uint8_t len)
{
 800f694:	b530      	push	{r4, r5, lr}
      pbuf[2 * idx] = (value >> 28) + 'A' - 10;
    }

    value = value << 4;

    pbuf[2 * idx + 1] = 0;
 800f696:	2500      	movs	r5, #0
 800f698:	0052      	lsls	r2, r2, #1
 800f69a:	188a      	adds	r2, r1, r2
    if (((value >> 28)) < 0xA)
 800f69c:	0f04      	lsrs	r4, r0, #28
 800f69e:	b2e3      	uxtb	r3, r4
 800f6a0:	2c09      	cmp	r4, #9
 800f6a2:	d807      	bhi.n	800f6b4 <IntToUnicode+0x20>
      pbuf[2 * idx] = (value >> 28) + '0';
 800f6a4:	3330      	adds	r3, #48	; 0x30
      pbuf[2 * idx] = (value >> 28) + 'A' - 10;
 800f6a6:	700b      	strb	r3, [r1, #0]
    pbuf[2 * idx + 1] = 0;
 800f6a8:	704d      	strb	r5, [r1, #1]
 800f6aa:	3102      	adds	r1, #2
    value = value << 4;
 800f6ac:	0100      	lsls	r0, r0, #4
  for (idx = 0; idx < len; idx++)
 800f6ae:	428a      	cmp	r2, r1
 800f6b0:	d1f4      	bne.n	800f69c <IntToUnicode+0x8>
  }
}
 800f6b2:	bd30      	pop	{r4, r5, pc}
      pbuf[2 * idx] = (value >> 28) + 'A' - 10;
 800f6b4:	3337      	adds	r3, #55	; 0x37
 800f6b6:	e7f6      	b.n	800f6a6 <IntToUnicode+0x12>

0800f6b8 <USBD_FS_SerialStrDescriptor>:
  *length = USB_SIZ_STRING_SERIAL;
 800f6b8:	231a      	movs	r3, #26
{
 800f6ba:	b570      	push	{r4, r5, r6, lr}
  *length = USB_SIZ_STRING_SERIAL;
 800f6bc:	800b      	strh	r3, [r1, #0]
  deviceserial0 = *(uint32_t *) DEVICE_ID1;
 800f6be:	4b0b      	ldr	r3, [pc, #44]	; (800f6ec <USBD_FS_SerialStrDescriptor+0x34>)
 800f6c0:	4c0b      	ldr	r4, [pc, #44]	; (800f6f0 <USBD_FS_SerialStrDescriptor+0x38>)
 800f6c2:	6818      	ldr	r0, [r3, #0]
  deviceserial2 = *(uint32_t *) DEVICE_ID3;
 800f6c4:	4b0b      	ldr	r3, [pc, #44]	; (800f6f4 <USBD_FS_SerialStrDescriptor+0x3c>)
  deviceserial0 += deviceserial2;
 800f6c6:	681b      	ldr	r3, [r3, #0]
 800f6c8:	18c0      	adds	r0, r0, r3
  if (deviceserial0 != 0)
 800f6ca:	2800      	cmp	r0, #0
 800f6cc:	d00b      	beq.n	800f6e6 <USBD_FS_SerialStrDescriptor+0x2e>
  deviceserial1 = *(uint32_t *) DEVICE_ID2;
 800f6ce:	4b0a      	ldr	r3, [pc, #40]	; (800f6f8 <USBD_FS_SerialStrDescriptor+0x40>)
    IntToUnicode(deviceserial0, &USBD_StringSerial[2], 8);
 800f6d0:	2208      	movs	r2, #8
 800f6d2:	1ca1      	adds	r1, r4, #2
  deviceserial1 = *(uint32_t *) DEVICE_ID2;
 800f6d4:	681d      	ldr	r5, [r3, #0]
    IntToUnicode(deviceserial0, &USBD_StringSerial[2], 8);
 800f6d6:	f7ff ffdd 	bl	800f694 <IntToUnicode>
    IntToUnicode(deviceserial1, &USBD_StringSerial[18], 4);
 800f6da:	0021      	movs	r1, r4
 800f6dc:	2204      	movs	r2, #4
 800f6de:	0028      	movs	r0, r5
 800f6e0:	3112      	adds	r1, #18
 800f6e2:	f7ff ffd7 	bl	800f694 <IntToUnicode>
}
 800f6e6:	0020      	movs	r0, r4
 800f6e8:	bd70      	pop	{r4, r5, r6, pc}
 800f6ea:	46c0      	nop			; (mov r8, r8)
 800f6ec:	1ffff7ac 	.word	0x1ffff7ac
 800f6f0:	200005bc 	.word	0x200005bc
 800f6f4:	1ffff7b4 	.word	0x1ffff7b4
 800f6f8:	1ffff7b0 	.word	0x1ffff7b0

0800f6fc <USBD_FS_ManufacturerStrDescriptor>:
{
 800f6fc:	b510      	push	{r4, lr}
  USBD_GetString((uint8_t *)USBD_MANUFACTURER_STRING, USBD_StrDesc, length);
 800f6fe:	4c04      	ldr	r4, [pc, #16]	; (800f710 <USBD_FS_ManufacturerStrDescriptor+0x14>)
{
 800f700:	000a      	movs	r2, r1
  USBD_GetString((uint8_t *)USBD_MANUFACTURER_STRING, USBD_StrDesc, length);
 800f702:	4804      	ldr	r0, [pc, #16]	; (800f714 <USBD_FS_ManufacturerStrDescriptor+0x18>)
 800f704:	0021      	movs	r1, r4
 800f706:	f7ff f9af 	bl	800ea68 <USBD_GetString>
}
 800f70a:	0020      	movs	r0, r4
 800f70c:	bd10      	pop	{r4, pc}
 800f70e:	46c0      	nop			; (mov r8, r8)
 800f710:	20002cec 	.word	0x20002cec
 800f714:	080109f4 	.word	0x080109f4

0800f718 <USBD_FS_ProductStrDescriptor>:
{
 800f718:	b510      	push	{r4, lr}
    USBD_GetString((uint8_t *)USBD_PRODUCT_STRING_FS, USBD_StrDesc, length);
 800f71a:	4c04      	ldr	r4, [pc, #16]	; (800f72c <USBD_FS_ProductStrDescriptor+0x14>)
{
 800f71c:	000a      	movs	r2, r1
    USBD_GetString((uint8_t *)USBD_PRODUCT_STRING_FS, USBD_StrDesc, length);
 800f71e:	4804      	ldr	r0, [pc, #16]	; (800f730 <USBD_FS_ProductStrDescriptor+0x18>)
 800f720:	0021      	movs	r1, r4
 800f722:	f7ff f9a1 	bl	800ea68 <USBD_GetString>
}
 800f726:	0020      	movs	r0, r4
 800f728:	bd10      	pop	{r4, pc}
 800f72a:	46c0      	nop			; (mov r8, r8)
 800f72c:	20002cec 	.word	0x20002cec
 800f730:	08010a07 	.word	0x08010a07

0800f734 <USBD_FS_ConfigStrDescriptor>:
{
 800f734:	b510      	push	{r4, lr}
    USBD_GetString((uint8_t *)USBD_CONFIGURATION_STRING_FS, USBD_StrDesc, length);
 800f736:	4c04      	ldr	r4, [pc, #16]	; (800f748 <USBD_FS_ConfigStrDescriptor+0x14>)
{
 800f738:	000a      	movs	r2, r1
    USBD_GetString((uint8_t *)USBD_CONFIGURATION_STRING_FS, USBD_StrDesc, length);
 800f73a:	4804      	ldr	r0, [pc, #16]	; (800f74c <USBD_FS_ConfigStrDescriptor+0x18>)
 800f73c:	0021      	movs	r1, r4
 800f73e:	f7ff f993 	bl	800ea68 <USBD_GetString>
}
 800f742:	0020      	movs	r0, r4
 800f744:	bd10      	pop	{r4, pc}
 800f746:	46c0      	nop			; (mov r8, r8)
 800f748:	20002cec 	.word	0x20002cec
 800f74c:	08010a1d 	.word	0x08010a1d

0800f750 <USBD_FS_InterfaceStrDescriptor>:
{
 800f750:	b510      	push	{r4, lr}
    USBD_GetString((uint8_t *)USBD_INTERFACE_STRING_FS, USBD_StrDesc, length);
 800f752:	4c04      	ldr	r4, [pc, #16]	; (800f764 <USBD_FS_InterfaceStrDescriptor+0x14>)
{
 800f754:	000a      	movs	r2, r1
    USBD_GetString((uint8_t *)USBD_INTERFACE_STRING_FS, USBD_StrDesc, length);
 800f756:	4804      	ldr	r0, [pc, #16]	; (800f768 <USBD_FS_InterfaceStrDescriptor+0x18>)
 800f758:	0021      	movs	r1, r4
 800f75a:	f7ff f985 	bl	800ea68 <USBD_GetString>
}
 800f75e:	0020      	movs	r0, r4
 800f760:	bd10      	pop	{r4, pc}
 800f762:	46c0      	nop			; (mov r8, r8)
 800f764:	20002cec 	.word	0x20002cec
 800f768:	08010a28 	.word	0x08010a28

0800f76c <HAL_PCD_MspInit>:
                       LL Driver Callbacks (PCD -> USB Device Library)
*******************************************************************************/
/* MSP Init */

void HAL_PCD_MspInit(PCD_HandleTypeDef* pcdHandle)
{
 800f76c:	b507      	push	{r0, r1, r2, lr}
  if(pcdHandle->Instance==USB)
 800f76e:	4b0b      	ldr	r3, [pc, #44]	; (800f79c <HAL_PCD_MspInit+0x30>)
 800f770:	6802      	ldr	r2, [r0, #0]
 800f772:	429a      	cmp	r2, r3
 800f774:	d111      	bne.n	800f79a <HAL_PCD_MspInit+0x2e>
  {
  /* USER CODE BEGIN USB_MspInit 0 */

  /* USER CODE END USB_MspInit 0 */
    /* Peripheral clock enable */
    __HAL_RCC_USB_CLK_ENABLE();
 800f776:	2080      	movs	r0, #128	; 0x80
 800f778:	4a09      	ldr	r2, [pc, #36]	; (800f7a0 <HAL_PCD_MspInit+0x34>)
 800f77a:	0400      	lsls	r0, r0, #16
 800f77c:	69d1      	ldr	r1, [r2, #28]
 800f77e:	4301      	orrs	r1, r0
 800f780:	61d1      	str	r1, [r2, #28]
 800f782:	69d3      	ldr	r3, [r2, #28]

    /* Peripheral interrupt init */
    HAL_NVIC_SetPriority(USB_IRQn, 3, 0);
 800f784:	2103      	movs	r1, #3
    __HAL_RCC_USB_CLK_ENABLE();
 800f786:	4003      	ands	r3, r0
 800f788:	9301      	str	r3, [sp, #4]
    HAL_NVIC_SetPriority(USB_IRQn, 3, 0);
 800f78a:	201f      	movs	r0, #31
 800f78c:	2200      	movs	r2, #0
    __HAL_RCC_USB_CLK_ENABLE();
 800f78e:	9b01      	ldr	r3, [sp, #4]
    HAL_NVIC_SetPriority(USB_IRQn, 3, 0);
 800f790:	f7fa fb92 	bl	8009eb8 <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(USB_IRQn);
 800f794:	201f      	movs	r0, #31
 800f796:	f7fa fbc3 	bl	8009f20 <HAL_NVIC_EnableIRQ>
  /* USER CODE BEGIN USB_MspInit 1 */

  /* USER CODE END USB_MspInit 1 */
  }
}
 800f79a:	bd07      	pop	{r0, r1, r2, pc}
 800f79c:	40005c00 	.word	0x40005c00
 800f7a0:	40021000 	.word	0x40021000

0800f7a4 <HAL_PCD_SetupStageCallback>:
static void PCD_SetupStageCallback(PCD_HandleTypeDef *hpcd)
#else
void HAL_PCD_SetupStageCallback(PCD_HandleTypeDef *hpcd)
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
{
  USBD_LL_SetupStage((USBD_HandleTypeDef*)hpcd->pData, (uint8_t *)hpcd->Setup);
 800f7a4:	23ac      	movs	r3, #172	; 0xac
{
 800f7a6:	b510      	push	{r4, lr}
  USBD_LL_SetupStage((USBD_HandleTypeDef*)hpcd->pData, (uint8_t *)hpcd->Setup);
 800f7a8:	009b      	lsls	r3, r3, #2
 800f7aa:	18c1      	adds	r1, r0, r3
 800f7ac:	3340      	adds	r3, #64	; 0x40
 800f7ae:	58c0      	ldr	r0, [r0, r3]
 800f7b0:	f7fe fe0c 	bl	800e3cc <USBD_LL_SetupStage>
}
 800f7b4:	bd10      	pop	{r4, pc}

0800f7b6 <HAL_PCD_DataOutStageCallback>:
static void PCD_DataOutStageCallback(PCD_HandleTypeDef *hpcd, uint8_t epnum)
#else
void HAL_PCD_DataOutStageCallback(PCD_HandleTypeDef *hpcd, uint8_t epnum)
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
{
  USBD_LL_DataOutStage((USBD_HandleTypeDef*)hpcd->pData, epnum, hpcd->OUT_ep[epnum].xfer_buff);
 800f7b6:	2328      	movs	r3, #40	; 0x28
 800f7b8:	434b      	muls	r3, r1
 800f7ba:	18c3      	adds	r3, r0, r3
 800f7bc:	337d      	adds	r3, #125	; 0x7d
 800f7be:	33ff      	adds	r3, #255	; 0xff
 800f7c0:	681a      	ldr	r2, [r3, #0]
 800f7c2:	23bc      	movs	r3, #188	; 0xbc
{
 800f7c4:	b510      	push	{r4, lr}
  USBD_LL_DataOutStage((USBD_HandleTypeDef*)hpcd->pData, epnum, hpcd->OUT_ep[epnum].xfer_buff);
 800f7c6:	009b      	lsls	r3, r3, #2
 800f7c8:	58c0      	ldr	r0, [r0, r3]
 800f7ca:	f7fe fe31 	bl	800e430 <USBD_LL_DataOutStage>
}
 800f7ce:	bd10      	pop	{r4, pc}

0800f7d0 <HAL_PCD_DataInStageCallback>:
static void PCD_DataInStageCallback(PCD_HandleTypeDef *hpcd, uint8_t epnum)
#else
void HAL_PCD_DataInStageCallback(PCD_HandleTypeDef *hpcd, uint8_t epnum)
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
{
  USBD_LL_DataInStage((USBD_HandleTypeDef*)hpcd->pData, epnum, hpcd->IN_ep[epnum].xfer_buff);
 800f7d0:	2328      	movs	r3, #40	; 0x28
 800f7d2:	434b      	muls	r3, r1
 800f7d4:	18c3      	adds	r3, r0, r3
 800f7d6:	6bda      	ldr	r2, [r3, #60]	; 0x3c
 800f7d8:	23bc      	movs	r3, #188	; 0xbc
{
 800f7da:	b510      	push	{r4, lr}
  USBD_LL_DataInStage((USBD_HandleTypeDef*)hpcd->pData, epnum, hpcd->IN_ep[epnum].xfer_buff);
 800f7dc:	009b      	lsls	r3, r3, #2
 800f7de:	58c0      	ldr	r0, [r0, r3]
 800f7e0:	f7fe fe6c 	bl	800e4bc <USBD_LL_DataInStage>
}
 800f7e4:	bd10      	pop	{r4, pc}

0800f7e6 <HAL_PCD_SOFCallback>:
static void PCD_SOFCallback(PCD_HandleTypeDef *hpcd)
#else
void HAL_PCD_SOFCallback(PCD_HandleTypeDef *hpcd)
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
{
  USBD_LL_SOF((USBD_HandleTypeDef*)hpcd->pData);
 800f7e6:	23bc      	movs	r3, #188	; 0xbc
{
 800f7e8:	b510      	push	{r4, lr}
  USBD_LL_SOF((USBD_HandleTypeDef*)hpcd->pData);
 800f7ea:	009b      	lsls	r3, r3, #2
 800f7ec:	58c0      	ldr	r0, [r0, r3]
 800f7ee:	f7fe ff0f 	bl	800e610 <USBD_LL_SOF>
}
 800f7f2:	bd10      	pop	{r4, pc}

0800f7f4 <HAL_PCD_ResetCallback>:
void HAL_PCD_ResetCallback(PCD_HandleTypeDef *hpcd)
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
{
  USBD_SpeedTypeDef speed = USBD_SPEED_FULL;

  if ( hpcd->Init.speed != PCD_SPEED_FULL)
 800f7f4:	6883      	ldr	r3, [r0, #8]
{
 800f7f6:	b570      	push	{r4, r5, r6, lr}
 800f7f8:	0004      	movs	r4, r0
  if ( hpcd->Init.speed != PCD_SPEED_FULL)
 800f7fa:	2b02      	cmp	r3, #2
 800f7fc:	d001      	beq.n	800f802 <HAL_PCD_ResetCallback+0xe>
  {
    Error_Handler();
 800f7fe:	f7f9 f895 	bl	800892c <Error_Handler>
  }
    /* Set Speed. */
  USBD_LL_SetSpeed((USBD_HandleTypeDef*)hpcd->pData, speed);
 800f802:	25bc      	movs	r5, #188	; 0xbc
 800f804:	00ad      	lsls	r5, r5, #2
 800f806:	2101      	movs	r1, #1
 800f808:	5960      	ldr	r0, [r4, r5]
 800f80a:	f7fe fee6 	bl	800e5da <USBD_LL_SetSpeed>

  /* Reset Device. */
  USBD_LL_Reset((USBD_HandleTypeDef*)hpcd->pData);
 800f80e:	5960      	ldr	r0, [r4, r5]
 800f810:	f7fe feb9 	bl	800e586 <USBD_LL_Reset>
}
 800f814:	bd70      	pop	{r4, r5, r6, pc}
	...

0800f818 <HAL_PCD_SuspendCallback>:
#else
void HAL_PCD_SuspendCallback(PCD_HandleTypeDef *hpcd)
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
{
  /* Inform USB library that core enters in suspend Mode. */
  USBD_LL_Suspend((USBD_HandleTypeDef*)hpcd->pData);
 800f818:	23bc      	movs	r3, #188	; 0xbc
{
 800f81a:	b510      	push	{r4, lr}
 800f81c:	0004      	movs	r4, r0
  USBD_LL_Suspend((USBD_HandleTypeDef*)hpcd->pData);
 800f81e:	009b      	lsls	r3, r3, #2
 800f820:	58c0      	ldr	r0, [r0, r3]
 800f822:	f7fe fedd 	bl	800e5e0 <USBD_LL_Suspend>
  /* Enter in STOP mode. */
  /* USER CODE BEGIN 2 */
  if (hpcd->Init.low_power_enable)
 800f826:	69a3      	ldr	r3, [r4, #24]
 800f828:	2b00      	cmp	r3, #0
 800f82a:	d004      	beq.n	800f836 <HAL_PCD_SuspendCallback+0x1e>
  {
    /* Set SLEEPDEEP bit and SleepOnExit of Cortex System Control Register. */
    SCB->SCR |= (uint32_t)((uint32_t)(SCB_SCR_SLEEPDEEP_Msk | SCB_SCR_SLEEPONEXIT_Msk));
 800f82c:	2306      	movs	r3, #6
 800f82e:	4a02      	ldr	r2, [pc, #8]	; (800f838 <HAL_PCD_SuspendCallback+0x20>)
 800f830:	6911      	ldr	r1, [r2, #16]
 800f832:	430b      	orrs	r3, r1
 800f834:	6113      	str	r3, [r2, #16]
  }
  /* USER CODE END 2 */
}
 800f836:	bd10      	pop	{r4, pc}
 800f838:	e000ed00 	.word	0xe000ed00

0800f83c <HAL_PCD_ResumeCallback>:
#else
void HAL_PCD_ResumeCallback(PCD_HandleTypeDef *hpcd)
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
{
  /* USER CODE BEGIN 3 */
  if (hpcd->Init.low_power_enable)
 800f83c:	6983      	ldr	r3, [r0, #24]
{
 800f83e:	b510      	push	{r4, lr}
 800f840:	0004      	movs	r4, r0
  if (hpcd->Init.low_power_enable)
 800f842:	2b00      	cmp	r3, #0
 800f844:	d006      	beq.n	800f854 <HAL_PCD_ResumeCallback+0x18>
  {
    /* Reset SLEEPDEEP bit of Cortex System Control Register. */
    SCB->SCR &= (uint32_t)~((uint32_t)(SCB_SCR_SLEEPDEEP_Msk | SCB_SCR_SLEEPONEXIT_Msk));
 800f846:	2106      	movs	r1, #6
 800f848:	4a05      	ldr	r2, [pc, #20]	; (800f860 <HAL_PCD_ResumeCallback+0x24>)
 800f84a:	6913      	ldr	r3, [r2, #16]
 800f84c:	438b      	bics	r3, r1
 800f84e:	6113      	str	r3, [r2, #16]
  *         enable HSI, PLL and select PLL as system clock source.
  * @retval None
  */
static void SystemClockConfig_Resume(void)
{
  SystemClock_Config();
 800f850:	f7f8 fffa 	bl	8008848 <SystemClock_Config>
  USBD_LL_Resume((USBD_HandleTypeDef*)hpcd->pData);
 800f854:	23bc      	movs	r3, #188	; 0xbc
 800f856:	009b      	lsls	r3, r3, #2
 800f858:	58e0      	ldr	r0, [r4, r3]
 800f85a:	f7fe fecd 	bl	800e5f8 <USBD_LL_Resume>
}
 800f85e:	bd10      	pop	{r4, pc}
 800f860:	e000ed00 	.word	0xe000ed00

0800f864 <USBD_LL_Init>:
  hpcd_USB_FS.pData = pdev;
 800f864:	23bc      	movs	r3, #188	; 0xbc
{
 800f866:	b570      	push	{r4, r5, r6, lr}
 800f868:	0004      	movs	r4, r0
  hpcd_USB_FS.pData = pdev;
 800f86a:	481c      	ldr	r0, [pc, #112]	; (800f8dc <USBD_LL_Init+0x78>)
 800f86c:	009b      	lsls	r3, r3, #2
 800f86e:	50c4      	str	r4, [r0, r3]
  hpcd_USB_FS.Instance = USB;
 800f870:	4b1b      	ldr	r3, [pc, #108]	; (800f8e0 <USBD_LL_Init+0x7c>)
  pdev->pData = &hpcd_USB_FS;
 800f872:	25b0      	movs	r5, #176	; 0xb0
  hpcd_USB_FS.Instance = USB;
 800f874:	6003      	str	r3, [r0, #0]
  hpcd_USB_FS.Init.dev_endpoints = 8;
 800f876:	2308      	movs	r3, #8
 800f878:	6043      	str	r3, [r0, #4]
  hpcd_USB_FS.Init.speed = PCD_SPEED_FULL;
 800f87a:	3b06      	subs	r3, #6
 800f87c:	6083      	str	r3, [r0, #8]
  hpcd_USB_FS.Init.phy_itface = PCD_PHY_EMBEDDED;
 800f87e:	6103      	str	r3, [r0, #16]
  hpcd_USB_FS.Init.low_power_enable = DISABLE;
 800f880:	2300      	movs	r3, #0
  pdev->pData = &hpcd_USB_FS;
 800f882:	00ad      	lsls	r5, r5, #2
 800f884:	5160      	str	r0, [r4, r5]
  hpcd_USB_FS.Init.low_power_enable = DISABLE;
 800f886:	6183      	str	r3, [r0, #24]
  hpcd_USB_FS.Init.lpm_enable = DISABLE;
 800f888:	61c3      	str	r3, [r0, #28]
  hpcd_USB_FS.Init.battery_charging_enable = DISABLE;
 800f88a:	6203      	str	r3, [r0, #32]
  if (HAL_PCD_Init(&hpcd_USB_FS) != HAL_OK)
 800f88c:	f7fb faac 	bl	800ade8 <HAL_PCD_Init>
 800f890:	2800      	cmp	r0, #0
 800f892:	d001      	beq.n	800f898 <USBD_LL_Init+0x34>
    Error_Handler( );
 800f894:	f7f9 f84a 	bl	800892c <Error_Handler>
  HAL_PCDEx_PMAConfig((PCD_HandleTypeDef*)pdev->pData , 0x00 , PCD_SNG_BUF, 0x18);
 800f898:	2200      	movs	r2, #0
 800f89a:	5960      	ldr	r0, [r4, r5]
 800f89c:	0011      	movs	r1, r2
 800f89e:	2318      	movs	r3, #24
 800f8a0:	f7fc f861 	bl	800b966 <HAL_PCDEx_PMAConfig>
  HAL_PCDEx_PMAConfig((PCD_HandleTypeDef*)pdev->pData , 0x80 , PCD_SNG_BUF, 0x58);
 800f8a4:	5960      	ldr	r0, [r4, r5]
 800f8a6:	2358      	movs	r3, #88	; 0x58
 800f8a8:	2200      	movs	r2, #0
 800f8aa:	2180      	movs	r1, #128	; 0x80
 800f8ac:	f7fc f85b 	bl	800b966 <HAL_PCDEx_PMAConfig>
  HAL_PCDEx_PMAConfig((PCD_HandleTypeDef*)pdev->pData , 0x81 , PCD_SNG_BUF, 0xC0);
 800f8b0:	5960      	ldr	r0, [r4, r5]
 800f8b2:	23c0      	movs	r3, #192	; 0xc0
 800f8b4:	2200      	movs	r2, #0
 800f8b6:	2181      	movs	r1, #129	; 0x81
 800f8b8:	f7fc f855 	bl	800b966 <HAL_PCDEx_PMAConfig>
  HAL_PCDEx_PMAConfig((PCD_HandleTypeDef*)pdev->pData , 0x01 , PCD_SNG_BUF, 0x110);
 800f8bc:	2388      	movs	r3, #136	; 0x88
 800f8be:	5960      	ldr	r0, [r4, r5]
 800f8c0:	2200      	movs	r2, #0
 800f8c2:	2101      	movs	r1, #1
 800f8c4:	005b      	lsls	r3, r3, #1
 800f8c6:	f7fc f84e 	bl	800b966 <HAL_PCDEx_PMAConfig>
  HAL_PCDEx_PMAConfig((PCD_HandleTypeDef*)pdev->pData , 0x82 , PCD_SNG_BUF, 0x100);
 800f8ca:	2380      	movs	r3, #128	; 0x80
 800f8cc:	5960      	ldr	r0, [r4, r5]
 800f8ce:	2200      	movs	r2, #0
 800f8d0:	2182      	movs	r1, #130	; 0x82
 800f8d2:	005b      	lsls	r3, r3, #1
 800f8d4:	f7fc f847 	bl	800b966 <HAL_PCDEx_PMAConfig>
}
 800f8d8:	2000      	movs	r0, #0
 800f8da:	bd70      	pop	{r4, r5, r6, pc}
 800f8dc:	20002eec 	.word	0x20002eec
 800f8e0:	40005c00 	.word	0x40005c00

0800f8e4 <USBD_LL_Start>:
  hal_status = HAL_PCD_Start(pdev->pData);
 800f8e4:	23b0      	movs	r3, #176	; 0xb0
 800f8e6:	009b      	lsls	r3, r3, #2
 800f8e8:	58c0      	ldr	r0, [r0, r3]
{
 800f8ea:	b510      	push	{r4, lr}
  hal_status = HAL_PCD_Start(pdev->pData);
 800f8ec:	f7fb faf4 	bl	800aed8 <HAL_PCD_Start>
 800f8f0:	0003      	movs	r3, r0
 800f8f2:	2002      	movs	r0, #2
 800f8f4:	2b03      	cmp	r3, #3
 800f8f6:	d801      	bhi.n	800f8fc <USBD_LL_Start+0x18>
 800f8f8:	4a01      	ldr	r2, [pc, #4]	; (800f900 <USBD_LL_Start+0x1c>)
 800f8fa:	5cd0      	ldrb	r0, [r2, r3]
}
 800f8fc:	bd10      	pop	{r4, pc}
 800f8fe:	46c0      	nop			; (mov r8, r8)
 800f900:	08010a36 	.word	0x08010a36

0800f904 <USBD_LL_OpenEP>:
{
 800f904:	b510      	push	{r4, lr}
 800f906:	0014      	movs	r4, r2
 800f908:	001a      	movs	r2, r3
  hal_status = HAL_PCD_EP_Open(pdev->pData, ep_addr, ep_mps, ep_type);
 800f90a:	0023      	movs	r3, r4
 800f90c:	24b0      	movs	r4, #176	; 0xb0
 800f90e:	00a4      	lsls	r4, r4, #2
 800f910:	5900      	ldr	r0, [r0, r4]
 800f912:	f7fb ff2f 	bl	800b774 <HAL_PCD_EP_Open>
 800f916:	0003      	movs	r3, r0
 800f918:	2002      	movs	r0, #2
 800f91a:	2b03      	cmp	r3, #3
 800f91c:	d801      	bhi.n	800f922 <USBD_LL_OpenEP+0x1e>
 800f91e:	4a01      	ldr	r2, [pc, #4]	; (800f924 <USBD_LL_OpenEP+0x20>)
 800f920:	5cd0      	ldrb	r0, [r2, r3]
}
 800f922:	bd10      	pop	{r4, pc}
 800f924:	08010a36 	.word	0x08010a36

0800f928 <USBD_LL_CloseEP>:
  hal_status = HAL_PCD_EP_Close(pdev->pData, ep_addr);
 800f928:	23b0      	movs	r3, #176	; 0xb0
 800f92a:	009b      	lsls	r3, r3, #2
 800f92c:	58c0      	ldr	r0, [r0, r3]
{
 800f92e:	b510      	push	{r4, lr}
  hal_status = HAL_PCD_EP_Close(pdev->pData, ep_addr);
 800f930:	f7fb ff51 	bl	800b7d6 <HAL_PCD_EP_Close>
 800f934:	0003      	movs	r3, r0
 800f936:	2002      	movs	r0, #2
 800f938:	2b03      	cmp	r3, #3
 800f93a:	d801      	bhi.n	800f940 <USBD_LL_CloseEP+0x18>
 800f93c:	4a01      	ldr	r2, [pc, #4]	; (800f944 <USBD_LL_CloseEP+0x1c>)
 800f93e:	5cd0      	ldrb	r0, [r2, r3]
}
 800f940:	bd10      	pop	{r4, pc}
 800f942:	46c0      	nop			; (mov r8, r8)
 800f944:	08010a36 	.word	0x08010a36

0800f948 <USBD_LL_StallEP>:
  hal_status = HAL_PCD_EP_SetStall(pdev->pData, ep_addr);
 800f948:	23b0      	movs	r3, #176	; 0xb0
 800f94a:	009b      	lsls	r3, r3, #2
 800f94c:	58c0      	ldr	r0, [r0, r3]
{
 800f94e:	b510      	push	{r4, lr}
  hal_status = HAL_PCD_EP_SetStall(pdev->pData, ep_addr);
 800f950:	f7fb ffaf 	bl	800b8b2 <HAL_PCD_EP_SetStall>
 800f954:	0003      	movs	r3, r0
 800f956:	2002      	movs	r0, #2
 800f958:	2b03      	cmp	r3, #3
 800f95a:	d801      	bhi.n	800f960 <USBD_LL_StallEP+0x18>
 800f95c:	4a01      	ldr	r2, [pc, #4]	; (800f964 <USBD_LL_StallEP+0x1c>)
 800f95e:	5cd0      	ldrb	r0, [r2, r3]
}
 800f960:	bd10      	pop	{r4, pc}
 800f962:	46c0      	nop			; (mov r8, r8)
 800f964:	08010a36 	.word	0x08010a36

0800f968 <USBD_LL_ClearStallEP>:
  hal_status = HAL_PCD_EP_ClrStall(pdev->pData, ep_addr);
 800f968:	23b0      	movs	r3, #176	; 0xb0
 800f96a:	009b      	lsls	r3, r3, #2
 800f96c:	58c0      	ldr	r0, [r0, r3]
{
 800f96e:	b510      	push	{r4, lr}
  hal_status = HAL_PCD_EP_ClrStall(pdev->pData, ep_addr);
 800f970:	f7fb ffca 	bl	800b908 <HAL_PCD_EP_ClrStall>
 800f974:	0003      	movs	r3, r0
 800f976:	2002      	movs	r0, #2
 800f978:	2b03      	cmp	r3, #3
 800f97a:	d801      	bhi.n	800f980 <USBD_LL_ClearStallEP+0x18>
 800f97c:	4a01      	ldr	r2, [pc, #4]	; (800f984 <USBD_LL_ClearStallEP+0x1c>)
 800f97e:	5cd0      	ldrb	r0, [r2, r3]
}
 800f980:	bd10      	pop	{r4, pc}
 800f982:	46c0      	nop			; (mov r8, r8)
 800f984:	08010a36 	.word	0x08010a36

0800f988 <USBD_LL_IsStallEP>:
  PCD_HandleTypeDef *hpcd = (PCD_HandleTypeDef*) pdev->pData;
 800f988:	23b0      	movs	r3, #176	; 0xb0
  if((ep_addr & 0x80) == 0x80)
 800f98a:	b24a      	sxtb	r2, r1
  PCD_HandleTypeDef *hpcd = (PCD_HandleTypeDef*) pdev->pData;
 800f98c:	009b      	lsls	r3, r3, #2
 800f98e:	58c3      	ldr	r3, [r0, r3]
  if((ep_addr & 0x80) == 0x80)
 800f990:	2a00      	cmp	r2, #0
 800f992:	da07      	bge.n	800f9a4 <USBD_LL_IsStallEP+0x1c>
    return hpcd->IN_ep[ep_addr & 0x7F].is_stall;
 800f994:	227f      	movs	r2, #127	; 0x7f
 800f996:	4011      	ands	r1, r2
 800f998:	3101      	adds	r1, #1
 800f99a:	3a57      	subs	r2, #87	; 0x57
 800f99c:	4351      	muls	r1, r2
 800f99e:	185b      	adds	r3, r3, r1
 800f9a0:	7898      	ldrb	r0, [r3, #2]
}
 800f9a2:	4770      	bx	lr
    return hpcd->OUT_ep[ep_addr & 0x7F].is_stall;
 800f9a4:	2228      	movs	r2, #40	; 0x28
 800f9a6:	4351      	muls	r1, r2
 800f9a8:	185b      	adds	r3, r3, r1
 800f9aa:	336b      	adds	r3, #107	; 0x6b
 800f9ac:	33ff      	adds	r3, #255	; 0xff
 800f9ae:	7818      	ldrb	r0, [r3, #0]
 800f9b0:	e7f7      	b.n	800f9a2 <USBD_LL_IsStallEP+0x1a>
	...

0800f9b4 <USBD_LL_SetUSBAddress>:
  hal_status = HAL_PCD_SetAddress(pdev->pData, dev_addr);
 800f9b4:	23b0      	movs	r3, #176	; 0xb0
 800f9b6:	009b      	lsls	r3, r3, #2
 800f9b8:	58c0      	ldr	r0, [r0, r3]
{
 800f9ba:	b510      	push	{r4, lr}
  hal_status = HAL_PCD_SetAddress(pdev->pData, dev_addr);
 800f9bc:	f7fb fa9f 	bl	800aefe <HAL_PCD_SetAddress>
 800f9c0:	0003      	movs	r3, r0
 800f9c2:	2002      	movs	r0, #2
 800f9c4:	2b03      	cmp	r3, #3
 800f9c6:	d801      	bhi.n	800f9cc <USBD_LL_SetUSBAddress+0x18>
 800f9c8:	4a01      	ldr	r2, [pc, #4]	; (800f9d0 <USBD_LL_SetUSBAddress+0x1c>)
 800f9ca:	5cd0      	ldrb	r0, [r2, r3]
}
 800f9cc:	bd10      	pop	{r4, pc}
 800f9ce:	46c0      	nop			; (mov r8, r8)
 800f9d0:	08010a36 	.word	0x08010a36

0800f9d4 <USBD_LL_Transmit>:
{
 800f9d4:	b510      	push	{r4, lr}
  hal_status = HAL_PCD_EP_Transmit(pdev->pData, ep_addr, pbuf, size);
 800f9d6:	24b0      	movs	r4, #176	; 0xb0
 800f9d8:	00a4      	lsls	r4, r4, #2
 800f9da:	5900      	ldr	r0, [r0, r4]
 800f9dc:	f7fb ff4c 	bl	800b878 <HAL_PCD_EP_Transmit>
 800f9e0:	0003      	movs	r3, r0
 800f9e2:	2002      	movs	r0, #2
 800f9e4:	2b03      	cmp	r3, #3
 800f9e6:	d801      	bhi.n	800f9ec <USBD_LL_Transmit+0x18>
 800f9e8:	4a01      	ldr	r2, [pc, #4]	; (800f9f0 <USBD_LL_Transmit+0x1c>)
 800f9ea:	5cd0      	ldrb	r0, [r2, r3]
}
 800f9ec:	bd10      	pop	{r4, pc}
 800f9ee:	46c0      	nop			; (mov r8, r8)
 800f9f0:	08010a36 	.word	0x08010a36

0800f9f4 <USBD_LL_PrepareReceive>:
{
 800f9f4:	b510      	push	{r4, lr}
  hal_status = HAL_PCD_EP_Receive(pdev->pData, ep_addr, pbuf, size);
 800f9f6:	24b0      	movs	r4, #176	; 0xb0
 800f9f8:	00a4      	lsls	r4, r4, #2
 800f9fa:	5900      	ldr	r0, [r0, r4]
 800f9fc:	f7fb ff12 	bl	800b824 <HAL_PCD_EP_Receive>
 800fa00:	0003      	movs	r3, r0
 800fa02:	2002      	movs	r0, #2
 800fa04:	2b03      	cmp	r3, #3
 800fa06:	d801      	bhi.n	800fa0c <USBD_LL_PrepareReceive+0x18>
 800fa08:	4a01      	ldr	r2, [pc, #4]	; (800fa10 <USBD_LL_PrepareReceive+0x1c>)
 800fa0a:	5cd0      	ldrb	r0, [r2, r3]
}
 800fa0c:	bd10      	pop	{r4, pc}
 800fa0e:	46c0      	nop			; (mov r8, r8)
 800fa10:	08010a36 	.word	0x08010a36

0800fa14 <USBD_LL_GetRxDataSize>:
  return HAL_PCD_EP_GetRxCount((PCD_HandleTypeDef*) pdev->pData, ep_addr);
 800fa14:	23b0      	movs	r3, #176	; 0xb0
{
 800fa16:	b510      	push	{r4, lr}
  return HAL_PCD_EP_GetRxCount((PCD_HandleTypeDef*) pdev->pData, ep_addr);
 800fa18:	009b      	lsls	r3, r3, #2
 800fa1a:	58c0      	ldr	r0, [r0, r3]
 800fa1c:	f7fb ff23 	bl	800b866 <HAL_PCD_EP_GetRxCount>
}
 800fa20:	bd10      	pop	{r4, pc}
	...

0800fa24 <USBD_static_malloc>:
}
 800fa24:	4800      	ldr	r0, [pc, #0]	; (800fa28 <USBD_static_malloc+0x4>)
 800fa26:	4770      	bx	lr
 800fa28:	200017f8 	.word	0x200017f8

0800fa2c <USBD_static_free>:
}
 800fa2c:	4770      	bx	lr
	...

0800fa30 <__errno>:
 800fa30:	4b01      	ldr	r3, [pc, #4]	; (800fa38 <__errno+0x8>)
 800fa32:	6818      	ldr	r0, [r3, #0]
 800fa34:	4770      	bx	lr
 800fa36:	46c0      	nop			; (mov r8, r8)
 800fa38:	200005d8 	.word	0x200005d8

0800fa3c <__libc_init_array>:
 800fa3c:	b570      	push	{r4, r5, r6, lr}
 800fa3e:	2600      	movs	r6, #0
 800fa40:	4d0c      	ldr	r5, [pc, #48]	; (800fa74 <__libc_init_array+0x38>)
 800fa42:	4c0d      	ldr	r4, [pc, #52]	; (800fa78 <__libc_init_array+0x3c>)
 800fa44:	1b64      	subs	r4, r4, r5
 800fa46:	10a4      	asrs	r4, r4, #2
 800fa48:	42a6      	cmp	r6, r4
 800fa4a:	d109      	bne.n	800fa60 <__libc_init_array+0x24>
 800fa4c:	2600      	movs	r6, #0
 800fa4e:	f000 fd15 	bl	801047c <_init>
 800fa52:	4d0a      	ldr	r5, [pc, #40]	; (800fa7c <__libc_init_array+0x40>)
 800fa54:	4c0a      	ldr	r4, [pc, #40]	; (800fa80 <__libc_init_array+0x44>)
 800fa56:	1b64      	subs	r4, r4, r5
 800fa58:	10a4      	asrs	r4, r4, #2
 800fa5a:	42a6      	cmp	r6, r4
 800fa5c:	d105      	bne.n	800fa6a <__libc_init_array+0x2e>
 800fa5e:	bd70      	pop	{r4, r5, r6, pc}
 800fa60:	00b3      	lsls	r3, r6, #2
 800fa62:	58eb      	ldr	r3, [r5, r3]
 800fa64:	4798      	blx	r3
 800fa66:	3601      	adds	r6, #1
 800fa68:	e7ee      	b.n	800fa48 <__libc_init_array+0xc>
 800fa6a:	00b3      	lsls	r3, r6, #2
 800fa6c:	58eb      	ldr	r3, [r5, r3]
 800fa6e:	4798      	blx	r3
 800fa70:	3601      	adds	r6, #1
 800fa72:	e7f2      	b.n	800fa5a <__libc_init_array+0x1e>
 800fa74:	08010a94 	.word	0x08010a94
 800fa78:	08010a94 	.word	0x08010a94
 800fa7c:	08010a94 	.word	0x08010a94
 800fa80:	08010a98 	.word	0x08010a98

0800fa84 <__itoa>:
 800fa84:	1e93      	subs	r3, r2, #2
 800fa86:	b510      	push	{r4, lr}
 800fa88:	000c      	movs	r4, r1
 800fa8a:	2b22      	cmp	r3, #34	; 0x22
 800fa8c:	d904      	bls.n	800fa98 <__itoa+0x14>
 800fa8e:	2300      	movs	r3, #0
 800fa90:	001c      	movs	r4, r3
 800fa92:	700b      	strb	r3, [r1, #0]
 800fa94:	0020      	movs	r0, r4
 800fa96:	bd10      	pop	{r4, pc}
 800fa98:	2a0a      	cmp	r2, #10
 800fa9a:	d109      	bne.n	800fab0 <__itoa+0x2c>
 800fa9c:	2800      	cmp	r0, #0
 800fa9e:	da07      	bge.n	800fab0 <__itoa+0x2c>
 800faa0:	232d      	movs	r3, #45	; 0x2d
 800faa2:	700b      	strb	r3, [r1, #0]
 800faa4:	2101      	movs	r1, #1
 800faa6:	4240      	negs	r0, r0
 800faa8:	1861      	adds	r1, r4, r1
 800faaa:	f000 f937 	bl	800fd1c <__utoa>
 800faae:	e7f1      	b.n	800fa94 <__itoa+0x10>
 800fab0:	2100      	movs	r1, #0
 800fab2:	e7f9      	b.n	800faa8 <__itoa+0x24>

0800fab4 <itoa>:
 800fab4:	b510      	push	{r4, lr}
 800fab6:	f7ff ffe5 	bl	800fa84 <__itoa>
 800faba:	bd10      	pop	{r4, pc}

0800fabc <malloc>:
 800fabc:	b510      	push	{r4, lr}
 800fabe:	4b03      	ldr	r3, [pc, #12]	; (800facc <malloc+0x10>)
 800fac0:	0001      	movs	r1, r0
 800fac2:	6818      	ldr	r0, [r3, #0]
 800fac4:	f000 f86e 	bl	800fba4 <_malloc_r>
 800fac8:	bd10      	pop	{r4, pc}
 800faca:	46c0      	nop			; (mov r8, r8)
 800facc:	200005d8 	.word	0x200005d8

0800fad0 <memcmp>:
 800fad0:	b530      	push	{r4, r5, lr}
 800fad2:	2400      	movs	r4, #0
 800fad4:	3901      	subs	r1, #1
 800fad6:	42a2      	cmp	r2, r4
 800fad8:	d101      	bne.n	800fade <memcmp+0xe>
 800fada:	2000      	movs	r0, #0
 800fadc:	e005      	b.n	800faea <memcmp+0x1a>
 800fade:	5d03      	ldrb	r3, [r0, r4]
 800fae0:	3401      	adds	r4, #1
 800fae2:	5d0d      	ldrb	r5, [r1, r4]
 800fae4:	42ab      	cmp	r3, r5
 800fae6:	d0f6      	beq.n	800fad6 <memcmp+0x6>
 800fae8:	1b58      	subs	r0, r3, r5
 800faea:	bd30      	pop	{r4, r5, pc}

0800faec <memcpy>:
 800faec:	2300      	movs	r3, #0
 800faee:	b510      	push	{r4, lr}
 800faf0:	429a      	cmp	r2, r3
 800faf2:	d100      	bne.n	800faf6 <memcpy+0xa>
 800faf4:	bd10      	pop	{r4, pc}
 800faf6:	5ccc      	ldrb	r4, [r1, r3]
 800faf8:	54c4      	strb	r4, [r0, r3]
 800fafa:	3301      	adds	r3, #1
 800fafc:	e7f8      	b.n	800faf0 <memcpy+0x4>

0800fafe <memset>:
 800fafe:	0003      	movs	r3, r0
 800fb00:	1882      	adds	r2, r0, r2
 800fb02:	4293      	cmp	r3, r2
 800fb04:	d100      	bne.n	800fb08 <memset+0xa>
 800fb06:	4770      	bx	lr
 800fb08:	7019      	strb	r1, [r3, #0]
 800fb0a:	3301      	adds	r3, #1
 800fb0c:	e7f9      	b.n	800fb02 <memset+0x4>
	...

0800fb10 <_free_r>:
 800fb10:	b570      	push	{r4, r5, r6, lr}
 800fb12:	0005      	movs	r5, r0
 800fb14:	2900      	cmp	r1, #0
 800fb16:	d010      	beq.n	800fb3a <_free_r+0x2a>
 800fb18:	1f0c      	subs	r4, r1, #4
 800fb1a:	6823      	ldr	r3, [r4, #0]
 800fb1c:	2b00      	cmp	r3, #0
 800fb1e:	da00      	bge.n	800fb22 <_free_r+0x12>
 800fb20:	18e4      	adds	r4, r4, r3
 800fb22:	0028      	movs	r0, r5
 800fb24:	f000 f968 	bl	800fdf8 <__malloc_lock>
 800fb28:	4a1d      	ldr	r2, [pc, #116]	; (800fba0 <_free_r+0x90>)
 800fb2a:	6813      	ldr	r3, [r2, #0]
 800fb2c:	2b00      	cmp	r3, #0
 800fb2e:	d105      	bne.n	800fb3c <_free_r+0x2c>
 800fb30:	6063      	str	r3, [r4, #4]
 800fb32:	6014      	str	r4, [r2, #0]
 800fb34:	0028      	movs	r0, r5
 800fb36:	f000 f967 	bl	800fe08 <__malloc_unlock>
 800fb3a:	bd70      	pop	{r4, r5, r6, pc}
 800fb3c:	42a3      	cmp	r3, r4
 800fb3e:	d908      	bls.n	800fb52 <_free_r+0x42>
 800fb40:	6821      	ldr	r1, [r4, #0]
 800fb42:	1860      	adds	r0, r4, r1
 800fb44:	4283      	cmp	r3, r0
 800fb46:	d1f3      	bne.n	800fb30 <_free_r+0x20>
 800fb48:	6818      	ldr	r0, [r3, #0]
 800fb4a:	685b      	ldr	r3, [r3, #4]
 800fb4c:	1841      	adds	r1, r0, r1
 800fb4e:	6021      	str	r1, [r4, #0]
 800fb50:	e7ee      	b.n	800fb30 <_free_r+0x20>
 800fb52:	001a      	movs	r2, r3
 800fb54:	685b      	ldr	r3, [r3, #4]
 800fb56:	2b00      	cmp	r3, #0
 800fb58:	d001      	beq.n	800fb5e <_free_r+0x4e>
 800fb5a:	42a3      	cmp	r3, r4
 800fb5c:	d9f9      	bls.n	800fb52 <_free_r+0x42>
 800fb5e:	6811      	ldr	r1, [r2, #0]
 800fb60:	1850      	adds	r0, r2, r1
 800fb62:	42a0      	cmp	r0, r4
 800fb64:	d10b      	bne.n	800fb7e <_free_r+0x6e>
 800fb66:	6820      	ldr	r0, [r4, #0]
 800fb68:	1809      	adds	r1, r1, r0
 800fb6a:	1850      	adds	r0, r2, r1
 800fb6c:	6011      	str	r1, [r2, #0]
 800fb6e:	4283      	cmp	r3, r0
 800fb70:	d1e0      	bne.n	800fb34 <_free_r+0x24>
 800fb72:	6818      	ldr	r0, [r3, #0]
 800fb74:	685b      	ldr	r3, [r3, #4]
 800fb76:	1841      	adds	r1, r0, r1
 800fb78:	6011      	str	r1, [r2, #0]
 800fb7a:	6053      	str	r3, [r2, #4]
 800fb7c:	e7da      	b.n	800fb34 <_free_r+0x24>
 800fb7e:	42a0      	cmp	r0, r4
 800fb80:	d902      	bls.n	800fb88 <_free_r+0x78>
 800fb82:	230c      	movs	r3, #12
 800fb84:	602b      	str	r3, [r5, #0]
 800fb86:	e7d5      	b.n	800fb34 <_free_r+0x24>
 800fb88:	6821      	ldr	r1, [r4, #0]
 800fb8a:	1860      	adds	r0, r4, r1
 800fb8c:	4283      	cmp	r3, r0
 800fb8e:	d103      	bne.n	800fb98 <_free_r+0x88>
 800fb90:	6818      	ldr	r0, [r3, #0]
 800fb92:	685b      	ldr	r3, [r3, #4]
 800fb94:	1841      	adds	r1, r0, r1
 800fb96:	6021      	str	r1, [r4, #0]
 800fb98:	6063      	str	r3, [r4, #4]
 800fb9a:	6054      	str	r4, [r2, #4]
 800fb9c:	e7ca      	b.n	800fb34 <_free_r+0x24>
 800fb9e:	46c0      	nop			; (mov r8, r8)
 800fba0:	20001a18 	.word	0x20001a18

0800fba4 <_malloc_r>:
 800fba4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800fba6:	2303      	movs	r3, #3
 800fba8:	1ccd      	adds	r5, r1, #3
 800fbaa:	439d      	bics	r5, r3
 800fbac:	3508      	adds	r5, #8
 800fbae:	0006      	movs	r6, r0
 800fbb0:	2d0c      	cmp	r5, #12
 800fbb2:	d21f      	bcs.n	800fbf4 <_malloc_r+0x50>
 800fbb4:	250c      	movs	r5, #12
 800fbb6:	42a9      	cmp	r1, r5
 800fbb8:	d81e      	bhi.n	800fbf8 <_malloc_r+0x54>
 800fbba:	0030      	movs	r0, r6
 800fbbc:	f000 f91c 	bl	800fdf8 <__malloc_lock>
 800fbc0:	4925      	ldr	r1, [pc, #148]	; (800fc58 <_malloc_r+0xb4>)
 800fbc2:	680a      	ldr	r2, [r1, #0]
 800fbc4:	0014      	movs	r4, r2
 800fbc6:	2c00      	cmp	r4, #0
 800fbc8:	d11a      	bne.n	800fc00 <_malloc_r+0x5c>
 800fbca:	4f24      	ldr	r7, [pc, #144]	; (800fc5c <_malloc_r+0xb8>)
 800fbcc:	683b      	ldr	r3, [r7, #0]
 800fbce:	2b00      	cmp	r3, #0
 800fbd0:	d104      	bne.n	800fbdc <_malloc_r+0x38>
 800fbd2:	0021      	movs	r1, r4
 800fbd4:	0030      	movs	r0, r6
 800fbd6:	f000 f843 	bl	800fc60 <_sbrk_r>
 800fbda:	6038      	str	r0, [r7, #0]
 800fbdc:	0029      	movs	r1, r5
 800fbde:	0030      	movs	r0, r6
 800fbe0:	f000 f83e 	bl	800fc60 <_sbrk_r>
 800fbe4:	1c43      	adds	r3, r0, #1
 800fbe6:	d12b      	bne.n	800fc40 <_malloc_r+0x9c>
 800fbe8:	230c      	movs	r3, #12
 800fbea:	0030      	movs	r0, r6
 800fbec:	6033      	str	r3, [r6, #0]
 800fbee:	f000 f90b 	bl	800fe08 <__malloc_unlock>
 800fbf2:	e003      	b.n	800fbfc <_malloc_r+0x58>
 800fbf4:	2d00      	cmp	r5, #0
 800fbf6:	dade      	bge.n	800fbb6 <_malloc_r+0x12>
 800fbf8:	230c      	movs	r3, #12
 800fbfa:	6033      	str	r3, [r6, #0]
 800fbfc:	2000      	movs	r0, #0
 800fbfe:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 800fc00:	6823      	ldr	r3, [r4, #0]
 800fc02:	1b5b      	subs	r3, r3, r5
 800fc04:	d419      	bmi.n	800fc3a <_malloc_r+0x96>
 800fc06:	2b0b      	cmp	r3, #11
 800fc08:	d903      	bls.n	800fc12 <_malloc_r+0x6e>
 800fc0a:	6023      	str	r3, [r4, #0]
 800fc0c:	18e4      	adds	r4, r4, r3
 800fc0e:	6025      	str	r5, [r4, #0]
 800fc10:	e003      	b.n	800fc1a <_malloc_r+0x76>
 800fc12:	6863      	ldr	r3, [r4, #4]
 800fc14:	42a2      	cmp	r2, r4
 800fc16:	d10e      	bne.n	800fc36 <_malloc_r+0x92>
 800fc18:	600b      	str	r3, [r1, #0]
 800fc1a:	0030      	movs	r0, r6
 800fc1c:	f000 f8f4 	bl	800fe08 <__malloc_unlock>
 800fc20:	0020      	movs	r0, r4
 800fc22:	2207      	movs	r2, #7
 800fc24:	300b      	adds	r0, #11
 800fc26:	1d23      	adds	r3, r4, #4
 800fc28:	4390      	bics	r0, r2
 800fc2a:	1ac2      	subs	r2, r0, r3
 800fc2c:	4298      	cmp	r0, r3
 800fc2e:	d0e6      	beq.n	800fbfe <_malloc_r+0x5a>
 800fc30:	1a1b      	subs	r3, r3, r0
 800fc32:	50a3      	str	r3, [r4, r2]
 800fc34:	e7e3      	b.n	800fbfe <_malloc_r+0x5a>
 800fc36:	6053      	str	r3, [r2, #4]
 800fc38:	e7ef      	b.n	800fc1a <_malloc_r+0x76>
 800fc3a:	0022      	movs	r2, r4
 800fc3c:	6864      	ldr	r4, [r4, #4]
 800fc3e:	e7c2      	b.n	800fbc6 <_malloc_r+0x22>
 800fc40:	2303      	movs	r3, #3
 800fc42:	1cc4      	adds	r4, r0, #3
 800fc44:	439c      	bics	r4, r3
 800fc46:	42a0      	cmp	r0, r4
 800fc48:	d0e1      	beq.n	800fc0e <_malloc_r+0x6a>
 800fc4a:	1a21      	subs	r1, r4, r0
 800fc4c:	0030      	movs	r0, r6
 800fc4e:	f000 f807 	bl	800fc60 <_sbrk_r>
 800fc52:	1c43      	adds	r3, r0, #1
 800fc54:	d1db      	bne.n	800fc0e <_malloc_r+0x6a>
 800fc56:	e7c7      	b.n	800fbe8 <_malloc_r+0x44>
 800fc58:	20001a18 	.word	0x20001a18
 800fc5c:	20001a1c 	.word	0x20001a1c

0800fc60 <_sbrk_r>:
 800fc60:	2300      	movs	r3, #0
 800fc62:	b570      	push	{r4, r5, r6, lr}
 800fc64:	4d06      	ldr	r5, [pc, #24]	; (800fc80 <_sbrk_r+0x20>)
 800fc66:	0004      	movs	r4, r0
 800fc68:	0008      	movs	r0, r1
 800fc6a:	602b      	str	r3, [r5, #0]
 800fc6c:	f7f8 ff38 	bl	8008ae0 <_sbrk>
 800fc70:	1c43      	adds	r3, r0, #1
 800fc72:	d103      	bne.n	800fc7c <_sbrk_r+0x1c>
 800fc74:	682b      	ldr	r3, [r5, #0]
 800fc76:	2b00      	cmp	r3, #0
 800fc78:	d000      	beq.n	800fc7c <_sbrk_r+0x1c>
 800fc7a:	6023      	str	r3, [r4, #0]
 800fc7c:	bd70      	pop	{r4, r5, r6, pc}
 800fc7e:	46c0      	nop			; (mov r8, r8)
 800fc80:	200031e0 	.word	0x200031e0

0800fc84 <siprintf>:
 800fc84:	b40e      	push	{r1, r2, r3}
 800fc86:	b500      	push	{lr}
 800fc88:	490b      	ldr	r1, [pc, #44]	; (800fcb8 <siprintf+0x34>)
 800fc8a:	b09c      	sub	sp, #112	; 0x70
 800fc8c:	ab1d      	add	r3, sp, #116	; 0x74
 800fc8e:	9002      	str	r0, [sp, #8]
 800fc90:	9006      	str	r0, [sp, #24]
 800fc92:	9107      	str	r1, [sp, #28]
 800fc94:	9104      	str	r1, [sp, #16]
 800fc96:	4809      	ldr	r0, [pc, #36]	; (800fcbc <siprintf+0x38>)
 800fc98:	4909      	ldr	r1, [pc, #36]	; (800fcc0 <siprintf+0x3c>)
 800fc9a:	cb04      	ldmia	r3!, {r2}
 800fc9c:	9105      	str	r1, [sp, #20]
 800fc9e:	6800      	ldr	r0, [r0, #0]
 800fca0:	a902      	add	r1, sp, #8
 800fca2:	9301      	str	r3, [sp, #4]
 800fca4:	f000 f91a 	bl	800fedc <_svfiprintf_r>
 800fca8:	2300      	movs	r3, #0
 800fcaa:	9a02      	ldr	r2, [sp, #8]
 800fcac:	7013      	strb	r3, [r2, #0]
 800fcae:	b01c      	add	sp, #112	; 0x70
 800fcb0:	bc08      	pop	{r3}
 800fcb2:	b003      	add	sp, #12
 800fcb4:	4718      	bx	r3
 800fcb6:	46c0      	nop			; (mov r8, r8)
 800fcb8:	7fffffff 	.word	0x7fffffff
 800fcbc:	200005d8 	.word	0x200005d8
 800fcc0:	ffff0208 	.word	0xffff0208

0800fcc4 <strchr>:
 800fcc4:	b2c9      	uxtb	r1, r1
 800fcc6:	7803      	ldrb	r3, [r0, #0]
 800fcc8:	2b00      	cmp	r3, #0
 800fcca:	d004      	beq.n	800fcd6 <strchr+0x12>
 800fccc:	428b      	cmp	r3, r1
 800fcce:	d100      	bne.n	800fcd2 <strchr+0xe>
 800fcd0:	4770      	bx	lr
 800fcd2:	3001      	adds	r0, #1
 800fcd4:	e7f7      	b.n	800fcc6 <strchr+0x2>
 800fcd6:	424b      	negs	r3, r1
 800fcd8:	4159      	adcs	r1, r3
 800fcda:	4249      	negs	r1, r1
 800fcdc:	4008      	ands	r0, r1
 800fcde:	e7f7      	b.n	800fcd0 <strchr+0xc>

0800fce0 <strcpy>:
 800fce0:	0003      	movs	r3, r0
 800fce2:	780a      	ldrb	r2, [r1, #0]
 800fce4:	3101      	adds	r1, #1
 800fce6:	701a      	strb	r2, [r3, #0]
 800fce8:	3301      	adds	r3, #1
 800fcea:	2a00      	cmp	r2, #0
 800fcec:	d1f9      	bne.n	800fce2 <strcpy+0x2>
 800fcee:	4770      	bx	lr

0800fcf0 <strstr>:
 800fcf0:	780a      	ldrb	r2, [r1, #0]
 800fcf2:	b530      	push	{r4, r5, lr}
 800fcf4:	2a00      	cmp	r2, #0
 800fcf6:	d10c      	bne.n	800fd12 <strstr+0x22>
 800fcf8:	bd30      	pop	{r4, r5, pc}
 800fcfa:	429a      	cmp	r2, r3
 800fcfc:	d108      	bne.n	800fd10 <strstr+0x20>
 800fcfe:	2301      	movs	r3, #1
 800fd00:	5ccc      	ldrb	r4, [r1, r3]
 800fd02:	2c00      	cmp	r4, #0
 800fd04:	d0f8      	beq.n	800fcf8 <strstr+0x8>
 800fd06:	5cc5      	ldrb	r5, [r0, r3]
 800fd08:	42a5      	cmp	r5, r4
 800fd0a:	d101      	bne.n	800fd10 <strstr+0x20>
 800fd0c:	3301      	adds	r3, #1
 800fd0e:	e7f7      	b.n	800fd00 <strstr+0x10>
 800fd10:	3001      	adds	r0, #1
 800fd12:	7803      	ldrb	r3, [r0, #0]
 800fd14:	2b00      	cmp	r3, #0
 800fd16:	d1f0      	bne.n	800fcfa <strstr+0xa>
 800fd18:	0018      	movs	r0, r3
 800fd1a:	e7ed      	b.n	800fcf8 <strstr+0x8>

0800fd1c <__utoa>:
 800fd1c:	b5f0      	push	{r4, r5, r6, r7, lr}
 800fd1e:	0016      	movs	r6, r2
 800fd20:	b08d      	sub	sp, #52	; 0x34
 800fd22:	0007      	movs	r7, r0
 800fd24:	000c      	movs	r4, r1
 800fd26:	2225      	movs	r2, #37	; 0x25
 800fd28:	4916      	ldr	r1, [pc, #88]	; (800fd84 <__utoa+0x68>)
 800fd2a:	a802      	add	r0, sp, #8
 800fd2c:	f7ff fede 	bl	800faec <memcpy>
 800fd30:	1eb3      	subs	r3, r6, #2
 800fd32:	2500      	movs	r5, #0
 800fd34:	2b22      	cmp	r3, #34	; 0x22
 800fd36:	d820      	bhi.n	800fd7a <__utoa+0x5e>
 800fd38:	1e63      	subs	r3, r4, #1
 800fd3a:	9300      	str	r3, [sp, #0]
 800fd3c:	ab02      	add	r3, sp, #8
 800fd3e:	9301      	str	r3, [sp, #4]
 800fd40:	0038      	movs	r0, r7
 800fd42:	0031      	movs	r1, r6
 800fd44:	f7f8 fa96 	bl	8008274 <__aeabi_uidivmod>
 800fd48:	000b      	movs	r3, r1
 800fd4a:	9a01      	ldr	r2, [sp, #4]
 800fd4c:	0029      	movs	r1, r5
 800fd4e:	5cd3      	ldrb	r3, [r2, r3]
 800fd50:	9a00      	ldr	r2, [sp, #0]
 800fd52:	3501      	adds	r5, #1
 800fd54:	5553      	strb	r3, [r2, r5]
 800fd56:	003b      	movs	r3, r7
 800fd58:	0007      	movs	r7, r0
 800fd5a:	429e      	cmp	r6, r3
 800fd5c:	d9f0      	bls.n	800fd40 <__utoa+0x24>
 800fd5e:	2300      	movs	r3, #0
 800fd60:	0022      	movs	r2, r4
 800fd62:	5563      	strb	r3, [r4, r5]
 800fd64:	000b      	movs	r3, r1
 800fd66:	1ac8      	subs	r0, r1, r3
 800fd68:	4283      	cmp	r3, r0
 800fd6a:	dd08      	ble.n	800fd7e <__utoa+0x62>
 800fd6c:	7810      	ldrb	r0, [r2, #0]
 800fd6e:	5ce5      	ldrb	r5, [r4, r3]
 800fd70:	7015      	strb	r5, [r2, #0]
 800fd72:	54e0      	strb	r0, [r4, r3]
 800fd74:	3201      	adds	r2, #1
 800fd76:	3b01      	subs	r3, #1
 800fd78:	e7f5      	b.n	800fd66 <__utoa+0x4a>
 800fd7a:	7025      	strb	r5, [r4, #0]
 800fd7c:	002c      	movs	r4, r5
 800fd7e:	0020      	movs	r0, r4
 800fd80:	b00d      	add	sp, #52	; 0x34
 800fd82:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800fd84:	08010a3a 	.word	0x08010a3a

0800fd88 <_vsniprintf_r>:
 800fd88:	b530      	push	{r4, r5, lr}
 800fd8a:	0014      	movs	r4, r2
 800fd8c:	0005      	movs	r5, r0
 800fd8e:	001a      	movs	r2, r3
 800fd90:	b09b      	sub	sp, #108	; 0x6c
 800fd92:	2c00      	cmp	r4, #0
 800fd94:	da05      	bge.n	800fda2 <_vsniprintf_r+0x1a>
 800fd96:	238b      	movs	r3, #139	; 0x8b
 800fd98:	6003      	str	r3, [r0, #0]
 800fd9a:	2001      	movs	r0, #1
 800fd9c:	4240      	negs	r0, r0
 800fd9e:	b01b      	add	sp, #108	; 0x6c
 800fda0:	bd30      	pop	{r4, r5, pc}
 800fda2:	2382      	movs	r3, #130	; 0x82
 800fda4:	4668      	mov	r0, sp
 800fda6:	009b      	lsls	r3, r3, #2
 800fda8:	8183      	strh	r3, [r0, #12]
 800fdaa:	2300      	movs	r3, #0
 800fdac:	9100      	str	r1, [sp, #0]
 800fdae:	9104      	str	r1, [sp, #16]
 800fdb0:	429c      	cmp	r4, r3
 800fdb2:	d000      	beq.n	800fdb6 <_vsniprintf_r+0x2e>
 800fdb4:	1e63      	subs	r3, r4, #1
 800fdb6:	9302      	str	r3, [sp, #8]
 800fdb8:	9305      	str	r3, [sp, #20]
 800fdba:	2301      	movs	r3, #1
 800fdbc:	4669      	mov	r1, sp
 800fdbe:	425b      	negs	r3, r3
 800fdc0:	81cb      	strh	r3, [r1, #14]
 800fdc2:	0028      	movs	r0, r5
 800fdc4:	9b1e      	ldr	r3, [sp, #120]	; 0x78
 800fdc6:	f000 f889 	bl	800fedc <_svfiprintf_r>
 800fdca:	1c43      	adds	r3, r0, #1
 800fdcc:	da01      	bge.n	800fdd2 <_vsniprintf_r+0x4a>
 800fdce:	238b      	movs	r3, #139	; 0x8b
 800fdd0:	602b      	str	r3, [r5, #0]
 800fdd2:	2c00      	cmp	r4, #0
 800fdd4:	d0e3      	beq.n	800fd9e <_vsniprintf_r+0x16>
 800fdd6:	2300      	movs	r3, #0
 800fdd8:	9a00      	ldr	r2, [sp, #0]
 800fdda:	7013      	strb	r3, [r2, #0]
 800fddc:	e7df      	b.n	800fd9e <_vsniprintf_r+0x16>
	...

0800fde0 <vsniprintf>:
 800fde0:	b507      	push	{r0, r1, r2, lr}
 800fde2:	9300      	str	r3, [sp, #0]
 800fde4:	0013      	movs	r3, r2
 800fde6:	000a      	movs	r2, r1
 800fde8:	0001      	movs	r1, r0
 800fdea:	4802      	ldr	r0, [pc, #8]	; (800fdf4 <vsniprintf+0x14>)
 800fdec:	6800      	ldr	r0, [r0, #0]
 800fdee:	f7ff ffcb 	bl	800fd88 <_vsniprintf_r>
 800fdf2:	bd0e      	pop	{r1, r2, r3, pc}
 800fdf4:	200005d8 	.word	0x200005d8

0800fdf8 <__malloc_lock>:
 800fdf8:	b510      	push	{r4, lr}
 800fdfa:	4802      	ldr	r0, [pc, #8]	; (800fe04 <__malloc_lock+0xc>)
 800fdfc:	f000 faf0 	bl	80103e0 <__retarget_lock_acquire_recursive>
 800fe00:	bd10      	pop	{r4, pc}
 800fe02:	46c0      	nop			; (mov r8, r8)
 800fe04:	200031e8 	.word	0x200031e8

0800fe08 <__malloc_unlock>:
 800fe08:	b510      	push	{r4, lr}
 800fe0a:	4802      	ldr	r0, [pc, #8]	; (800fe14 <__malloc_unlock+0xc>)
 800fe0c:	f000 fae9 	bl	80103e2 <__retarget_lock_release_recursive>
 800fe10:	bd10      	pop	{r4, pc}
 800fe12:	46c0      	nop			; (mov r8, r8)
 800fe14:	200031e8 	.word	0x200031e8

0800fe18 <__ssputs_r>:
 800fe18:	b5f0      	push	{r4, r5, r6, r7, lr}
 800fe1a:	688e      	ldr	r6, [r1, #8]
 800fe1c:	b085      	sub	sp, #20
 800fe1e:	0007      	movs	r7, r0
 800fe20:	000c      	movs	r4, r1
 800fe22:	9203      	str	r2, [sp, #12]
 800fe24:	9301      	str	r3, [sp, #4]
 800fe26:	429e      	cmp	r6, r3
 800fe28:	d83c      	bhi.n	800fea4 <__ssputs_r+0x8c>
 800fe2a:	2390      	movs	r3, #144	; 0x90
 800fe2c:	898a      	ldrh	r2, [r1, #12]
 800fe2e:	00db      	lsls	r3, r3, #3
 800fe30:	421a      	tst	r2, r3
 800fe32:	d034      	beq.n	800fe9e <__ssputs_r+0x86>
 800fe34:	2503      	movs	r5, #3
 800fe36:	6909      	ldr	r1, [r1, #16]
 800fe38:	6823      	ldr	r3, [r4, #0]
 800fe3a:	1a5b      	subs	r3, r3, r1
 800fe3c:	9302      	str	r3, [sp, #8]
 800fe3e:	6963      	ldr	r3, [r4, #20]
 800fe40:	9802      	ldr	r0, [sp, #8]
 800fe42:	435d      	muls	r5, r3
 800fe44:	0feb      	lsrs	r3, r5, #31
 800fe46:	195d      	adds	r5, r3, r5
 800fe48:	9b01      	ldr	r3, [sp, #4]
 800fe4a:	106d      	asrs	r5, r5, #1
 800fe4c:	3301      	adds	r3, #1
 800fe4e:	181b      	adds	r3, r3, r0
 800fe50:	42ab      	cmp	r3, r5
 800fe52:	d900      	bls.n	800fe56 <__ssputs_r+0x3e>
 800fe54:	001d      	movs	r5, r3
 800fe56:	0553      	lsls	r3, r2, #21
 800fe58:	d532      	bpl.n	800fec0 <__ssputs_r+0xa8>
 800fe5a:	0029      	movs	r1, r5
 800fe5c:	0038      	movs	r0, r7
 800fe5e:	f7ff fea1 	bl	800fba4 <_malloc_r>
 800fe62:	1e06      	subs	r6, r0, #0
 800fe64:	d109      	bne.n	800fe7a <__ssputs_r+0x62>
 800fe66:	230c      	movs	r3, #12
 800fe68:	603b      	str	r3, [r7, #0]
 800fe6a:	2340      	movs	r3, #64	; 0x40
 800fe6c:	2001      	movs	r0, #1
 800fe6e:	89a2      	ldrh	r2, [r4, #12]
 800fe70:	4240      	negs	r0, r0
 800fe72:	4313      	orrs	r3, r2
 800fe74:	81a3      	strh	r3, [r4, #12]
 800fe76:	b005      	add	sp, #20
 800fe78:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800fe7a:	9a02      	ldr	r2, [sp, #8]
 800fe7c:	6921      	ldr	r1, [r4, #16]
 800fe7e:	f7ff fe35 	bl	800faec <memcpy>
 800fe82:	89a3      	ldrh	r3, [r4, #12]
 800fe84:	4a14      	ldr	r2, [pc, #80]	; (800fed8 <__ssputs_r+0xc0>)
 800fe86:	401a      	ands	r2, r3
 800fe88:	2380      	movs	r3, #128	; 0x80
 800fe8a:	4313      	orrs	r3, r2
 800fe8c:	81a3      	strh	r3, [r4, #12]
 800fe8e:	9b02      	ldr	r3, [sp, #8]
 800fe90:	6126      	str	r6, [r4, #16]
 800fe92:	18f6      	adds	r6, r6, r3
 800fe94:	6026      	str	r6, [r4, #0]
 800fe96:	6165      	str	r5, [r4, #20]
 800fe98:	9e01      	ldr	r6, [sp, #4]
 800fe9a:	1aed      	subs	r5, r5, r3
 800fe9c:	60a5      	str	r5, [r4, #8]
 800fe9e:	9b01      	ldr	r3, [sp, #4]
 800fea0:	429e      	cmp	r6, r3
 800fea2:	d900      	bls.n	800fea6 <__ssputs_r+0x8e>
 800fea4:	9e01      	ldr	r6, [sp, #4]
 800fea6:	0032      	movs	r2, r6
 800fea8:	9903      	ldr	r1, [sp, #12]
 800feaa:	6820      	ldr	r0, [r4, #0]
 800feac:	f000 faa5 	bl	80103fa <memmove>
 800feb0:	68a3      	ldr	r3, [r4, #8]
 800feb2:	2000      	movs	r0, #0
 800feb4:	1b9b      	subs	r3, r3, r6
 800feb6:	60a3      	str	r3, [r4, #8]
 800feb8:	6823      	ldr	r3, [r4, #0]
 800feba:	199e      	adds	r6, r3, r6
 800febc:	6026      	str	r6, [r4, #0]
 800febe:	e7da      	b.n	800fe76 <__ssputs_r+0x5e>
 800fec0:	002a      	movs	r2, r5
 800fec2:	0038      	movs	r0, r7
 800fec4:	f000 faac 	bl	8010420 <_realloc_r>
 800fec8:	1e06      	subs	r6, r0, #0
 800feca:	d1e0      	bne.n	800fe8e <__ssputs_r+0x76>
 800fecc:	0038      	movs	r0, r7
 800fece:	6921      	ldr	r1, [r4, #16]
 800fed0:	f7ff fe1e 	bl	800fb10 <_free_r>
 800fed4:	e7c7      	b.n	800fe66 <__ssputs_r+0x4e>
 800fed6:	46c0      	nop			; (mov r8, r8)
 800fed8:	fffffb7f 	.word	0xfffffb7f

0800fedc <_svfiprintf_r>:
 800fedc:	b5f0      	push	{r4, r5, r6, r7, lr}
 800fede:	b0a1      	sub	sp, #132	; 0x84
 800fee0:	9003      	str	r0, [sp, #12]
 800fee2:	001d      	movs	r5, r3
 800fee4:	898b      	ldrh	r3, [r1, #12]
 800fee6:	000f      	movs	r7, r1
 800fee8:	0016      	movs	r6, r2
 800feea:	061b      	lsls	r3, r3, #24
 800feec:	d511      	bpl.n	800ff12 <_svfiprintf_r+0x36>
 800feee:	690b      	ldr	r3, [r1, #16]
 800fef0:	2b00      	cmp	r3, #0
 800fef2:	d10e      	bne.n	800ff12 <_svfiprintf_r+0x36>
 800fef4:	2140      	movs	r1, #64	; 0x40
 800fef6:	f7ff fe55 	bl	800fba4 <_malloc_r>
 800fefa:	6038      	str	r0, [r7, #0]
 800fefc:	6138      	str	r0, [r7, #16]
 800fefe:	2800      	cmp	r0, #0
 800ff00:	d105      	bne.n	800ff0e <_svfiprintf_r+0x32>
 800ff02:	230c      	movs	r3, #12
 800ff04:	9a03      	ldr	r2, [sp, #12]
 800ff06:	3801      	subs	r0, #1
 800ff08:	6013      	str	r3, [r2, #0]
 800ff0a:	b021      	add	sp, #132	; 0x84
 800ff0c:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800ff0e:	2340      	movs	r3, #64	; 0x40
 800ff10:	617b      	str	r3, [r7, #20]
 800ff12:	2300      	movs	r3, #0
 800ff14:	ac08      	add	r4, sp, #32
 800ff16:	6163      	str	r3, [r4, #20]
 800ff18:	3320      	adds	r3, #32
 800ff1a:	7663      	strb	r3, [r4, #25]
 800ff1c:	3310      	adds	r3, #16
 800ff1e:	76a3      	strb	r3, [r4, #26]
 800ff20:	9507      	str	r5, [sp, #28]
 800ff22:	0035      	movs	r5, r6
 800ff24:	782b      	ldrb	r3, [r5, #0]
 800ff26:	2b00      	cmp	r3, #0
 800ff28:	d001      	beq.n	800ff2e <_svfiprintf_r+0x52>
 800ff2a:	2b25      	cmp	r3, #37	; 0x25
 800ff2c:	d147      	bne.n	800ffbe <_svfiprintf_r+0xe2>
 800ff2e:	1bab      	subs	r3, r5, r6
 800ff30:	9305      	str	r3, [sp, #20]
 800ff32:	42b5      	cmp	r5, r6
 800ff34:	d00c      	beq.n	800ff50 <_svfiprintf_r+0x74>
 800ff36:	0032      	movs	r2, r6
 800ff38:	0039      	movs	r1, r7
 800ff3a:	9803      	ldr	r0, [sp, #12]
 800ff3c:	f7ff ff6c 	bl	800fe18 <__ssputs_r>
 800ff40:	1c43      	adds	r3, r0, #1
 800ff42:	d100      	bne.n	800ff46 <_svfiprintf_r+0x6a>
 800ff44:	e0ae      	b.n	80100a4 <_svfiprintf_r+0x1c8>
 800ff46:	6962      	ldr	r2, [r4, #20]
 800ff48:	9b05      	ldr	r3, [sp, #20]
 800ff4a:	4694      	mov	ip, r2
 800ff4c:	4463      	add	r3, ip
 800ff4e:	6163      	str	r3, [r4, #20]
 800ff50:	782b      	ldrb	r3, [r5, #0]
 800ff52:	2b00      	cmp	r3, #0
 800ff54:	d100      	bne.n	800ff58 <_svfiprintf_r+0x7c>
 800ff56:	e0a5      	b.n	80100a4 <_svfiprintf_r+0x1c8>
 800ff58:	2201      	movs	r2, #1
 800ff5a:	2300      	movs	r3, #0
 800ff5c:	4252      	negs	r2, r2
 800ff5e:	6062      	str	r2, [r4, #4]
 800ff60:	a904      	add	r1, sp, #16
 800ff62:	3254      	adds	r2, #84	; 0x54
 800ff64:	1852      	adds	r2, r2, r1
 800ff66:	1c6e      	adds	r6, r5, #1
 800ff68:	6023      	str	r3, [r4, #0]
 800ff6a:	60e3      	str	r3, [r4, #12]
 800ff6c:	60a3      	str	r3, [r4, #8]
 800ff6e:	7013      	strb	r3, [r2, #0]
 800ff70:	65a3      	str	r3, [r4, #88]	; 0x58
 800ff72:	2205      	movs	r2, #5
 800ff74:	7831      	ldrb	r1, [r6, #0]
 800ff76:	4854      	ldr	r0, [pc, #336]	; (80100c8 <_svfiprintf_r+0x1ec>)
 800ff78:	f000 fa34 	bl	80103e4 <memchr>
 800ff7c:	1c75      	adds	r5, r6, #1
 800ff7e:	2800      	cmp	r0, #0
 800ff80:	d11f      	bne.n	800ffc2 <_svfiprintf_r+0xe6>
 800ff82:	6822      	ldr	r2, [r4, #0]
 800ff84:	06d3      	lsls	r3, r2, #27
 800ff86:	d504      	bpl.n	800ff92 <_svfiprintf_r+0xb6>
 800ff88:	2353      	movs	r3, #83	; 0x53
 800ff8a:	a904      	add	r1, sp, #16
 800ff8c:	185b      	adds	r3, r3, r1
 800ff8e:	2120      	movs	r1, #32
 800ff90:	7019      	strb	r1, [r3, #0]
 800ff92:	0713      	lsls	r3, r2, #28
 800ff94:	d504      	bpl.n	800ffa0 <_svfiprintf_r+0xc4>
 800ff96:	2353      	movs	r3, #83	; 0x53
 800ff98:	a904      	add	r1, sp, #16
 800ff9a:	185b      	adds	r3, r3, r1
 800ff9c:	212b      	movs	r1, #43	; 0x2b
 800ff9e:	7019      	strb	r1, [r3, #0]
 800ffa0:	7833      	ldrb	r3, [r6, #0]
 800ffa2:	2b2a      	cmp	r3, #42	; 0x2a
 800ffa4:	d016      	beq.n	800ffd4 <_svfiprintf_r+0xf8>
 800ffa6:	0035      	movs	r5, r6
 800ffa8:	2100      	movs	r1, #0
 800ffaa:	200a      	movs	r0, #10
 800ffac:	68e3      	ldr	r3, [r4, #12]
 800ffae:	782a      	ldrb	r2, [r5, #0]
 800ffb0:	1c6e      	adds	r6, r5, #1
 800ffb2:	3a30      	subs	r2, #48	; 0x30
 800ffb4:	2a09      	cmp	r2, #9
 800ffb6:	d94e      	bls.n	8010056 <_svfiprintf_r+0x17a>
 800ffb8:	2900      	cmp	r1, #0
 800ffba:	d111      	bne.n	800ffe0 <_svfiprintf_r+0x104>
 800ffbc:	e017      	b.n	800ffee <_svfiprintf_r+0x112>
 800ffbe:	3501      	adds	r5, #1
 800ffc0:	e7b0      	b.n	800ff24 <_svfiprintf_r+0x48>
 800ffc2:	4b41      	ldr	r3, [pc, #260]	; (80100c8 <_svfiprintf_r+0x1ec>)
 800ffc4:	6822      	ldr	r2, [r4, #0]
 800ffc6:	1ac0      	subs	r0, r0, r3
 800ffc8:	2301      	movs	r3, #1
 800ffca:	4083      	lsls	r3, r0
 800ffcc:	4313      	orrs	r3, r2
 800ffce:	002e      	movs	r6, r5
 800ffd0:	6023      	str	r3, [r4, #0]
 800ffd2:	e7ce      	b.n	800ff72 <_svfiprintf_r+0x96>
 800ffd4:	9b07      	ldr	r3, [sp, #28]
 800ffd6:	1d19      	adds	r1, r3, #4
 800ffd8:	681b      	ldr	r3, [r3, #0]
 800ffda:	9107      	str	r1, [sp, #28]
 800ffdc:	2b00      	cmp	r3, #0
 800ffde:	db01      	blt.n	800ffe4 <_svfiprintf_r+0x108>
 800ffe0:	930b      	str	r3, [sp, #44]	; 0x2c
 800ffe2:	e004      	b.n	800ffee <_svfiprintf_r+0x112>
 800ffe4:	425b      	negs	r3, r3
 800ffe6:	60e3      	str	r3, [r4, #12]
 800ffe8:	2302      	movs	r3, #2
 800ffea:	4313      	orrs	r3, r2
 800ffec:	6023      	str	r3, [r4, #0]
 800ffee:	782b      	ldrb	r3, [r5, #0]
 800fff0:	2b2e      	cmp	r3, #46	; 0x2e
 800fff2:	d10a      	bne.n	801000a <_svfiprintf_r+0x12e>
 800fff4:	786b      	ldrb	r3, [r5, #1]
 800fff6:	2b2a      	cmp	r3, #42	; 0x2a
 800fff8:	d135      	bne.n	8010066 <_svfiprintf_r+0x18a>
 800fffa:	9b07      	ldr	r3, [sp, #28]
 800fffc:	3502      	adds	r5, #2
 800fffe:	1d1a      	adds	r2, r3, #4
 8010000:	681b      	ldr	r3, [r3, #0]
 8010002:	9207      	str	r2, [sp, #28]
 8010004:	2b00      	cmp	r3, #0
 8010006:	db2b      	blt.n	8010060 <_svfiprintf_r+0x184>
 8010008:	9309      	str	r3, [sp, #36]	; 0x24
 801000a:	4e30      	ldr	r6, [pc, #192]	; (80100cc <_svfiprintf_r+0x1f0>)
 801000c:	2203      	movs	r2, #3
 801000e:	0030      	movs	r0, r6
 8010010:	7829      	ldrb	r1, [r5, #0]
 8010012:	f000 f9e7 	bl	80103e4 <memchr>
 8010016:	2800      	cmp	r0, #0
 8010018:	d006      	beq.n	8010028 <_svfiprintf_r+0x14c>
 801001a:	2340      	movs	r3, #64	; 0x40
 801001c:	1b80      	subs	r0, r0, r6
 801001e:	4083      	lsls	r3, r0
 8010020:	6822      	ldr	r2, [r4, #0]
 8010022:	3501      	adds	r5, #1
 8010024:	4313      	orrs	r3, r2
 8010026:	6023      	str	r3, [r4, #0]
 8010028:	7829      	ldrb	r1, [r5, #0]
 801002a:	2206      	movs	r2, #6
 801002c:	4828      	ldr	r0, [pc, #160]	; (80100d0 <_svfiprintf_r+0x1f4>)
 801002e:	1c6e      	adds	r6, r5, #1
 8010030:	7621      	strb	r1, [r4, #24]
 8010032:	f000 f9d7 	bl	80103e4 <memchr>
 8010036:	2800      	cmp	r0, #0
 8010038:	d03c      	beq.n	80100b4 <_svfiprintf_r+0x1d8>
 801003a:	4b26      	ldr	r3, [pc, #152]	; (80100d4 <_svfiprintf_r+0x1f8>)
 801003c:	2b00      	cmp	r3, #0
 801003e:	d125      	bne.n	801008c <_svfiprintf_r+0x1b0>
 8010040:	2207      	movs	r2, #7
 8010042:	9b07      	ldr	r3, [sp, #28]
 8010044:	3307      	adds	r3, #7
 8010046:	4393      	bics	r3, r2
 8010048:	3308      	adds	r3, #8
 801004a:	9307      	str	r3, [sp, #28]
 801004c:	6963      	ldr	r3, [r4, #20]
 801004e:	9a04      	ldr	r2, [sp, #16]
 8010050:	189b      	adds	r3, r3, r2
 8010052:	6163      	str	r3, [r4, #20]
 8010054:	e765      	b.n	800ff22 <_svfiprintf_r+0x46>
 8010056:	4343      	muls	r3, r0
 8010058:	0035      	movs	r5, r6
 801005a:	2101      	movs	r1, #1
 801005c:	189b      	adds	r3, r3, r2
 801005e:	e7a6      	b.n	800ffae <_svfiprintf_r+0xd2>
 8010060:	2301      	movs	r3, #1
 8010062:	425b      	negs	r3, r3
 8010064:	e7d0      	b.n	8010008 <_svfiprintf_r+0x12c>
 8010066:	2300      	movs	r3, #0
 8010068:	200a      	movs	r0, #10
 801006a:	001a      	movs	r2, r3
 801006c:	3501      	adds	r5, #1
 801006e:	6063      	str	r3, [r4, #4]
 8010070:	7829      	ldrb	r1, [r5, #0]
 8010072:	1c6e      	adds	r6, r5, #1
 8010074:	3930      	subs	r1, #48	; 0x30
 8010076:	2909      	cmp	r1, #9
 8010078:	d903      	bls.n	8010082 <_svfiprintf_r+0x1a6>
 801007a:	2b00      	cmp	r3, #0
 801007c:	d0c5      	beq.n	801000a <_svfiprintf_r+0x12e>
 801007e:	9209      	str	r2, [sp, #36]	; 0x24
 8010080:	e7c3      	b.n	801000a <_svfiprintf_r+0x12e>
 8010082:	4342      	muls	r2, r0
 8010084:	0035      	movs	r5, r6
 8010086:	2301      	movs	r3, #1
 8010088:	1852      	adds	r2, r2, r1
 801008a:	e7f1      	b.n	8010070 <_svfiprintf_r+0x194>
 801008c:	ab07      	add	r3, sp, #28
 801008e:	9300      	str	r3, [sp, #0]
 8010090:	003a      	movs	r2, r7
 8010092:	0021      	movs	r1, r4
 8010094:	4b10      	ldr	r3, [pc, #64]	; (80100d8 <_svfiprintf_r+0x1fc>)
 8010096:	9803      	ldr	r0, [sp, #12]
 8010098:	e000      	b.n	801009c <_svfiprintf_r+0x1c0>
 801009a:	bf00      	nop
 801009c:	9004      	str	r0, [sp, #16]
 801009e:	9b04      	ldr	r3, [sp, #16]
 80100a0:	3301      	adds	r3, #1
 80100a2:	d1d3      	bne.n	801004c <_svfiprintf_r+0x170>
 80100a4:	89bb      	ldrh	r3, [r7, #12]
 80100a6:	980d      	ldr	r0, [sp, #52]	; 0x34
 80100a8:	065b      	lsls	r3, r3, #25
 80100aa:	d400      	bmi.n	80100ae <_svfiprintf_r+0x1d2>
 80100ac:	e72d      	b.n	800ff0a <_svfiprintf_r+0x2e>
 80100ae:	2001      	movs	r0, #1
 80100b0:	4240      	negs	r0, r0
 80100b2:	e72a      	b.n	800ff0a <_svfiprintf_r+0x2e>
 80100b4:	ab07      	add	r3, sp, #28
 80100b6:	9300      	str	r3, [sp, #0]
 80100b8:	003a      	movs	r2, r7
 80100ba:	0021      	movs	r1, r4
 80100bc:	4b06      	ldr	r3, [pc, #24]	; (80100d8 <_svfiprintf_r+0x1fc>)
 80100be:	9803      	ldr	r0, [sp, #12]
 80100c0:	f000 f87c 	bl	80101bc <_printf_i>
 80100c4:	e7ea      	b.n	801009c <_svfiprintf_r+0x1c0>
 80100c6:	46c0      	nop			; (mov r8, r8)
 80100c8:	08010a5f 	.word	0x08010a5f
 80100cc:	08010a65 	.word	0x08010a65
 80100d0:	08010a69 	.word	0x08010a69
 80100d4:	00000000 	.word	0x00000000
 80100d8:	0800fe19 	.word	0x0800fe19

080100dc <_printf_common>:
 80100dc:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
 80100de:	0015      	movs	r5, r2
 80100e0:	9301      	str	r3, [sp, #4]
 80100e2:	688a      	ldr	r2, [r1, #8]
 80100e4:	690b      	ldr	r3, [r1, #16]
 80100e6:	000c      	movs	r4, r1
 80100e8:	9000      	str	r0, [sp, #0]
 80100ea:	4293      	cmp	r3, r2
 80100ec:	da00      	bge.n	80100f0 <_printf_common+0x14>
 80100ee:	0013      	movs	r3, r2
 80100f0:	0022      	movs	r2, r4
 80100f2:	602b      	str	r3, [r5, #0]
 80100f4:	3243      	adds	r2, #67	; 0x43
 80100f6:	7812      	ldrb	r2, [r2, #0]
 80100f8:	2a00      	cmp	r2, #0
 80100fa:	d001      	beq.n	8010100 <_printf_common+0x24>
 80100fc:	3301      	adds	r3, #1
 80100fe:	602b      	str	r3, [r5, #0]
 8010100:	6823      	ldr	r3, [r4, #0]
 8010102:	069b      	lsls	r3, r3, #26
 8010104:	d502      	bpl.n	801010c <_printf_common+0x30>
 8010106:	682b      	ldr	r3, [r5, #0]
 8010108:	3302      	adds	r3, #2
 801010a:	602b      	str	r3, [r5, #0]
 801010c:	6822      	ldr	r2, [r4, #0]
 801010e:	2306      	movs	r3, #6
 8010110:	0017      	movs	r7, r2
 8010112:	401f      	ands	r7, r3
 8010114:	421a      	tst	r2, r3
 8010116:	d027      	beq.n	8010168 <_printf_common+0x8c>
 8010118:	0023      	movs	r3, r4
 801011a:	3343      	adds	r3, #67	; 0x43
 801011c:	781b      	ldrb	r3, [r3, #0]
 801011e:	1e5a      	subs	r2, r3, #1
 8010120:	4193      	sbcs	r3, r2
 8010122:	6822      	ldr	r2, [r4, #0]
 8010124:	0692      	lsls	r2, r2, #26
 8010126:	d430      	bmi.n	801018a <_printf_common+0xae>
 8010128:	0022      	movs	r2, r4
 801012a:	9901      	ldr	r1, [sp, #4]
 801012c:	9800      	ldr	r0, [sp, #0]
 801012e:	9e08      	ldr	r6, [sp, #32]
 8010130:	3243      	adds	r2, #67	; 0x43
 8010132:	47b0      	blx	r6
 8010134:	1c43      	adds	r3, r0, #1
 8010136:	d025      	beq.n	8010184 <_printf_common+0xa8>
 8010138:	2306      	movs	r3, #6
 801013a:	6820      	ldr	r0, [r4, #0]
 801013c:	682a      	ldr	r2, [r5, #0]
 801013e:	68e1      	ldr	r1, [r4, #12]
 8010140:	2500      	movs	r5, #0
 8010142:	4003      	ands	r3, r0
 8010144:	2b04      	cmp	r3, #4
 8010146:	d103      	bne.n	8010150 <_printf_common+0x74>
 8010148:	1a8d      	subs	r5, r1, r2
 801014a:	43eb      	mvns	r3, r5
 801014c:	17db      	asrs	r3, r3, #31
 801014e:	401d      	ands	r5, r3
 8010150:	68a3      	ldr	r3, [r4, #8]
 8010152:	6922      	ldr	r2, [r4, #16]
 8010154:	4293      	cmp	r3, r2
 8010156:	dd01      	ble.n	801015c <_printf_common+0x80>
 8010158:	1a9b      	subs	r3, r3, r2
 801015a:	18ed      	adds	r5, r5, r3
 801015c:	2700      	movs	r7, #0
 801015e:	42bd      	cmp	r5, r7
 8010160:	d120      	bne.n	80101a4 <_printf_common+0xc8>
 8010162:	2000      	movs	r0, #0
 8010164:	e010      	b.n	8010188 <_printf_common+0xac>
 8010166:	3701      	adds	r7, #1
 8010168:	68e3      	ldr	r3, [r4, #12]
 801016a:	682a      	ldr	r2, [r5, #0]
 801016c:	1a9b      	subs	r3, r3, r2
 801016e:	42bb      	cmp	r3, r7
 8010170:	ddd2      	ble.n	8010118 <_printf_common+0x3c>
 8010172:	0022      	movs	r2, r4
 8010174:	2301      	movs	r3, #1
 8010176:	9901      	ldr	r1, [sp, #4]
 8010178:	9800      	ldr	r0, [sp, #0]
 801017a:	9e08      	ldr	r6, [sp, #32]
 801017c:	3219      	adds	r2, #25
 801017e:	47b0      	blx	r6
 8010180:	1c43      	adds	r3, r0, #1
 8010182:	d1f0      	bne.n	8010166 <_printf_common+0x8a>
 8010184:	2001      	movs	r0, #1
 8010186:	4240      	negs	r0, r0
 8010188:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
 801018a:	2030      	movs	r0, #48	; 0x30
 801018c:	18e1      	adds	r1, r4, r3
 801018e:	3143      	adds	r1, #67	; 0x43
 8010190:	7008      	strb	r0, [r1, #0]
 8010192:	0021      	movs	r1, r4
 8010194:	1c5a      	adds	r2, r3, #1
 8010196:	3145      	adds	r1, #69	; 0x45
 8010198:	7809      	ldrb	r1, [r1, #0]
 801019a:	18a2      	adds	r2, r4, r2
 801019c:	3243      	adds	r2, #67	; 0x43
 801019e:	3302      	adds	r3, #2
 80101a0:	7011      	strb	r1, [r2, #0]
 80101a2:	e7c1      	b.n	8010128 <_printf_common+0x4c>
 80101a4:	0022      	movs	r2, r4
 80101a6:	2301      	movs	r3, #1
 80101a8:	9901      	ldr	r1, [sp, #4]
 80101aa:	9800      	ldr	r0, [sp, #0]
 80101ac:	9e08      	ldr	r6, [sp, #32]
 80101ae:	321a      	adds	r2, #26
 80101b0:	47b0      	blx	r6
 80101b2:	1c43      	adds	r3, r0, #1
 80101b4:	d0e6      	beq.n	8010184 <_printf_common+0xa8>
 80101b6:	3701      	adds	r7, #1
 80101b8:	e7d1      	b.n	801015e <_printf_common+0x82>
	...

080101bc <_printf_i>:
 80101bc:	b5f0      	push	{r4, r5, r6, r7, lr}
 80101be:	b08b      	sub	sp, #44	; 0x2c
 80101c0:	9206      	str	r2, [sp, #24]
 80101c2:	000a      	movs	r2, r1
 80101c4:	3243      	adds	r2, #67	; 0x43
 80101c6:	9307      	str	r3, [sp, #28]
 80101c8:	9005      	str	r0, [sp, #20]
 80101ca:	9204      	str	r2, [sp, #16]
 80101cc:	7e0a      	ldrb	r2, [r1, #24]
 80101ce:	000c      	movs	r4, r1
 80101d0:	9b10      	ldr	r3, [sp, #64]	; 0x40
 80101d2:	2a78      	cmp	r2, #120	; 0x78
 80101d4:	d806      	bhi.n	80101e4 <_printf_i+0x28>
 80101d6:	2a62      	cmp	r2, #98	; 0x62
 80101d8:	d808      	bhi.n	80101ec <_printf_i+0x30>
 80101da:	2a00      	cmp	r2, #0
 80101dc:	d100      	bne.n	80101e0 <_printf_i+0x24>
 80101de:	e0c0      	b.n	8010362 <_printf_i+0x1a6>
 80101e0:	2a58      	cmp	r2, #88	; 0x58
 80101e2:	d052      	beq.n	801028a <_printf_i+0xce>
 80101e4:	0026      	movs	r6, r4
 80101e6:	3642      	adds	r6, #66	; 0x42
 80101e8:	7032      	strb	r2, [r6, #0]
 80101ea:	e022      	b.n	8010232 <_printf_i+0x76>
 80101ec:	0010      	movs	r0, r2
 80101ee:	3863      	subs	r0, #99	; 0x63
 80101f0:	2815      	cmp	r0, #21
 80101f2:	d8f7      	bhi.n	80101e4 <_printf_i+0x28>
 80101f4:	f7f7 ffa4 	bl	8008140 <__gnu_thumb1_case_shi>
 80101f8:	001f0016 	.word	0x001f0016
 80101fc:	fff6fff6 	.word	0xfff6fff6
 8010200:	fff6fff6 	.word	0xfff6fff6
 8010204:	fff6001f 	.word	0xfff6001f
 8010208:	fff6fff6 	.word	0xfff6fff6
 801020c:	00a8fff6 	.word	0x00a8fff6
 8010210:	009a0036 	.word	0x009a0036
 8010214:	fff6fff6 	.word	0xfff6fff6
 8010218:	fff600b9 	.word	0xfff600b9
 801021c:	fff60036 	.word	0xfff60036
 8010220:	009efff6 	.word	0x009efff6
 8010224:	0026      	movs	r6, r4
 8010226:	681a      	ldr	r2, [r3, #0]
 8010228:	3642      	adds	r6, #66	; 0x42
 801022a:	1d11      	adds	r1, r2, #4
 801022c:	6019      	str	r1, [r3, #0]
 801022e:	6813      	ldr	r3, [r2, #0]
 8010230:	7033      	strb	r3, [r6, #0]
 8010232:	2301      	movs	r3, #1
 8010234:	e0a7      	b.n	8010386 <_printf_i+0x1ca>
 8010236:	6808      	ldr	r0, [r1, #0]
 8010238:	6819      	ldr	r1, [r3, #0]
 801023a:	1d0a      	adds	r2, r1, #4
 801023c:	0605      	lsls	r5, r0, #24
 801023e:	d50b      	bpl.n	8010258 <_printf_i+0x9c>
 8010240:	680d      	ldr	r5, [r1, #0]
 8010242:	601a      	str	r2, [r3, #0]
 8010244:	2d00      	cmp	r5, #0
 8010246:	da03      	bge.n	8010250 <_printf_i+0x94>
 8010248:	232d      	movs	r3, #45	; 0x2d
 801024a:	9a04      	ldr	r2, [sp, #16]
 801024c:	426d      	negs	r5, r5
 801024e:	7013      	strb	r3, [r2, #0]
 8010250:	4b61      	ldr	r3, [pc, #388]	; (80103d8 <_printf_i+0x21c>)
 8010252:	270a      	movs	r7, #10
 8010254:	9303      	str	r3, [sp, #12]
 8010256:	e032      	b.n	80102be <_printf_i+0x102>
 8010258:	680d      	ldr	r5, [r1, #0]
 801025a:	601a      	str	r2, [r3, #0]
 801025c:	0641      	lsls	r1, r0, #25
 801025e:	d5f1      	bpl.n	8010244 <_printf_i+0x88>
 8010260:	b22d      	sxth	r5, r5
 8010262:	e7ef      	b.n	8010244 <_printf_i+0x88>
 8010264:	680d      	ldr	r5, [r1, #0]
 8010266:	6819      	ldr	r1, [r3, #0]
 8010268:	1d08      	adds	r0, r1, #4
 801026a:	6018      	str	r0, [r3, #0]
 801026c:	062e      	lsls	r6, r5, #24
 801026e:	d501      	bpl.n	8010274 <_printf_i+0xb8>
 8010270:	680d      	ldr	r5, [r1, #0]
 8010272:	e003      	b.n	801027c <_printf_i+0xc0>
 8010274:	066d      	lsls	r5, r5, #25
 8010276:	d5fb      	bpl.n	8010270 <_printf_i+0xb4>
 8010278:	680d      	ldr	r5, [r1, #0]
 801027a:	b2ad      	uxth	r5, r5
 801027c:	4b56      	ldr	r3, [pc, #344]	; (80103d8 <_printf_i+0x21c>)
 801027e:	270a      	movs	r7, #10
 8010280:	9303      	str	r3, [sp, #12]
 8010282:	2a6f      	cmp	r2, #111	; 0x6f
 8010284:	d117      	bne.n	80102b6 <_printf_i+0xfa>
 8010286:	2708      	movs	r7, #8
 8010288:	e015      	b.n	80102b6 <_printf_i+0xfa>
 801028a:	3145      	adds	r1, #69	; 0x45
 801028c:	700a      	strb	r2, [r1, #0]
 801028e:	4a52      	ldr	r2, [pc, #328]	; (80103d8 <_printf_i+0x21c>)
 8010290:	9203      	str	r2, [sp, #12]
 8010292:	681a      	ldr	r2, [r3, #0]
 8010294:	6821      	ldr	r1, [r4, #0]
 8010296:	ca20      	ldmia	r2!, {r5}
 8010298:	601a      	str	r2, [r3, #0]
 801029a:	0608      	lsls	r0, r1, #24
 801029c:	d550      	bpl.n	8010340 <_printf_i+0x184>
 801029e:	07cb      	lsls	r3, r1, #31
 80102a0:	d502      	bpl.n	80102a8 <_printf_i+0xec>
 80102a2:	2320      	movs	r3, #32
 80102a4:	4319      	orrs	r1, r3
 80102a6:	6021      	str	r1, [r4, #0]
 80102a8:	2710      	movs	r7, #16
 80102aa:	2d00      	cmp	r5, #0
 80102ac:	d103      	bne.n	80102b6 <_printf_i+0xfa>
 80102ae:	2320      	movs	r3, #32
 80102b0:	6822      	ldr	r2, [r4, #0]
 80102b2:	439a      	bics	r2, r3
 80102b4:	6022      	str	r2, [r4, #0]
 80102b6:	0023      	movs	r3, r4
 80102b8:	2200      	movs	r2, #0
 80102ba:	3343      	adds	r3, #67	; 0x43
 80102bc:	701a      	strb	r2, [r3, #0]
 80102be:	6863      	ldr	r3, [r4, #4]
 80102c0:	60a3      	str	r3, [r4, #8]
 80102c2:	2b00      	cmp	r3, #0
 80102c4:	db03      	blt.n	80102ce <_printf_i+0x112>
 80102c6:	2204      	movs	r2, #4
 80102c8:	6821      	ldr	r1, [r4, #0]
 80102ca:	4391      	bics	r1, r2
 80102cc:	6021      	str	r1, [r4, #0]
 80102ce:	2d00      	cmp	r5, #0
 80102d0:	d102      	bne.n	80102d8 <_printf_i+0x11c>
 80102d2:	9e04      	ldr	r6, [sp, #16]
 80102d4:	2b00      	cmp	r3, #0
 80102d6:	d00c      	beq.n	80102f2 <_printf_i+0x136>
 80102d8:	9e04      	ldr	r6, [sp, #16]
 80102da:	0028      	movs	r0, r5
 80102dc:	0039      	movs	r1, r7
 80102de:	f7f7 ffc9 	bl	8008274 <__aeabi_uidivmod>
 80102e2:	9b03      	ldr	r3, [sp, #12]
 80102e4:	3e01      	subs	r6, #1
 80102e6:	5c5b      	ldrb	r3, [r3, r1]
 80102e8:	7033      	strb	r3, [r6, #0]
 80102ea:	002b      	movs	r3, r5
 80102ec:	0005      	movs	r5, r0
 80102ee:	429f      	cmp	r7, r3
 80102f0:	d9f3      	bls.n	80102da <_printf_i+0x11e>
 80102f2:	2f08      	cmp	r7, #8
 80102f4:	d109      	bne.n	801030a <_printf_i+0x14e>
 80102f6:	6823      	ldr	r3, [r4, #0]
 80102f8:	07db      	lsls	r3, r3, #31
 80102fa:	d506      	bpl.n	801030a <_printf_i+0x14e>
 80102fc:	6863      	ldr	r3, [r4, #4]
 80102fe:	6922      	ldr	r2, [r4, #16]
 8010300:	4293      	cmp	r3, r2
 8010302:	dc02      	bgt.n	801030a <_printf_i+0x14e>
 8010304:	2330      	movs	r3, #48	; 0x30
 8010306:	3e01      	subs	r6, #1
 8010308:	7033      	strb	r3, [r6, #0]
 801030a:	9b04      	ldr	r3, [sp, #16]
 801030c:	1b9b      	subs	r3, r3, r6
 801030e:	6123      	str	r3, [r4, #16]
 8010310:	9b07      	ldr	r3, [sp, #28]
 8010312:	0021      	movs	r1, r4
 8010314:	9300      	str	r3, [sp, #0]
 8010316:	9805      	ldr	r0, [sp, #20]
 8010318:	9b06      	ldr	r3, [sp, #24]
 801031a:	aa09      	add	r2, sp, #36	; 0x24
 801031c:	f7ff fede 	bl	80100dc <_printf_common>
 8010320:	1c43      	adds	r3, r0, #1
 8010322:	d135      	bne.n	8010390 <_printf_i+0x1d4>
 8010324:	2001      	movs	r0, #1
 8010326:	4240      	negs	r0, r0
 8010328:	b00b      	add	sp, #44	; 0x2c
 801032a:	bdf0      	pop	{r4, r5, r6, r7, pc}
 801032c:	2220      	movs	r2, #32
 801032e:	6809      	ldr	r1, [r1, #0]
 8010330:	430a      	orrs	r2, r1
 8010332:	6022      	str	r2, [r4, #0]
 8010334:	0022      	movs	r2, r4
 8010336:	2178      	movs	r1, #120	; 0x78
 8010338:	3245      	adds	r2, #69	; 0x45
 801033a:	7011      	strb	r1, [r2, #0]
 801033c:	4a27      	ldr	r2, [pc, #156]	; (80103dc <_printf_i+0x220>)
 801033e:	e7a7      	b.n	8010290 <_printf_i+0xd4>
 8010340:	0648      	lsls	r0, r1, #25
 8010342:	d5ac      	bpl.n	801029e <_printf_i+0xe2>
 8010344:	b2ad      	uxth	r5, r5
 8010346:	e7aa      	b.n	801029e <_printf_i+0xe2>
 8010348:	681a      	ldr	r2, [r3, #0]
 801034a:	680d      	ldr	r5, [r1, #0]
 801034c:	1d10      	adds	r0, r2, #4
 801034e:	6949      	ldr	r1, [r1, #20]
 8010350:	6018      	str	r0, [r3, #0]
 8010352:	6813      	ldr	r3, [r2, #0]
 8010354:	062e      	lsls	r6, r5, #24
 8010356:	d501      	bpl.n	801035c <_printf_i+0x1a0>
 8010358:	6019      	str	r1, [r3, #0]
 801035a:	e002      	b.n	8010362 <_printf_i+0x1a6>
 801035c:	066d      	lsls	r5, r5, #25
 801035e:	d5fb      	bpl.n	8010358 <_printf_i+0x19c>
 8010360:	8019      	strh	r1, [r3, #0]
 8010362:	2300      	movs	r3, #0
 8010364:	9e04      	ldr	r6, [sp, #16]
 8010366:	6123      	str	r3, [r4, #16]
 8010368:	e7d2      	b.n	8010310 <_printf_i+0x154>
 801036a:	681a      	ldr	r2, [r3, #0]
 801036c:	1d11      	adds	r1, r2, #4
 801036e:	6019      	str	r1, [r3, #0]
 8010370:	6816      	ldr	r6, [r2, #0]
 8010372:	2100      	movs	r1, #0
 8010374:	0030      	movs	r0, r6
 8010376:	6862      	ldr	r2, [r4, #4]
 8010378:	f000 f834 	bl	80103e4 <memchr>
 801037c:	2800      	cmp	r0, #0
 801037e:	d001      	beq.n	8010384 <_printf_i+0x1c8>
 8010380:	1b80      	subs	r0, r0, r6
 8010382:	6060      	str	r0, [r4, #4]
 8010384:	6863      	ldr	r3, [r4, #4]
 8010386:	6123      	str	r3, [r4, #16]
 8010388:	2300      	movs	r3, #0
 801038a:	9a04      	ldr	r2, [sp, #16]
 801038c:	7013      	strb	r3, [r2, #0]
 801038e:	e7bf      	b.n	8010310 <_printf_i+0x154>
 8010390:	6923      	ldr	r3, [r4, #16]
 8010392:	0032      	movs	r2, r6
 8010394:	9906      	ldr	r1, [sp, #24]
 8010396:	9805      	ldr	r0, [sp, #20]
 8010398:	9d07      	ldr	r5, [sp, #28]
 801039a:	47a8      	blx	r5
 801039c:	1c43      	adds	r3, r0, #1
 801039e:	d0c1      	beq.n	8010324 <_printf_i+0x168>
 80103a0:	6823      	ldr	r3, [r4, #0]
 80103a2:	079b      	lsls	r3, r3, #30
 80103a4:	d415      	bmi.n	80103d2 <_printf_i+0x216>
 80103a6:	9b09      	ldr	r3, [sp, #36]	; 0x24
 80103a8:	68e0      	ldr	r0, [r4, #12]
 80103aa:	4298      	cmp	r0, r3
 80103ac:	dabc      	bge.n	8010328 <_printf_i+0x16c>
 80103ae:	0018      	movs	r0, r3
 80103b0:	e7ba      	b.n	8010328 <_printf_i+0x16c>
 80103b2:	0022      	movs	r2, r4
 80103b4:	2301      	movs	r3, #1
 80103b6:	9906      	ldr	r1, [sp, #24]
 80103b8:	9805      	ldr	r0, [sp, #20]
 80103ba:	9e07      	ldr	r6, [sp, #28]
 80103bc:	3219      	adds	r2, #25
 80103be:	47b0      	blx	r6
 80103c0:	1c43      	adds	r3, r0, #1
 80103c2:	d0af      	beq.n	8010324 <_printf_i+0x168>
 80103c4:	3501      	adds	r5, #1
 80103c6:	68e3      	ldr	r3, [r4, #12]
 80103c8:	9a09      	ldr	r2, [sp, #36]	; 0x24
 80103ca:	1a9b      	subs	r3, r3, r2
 80103cc:	42ab      	cmp	r3, r5
 80103ce:	dcf0      	bgt.n	80103b2 <_printf_i+0x1f6>
 80103d0:	e7e9      	b.n	80103a6 <_printf_i+0x1ea>
 80103d2:	2500      	movs	r5, #0
 80103d4:	e7f7      	b.n	80103c6 <_printf_i+0x20a>
 80103d6:	46c0      	nop			; (mov r8, r8)
 80103d8:	08010a70 	.word	0x08010a70
 80103dc:	08010a81 	.word	0x08010a81

080103e0 <__retarget_lock_acquire_recursive>:
 80103e0:	4770      	bx	lr

080103e2 <__retarget_lock_release_recursive>:
 80103e2:	4770      	bx	lr

080103e4 <memchr>:
 80103e4:	b2c9      	uxtb	r1, r1
 80103e6:	1882      	adds	r2, r0, r2
 80103e8:	4290      	cmp	r0, r2
 80103ea:	d101      	bne.n	80103f0 <memchr+0xc>
 80103ec:	2000      	movs	r0, #0
 80103ee:	4770      	bx	lr
 80103f0:	7803      	ldrb	r3, [r0, #0]
 80103f2:	428b      	cmp	r3, r1
 80103f4:	d0fb      	beq.n	80103ee <memchr+0xa>
 80103f6:	3001      	adds	r0, #1
 80103f8:	e7f6      	b.n	80103e8 <memchr+0x4>

080103fa <memmove>:
 80103fa:	b510      	push	{r4, lr}
 80103fc:	4288      	cmp	r0, r1
 80103fe:	d902      	bls.n	8010406 <memmove+0xc>
 8010400:	188b      	adds	r3, r1, r2
 8010402:	4298      	cmp	r0, r3
 8010404:	d303      	bcc.n	801040e <memmove+0x14>
 8010406:	2300      	movs	r3, #0
 8010408:	e007      	b.n	801041a <memmove+0x20>
 801040a:	5c8b      	ldrb	r3, [r1, r2]
 801040c:	5483      	strb	r3, [r0, r2]
 801040e:	3a01      	subs	r2, #1
 8010410:	d2fb      	bcs.n	801040a <memmove+0x10>
 8010412:	bd10      	pop	{r4, pc}
 8010414:	5ccc      	ldrb	r4, [r1, r3]
 8010416:	54c4      	strb	r4, [r0, r3]
 8010418:	3301      	adds	r3, #1
 801041a:	429a      	cmp	r2, r3
 801041c:	d1fa      	bne.n	8010414 <memmove+0x1a>
 801041e:	e7f8      	b.n	8010412 <memmove+0x18>

08010420 <_realloc_r>:
 8010420:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8010422:	0007      	movs	r7, r0
 8010424:	000d      	movs	r5, r1
 8010426:	0016      	movs	r6, r2
 8010428:	2900      	cmp	r1, #0
 801042a:	d105      	bne.n	8010438 <_realloc_r+0x18>
 801042c:	0011      	movs	r1, r2
 801042e:	f7ff fbb9 	bl	800fba4 <_malloc_r>
 8010432:	0004      	movs	r4, r0
 8010434:	0020      	movs	r0, r4
 8010436:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8010438:	2a00      	cmp	r2, #0
 801043a:	d103      	bne.n	8010444 <_realloc_r+0x24>
 801043c:	f7ff fb68 	bl	800fb10 <_free_r>
 8010440:	0034      	movs	r4, r6
 8010442:	e7f7      	b.n	8010434 <_realloc_r+0x14>
 8010444:	f000 f812 	bl	801046c <_malloc_usable_size_r>
 8010448:	002c      	movs	r4, r5
 801044a:	42b0      	cmp	r0, r6
 801044c:	d2f2      	bcs.n	8010434 <_realloc_r+0x14>
 801044e:	0031      	movs	r1, r6
 8010450:	0038      	movs	r0, r7
 8010452:	f7ff fba7 	bl	800fba4 <_malloc_r>
 8010456:	1e04      	subs	r4, r0, #0
 8010458:	d0ec      	beq.n	8010434 <_realloc_r+0x14>
 801045a:	0029      	movs	r1, r5
 801045c:	0032      	movs	r2, r6
 801045e:	f7ff fb45 	bl	800faec <memcpy>
 8010462:	0029      	movs	r1, r5
 8010464:	0038      	movs	r0, r7
 8010466:	f7ff fb53 	bl	800fb10 <_free_r>
 801046a:	e7e3      	b.n	8010434 <_realloc_r+0x14>

0801046c <_malloc_usable_size_r>:
 801046c:	1f0b      	subs	r3, r1, #4
 801046e:	681b      	ldr	r3, [r3, #0]
 8010470:	1f18      	subs	r0, r3, #4
 8010472:	2b00      	cmp	r3, #0
 8010474:	da01      	bge.n	801047a <_malloc_usable_size_r+0xe>
 8010476:	580b      	ldr	r3, [r1, r0]
 8010478:	18c0      	adds	r0, r0, r3
 801047a:	4770      	bx	lr

0801047c <_init>:
 801047c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 801047e:	46c0      	nop			; (mov r8, r8)
 8010480:	bcf8      	pop	{r3, r4, r5, r6, r7}
 8010482:	bc08      	pop	{r3}
 8010484:	469e      	mov	lr, r3
 8010486:	4770      	bx	lr

08010488 <_fini>:
 8010488:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 801048a:	46c0      	nop			; (mov r8, r8)
 801048c:	bcf8      	pop	{r3, r4, r5, r6, r7}
 801048e:	bc08      	pop	{r3}
 8010490:	469e      	mov	lr, r3
 8010492:	4770      	bx	lr
